#!/usr/bin/env node

/**
 * Generate README.md files for crates and packages from extracted documentation.
 *
 * Reads the JSON files generated by extract-rust-docs.rs and extract-ts-docs.rs
 * and produces README.md files for each crate/package.
 */

const { program } = require('commander');
const fs = require('fs');
const path = require('path');

program
	.name('generate-readmes')
	.description('Generate README.md files for crates and packages from extracted documentation');

const rootDir = path.join(__dirname, '..');
const rustApiData = path.join(rootDir, 'website', 'static', 'api-data', 'rust');
const tsApiData = path.join(rootDir, 'website', 'static', 'api-data', 'typescript');

// Crate configurations
const RUST_CRATES = [
	{ name: 'macroforge_ts', dir: 'crates/macroforge_ts' },
	{ name: 'macroforge_ts_syn', dir: 'crates/macroforge_ts_syn' },
	{ name: 'macroforge_ts_quote', dir: 'crates/macroforge_ts_quote' },
	{ name: 'macroforge_ts_macros', dir: 'crates/macroforge_ts_macros' }
];

// Package configurations
const TS_PACKAGES = [
	{ name: 'shared', dir: 'packages/shared', npm: '@macroforge/shared' },
	{ name: 'typescript-plugin', dir: 'packages/typescript-plugin', npm: '@macroforge/typescript-plugin' },
	{ name: 'vite-plugin', dir: 'packages/vite-plugin', npm: '@macroforge/vite-plugin' },
	{ name: 'svelte-preprocessor', dir: 'packages/svelte-preprocessor', npm: '@macroforge/svelte-preprocessor' },
	{ name: 'mcp-server', dir: 'packages/mcp-server', npm: '@macroforge/mcp-server' }
];

/**
 * Generate a README for a Rust crate.
 * @param {Object} config - Crate configuration
 * @param {Object} docs - Extracted documentation
 * @returns {string} - Generated README content
 */
function generateRustReadme(config, docs) {
	const lines = [];

	// Header
	lines.push(`# ${docs.name}`);
	lines.push('');

	if (docs.description) {
		lines.push(docs.description);
		lines.push('');
	}

	// Badges
	lines.push(`[![Crates.io](https://img.shields.io/crates/v/${docs.name}.svg)](https://crates.io/crates/${docs.name})`);
	lines.push(`[![Documentation](https://docs.rs/${docs.name}/badge.svg)](https://docs.rs/${docs.name})`);
	lines.push('');

	// Overview from module docs
	if (docs.overview) {
		// The overview already contains markdown headers, so we include it as-is
		// but remove the first # header since we already have the crate name
		const overviewLines = docs.overview.split('\n');
		const firstNonHeaderIdx = overviewLines.findIndex((line) => !line.startsWith('# '));
		const overview = overviewLines.slice(firstNonHeaderIdx).join('\n').trim();
		if (overview) {
			lines.push(overview);
			lines.push('');
		}
	}

	// Installation
	lines.push('## Installation');
	lines.push('');
	lines.push('Add this to your `Cargo.toml`:');
	lines.push('');
	lines.push('```toml');
	lines.push(`[dependencies]`);
	lines.push(`${docs.name} = "${docs.version}"`);
	lines.push('```');
	lines.push('');

	// Key exports (structs and functions)
	const keyExports = docs.items.filter((item) =>
		['struct', 'function', 'enum', 'trait'].includes(item.kind) &&
		item.description &&
		!item.name.startsWith('_')
	);

	if (keyExports.length > 0) {
		lines.push('## Key Exports');
		lines.push('');

		// Group by kind
		const structs = keyExports.filter((i) => i.kind === 'struct');
		const functions = keyExports.filter((i) => i.kind === 'function');
		const enums = keyExports.filter((i) => i.kind === 'enum');
		const traits = keyExports.filter((i) => i.kind === 'trait');

		if (structs.length > 0) {
			lines.push('### Structs');
			lines.push('');
			for (const item of structs.slice(0, 10)) {
				// Limit to avoid huge READMEs
				const desc = item.description.split('\n')[0]; // First line only
				lines.push(`- **\`${item.name}\`** - ${desc}`);
			}
			if (structs.length > 10) {
				lines.push(`- ... and ${structs.length - 10} more`);
			}
			lines.push('');
		}

		if (functions.length > 0) {
			lines.push('### Functions');
			lines.push('');
			for (const item of functions.slice(0, 10)) {
				const desc = item.description.split('\n')[0];
				lines.push(`- **\`${item.name}\`** - ${desc}`);
			}
			if (functions.length > 10) {
				lines.push(`- ... and ${functions.length - 10} more`);
			}
			lines.push('');
		}

		if (enums.length > 0) {
			lines.push('### Enums');
			lines.push('');
			for (const item of enums) {
				const desc = item.description.split('\n')[0];
				lines.push(`- **\`${item.name}\`** - ${desc}`);
			}
			lines.push('');
		}

		if (traits.length > 0) {
			lines.push('### Traits');
			lines.push('');
			for (const item of traits) {
				const desc = item.description.split('\n')[0];
				lines.push(`- **\`${item.name}\`** - ${desc}`);
			}
			lines.push('');
		}
	}

	// API Reference link
	lines.push('## API Reference');
	lines.push('');
	lines.push(`See the [full API documentation](https://macroforge.dev/docs/api/reference/rust/${docs.name}) on the Macroforge website.`);
	lines.push('');

	// License
	lines.push('## License');
	lines.push('');
	lines.push('MIT');
	lines.push('');

	return lines.join('\n');
}

/**
 * Generate a README for a TypeScript package.
 * @param {Object} config - Package configuration
 * @param {Object} docs - Extracted documentation
 * @returns {string} - Generated README content
 */
function generateTsReadme(config, docs) {
	const lines = [];

	// Header
	lines.push(`# ${docs.name}`);
	lines.push('');

	if (docs.description) {
		lines.push(docs.description);
		lines.push('');
	}

	// Badges
	lines.push(`[![npm version](https://badge.fury.io/js/${encodeURIComponent(config.npm)}.svg)](https://www.npmjs.com/package/${config.npm})`);
	lines.push('');

	// Overview from file docs
	if (docs.overview) {
		lines.push('## Overview');
		lines.push('');
		lines.push(docs.overview);
		lines.push('');
	}

	// Installation
	lines.push('## Installation');
	lines.push('');
	lines.push('```bash');
	lines.push(`npm install ${config.npm}`);
	lines.push('```');
	lines.push('');

	// Key exports
	const keyExports = docs.items.filter(
		(item) => item.description && !item.name.startsWith('_')
	);

	if (keyExports.length > 0) {
		lines.push('## API');
		lines.push('');

		const functions = keyExports.filter((i) => i.kind === 'function');
		const classes = keyExports.filter((i) => i.kind === 'class');
		const types = keyExports.filter((i) => i.kind === 'type' || i.kind === 'interface');

		if (functions.length > 0) {
			lines.push('### Functions');
			lines.push('');
			for (const item of functions.slice(0, 10)) {
				const desc = item.description.split('\n')[0];
				lines.push(`- **\`${item.name}\`** - ${desc}`);
			}
			if (functions.length > 10) {
				lines.push(`- ... and ${functions.length - 10} more`);
			}
			lines.push('');
		}

		if (classes.length > 0) {
			lines.push('### Classes');
			lines.push('');
			for (const item of classes) {
				const desc = item.description.split('\n')[0];
				lines.push(`- **\`${item.name}\`** - ${desc}`);
			}
			lines.push('');
		}

		if (types.length > 0) {
			lines.push('### Types');
			lines.push('');
			for (const item of types.slice(0, 10)) {
				const desc = item.description.split('\n')[0];
				lines.push(`- **\`${item.name}\`** - ${desc}`);
			}
			if (types.length > 10) {
				lines.push(`- ... and ${types.length - 10} more`);
			}
			lines.push('');
		}
	}

	// Examples from items
	const itemsWithExamples = docs.items.filter((i) => i.examples && i.examples.length > 0);
	if (itemsWithExamples.length > 0) {
		lines.push('## Examples');
		lines.push('');
		// Use first example found
		const firstExample = itemsWithExamples[0].examples[0];
		// Clean up the example (remove ```typescript markers if present)
		const cleanExample = firstExample.replace(/^```\w*\n?/, '').replace(/\n?```$/, '');
		lines.push('```typescript');
		lines.push(cleanExample);
		lines.push('```');
		lines.push('');
	}

	// API Reference link
	lines.push('## Documentation');
	lines.push('');
	lines.push(`See the [full documentation](https://macroforge.dev/docs/api/reference/typescript/${config.name}) on the Macroforge website.`);
	lines.push('');

	// License
	lines.push('## License');
	lines.push('');
	lines.push('MIT');
	lines.push('');

	return lines.join('\n');
}

/**
 * Main entry point.
 */
function main() {
	console.log('Generating README files from extracted documentation...\n');

	let generatedCount = 0;

	// Process Rust crates
	console.log('Rust crates:');
	for (const crate of RUST_CRATES) {
		const docsPath = path.join(rustApiData, `${crate.name}.json`);
		if (!fs.existsSync(docsPath)) {
			console.log(`  [SKIP] ${crate.name} - no extracted docs found`);
			continue;
		}

		const docs = JSON.parse(fs.readFileSync(docsPath, 'utf-8'));
		const readme = generateRustReadme(crate, docs);

		const readmePath = path.join(rootDir, crate.dir, 'README.md');
		fs.writeFileSync(readmePath, readme);
		console.log(`  [OK] ${crate.name} -> ${readmePath}`);
		generatedCount++;
	}

	console.log('');

	// Process TypeScript packages
	console.log('TypeScript packages:');
	for (const pkg of TS_PACKAGES) {
		const docsPath = path.join(tsApiData, `${pkg.name}.json`);
		if (!fs.existsSync(docsPath)) {
			console.log(`  [SKIP] ${pkg.name} - no extracted docs found`);
			continue;
		}

		const docs = JSON.parse(fs.readFileSync(docsPath, 'utf-8'));
		const readme = generateTsReadme(pkg, docs);

		const readmePath = path.join(rootDir, pkg.dir, 'README.md');
		fs.writeFileSync(readmePath, readme);
		console.log(`  [OK] ${pkg.name} -> ${readmePath}`);
		generatedCount++;
	}

	console.log(`\nGenerated ${generatedCount} README files.`);
}

program.action(main);
program.parse();
