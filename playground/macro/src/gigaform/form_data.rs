//! Generates the fromFormData() function for parsing FormData with type coercion.

use macroforge_ts::macros::ts_template;
use macroforge_ts::ts_syn::TsStream;

use crate::gigaform::GenericInfo;
use crate::gigaform::naming::{call_deserialize, fn_name_from_form_data};
use crate::gigaform::parser::{ParsedField, UnionConfig, UnionMode};

/// Generates the fromFormData function.
pub fn generate(
    interface_name: &str,
    fields: &[ParsedField],
) -> TsStream {
    let fn_name = fn_name_from_form_data(interface_name, "");
    let field_extractions = generate_field_extractions(fields, "");
    let delegate_call = call_deserialize(interface_name, "", "obj");

    ts_template! {
        {>> "Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize)." <<}
        export function @{fn_name}(formData: FormData): Exit<@{interface_name}, Array<{ field: string; message: string }>> {
            const obj: Record<string, unknown> = {};

            {$typescript field_extractions}

            // Delegate validation to the deserialize function generated by @derive(Deserialize)
            return toExit(@{delegate_call});
        }
    }
}

/// Generates the fromFormData function with generic support.
pub fn generate_with_generics(
    interface_name: &str,
    fields: &[ParsedField],
    generics: &GenericInfo,
) -> TsStream {
    if generics.is_empty() {
        return generate(interface_name, fields);
    }

    let generic_decl = generics.decl();
    let fn_name = fn_name_from_form_data(interface_name, &generic_decl);
    let field_extractions = generate_field_extractions(fields, "");
    let generic_args = generics.args();
    let delegate_call = call_deserialize(interface_name, &generic_args, "obj");

    ts_template! {
        {>> "Parses FormData and validates it, returning a Result with the parsed data or errors." <<}
        export function @{fn_name}(formData: FormData): Exit<@{interface_name}@{generic_args}, Array<{ field: string; message: string }>> {
            const obj: Record<string, unknown> = {};

            {$typescript field_extractions}

            // Delegate validation to the deserialize function generated by @derive(Deserialize)
            return toExit(@{delegate_call});
        }
    }
}

/// Generates the fromFormData function for discriminated unions with generic support.
pub fn generate_union_with_generics(
    type_name: &str,
    config: &UnionConfig,
    _generics: &GenericInfo,
) -> TsStream {
    // Unions typically don't have type parameters
    generate_union(type_name, config)
}

/// Generates the fromFormData function for discriminated unions.
pub fn generate_union(type_name: &str, config: &UnionConfig) -> TsStream {
    let fn_name = fn_name_from_form_data(type_name, "");
    let discriminant_field = match &config.mode {
        UnionMode::Tagged { field } => field.as_str(),
        UnionMode::Untagged => "_variant", // synthetic field for untagged
    };

    let variant_cases = generate_variant_cases(config, discriminant_field);
    let variant_literals = config
        .variants
        .iter()
        .map(|v| format!("\"{}\"", v.discriminant_value))
        .collect::<Vec<_>>()
        .join(" | ");
    let delegate_call = call_deserialize(type_name, "", "obj");

    ts_template! {
        {>> "Parses FormData for union type, determining variant from discriminant field" <<}
        export function @{fn_name}(formData: FormData): Exit<@{type_name}, Array<{ field: string; message: string }>> {
            const discriminant = formData.get("@{discriminant_field}") as @{variant_literals} | null;

            if (!discriminant) {
                return toExit({ success: false, errors: [{ field: "@{discriminant_field}", message: "Missing discriminant field" }] });
            }

            const obj: Record<string, unknown> = {};
            obj.@{discriminant_field} = discriminant;

            {$typescript variant_cases}

            // Delegate validation to the deserialize function generated by @derive(Deserialize)
            return toExit(@{delegate_call});
        }
    }
}

/// Generates the switch cases for variant field extraction.
fn generate_variant_cases(config: &UnionConfig, _discriminant_field: &str) -> TsStream {
    ts_template! {
        {#for (i, variant) in config.variants.iter().enumerate()}
            {$let value = &variant.discriminant_value}
            {$let field_extractions = generate_field_extractions(&variant.fields, "")}
            {#if i == 0}
                if (discriminant === "@{value}") {
                    {$typescript field_extractions}
                }
            {:else}
                else if (discriminant === "@{value}") {
                    {$typescript field_extractions}
                }
            {/if}
        {/for}
    }
}

/// Generates the field extraction statements.
fn generate_field_extractions(fields: &[ParsedField], prefix: &str) -> TsStream {
    ts_template! {
        {#for field in fields}
            {$let extraction = generate_field_extraction(field, prefix)}
            {$typescript extraction}
        {/for}
    }
}

/// Generates extraction code for a single field.
fn generate_field_extraction(field: &ParsedField, prefix: &str) -> TsStream {
    let name = &field.name;
    let form_key = if prefix.is_empty() {
        name.clone()
    } else {
        format!("{prefix}.{name}")
    };

    let ts_type = field.ts_type.trim();

    // Handle different types
    if field.is_array {
        generate_array_extraction(name, &form_key, field)
    } else if field.is_nested {
        generate_nested_extraction(name, &form_key, field)
    } else {
        generate_primitive_extraction(name, &form_key, ts_type, field.optional)
    }
}

/// Generates extraction for primitive types.
fn generate_primitive_extraction(
    name: &str,
    form_key: &str,
    ts_type: &str,
    optional: bool,
) -> TsStream {
    let base_type = extract_base_type(ts_type);

    match base_type {
        "string" => {
            if optional {
                ts_template! { obj.@{name} = formData.get("@{form_key}") ?? undefined; }
            } else {
                ts_template! { obj.@{name} = formData.get("@{form_key}") ?? ""; }
            }
        }
        "number" => {
            let default_val = if optional { "undefined" } else { "0" };
            ts_template! {
                {
                    const {|@{name}Str|} = formData.get("@{form_key}");
                    obj.@{name} = {|@{name}Str|} ? parseFloat({|@{name}Str|} as string) : @{default_val};
                    if (obj.@{name} !== undefined && isNaN(obj.@{name} as number)) obj.@{name} = @{default_val};
                }
            }
        }
        "boolean" => {
            // FormData booleans: "true"/"on" = true, absent/other = false
            ts_template! {
                {
                    const {|@{name}Val|} = formData.get("@{form_key}");
                    obj.@{name} = {|@{name}Val|} === "true" || {|@{name}Val|} === "on" || {|@{name}Val|} === "1";
                }
            }
        }
        "Date" => {
            if optional {
                ts_template! {
                    {
                        const {|@{name}Str|} = formData.get("@{form_key}");
                        obj.@{name} = {|@{name}Str|} ? new Date({|@{name}Str|} as string) : undefined;
                    }
                }
            } else {
                ts_template! {
                    {
                        const {|@{name}Str|} = formData.get("@{form_key}");
                        obj.@{name} = {|@{name}Str|} ? new Date({|@{name}Str|} as string) : new Date();
                    }
                }
            }
        }
        "bigint" => {
            if optional {
                ts_template! {
                    {
                        const {|@{name}Str|} = formData.get("@{form_key}");
                        obj.@{name} = {|@{name}Str|} ? BigInt({|@{name}Str|} as string) : undefined;
                    }
                }
            } else {
                ts_template! {
                    {
                        const {|@{name}Str|} = formData.get("@{form_key}");
                        obj.@{name} = {|@{name}Str|} ? BigInt({|@{name}Str|} as string) : 0n;
                    }
                }
            }
        }
        _ => {
            // Unknown type - treat as string
            if optional {
                ts_template! { obj.@{name} = formData.get("@{form_key}") ?? undefined; }
            } else {
                ts_template! { obj.@{name} = formData.get("@{form_key}") ?? ""; }
            }
        }
    }
}

/// Generates extraction for array types.
fn generate_array_extraction(name: &str, form_key: &str, field: &ParsedField) -> TsStream {
    let element_type = field.array_element_type.as_deref().unwrap_or("string");
    let base_element = extract_base_type(element_type);

    match base_element {
        "string" => {
            ts_template! { obj.@{name} = formData.getAll("@{form_key}") as Array<string>; }
        }
        "number" => {
            ts_template! {
                obj.@{name} = formData.getAll("@{form_key}").map(v => parseFloat(v as string)).filter(n => !isNaN(n));
            }
        }
        "boolean" => {
            ts_template! {
                obj.@{name} = formData.getAll("@{form_key}").map(v => v === "true" || v === "on" || v === "1");
            }
        }
        _ => {
            // For nested types in arrays, we need to handle indexed fields
            // FormData would have fields like: items.0.name, items.0.value, items.1.name, etc.
            ts_template! {
                {
                    // Collect array items from indexed form fields
                    const {|@{name}Items|}: Array<Record<string, unknown>> = [];
                    let idx = 0;
                    while (formData.has("@{form_key}." + idx + ".") || idx === 0) {
                        // Check if any field with this index exists
                        const hasAny = Array.from(formData.keys()).some(k => k.startsWith("@{form_key}." + idx + "."));
                        if (!hasAny && idx > 0) break;
                        if (hasAny) {
                            const item: Record<string, unknown> = {};
                            for (const [key, value] of Array.from(formData.entries())) {
                                if (key.startsWith("@{form_key}." + idx + ".")) {
                                    const fieldName = key.slice("@{form_key}.".length + String(idx).length + 1);
                                    item[fieldName] = value;
                                }
                            }
                            {|@{name}Items|}.push(item);
                        }
                        idx++;
                        if (idx > 1000) break; // Safety limit
                    }
                    obj.@{name} = {|@{name}Items|};
                }
            }
        }
    }
}

/// Generates extraction for nested object types.
fn generate_nested_extraction(name: &str, form_key: &str, field: &ParsedField) -> TsStream {
    let _nested_type = field.nested_type.as_deref().unwrap_or("unknown");

    // For nested types that also have Gigaform, we can delegate to their fromFormData
    // But since we don't know the fields at macro time, we collect by prefix
    ts_template! {
        {
            // Collect nested object fields with prefix "@{form_key}."
            const {|@{name}Obj|}: Record<string, unknown> = {};
            for (const [key, value] of Array.from(formData.entries())) {
                if (key.startsWith("@{form_key}.")) {
                    const fieldName = key.slice("@{form_key}.".length);
                    // Handle deeper nesting by splitting on dots
                    const parts = fieldName.split(".");
                    let current = {|@{name}Obj|};
                    for (let i = 0; i < parts.length - 1; i++) {
                        const part = parts[i]!;
                        if (!(part in current)) {
                            current[part] = {};
                        }
                        current = current[part] as Record<string, unknown>;
                    }
                    current[parts[parts.length - 1]!] = value;
                }
            }
            obj.@{name} = {|@{name}Obj|};
        }
    }
}

/// Extracts the base type from a potentially nullable/optional type.
fn extract_base_type(ts_type: &str) -> &str {
    let trimmed = ts_type.trim();

    // Handle "T | null", "null | T", "T | undefined", etc.
    if trimmed.contains('|') {
        for part in trimmed.split('|') {
            let p = part.trim();
            if p != "null" && p != "undefined" {
                return p;
            }
        }
    }

    trimmed
}
