import { SerializeContext as __mf_SerializeContext } from "macroforge/serde";
import { DeserializeContext as __mf_DeserializeContext } from "macroforge/serde";
import { DeserializeError as __mf_DeserializeError } from "macroforge/serde";
import type { DeserializeOptions as __mf_DeserializeOptions } from "macroforge/serde";
import { PendingRef as __mf_PendingRef } from "macroforge/serde";
import type { Exit } from "@playground/macro/gigaform";
import { toExit } from "@playground/macro/gigaform";
import type { Option as __gf_Option } from "@playground/macro/gigaform";
import { optionNone } from "@playground/macro/gigaform";
import type { FieldController } from "@playground/macro/gigaform";
import type { ArrayFieldController } from "@playground/macro/gigaform";
/** import macro {Gigaform} from "@playground/macro"; */


export interface User {
    id: string;
    email: string | null;
    
    firstName: string;
    
    lastName: string;
    password: string | null;
    metadata: Metadata | null;
    settings: Settings;
    
    role: UserRole;
    emailVerified: boolean;
    verificationToken: string | null;
    verificationExpires: string | null;
    passwordResetToken: string | null;
    passwordResetExpires: string | null;
    permissions: AppPermissions;
}

export function userDefaultValue(): User {return {id: "",
                            email: null,
                            firstName: "",
                            lastName: "",
                            password: null,
                            metadata: null,
                            settings: settingsDefaultValue(),
                            role: "Administrator",
                            emailVerified: false,
                            verificationToken: null,
                            verificationExpires: null,
                            passwordResetToken: null,
                            passwordResetExpires: null,
                            permissions: appPermissionsDefaultValue(), }as User;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function userSerialize(value: User): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(userSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function userSerializeWithContext(value: User, ctx: __mf_SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "User" , __id,}; result["id" ]= value.id; result["email" ]= value.email; result["firstName" ]= value.firstName; result["lastName" ]= value.lastName; result["password" ]= value.password; if(value.metadata!== null){result["metadata" ]= metadataSerializeWithContext(value.metadata, ctx); }else {result["metadata" ]= null;}result["settings" ]= settingsSerializeWithContext(value.settings, ctx); result["role" ]= userRoleSerializeWithContext(value.role, ctx); result["emailVerified" ]= value.emailVerified; result["verificationToken" ]= value.verificationToken; result["verificationExpires" ]= value.verificationExpires; result["passwordResetToken" ]= value.passwordResetToken; result["passwordResetExpires" ]= value.passwordResetExpires; result["permissions" ]= appPermissionsSerializeWithContext(value.permissions, ctx); return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function userDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: User } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = userDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "User.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function userDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): User | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new __mf_DeserializeError([{field: "_root" , message: "User.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("id" in obj)){errors.push({field: "id" , message: "missing required field" });}if(!("email" in obj)){errors.push({field: "email" , message: "missing required field" });}if(!("firstName" in obj)){errors.push({field: "firstName" , message: "missing required field" });}if(!("lastName" in obj)){errors.push({field: "lastName" , message: "missing required field" });}if(!("password" in obj)){errors.push({field: "password" , message: "missing required field" });}if(!("metadata" in obj)){errors.push({field: "metadata" , message: "missing required field" });}if(!("settings" in obj)){errors.push({field: "settings" , message: "missing required field" });}if(!("role" in obj)){errors.push({field: "role" , message: "missing required field" });}if(!("emailVerified" in obj)){errors.push({field: "emailVerified" , message: "missing required field" });}if(!("verificationToken" in obj)){errors.push({field: "verificationToken" , message: "missing required field" });}if(!("verificationExpires" in obj)){errors.push({field: "verificationExpires" , message: "missing required field" });}if(!("passwordResetToken" in obj)){errors.push({field: "passwordResetToken" , message: "missing required field" });}if(!("passwordResetExpires" in obj)){errors.push({field: "passwordResetExpires" , message: "missing required field" });}if(!("permissions" in obj)){errors.push({field: "permissions" , message: "missing required field" });}if(errors.length>0){throw new __mf_DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_id = obj["id" ]as string; instance.id = __raw_id; }{const __raw_email = obj["email" ]as string | null; instance.email = __raw_email; }{const __raw_firstName = obj["firstName" ]as string; 
                if (__raw_firstName.length === 0) {
                    errors.push({ field: "firstName", message: "must not be empty" });
                }
 instance.firstName = __raw_firstName; }{const __raw_lastName = obj["lastName" ]as string; 
                if (__raw_lastName.length === 0) {
                    errors.push({ field: "lastName", message: "must not be empty" });
                }
 instance.lastName = __raw_lastName; }{const __raw_password = obj["password" ]as string | null; instance.password = __raw_password; }{const __raw_metadata = obj["metadata" ]as Metadata | null; if(__raw_metadata === null){instance.metadata = null;}else {const __result = metadataDeserializeWithContext(__raw_metadata, ctx); ctx.assignOrDefer(instance, "metadata" , __result); }}{const __raw_settings = obj["settings" ]as Settings; {const __result = settingsDeserializeWithContext(__raw_settings, ctx); ctx.assignOrDefer(instance, "settings" , __result);}}{const __raw_role = obj["role" ]as UserRole; {const __result = userRoleDeserializeWithContext(__raw_role, ctx); ctx.assignOrDefer(instance, "role" , __result);}}{const __raw_emailVerified = obj["emailVerified" ]as boolean; instance.emailVerified = __raw_emailVerified; }{const __raw_verificationToken = obj["verificationToken" ]as string | null; instance.verificationToken = __raw_verificationToken; }{const __raw_verificationExpires = obj["verificationExpires" ]as string | null; instance.verificationExpires = __raw_verificationExpires; }{const __raw_passwordResetToken = obj["passwordResetToken" ]as string | null; instance.passwordResetToken = __raw_passwordResetToken; }{const __raw_passwordResetExpires = obj["passwordResetExpires" ]as string | null; instance.passwordResetExpires = __raw_passwordResetExpires; }{const __raw_permissions = obj["permissions" ]as AppPermissions; {const __result = appPermissionsDeserializeWithContext(__raw_permissions, ctx); ctx.assignOrDefer(instance, "permissions" , __result);}}if(errors.length>0){throw new __mf_DeserializeError(errors);}return instance as User;}export function userValidateField<K extends keyof User>(_field: K, _value: User[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(_field){case "firstName" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "firstName", message: "must not be empty" });
                }
 break;}case "lastName" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "lastName", message: "must not be empty" });
                }
 break;}}return errors; }export function userValidateFields(_partial: Partial<User>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("firstName" in _partial && _partial.firstName!== undefined){const __val = _partial.firstName as string; 
                if (__val.length === 0) {
                    errors.push({ field: "firstName", message: "must not be empty" });
                }
}if("lastName" in _partial && _partial.lastName!== undefined){const __val = _partial.lastName as string; 
                if (__val.length === 0) {
                    errors.push({ field: "lastName", message: "must not be empty" });
                }
}return errors; }export function userHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "id" in o && "email" in o && "firstName" in o && "lastName" in o && "password" in o && "metadata" in o && "settings" in o && "role" in o && "emailVerified" in o && "verificationToken" in o && "verificationExpires" in o && "passwordResetToken" in o && "passwordResetExpires" in o && "permissions" in o;}export function userIs(obj: unknown): obj is User {if(!userHasShape(obj)){return false;}const result = userDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type UserErrors = {_errors: __gf_Option<Array<string>>; id: __gf_Option<Array<string>>; email: __gf_Option<Array<string>>; firstName: __gf_Option<Array<string>>; lastName: __gf_Option<Array<string>>; password: __gf_Option<Array<string>>; metadata: __gf_Option<Array<string>>; settings: __gf_Option<Array<string>>; role: __gf_Option<Array<string>>; emailVerified: __gf_Option<Array<string>>; verificationToken: __gf_Option<Array<string>>; verificationExpires: __gf_Option<Array<string>>; passwordResetToken: __gf_Option<Array<string>>; passwordResetExpires: __gf_Option<Array<string>>; permissions: __gf_Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type UserTainted = {id: __gf_Option<boolean>; email: __gf_Option<boolean>; firstName: __gf_Option<boolean>; lastName: __gf_Option<boolean>; password: __gf_Option<boolean>; metadata: __gf_Option<boolean>; settings: __gf_Option<boolean>; role: __gf_Option<boolean>; emailVerified: __gf_Option<boolean>; verificationToken: __gf_Option<boolean>; verificationExpires: __gf_Option<boolean>; passwordResetToken: __gf_Option<boolean>; passwordResetExpires: __gf_Option<boolean>; permissions: __gf_Option<boolean>; }; /** Type-safe field controllers for this form */export interface UserFieldControllers {readonly id: FieldController<string>; readonly email: FieldController<string | null>; readonly firstName: FieldController<string>; readonly lastName: FieldController<string>; readonly password: FieldController<string | null>; readonly metadata: FieldController<Metadata | null>; readonly settings: FieldController<Settings>; readonly role: FieldController<UserRole>; readonly emailVerified: FieldController<boolean>; readonly verificationToken: FieldController<string | null>; readonly verificationExpires: FieldController<string | null>; readonly passwordResetToken: FieldController<string | null>; readonly passwordResetExpires: FieldController<string | null>; readonly permissions: FieldController<AppPermissions>; }/** Gigaform instance containing reactive state and field controllers */export interface UserGigaform {readonly data: User; readonly errors: UserErrors; readonly tainted: UserTainted; readonly fields: UserFieldControllers; validate(): Exit<User, Array<{field: string; message: string}>>; reset(overrides?: Partial<User>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function userCreateForm(overrides?: Partial<User>): UserGigaform {let data = $state({...userDefaultValue(),...overrides}); let errors = $state<UserErrors>({_errors: optionNone(), id: optionNone(), email: optionNone(), firstName: optionNone(), lastName: optionNone(), password: optionNone(), metadata: optionNone(), settings: optionNone(), role: optionNone(), emailVerified: optionNone(), verificationToken: optionNone(), verificationExpires: optionNone(), passwordResetToken: optionNone(), passwordResetExpires: optionNone(), permissions: optionNone(), }); let tainted = $state<UserTainted>({id: optionNone(), email: optionNone(), firstName: optionNone(), lastName: optionNone(), password: optionNone(), metadata: optionNone(), settings: optionNone(), role: optionNone(), emailVerified: optionNone(), verificationToken: optionNone(), verificationExpires: optionNone(), passwordResetToken: optionNone(), passwordResetExpires: optionNone(), permissions: optionNone(), }); const fields: UserFieldControllers = {id: {path: ["id" ]as const, name: "id" , constraints: { required: true }, get: ()=>data.id, set: (value: string)=>{data.id = value;}, transform: (value: string): string =>value,getError: ()=>errors.id, setError: (value: __gf_Option<Array<string>>)=>{errors.id = value;}, getTainted: ()=>tainted.id, setTainted: (value: __gf_Option<boolean>)=>{tainted.id = value;}, validate: (): Array<string>=>{const fieldErrors = userValidateField("id", data.id); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},email: {path: ["email" ]as const, name: "email" , constraints: { required: true }, get: ()=>data.email, set: (value: string | null)=>{data.email = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.email, setError: (value: __gf_Option<Array<string>>)=>{errors.email = value;}, getTainted: ()=>tainted.email, setTainted: (value: __gf_Option<boolean>)=>{tainted.email = value;}, validate: (): Array<string>=>{const fieldErrors = userValidateField("email", data.email); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},firstName: {path: ["firstName" ]as const, name: "firstName" , constraints: { required: true }, get: ()=>data.firstName, set: (value: string)=>{data.firstName = value;}, transform: (value: string): string =>value,getError: ()=>errors.firstName, setError: (value: __gf_Option<Array<string>>)=>{errors.firstName = value;}, getTainted: ()=>tainted.firstName, setTainted: (value: __gf_Option<boolean>)=>{tainted.firstName = value;}, validate: (): Array<string>=>{const fieldErrors = userValidateField("firstName", data.firstName); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},lastName: {path: ["lastName" ]as const, name: "lastName" , constraints: { required: true }, get: ()=>data.lastName, set: (value: string)=>{data.lastName = value;}, transform: (value: string): string =>value,getError: ()=>errors.lastName, setError: (value: __gf_Option<Array<string>>)=>{errors.lastName = value;}, getTainted: ()=>tainted.lastName, setTainted: (value: __gf_Option<boolean>)=>{tainted.lastName = value;}, validate: (): Array<string>=>{const fieldErrors = userValidateField("lastName", data.lastName); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},password: {path: ["password" ]as const, name: "password" , constraints: { required: true }, get: ()=>data.password, set: (value: string | null)=>{data.password = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.password, setError: (value: __gf_Option<Array<string>>)=>{errors.password = value;}, getTainted: ()=>tainted.password, setTainted: (value: __gf_Option<boolean>)=>{tainted.password = value;}, validate: (): Array<string>=>{const fieldErrors = userValidateField("password", data.password); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},metadata: {path: ["metadata" ]as const, name: "metadata" , constraints: { required: true }, get: ()=>data.metadata, set: (value: Metadata | null)=>{data.metadata = value;}, transform: (value: Metadata | null): Metadata | null =>value,getError: ()=>errors.metadata, setError: (value: __gf_Option<Array<string>>)=>{errors.metadata = value;}, getTainted: ()=>tainted.metadata, setTainted: (value: __gf_Option<boolean>)=>{tainted.metadata = value;}, validate: (): Array<string>=>{const fieldErrors = userValidateField("metadata", data.metadata); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},settings: {path: ["settings" ]as const, name: "settings" , constraints: { required: true }, get: ()=>data.settings, set: (value: Settings)=>{data.settings = value;}, transform: (value: Settings): Settings =>value,getError: ()=>errors.settings, setError: (value: __gf_Option<Array<string>>)=>{errors.settings = value;}, getTainted: ()=>tainted.settings, setTainted: (value: __gf_Option<boolean>)=>{tainted.settings = value;}, validate: (): Array<string>=>{const fieldErrors = userValidateField("settings", data.settings); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},role: {path: ["role" ]as const, name: "role" , constraints: { required: true }, get: ()=>data.role, set: (value: UserRole)=>{data.role = value;}, transform: (value: UserRole): UserRole =>value,getError: ()=>errors.role, setError: (value: __gf_Option<Array<string>>)=>{errors.role = value;}, getTainted: ()=>tainted.role, setTainted: (value: __gf_Option<boolean>)=>{tainted.role = value;}, validate: (): Array<string>=>{const fieldErrors = userValidateField("role", data.role); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},emailVerified: {path: ["emailVerified" ]as const, name: "emailVerified" , constraints: { required: true }, get: ()=>data.emailVerified, set: (value: boolean)=>{data.emailVerified = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.emailVerified, setError: (value: __gf_Option<Array<string>>)=>{errors.emailVerified = value;}, getTainted: ()=>tainted.emailVerified, setTainted: (value: __gf_Option<boolean>)=>{tainted.emailVerified = value;}, validate: (): Array<string>=>{const fieldErrors = userValidateField("emailVerified", data.emailVerified); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},verificationToken: {path: ["verificationToken" ]as const, name: "verificationToken" , constraints: { required: true }, get: ()=>data.verificationToken, set: (value: string | null)=>{data.verificationToken = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.verificationToken, setError: (value: __gf_Option<Array<string>>)=>{errors.verificationToken = value;}, getTainted: ()=>tainted.verificationToken, setTainted: (value: __gf_Option<boolean>)=>{tainted.verificationToken = value;}, validate: (): Array<string>=>{const fieldErrors = userValidateField("verificationToken", data.verificationToken); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},verificationExpires: {path: ["verificationExpires" ]as const, name: "verificationExpires" , constraints: { required: true }, get: ()=>data.verificationExpires, set: (value: string | null)=>{data.verificationExpires = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.verificationExpires, setError: (value: __gf_Option<Array<string>>)=>{errors.verificationExpires = value;}, getTainted: ()=>tainted.verificationExpires, setTainted: (value: __gf_Option<boolean>)=>{tainted.verificationExpires = value;}, validate: (): Array<string>=>{const fieldErrors = userValidateField("verificationExpires", data.verificationExpires); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},passwordResetToken: {path: ["passwordResetToken" ]as const, name: "passwordResetToken" , constraints: { required: true }, get: ()=>data.passwordResetToken, set: (value: string | null)=>{data.passwordResetToken = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.passwordResetToken, setError: (value: __gf_Option<Array<string>>)=>{errors.passwordResetToken = value;}, getTainted: ()=>tainted.passwordResetToken, setTainted: (value: __gf_Option<boolean>)=>{tainted.passwordResetToken = value;}, validate: (): Array<string>=>{const fieldErrors = userValidateField("passwordResetToken", data.passwordResetToken); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},passwordResetExpires: {path: ["passwordResetExpires" ]as const, name: "passwordResetExpires" , constraints: { required: true }, get: ()=>data.passwordResetExpires, set: (value: string | null)=>{data.passwordResetExpires = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.passwordResetExpires, setError: (value: __gf_Option<Array<string>>)=>{errors.passwordResetExpires = value;}, getTainted: ()=>tainted.passwordResetExpires, setTainted: (value: __gf_Option<boolean>)=>{tainted.passwordResetExpires = value;}, validate: (): Array<string>=>{const fieldErrors = userValidateField("passwordResetExpires", data.passwordResetExpires); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},permissions: {path: ["permissions" ]as const, name: "permissions" , constraints: { required: true }, get: ()=>data.permissions, set: (value: AppPermissions)=>{data.permissions = value;}, transform: (value: AppPermissions): AppPermissions =>value,getError: ()=>errors.permissions, setError: (value: __gf_Option<Array<string>>)=>{errors.permissions = value;}, getTainted: ()=>tainted.permissions, setTainted: (value: __gf_Option<boolean>)=>{tainted.permissions = value;}, validate: (): Array<string>=>{const fieldErrors = userValidateField("permissions", data.permissions); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Exit<User, Array<{field: string; message: string}>>{return toExit(userDeserialize(data));}function reset(newOverrides?: Partial<User>): void {data = {...userDefaultValue(),...newOverrides}; errors = {_errors: optionNone(), id: optionNone(), email: optionNone(), firstName: optionNone(), lastName: optionNone(), password: optionNone(), metadata: optionNone(), settings: optionNone(), role: optionNone(), emailVerified: optionNone(), verificationToken: optionNone(), verificationExpires: optionNone(), passwordResetToken: optionNone(), passwordResetExpires: optionNone(), permissions: optionNone(), }; tainted = {id: optionNone(), email: optionNone(), firstName: optionNone(), lastName: optionNone(), password: optionNone(), metadata: optionNone(), settings: optionNone(), role: optionNone(), emailVerified: optionNone(), verificationToken: optionNone(), verificationExpires: optionNone(), passwordResetToken: optionNone(), passwordResetExpires: optionNone(), permissions: optionNone(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function userFromFormData(formData: FormData): Exit<User, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.id = formData.get("id" )?? "" ;obj.email = formData.get("email" )?? "" ;obj.firstName = formData.get("firstName" )?? "" ;obj.lastName = formData.get("lastName" )?? "" ;obj.password = formData.get("password" )?? "" ;obj.metadata = formData.get("metadata" )?? "" ;{const settingsObj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("settings." )){const fieldName = key.slice("settings." .length); const parts = fieldName.split("." ); let current = settingsObj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.settings = settingsObj;}{const roleObj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("role." )){const fieldName = key.slice("role." .length); const parts = fieldName.split("." ); let current = roleObj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.role = roleObj;}{const emailVerifiedVal = formData.get("emailVerified" ); obj.emailVerified = emailVerifiedVal === "true" || emailVerifiedVal === "on" || emailVerifiedVal === "1" ;}obj.verificationToken = formData.get("verificationToken" )?? "" ;obj.verificationExpires = formData.get("verificationExpires" )?? "" ;obj.passwordResetToken = formData.get("passwordResetToken" )?? "" ;obj.passwordResetExpires = formData.get("passwordResetExpires" )?? "" ;{const permissionsObj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("permissions." )){const fieldName = key.slice("permissions." .length); const parts = fieldName.split("." ); let current = permissionsObj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.permissions = permissionsObj;}return toExit(userDeserialize(obj));}

export const User = {
  defaultValue: userDefaultValue,
  serialize: userSerialize,
  serializeWithContext: userSerializeWithContext,
  deserialize: userDeserialize,
  deserializeWithContext: userDeserializeWithContext,
  validateFields: userValidateFields,
  hasShape: userHasShape,
  is: userIs,
  createForm: userCreateForm,
  fromFormData: userFromFormData
} as const;


export interface Service {
    
    id: string;
    
    
    name: string;
    
    
    quickCode: string;
    
    group: string | null;
    
    subgroup: string | null;
    
    unit: string | null;
    
    active: boolean;
    
    commission: boolean;
    
    favorite: boolean;
    
    averageTime: string | null;
    defaults: ServiceDefaults;
}

export function serviceDefaultValue(): Service {return {id: "",
                            name: "",
                            quickCode: "",
                            group: null,
                            subgroup: null,
                            unit: null,
                            active: false,
                            commission: false,
                            favorite: false,
                            averageTime: null,
                            defaults: serviceDefaultsDefaultValue(), }as Service;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function serviceSerialize(value: Service): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(serviceSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function serviceSerializeWithContext(value: Service, ctx: __mf_SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Service" , __id,}; result["id" ]= value.id; result["name" ]= value.name; result["quickCode" ]= value.quickCode; result["group" ]= value.group; result["subgroup" ]= value.subgroup; result["unit" ]= value.unit; result["active" ]= value.active; result["commission" ]= value.commission; result["favorite" ]= value.favorite; result["averageTime" ]= value.averageTime; result["defaults" ]= serviceDefaultsSerializeWithContext(value.defaults, ctx); return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function serviceDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: Service } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = serviceDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Service.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function serviceDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Service | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new __mf_DeserializeError([{field: "_root" , message: "Service.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("id" in obj)){errors.push({field: "id" , message: "missing required field" });}if(!("name" in obj)){errors.push({field: "name" , message: "missing required field" });}if(!("quickCode" in obj)){errors.push({field: "quickCode" , message: "missing required field" });}if(!("group" in obj)){errors.push({field: "group" , message: "missing required field" });}if(!("subgroup" in obj)){errors.push({field: "subgroup" , message: "missing required field" });}if(!("unit" in obj)){errors.push({field: "unit" , message: "missing required field" });}if(!("active" in obj)){errors.push({field: "active" , message: "missing required field" });}if(!("commission" in obj)){errors.push({field: "commission" , message: "missing required field" });}if(!("favorite" in obj)){errors.push({field: "favorite" , message: "missing required field" });}if(!("averageTime" in obj)){errors.push({field: "averageTime" , message: "missing required field" });}if(!("defaults" in obj)){errors.push({field: "defaults" , message: "missing required field" });}if(errors.length>0){throw new __mf_DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_id = obj["id" ]as string; instance.id = __raw_id; }{const __raw_name = obj["name" ]as string; 
                if (__raw_name.length === 0) {
                    errors.push({ field: "name", message: "must not be empty" });
                }
 instance.name = __raw_name; }{const __raw_quickCode = obj["quickCode" ]as string; 
                if (__raw_quickCode.length === 0) {
                    errors.push({ field: "quickCode", message: "must not be empty" });
                }
 instance.quickCode = __raw_quickCode; }{const __raw_group = obj["group" ]as string | null; instance.group = __raw_group; }{const __raw_subgroup = obj["subgroup" ]as string | null; instance.subgroup = __raw_subgroup; }{const __raw_unit = obj["unit" ]as string | null; instance.unit = __raw_unit; }{const __raw_active = obj["active" ]as boolean; instance.active = __raw_active; }{const __raw_commission = obj["commission" ]as boolean; instance.commission = __raw_commission; }{const __raw_favorite = obj["favorite" ]as boolean; instance.favorite = __raw_favorite; }{const __raw_averageTime = obj["averageTime" ]as string | null; instance.averageTime = __raw_averageTime; }{const __raw_defaults = obj["defaults" ]as ServiceDefaults; {const __result = serviceDefaultsDeserializeWithContext(__raw_defaults, ctx); ctx.assignOrDefer(instance, "defaults" , __result);}}if(errors.length>0){throw new __mf_DeserializeError(errors);}return instance as Service;}export function serviceValidateField<K extends keyof Service>(_field: K, _value: Service[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(_field){case "name" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "name", message: "must not be empty" });
                }
 break;}case "quickCode" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "quickCode", message: "must not be empty" });
                }
 break;}}return errors; }export function serviceValidateFields(_partial: Partial<Service>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("name" in _partial && _partial.name!== undefined){const __val = _partial.name as string; 
                if (__val.length === 0) {
                    errors.push({ field: "name", message: "must not be empty" });
                }
}if("quickCode" in _partial && _partial.quickCode!== undefined){const __val = _partial.quickCode as string; 
                if (__val.length === 0) {
                    errors.push({ field: "quickCode", message: "must not be empty" });
                }
}return errors; }export function serviceHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "id" in o && "name" in o && "quickCode" in o && "group" in o && "subgroup" in o && "unit" in o && "active" in o && "commission" in o && "favorite" in o && "averageTime" in o && "defaults" in o;}export function serviceIs(obj: unknown): obj is Service {if(!serviceHasShape(obj)){return false;}const result = serviceDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type ServiceErrors = {_errors: __gf_Option<Array<string>>; id: __gf_Option<Array<string>>; name: __gf_Option<Array<string>>; quickCode: __gf_Option<Array<string>>; group: __gf_Option<Array<string>>; subgroup: __gf_Option<Array<string>>; unit: __gf_Option<Array<string>>; active: __gf_Option<Array<string>>; commission: __gf_Option<Array<string>>; favorite: __gf_Option<Array<string>>; averageTime: __gf_Option<Array<string>>; defaults: __gf_Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type ServiceTainted = {id: __gf_Option<boolean>; name: __gf_Option<boolean>; quickCode: __gf_Option<boolean>; group: __gf_Option<boolean>; subgroup: __gf_Option<boolean>; unit: __gf_Option<boolean>; active: __gf_Option<boolean>; commission: __gf_Option<boolean>; favorite: __gf_Option<boolean>; averageTime: __gf_Option<boolean>; defaults: __gf_Option<boolean>; }; /** Type-safe field controllers for this form */export interface ServiceFieldControllers {readonly id: FieldController<string>; readonly name: FieldController<string>; readonly quickCode: FieldController<string>; readonly group: FieldController<string | null>; readonly subgroup: FieldController<string | null>; readonly unit: FieldController<string | null>; readonly active: FieldController<boolean>; readonly commission: FieldController<boolean>; readonly favorite: FieldController<boolean>; readonly averageTime: FieldController<string | null>; readonly defaults: FieldController<ServiceDefaults>; }/** Gigaform instance containing reactive state and field controllers */export interface ServiceGigaform {readonly data: Service; readonly errors: ServiceErrors; readonly tainted: ServiceTainted; readonly fields: ServiceFieldControllers; validate(): Exit<Service, Array<{field: string; message: string}>>; reset(overrides?: Partial<Service>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function serviceCreateForm(overrides?: Partial<Service>): ServiceGigaform {let data = $state({...serviceDefaultValue(),...overrides}); let errors = $state<ServiceErrors>({_errors: optionNone(), id: optionNone(), name: optionNone(), quickCode: optionNone(), group: optionNone(), subgroup: optionNone(), unit: optionNone(), active: optionNone(), commission: optionNone(), favorite: optionNone(), averageTime: optionNone(), defaults: optionNone(), }); let tainted = $state<ServiceTainted>({id: optionNone(), name: optionNone(), quickCode: optionNone(), group: optionNone(), subgroup: optionNone(), unit: optionNone(), active: optionNone(), commission: optionNone(), favorite: optionNone(), averageTime: optionNone(), defaults: optionNone(), }); const fields: ServiceFieldControllers = {id: {path: ["id" ]as const, name: "id" , constraints: { required: true }, get: ()=>data.id, set: (value: string)=>{data.id = value;}, transform: (value: string): string =>value,getError: ()=>errors.id, setError: (value: __gf_Option<Array<string>>)=>{errors.id = value;}, getTainted: ()=>tainted.id, setTainted: (value: __gf_Option<boolean>)=>{tainted.id = value;}, validate: (): Array<string>=>{const fieldErrors = serviceValidateField("id", data.id); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},name: {path: ["name" ]as const, name: "name" , constraints: { required: true }, label: "Name" , get: ()=>data.name, set: (value: string)=>{data.name = value;}, transform: (value: string): string =>value,getError: ()=>errors.name, setError: (value: __gf_Option<Array<string>>)=>{errors.name = value;}, getTainted: ()=>tainted.name, setTainted: (value: __gf_Option<boolean>)=>{tainted.name = value;}, validate: (): Array<string>=>{const fieldErrors = serviceValidateField("name", data.name); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},quickCode: {path: ["quickCode" ]as const, name: "quickCode" , constraints: { required: true }, label: "Quick Code" , get: ()=>data.quickCode, set: (value: string)=>{data.quickCode = value;}, transform: (value: string): string =>value,getError: ()=>errors.quickCode, setError: (value: __gf_Option<Array<string>>)=>{errors.quickCode = value;}, getTainted: ()=>tainted.quickCode, setTainted: (value: __gf_Option<boolean>)=>{tainted.quickCode = value;}, validate: (): Array<string>=>{const fieldErrors = serviceValidateField("quickCode", data.quickCode); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},group: {path: ["group" ]as const, name: "group" , constraints: { required: true }, label: "Group" , get: ()=>data.group, set: (value: string | null)=>{data.group = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.group, setError: (value: __gf_Option<Array<string>>)=>{errors.group = value;}, getTainted: ()=>tainted.group, setTainted: (value: __gf_Option<boolean>)=>{tainted.group = value;}, validate: (): Array<string>=>{const fieldErrors = serviceValidateField("group", data.group); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},subgroup: {path: ["subgroup" ]as const, name: "subgroup" , constraints: { required: true }, label: "Subgroup" , get: ()=>data.subgroup, set: (value: string | null)=>{data.subgroup = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.subgroup, setError: (value: __gf_Option<Array<string>>)=>{errors.subgroup = value;}, getTainted: ()=>tainted.subgroup, setTainted: (value: __gf_Option<boolean>)=>{tainted.subgroup = value;}, validate: (): Array<string>=>{const fieldErrors = serviceValidateField("subgroup", data.subgroup); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},unit: {path: ["unit" ]as const, name: "unit" , constraints: { required: true }, label: "Unit" , get: ()=>data.unit, set: (value: string | null)=>{data.unit = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.unit, setError: (value: __gf_Option<Array<string>>)=>{errors.unit = value;}, getTainted: ()=>tainted.unit, setTainted: (value: __gf_Option<boolean>)=>{tainted.unit = value;}, validate: (): Array<string>=>{const fieldErrors = serviceValidateField("unit", data.unit); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},active: {path: ["active" ]as const, name: "active" , constraints: { required: true }, label: "Active" , get: ()=>data.active, set: (value: boolean)=>{data.active = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.active, setError: (value: __gf_Option<Array<string>>)=>{errors.active = value;}, getTainted: ()=>tainted.active, setTainted: (value: __gf_Option<boolean>)=>{tainted.active = value;}, validate: (): Array<string>=>{const fieldErrors = serviceValidateField("active", data.active); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},commission: {path: ["commission" ]as const, name: "commission" , constraints: { required: true }, label: "Commission" , get: ()=>data.commission, set: (value: boolean)=>{data.commission = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.commission, setError: (value: __gf_Option<Array<string>>)=>{errors.commission = value;}, getTainted: ()=>tainted.commission, setTainted: (value: __gf_Option<boolean>)=>{tainted.commission = value;}, validate: (): Array<string>=>{const fieldErrors = serviceValidateField("commission", data.commission); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},favorite: {path: ["favorite" ]as const, name: "favorite" , constraints: { required: true }, label: "Favorite" , get: ()=>data.favorite, set: (value: boolean)=>{data.favorite = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.favorite, setError: (value: __gf_Option<Array<string>>)=>{errors.favorite = value;}, getTainted: ()=>tainted.favorite, setTainted: (value: __gf_Option<boolean>)=>{tainted.favorite = value;}, validate: (): Array<string>=>{const fieldErrors = serviceValidateField("favorite", data.favorite); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},averageTime: {path: ["averageTime" ]as const, name: "averageTime" , constraints: { required: true }, label: "Average Time" , get: ()=>data.averageTime, set: (value: string | null)=>{data.averageTime = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.averageTime, setError: (value: __gf_Option<Array<string>>)=>{errors.averageTime = value;}, getTainted: ()=>tainted.averageTime, setTainted: (value: __gf_Option<boolean>)=>{tainted.averageTime = value;}, validate: (): Array<string>=>{const fieldErrors = serviceValidateField("averageTime", data.averageTime); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},defaults: {path: ["defaults" ]as const, name: "defaults" , constraints: { required: true }, get: ()=>data.defaults, set: (value: ServiceDefaults)=>{data.defaults = value;}, transform: (value: ServiceDefaults): ServiceDefaults =>value,getError: ()=>errors.defaults, setError: (value: __gf_Option<Array<string>>)=>{errors.defaults = value;}, getTainted: ()=>tainted.defaults, setTainted: (value: __gf_Option<boolean>)=>{tainted.defaults = value;}, validate: (): Array<string>=>{const fieldErrors = serviceValidateField("defaults", data.defaults); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Exit<Service, Array<{field: string; message: string}>>{return toExit(serviceDeserialize(data));}function reset(newOverrides?: Partial<Service>): void {data = {...serviceDefaultValue(),...newOverrides}; errors = {_errors: optionNone(), id: optionNone(), name: optionNone(), quickCode: optionNone(), group: optionNone(), subgroup: optionNone(), unit: optionNone(), active: optionNone(), commission: optionNone(), favorite: optionNone(), averageTime: optionNone(), defaults: optionNone(), }; tainted = {id: optionNone(), name: optionNone(), quickCode: optionNone(), group: optionNone(), subgroup: optionNone(), unit: optionNone(), active: optionNone(), commission: optionNone(), favorite: optionNone(), averageTime: optionNone(), defaults: optionNone(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function serviceFromFormData(formData: FormData): Exit<Service, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.id = formData.get("id" )?? "" ;obj.name = formData.get("name" )?? "" ;obj.quickCode = formData.get("quickCode" )?? "" ;obj.group = formData.get("group" )?? "" ;obj.subgroup = formData.get("subgroup" )?? "" ;obj.unit = formData.get("unit" )?? "" ;{const activeVal = formData.get("active" ); obj.active = activeVal === "true" || activeVal === "on" || activeVal === "1" ;}{const commissionVal = formData.get("commission" ); obj.commission = commissionVal === "true" || commissionVal === "on" || commissionVal === "1" ;}{const favoriteVal = formData.get("favorite" ); obj.favorite = favoriteVal === "true" || favoriteVal === "on" || favoriteVal === "1" ;}obj.averageTime = formData.get("averageTime" )?? "" ;{const defaultsObj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("defaults." )){const fieldName = key.slice("defaults." .length); const parts = fieldName.split("." ); let current = defaultsObj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.defaults = defaultsObj;}return toExit(serviceDeserialize(obj));}

export const Service = {
  defaultValue: serviceDefaultValue,
  serialize: serviceSerialize,
  serializeWithContext: serviceSerializeWithContext,
  deserialize: serviceDeserialize,
  deserializeWithContext: serviceDeserializeWithContext,
  validateFields: serviceValidateFields,
  hasShape: serviceHasShape,
  is: serviceIs,
  createForm: serviceCreateForm,
  fromFormData: serviceFromFormData
} as const;


export interface ServiceDefaults {
    
    price: number;
    
    
    description: string;
}

export function serviceDefaultsDefaultValue(): ServiceDefaults {return {price: 0,
                            description: "", }as ServiceDefaults;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function serviceDefaultsSerialize(value: ServiceDefaults): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(serviceDefaultsSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function serviceDefaultsSerializeWithContext(value: ServiceDefaults, ctx: __mf_SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "ServiceDefaults" , __id,}; result["price" ]= value.price; result["description" ]= value.description; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function serviceDefaultsDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: ServiceDefaults } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = serviceDefaultsDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "ServiceDefaults.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function serviceDefaultsDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): ServiceDefaults | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new __mf_DeserializeError([{field: "_root" , message: "ServiceDefaults.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("price" in obj)){errors.push({field: "price" , message: "missing required field" });}if(!("description" in obj)){errors.push({field: "description" , message: "missing required field" });}if(errors.length>0){throw new __mf_DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_price = obj["price" ]as number; instance.price = __raw_price; }{const __raw_description = obj["description" ]as string; 
                if (__raw_description.length === 0) {
                    errors.push({ field: "description", message: "must not be empty" });
                }
 instance.description = __raw_description; }if(errors.length>0){throw new __mf_DeserializeError(errors);}return instance as ServiceDefaults;}export function serviceDefaultsValidateField<K extends keyof ServiceDefaults>(_field: K, _value: ServiceDefaults[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(_field){case "description" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "description", message: "must not be empty" });
                }
 break;}}return errors; }export function serviceDefaultsValidateFields(_partial: Partial<ServiceDefaults>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("description" in _partial && _partial.description!== undefined){const __val = _partial.description as string; 
                if (__val.length === 0) {
                    errors.push({ field: "description", message: "must not be empty" });
                }
}return errors; }export function serviceDefaultsHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "price" in o && "description" in o;}export function serviceDefaultsIs(obj: unknown): obj is ServiceDefaults {if(!serviceDefaultsHasShape(obj)){return false;}const result = serviceDefaultsDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type ServiceDefaultsErrors = {_errors: __gf_Option<Array<string>>; price: __gf_Option<Array<string>>; description: __gf_Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type ServiceDefaultsTainted = {price: __gf_Option<boolean>; description: __gf_Option<boolean>; }; /** Type-safe field controllers for this form */export interface ServiceDefaultsFieldControllers {readonly price: FieldController<number>; readonly description: FieldController<string>; }/** Gigaform instance containing reactive state and field controllers */export interface ServiceDefaultsGigaform {readonly data: ServiceDefaults; readonly errors: ServiceDefaultsErrors; readonly tainted: ServiceDefaultsTainted; readonly fields: ServiceDefaultsFieldControllers; validate(): Exit<ServiceDefaults, Array<{field: string; message: string}>>; reset(overrides?: Partial<ServiceDefaults>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function serviceDefaultsCreateForm(overrides?: Partial<ServiceDefaults>): ServiceDefaultsGigaform {let data = $state({...serviceDefaultsDefaultValue(),...overrides}); let errors = $state<ServiceDefaultsErrors>({_errors: optionNone(), price: optionNone(), description: optionNone(), }); let tainted = $state<ServiceDefaultsTainted>({price: optionNone(), description: optionNone(), }); const fields: ServiceDefaultsFieldControllers = {price: {path: ["price" ]as const, name: "price" , constraints: { required: true }, label: "Price" , get: ()=>data.price, set: (value: number)=>{data.price = value;}, transform: (value: number): number =>value,getError: ()=>errors.price, setError: (value: __gf_Option<Array<string>>)=>{errors.price = value;}, getTainted: ()=>tainted.price, setTainted: (value: __gf_Option<boolean>)=>{tainted.price = value;}, validate: (): Array<string>=>{const fieldErrors = serviceDefaultsValidateField("price", data.price); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},description: {path: ["description" ]as const, name: "description" , constraints: { required: true }, label: "Description" , get: ()=>data.description, set: (value: string)=>{data.description = value;}, transform: (value: string): string =>value,getError: ()=>errors.description, setError: (value: __gf_Option<Array<string>>)=>{errors.description = value;}, getTainted: ()=>tainted.description, setTainted: (value: __gf_Option<boolean>)=>{tainted.description = value;}, validate: (): Array<string>=>{const fieldErrors = serviceDefaultsValidateField("description", data.description); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Exit<ServiceDefaults, Array<{field: string; message: string}>>{return toExit(serviceDefaultsDeserialize(data));}function reset(newOverrides?: Partial<ServiceDefaults>): void {data = {...serviceDefaultsDefaultValue(),...newOverrides}; errors = {_errors: optionNone(), price: optionNone(), description: optionNone(), }; tainted = {price: optionNone(), description: optionNone(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function serviceDefaultsFromFormData(formData: FormData): Exit<ServiceDefaults, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; {const priceStr = formData.get("price" ); obj.price = priceStr? parseFloat(priceStr as string): 0; if(obj.price!== undefined && isNaN(obj.price as number))obj.price = 0;}obj.description = formData.get("description" )?? "" ;return toExit(serviceDefaultsDeserialize(obj));}

export const ServiceDefaults = {
  defaultValue: serviceDefaultsDefaultValue,
  serialize: serviceDefaultsSerialize,
  serializeWithContext: serviceDefaultsSerializeWithContext,
  deserialize: serviceDefaultsDeserialize,
  deserializeWithContext: serviceDefaultsDeserializeWithContext,
  validateFields: serviceDefaultsValidateFields,
  hasShape: serviceDefaultsHasShape,
  is: serviceDefaultsIs,
  createForm: serviceDefaultsCreateForm,
  fromFormData: serviceDefaultsFromFormData
} as const;


export interface Did {
    
    in: string | Actor;
    
    out: string | Target;
    id: string;
    activityType: ActivityType;
    createdAt: string;
    metadata: string | null;
}

export function didDefaultValue(): Did {return {in: "",
                            out: "",
                            id: "",
                            activityType: activityTypeDefaultValue(),
                            createdAt: "",
                            metadata: null, }as Did;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function didSerialize(value: Did): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(didSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function didSerializeWithContext(value: Did, ctx: __mf_SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Did" , __id,}; result["in" ]= value.in; result["out" ]= value.out; result["id" ]= value.id; result["activityType" ]= activityTypeSerializeWithContext(value.activityType, ctx); result["createdAt" ]= value.createdAt; result["metadata" ]= value.metadata; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function didDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: Did } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = didDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Did.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function didDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Did | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new __mf_DeserializeError([{field: "_root" , message: "Did.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("in" in obj)){errors.push({field: "in" , message: "missing required field" });}if(!("out" in obj)){errors.push({field: "out" , message: "missing required field" });}if(!("id" in obj)){errors.push({field: "id" , message: "missing required field" });}if(!("activityType" in obj)){errors.push({field: "activityType" , message: "missing required field" });}if(!("createdAt" in obj)){errors.push({field: "createdAt" , message: "missing required field" });}if(!("metadata" in obj)){errors.push({field: "metadata" , message: "missing required field" });}if(errors.length>0){throw new __mf_DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_in = obj["in" ]as string | Actor; instance.in = __raw_in; }{const __raw_out = obj["out" ]as string | Target; instance.out = __raw_out; }{const __raw_id = obj["id" ]as string; instance.id = __raw_id; }{const __raw_activityType = obj["activityType" ]as ActivityType; {const __result = activityTypeDeserializeWithContext(__raw_activityType, ctx); ctx.assignOrDefer(instance, "activityType" , __result);}}{const __raw_createdAt = obj["createdAt" ]as string; instance.createdAt = __raw_createdAt; }{const __raw_metadata = obj["metadata" ]as string | null; instance.metadata = __raw_metadata; }if(errors.length>0){throw new __mf_DeserializeError(errors);}return instance as Did;}export function didValidateField<K extends keyof Did>(_field: K, _value: Did[K]): Array<{field: string; message: string}>{return[]; }export function didValidateFields(_partial: Partial<Did>): Array<{field: string; message: string}>{return[]; }export function didHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "in" in o && "out" in o && "id" in o && "activityType" in o && "createdAt" in o && "metadata" in o;}export function didIs(obj: unknown): obj is Did {if(!didHasShape(obj)){return false;}const result = didDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type DidErrors = {_errors: __gf_Option<Array<string>>; in: __gf_Option<Array<string>>; out: __gf_Option<Array<string>>; id: __gf_Option<Array<string>>; activityType: __gf_Option<Array<string>>; createdAt: __gf_Option<Array<string>>; metadata: __gf_Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type DidTainted = {in: __gf_Option<boolean>; out: __gf_Option<boolean>; id: __gf_Option<boolean>; activityType: __gf_Option<boolean>; createdAt: __gf_Option<boolean>; metadata: __gf_Option<boolean>; }; /** Type-safe field controllers for this form */export interface DidFieldControllers {readonly in: FieldController<string | Actor>; readonly out: FieldController<string | Target>; readonly id: FieldController<string>; readonly activityType: FieldController<ActivityType>; readonly createdAt: FieldController<string>; readonly metadata: FieldController<string | null>; }/** Gigaform instance containing reactive state and field controllers */export interface DidGigaform {readonly data: Did; readonly errors: DidErrors; readonly tainted: DidTainted; readonly fields: DidFieldControllers; validate(): Exit<Did, Array<{field: string; message: string}>>; reset(overrides?: Partial<Did>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function didCreateForm(overrides?: Partial<Did>): DidGigaform {let data = $state({...didDefaultValue(),...overrides}); let errors = $state<DidErrors>({_errors: optionNone(), in: optionNone(), out: optionNone(), id: optionNone(), activityType: optionNone(), createdAt: optionNone(), metadata: optionNone(), }); let tainted = $state<DidTainted>({in: optionNone(), out: optionNone(), id: optionNone(), activityType: optionNone(), createdAt: optionNone(), metadata: optionNone(), }); const fields: DidFieldControllers = {in: {path: ["in" ]as const, name: "in" , constraints: { required: true }, get: ()=>data.in, set: (value: string | Actor)=>{data.in = value;}, transform: (value: string | Actor): string | Actor =>value,getError: ()=>errors.in, setError: (value: __gf_Option<Array<string>>)=>{errors.in = value;}, getTainted: ()=>tainted.in, setTainted: (value: __gf_Option<boolean>)=>{tainted.in = value;}, validate: (): Array<string>=>{const fieldErrors = didValidateField("in", data.in); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},out: {path: ["out" ]as const, name: "out" , constraints: { required: true }, get: ()=>data.out, set: (value: string | Target)=>{data.out = value;}, transform: (value: string | Target): string | Target =>value,getError: ()=>errors.out, setError: (value: __gf_Option<Array<string>>)=>{errors.out = value;}, getTainted: ()=>tainted.out, setTainted: (value: __gf_Option<boolean>)=>{tainted.out = value;}, validate: (): Array<string>=>{const fieldErrors = didValidateField("out", data.out); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},id: {path: ["id" ]as const, name: "id" , constraints: { required: true }, get: ()=>data.id, set: (value: string)=>{data.id = value;}, transform: (value: string): string =>value,getError: ()=>errors.id, setError: (value: __gf_Option<Array<string>>)=>{errors.id = value;}, getTainted: ()=>tainted.id, setTainted: (value: __gf_Option<boolean>)=>{tainted.id = value;}, validate: (): Array<string>=>{const fieldErrors = didValidateField("id", data.id); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},activityType: {path: ["activityType" ]as const, name: "activityType" , constraints: { required: true }, get: ()=>data.activityType, set: (value: ActivityType)=>{data.activityType = value;}, transform: (value: ActivityType): ActivityType =>value,getError: ()=>errors.activityType, setError: (value: __gf_Option<Array<string>>)=>{errors.activityType = value;}, getTainted: ()=>tainted.activityType, setTainted: (value: __gf_Option<boolean>)=>{tainted.activityType = value;}, validate: (): Array<string>=>{const fieldErrors = didValidateField("activityType", data.activityType); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},createdAt: {path: ["createdAt" ]as const, name: "createdAt" , constraints: { required: true }, get: ()=>data.createdAt, set: (value: string)=>{data.createdAt = value;}, transform: (value: string): string =>value,getError: ()=>errors.createdAt, setError: (value: __gf_Option<Array<string>>)=>{errors.createdAt = value;}, getTainted: ()=>tainted.createdAt, setTainted: (value: __gf_Option<boolean>)=>{tainted.createdAt = value;}, validate: (): Array<string>=>{const fieldErrors = didValidateField("createdAt", data.createdAt); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},metadata: {path: ["metadata" ]as const, name: "metadata" , constraints: { required: true }, get: ()=>data.metadata, set: (value: string | null)=>{data.metadata = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.metadata, setError: (value: __gf_Option<Array<string>>)=>{errors.metadata = value;}, getTainted: ()=>tainted.metadata, setTainted: (value: __gf_Option<boolean>)=>{tainted.metadata = value;}, validate: (): Array<string>=>{const fieldErrors = didValidateField("metadata", data.metadata); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Exit<Did, Array<{field: string; message: string}>>{return toExit(didDeserialize(data));}function reset(newOverrides?: Partial<Did>): void {data = {...didDefaultValue(),...newOverrides}; errors = {_errors: optionNone(), in: optionNone(), out: optionNone(), id: optionNone(), activityType: optionNone(), createdAt: optionNone(), metadata: optionNone(), }; tainted = {in: optionNone(), out: optionNone(), id: optionNone(), activityType: optionNone(), createdAt: optionNone(), metadata: optionNone(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function didFromFormData(formData: FormData): Exit<Did, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.in = formData.get("in" )?? "" ;obj.out = formData.get("out" )?? "" ;obj.id = formData.get("id" )?? "" ;{const activityTypeObj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("activityType." )){const fieldName = key.slice("activityType." .length); const parts = fieldName.split("." ); let current = activityTypeObj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.activityType = activityTypeObj;}obj.createdAt = formData.get("createdAt" )?? "" ;obj.metadata = formData.get("metadata" )?? "" ;return toExit(didDeserialize(obj));}

export const Did = {
  defaultValue: didDefaultValue,
  serialize: didSerialize,
  serializeWithContext: didSerializeWithContext,
  deserialize: didDeserialize,
  deserializeWithContext: didDeserializeWithContext,
  validateFields: didValidateFields,
  hasShape: didHasShape,
  is: didIs,
  createForm: didCreateForm,
  fromFormData: didFromFormData
} as const;


export interface PersonName {
    
    
    firstName: string;
    
    
    lastName: string;
}

export function personNameDefaultValue(): PersonName {return {firstName: "",
                            lastName: "", }as PersonName;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function personNameSerialize(value: PersonName): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(personNameSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function personNameSerializeWithContext(value: PersonName, ctx: __mf_SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "PersonName" , __id,}; result["firstName" ]= value.firstName; result["lastName" ]= value.lastName; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function personNameDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: PersonName } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = personNameDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "PersonName.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function personNameDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): PersonName | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new __mf_DeserializeError([{field: "_root" , message: "PersonName.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("firstName" in obj)){errors.push({field: "firstName" , message: "missing required field" });}if(!("lastName" in obj)){errors.push({field: "lastName" , message: "missing required field" });}if(errors.length>0){throw new __mf_DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_firstName = obj["firstName" ]as string; 
                if (__raw_firstName.length === 0) {
                    errors.push({ field: "firstName", message: "must not be empty" });
                }
 instance.firstName = __raw_firstName; }{const __raw_lastName = obj["lastName" ]as string; 
                if (__raw_lastName.length === 0) {
                    errors.push({ field: "lastName", message: "must not be empty" });
                }
 instance.lastName = __raw_lastName; }if(errors.length>0){throw new __mf_DeserializeError(errors);}return instance as PersonName;}export function personNameValidateField<K extends keyof PersonName>(_field: K, _value: PersonName[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(_field){case "firstName" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "firstName", message: "must not be empty" });
                }
 break;}case "lastName" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "lastName", message: "must not be empty" });
                }
 break;}}return errors; }export function personNameValidateFields(_partial: Partial<PersonName>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("firstName" in _partial && _partial.firstName!== undefined){const __val = _partial.firstName as string; 
                if (__val.length === 0) {
                    errors.push({ field: "firstName", message: "must not be empty" });
                }
}if("lastName" in _partial && _partial.lastName!== undefined){const __val = _partial.lastName as string; 
                if (__val.length === 0) {
                    errors.push({ field: "lastName", message: "must not be empty" });
                }
}return errors; }export function personNameHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "firstName" in o && "lastName" in o;}export function personNameIs(obj: unknown): obj is PersonName {if(!personNameHasShape(obj)){return false;}const result = personNameDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type PersonNameErrors = {_errors: __gf_Option<Array<string>>; firstName: __gf_Option<Array<string>>; lastName: __gf_Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type PersonNameTainted = {firstName: __gf_Option<boolean>; lastName: __gf_Option<boolean>; }; /** Type-safe field controllers for this form */export interface PersonNameFieldControllers {readonly firstName: FieldController<string>; readonly lastName: FieldController<string>; }/** Gigaform instance containing reactive state and field controllers */export interface PersonNameGigaform {readonly data: PersonName; readonly errors: PersonNameErrors; readonly tainted: PersonNameTainted; readonly fields: PersonNameFieldControllers; validate(): Exit<PersonName, Array<{field: string; message: string}>>; reset(overrides?: Partial<PersonName>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function personNameCreateForm(overrides?: Partial<PersonName>): PersonNameGigaform {let data = $state({...personNameDefaultValue(),...overrides}); let errors = $state<PersonNameErrors>({_errors: optionNone(), firstName: optionNone(), lastName: optionNone(), }); let tainted = $state<PersonNameTainted>({firstName: optionNone(), lastName: optionNone(), }); const fields: PersonNameFieldControllers = {firstName: {path: ["firstName" ]as const, name: "firstName" , constraints: { required: true }, label: "First Name" , get: ()=>data.firstName, set: (value: string)=>{data.firstName = value;}, transform: (value: string): string =>value,getError: ()=>errors.firstName, setError: (value: __gf_Option<Array<string>>)=>{errors.firstName = value;}, getTainted: ()=>tainted.firstName, setTainted: (value: __gf_Option<boolean>)=>{tainted.firstName = value;}, validate: (): Array<string>=>{const fieldErrors = personNameValidateField("firstName", data.firstName); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},lastName: {path: ["lastName" ]as const, name: "lastName" , constraints: { required: true }, label: "Last Name" , get: ()=>data.lastName, set: (value: string)=>{data.lastName = value;}, transform: (value: string): string =>value,getError: ()=>errors.lastName, setError: (value: __gf_Option<Array<string>>)=>{errors.lastName = value;}, getTainted: ()=>tainted.lastName, setTainted: (value: __gf_Option<boolean>)=>{tainted.lastName = value;}, validate: (): Array<string>=>{const fieldErrors = personNameValidateField("lastName", data.lastName); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Exit<PersonName, Array<{field: string; message: string}>>{return toExit(personNameDeserialize(data));}function reset(newOverrides?: Partial<PersonName>): void {data = {...personNameDefaultValue(),...newOverrides}; errors = {_errors: optionNone(), firstName: optionNone(), lastName: optionNone(), }; tainted = {firstName: optionNone(), lastName: optionNone(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function personNameFromFormData(formData: FormData): Exit<PersonName, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.firstName = formData.get("firstName" )?? "" ;obj.lastName = formData.get("lastName" )?? "" ;return toExit(personNameDeserialize(obj));}

export const PersonName = {
  defaultValue: personNameDefaultValue,
  serialize: personNameSerialize,
  serializeWithContext: personNameSerializeWithContext,
  deserialize: personNameDeserialize,
  deserializeWithContext: personNameDeserializeWithContext,
  validateFields: personNameValidateFields,
  hasShape: personNameHasShape,
  is: personNameIs,
  createForm: personNameCreateForm,
  fromFormData: personNameFromFormData
} as const;


export interface Promotion {
    id: string;
    date: string;
}

export function promotionDefaultValue(): Promotion {return {id: "",
                            date: "", }as Promotion;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function promotionSerialize(value: Promotion): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(promotionSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function promotionSerializeWithContext(value: Promotion, ctx: __mf_SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Promotion" , __id,}; result["id" ]= value.id; result["date" ]= value.date; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function promotionDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: Promotion } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = promotionDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Promotion.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function promotionDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Promotion | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new __mf_DeserializeError([{field: "_root" , message: "Promotion.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("id" in obj)){errors.push({field: "id" , message: "missing required field" });}if(!("date" in obj)){errors.push({field: "date" , message: "missing required field" });}if(errors.length>0){throw new __mf_DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_id = obj["id" ]as string; instance.id = __raw_id; }{const __raw_date = obj["date" ]as string; instance.date = __raw_date; }if(errors.length>0){throw new __mf_DeserializeError(errors);}return instance as Promotion;}export function promotionValidateField<K extends keyof Promotion>(_field: K, _value: Promotion[K]): Array<{field: string; message: string}>{return[]; }export function promotionValidateFields(_partial: Partial<Promotion>): Array<{field: string; message: string}>{return[]; }export function promotionHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "id" in o && "date" in o;}export function promotionIs(obj: unknown): obj is Promotion {if(!promotionHasShape(obj)){return false;}const result = promotionDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type PromotionErrors = {_errors: __gf_Option<Array<string>>; id: __gf_Option<Array<string>>; date: __gf_Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type PromotionTainted = {id: __gf_Option<boolean>; date: __gf_Option<boolean>; }; /** Type-safe field controllers for this form */export interface PromotionFieldControllers {readonly id: FieldController<string>; readonly date: FieldController<string>; }/** Gigaform instance containing reactive state and field controllers */export interface PromotionGigaform {readonly data: Promotion; readonly errors: PromotionErrors; readonly tainted: PromotionTainted; readonly fields: PromotionFieldControllers; validate(): Exit<Promotion, Array<{field: string; message: string}>>; reset(overrides?: Partial<Promotion>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function promotionCreateForm(overrides?: Partial<Promotion>): PromotionGigaform {let data = $state({...promotionDefaultValue(),...overrides}); let errors = $state<PromotionErrors>({_errors: optionNone(), id: optionNone(), date: optionNone(), }); let tainted = $state<PromotionTainted>({id: optionNone(), date: optionNone(), }); const fields: PromotionFieldControllers = {id: {path: ["id" ]as const, name: "id" , constraints: { required: true }, get: ()=>data.id, set: (value: string)=>{data.id = value;}, transform: (value: string): string =>value,getError: ()=>errors.id, setError: (value: __gf_Option<Array<string>>)=>{errors.id = value;}, getTainted: ()=>tainted.id, setTainted: (value: __gf_Option<boolean>)=>{tainted.id = value;}, validate: (): Array<string>=>{const fieldErrors = promotionValidateField("id", data.id); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},date: {path: ["date" ]as const, name: "date" , constraints: { required: true }, get: ()=>data.date, set: (value: string)=>{data.date = value;}, transform: (value: string): string =>value,getError: ()=>errors.date, setError: (value: __gf_Option<Array<string>>)=>{errors.date = value;}, getTainted: ()=>tainted.date, setTainted: (value: __gf_Option<boolean>)=>{tainted.date = value;}, validate: (): Array<string>=>{const fieldErrors = promotionValidateField("date", data.date); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Exit<Promotion, Array<{field: string; message: string}>>{return toExit(promotionDeserialize(data));}function reset(newOverrides?: Partial<Promotion>): void {data = {...promotionDefaultValue(),...newOverrides}; errors = {_errors: optionNone(), id: optionNone(), date: optionNone(), }; tainted = {id: optionNone(), date: optionNone(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function promotionFromFormData(formData: FormData): Exit<Promotion, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.id = formData.get("id" )?? "" ;obj.date = formData.get("date" )?? "" ;return toExit(promotionDeserialize(obj));}

export const Promotion = {
  defaultValue: promotionDefaultValue,
  serialize: promotionSerialize,
  serializeWithContext: promotionSerializeWithContext,
  deserialize: promotionDeserialize,
  deserializeWithContext: promotionDeserializeWithContext,
  validateFields: promotionValidateFields,
  hasShape: promotionHasShape,
  is: promotionIs,
  createForm: promotionCreateForm,
  fromFormData: promotionFromFormData
} as const;


export interface Site {
    id: string;
    
    addressLine1: string;
    addressLine2: string | null;
    sublocalityLevel1: string | null;
    
    locality: string;
    administrativeAreaLevel3: string | null;
    administrativeAreaLevel2: string | null;
    
    administrativeAreaLevel1: string;
    
    country: string;
    
    postalCode: string;
    postalCodeSuffix: string | null;
    coordinates: Coordinates;
}

export function siteDefaultValue(): Site {return {id: "",
                            addressLine1: "",
                            addressLine2: null,
                            sublocalityLevel1: null,
                            locality: "",
                            administrativeAreaLevel3: null,
                            administrativeAreaLevel2: null,
                            administrativeAreaLevel1: "",
                            country: "",
                            postalCode: "",
                            postalCodeSuffix: null,
                            coordinates: coordinatesDefaultValue(), }as Site;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function siteSerialize(value: Site): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(siteSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function siteSerializeWithContext(value: Site, ctx: __mf_SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Site" , __id,}; result["id" ]= value.id; result["addressLine1" ]= value.addressLine1; result["addressLine2" ]= value.addressLine2; result["sublocalityLevel1" ]= value.sublocalityLevel1; result["locality" ]= value.locality; result["administrativeAreaLevel3" ]= value.administrativeAreaLevel3; result["administrativeAreaLevel2" ]= value.administrativeAreaLevel2; result["administrativeAreaLevel1" ]= value.administrativeAreaLevel1; result["country" ]= value.country; result["postalCode" ]= value.postalCode; result["postalCodeSuffix" ]= value.postalCodeSuffix; result["coordinates" ]= coordinatesSerializeWithContext(value.coordinates, ctx); return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function siteDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: Site } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = siteDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Site.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function siteDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Site | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new __mf_DeserializeError([{field: "_root" , message: "Site.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("id" in obj)){errors.push({field: "id" , message: "missing required field" });}if(!("addressLine1" in obj)){errors.push({field: "addressLine1" , message: "missing required field" });}if(!("addressLine2" in obj)){errors.push({field: "addressLine2" , message: "missing required field" });}if(!("sublocalityLevel1" in obj)){errors.push({field: "sublocalityLevel1" , message: "missing required field" });}if(!("locality" in obj)){errors.push({field: "locality" , message: "missing required field" });}if(!("administrativeAreaLevel3" in obj)){errors.push({field: "administrativeAreaLevel3" , message: "missing required field" });}if(!("administrativeAreaLevel2" in obj)){errors.push({field: "administrativeAreaLevel2" , message: "missing required field" });}if(!("administrativeAreaLevel1" in obj)){errors.push({field: "administrativeAreaLevel1" , message: "missing required field" });}if(!("country" in obj)){errors.push({field: "country" , message: "missing required field" });}if(!("postalCode" in obj)){errors.push({field: "postalCode" , message: "missing required field" });}if(!("postalCodeSuffix" in obj)){errors.push({field: "postalCodeSuffix" , message: "missing required field" });}if(!("coordinates" in obj)){errors.push({field: "coordinates" , message: "missing required field" });}if(errors.length>0){throw new __mf_DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_id = obj["id" ]as string; instance.id = __raw_id; }{const __raw_addressLine1 = obj["addressLine1" ]as string; 
                if (__raw_addressLine1.length === 0) {
                    errors.push({ field: "addressLine1", message: "must not be empty" });
                }
 instance.addressLine1 = __raw_addressLine1; }{const __raw_addressLine2 = obj["addressLine2" ]as string | null; instance.addressLine2 = __raw_addressLine2; }{const __raw_sublocalityLevel1 = obj["sublocalityLevel1" ]as string | null; instance.sublocalityLevel1 = __raw_sublocalityLevel1; }{const __raw_locality = obj["locality" ]as string; 
                if (__raw_locality.length === 0) {
                    errors.push({ field: "locality", message: "must not be empty" });
                }
 instance.locality = __raw_locality; }{const __raw_administrativeAreaLevel3 = obj["administrativeAreaLevel3" ]as string | null; instance.administrativeAreaLevel3 = __raw_administrativeAreaLevel3; }{const __raw_administrativeAreaLevel2 = obj["administrativeAreaLevel2" ]as string | null; instance.administrativeAreaLevel2 = __raw_administrativeAreaLevel2; }{const __raw_administrativeAreaLevel1 = obj["administrativeAreaLevel1" ]as string; 
                if (__raw_administrativeAreaLevel1.length === 0) {
                    errors.push({ field: "administrativeAreaLevel1", message: "must not be empty" });
                }
 instance.administrativeAreaLevel1 = __raw_administrativeAreaLevel1; }{const __raw_country = obj["country" ]as string; 
                if (__raw_country.length === 0) {
                    errors.push({ field: "country", message: "must not be empty" });
                }
 instance.country = __raw_country; }{const __raw_postalCode = obj["postalCode" ]as string; 
                if (__raw_postalCode.length === 0) {
                    errors.push({ field: "postalCode", message: "must not be empty" });
                }
 instance.postalCode = __raw_postalCode; }{const __raw_postalCodeSuffix = obj["postalCodeSuffix" ]as string | null; instance.postalCodeSuffix = __raw_postalCodeSuffix; }{const __raw_coordinates = obj["coordinates" ]as Coordinates; {const __result = coordinatesDeserializeWithContext(__raw_coordinates, ctx); ctx.assignOrDefer(instance, "coordinates" , __result);}}if(errors.length>0){throw new __mf_DeserializeError(errors);}return instance as Site;}export function siteValidateField<K extends keyof Site>(_field: K, _value: Site[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(_field){case "addressLine1" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "addressLine1", message: "must not be empty" });
                }
 break;}case "locality" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "locality", message: "must not be empty" });
                }
 break;}case "administrativeAreaLevel1" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "administrativeAreaLevel1", message: "must not be empty" });
                }
 break;}case "country" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "country", message: "must not be empty" });
                }
 break;}case "postalCode" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "postalCode", message: "must not be empty" });
                }
 break;}}return errors; }export function siteValidateFields(_partial: Partial<Site>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("addressLine1" in _partial && _partial.addressLine1!== undefined){const __val = _partial.addressLine1 as string; 
                if (__val.length === 0) {
                    errors.push({ field: "addressLine1", message: "must not be empty" });
                }
}if("locality" in _partial && _partial.locality!== undefined){const __val = _partial.locality as string; 
                if (__val.length === 0) {
                    errors.push({ field: "locality", message: "must not be empty" });
                }
}if("administrativeAreaLevel1" in _partial && _partial.administrativeAreaLevel1!== undefined){const __val = _partial.administrativeAreaLevel1 as string; 
                if (__val.length === 0) {
                    errors.push({ field: "administrativeAreaLevel1", message: "must not be empty" });
                }
}if("country" in _partial && _partial.country!== undefined){const __val = _partial.country as string; 
                if (__val.length === 0) {
                    errors.push({ field: "country", message: "must not be empty" });
                }
}if("postalCode" in _partial && _partial.postalCode!== undefined){const __val = _partial.postalCode as string; 
                if (__val.length === 0) {
                    errors.push({ field: "postalCode", message: "must not be empty" });
                }
}return errors; }export function siteHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "id" in o && "addressLine1" in o && "addressLine2" in o && "sublocalityLevel1" in o && "locality" in o && "administrativeAreaLevel3" in o && "administrativeAreaLevel2" in o && "administrativeAreaLevel1" in o && "country" in o && "postalCode" in o && "postalCodeSuffix" in o && "coordinates" in o;}export function siteIs(obj: unknown): obj is Site {if(!siteHasShape(obj)){return false;}const result = siteDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type SiteErrors = {_errors: __gf_Option<Array<string>>; id: __gf_Option<Array<string>>; addressLine1: __gf_Option<Array<string>>; addressLine2: __gf_Option<Array<string>>; sublocalityLevel1: __gf_Option<Array<string>>; locality: __gf_Option<Array<string>>; administrativeAreaLevel3: __gf_Option<Array<string>>; administrativeAreaLevel2: __gf_Option<Array<string>>; administrativeAreaLevel1: __gf_Option<Array<string>>; country: __gf_Option<Array<string>>; postalCode: __gf_Option<Array<string>>; postalCodeSuffix: __gf_Option<Array<string>>; coordinates: __gf_Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type SiteTainted = {id: __gf_Option<boolean>; addressLine1: __gf_Option<boolean>; addressLine2: __gf_Option<boolean>; sublocalityLevel1: __gf_Option<boolean>; locality: __gf_Option<boolean>; administrativeAreaLevel3: __gf_Option<boolean>; administrativeAreaLevel2: __gf_Option<boolean>; administrativeAreaLevel1: __gf_Option<boolean>; country: __gf_Option<boolean>; postalCode: __gf_Option<boolean>; postalCodeSuffix: __gf_Option<boolean>; coordinates: __gf_Option<boolean>; }; /** Type-safe field controllers for this form */export interface SiteFieldControllers {readonly id: FieldController<string>; readonly addressLine1: FieldController<string>; readonly addressLine2: FieldController<string | null>; readonly sublocalityLevel1: FieldController<string | null>; readonly locality: FieldController<string>; readonly administrativeAreaLevel3: FieldController<string | null>; readonly administrativeAreaLevel2: FieldController<string | null>; readonly administrativeAreaLevel1: FieldController<string>; readonly country: FieldController<string>; readonly postalCode: FieldController<string>; readonly postalCodeSuffix: FieldController<string | null>; readonly coordinates: FieldController<Coordinates>; }/** Gigaform instance containing reactive state and field controllers */export interface SiteGigaform {readonly data: Site; readonly errors: SiteErrors; readonly tainted: SiteTainted; readonly fields: SiteFieldControllers; validate(): Exit<Site, Array<{field: string; message: string}>>; reset(overrides?: Partial<Site>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function siteCreateForm(overrides?: Partial<Site>): SiteGigaform {let data = $state({...siteDefaultValue(),...overrides}); let errors = $state<SiteErrors>({_errors: optionNone(), id: optionNone(), addressLine1: optionNone(), addressLine2: optionNone(), sublocalityLevel1: optionNone(), locality: optionNone(), administrativeAreaLevel3: optionNone(), administrativeAreaLevel2: optionNone(), administrativeAreaLevel1: optionNone(), country: optionNone(), postalCode: optionNone(), postalCodeSuffix: optionNone(), coordinates: optionNone(), }); let tainted = $state<SiteTainted>({id: optionNone(), addressLine1: optionNone(), addressLine2: optionNone(), sublocalityLevel1: optionNone(), locality: optionNone(), administrativeAreaLevel3: optionNone(), administrativeAreaLevel2: optionNone(), administrativeAreaLevel1: optionNone(), country: optionNone(), postalCode: optionNone(), postalCodeSuffix: optionNone(), coordinates: optionNone(), }); const fields: SiteFieldControllers = {id: {path: ["id" ]as const, name: "id" , constraints: { required: true }, get: ()=>data.id, set: (value: string)=>{data.id = value;}, transform: (value: string): string =>value,getError: ()=>errors.id, setError: (value: __gf_Option<Array<string>>)=>{errors.id = value;}, getTainted: ()=>tainted.id, setTainted: (value: __gf_Option<boolean>)=>{tainted.id = value;}, validate: (): Array<string>=>{const fieldErrors = siteValidateField("id", data.id); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},addressLine1: {path: ["addressLine1" ]as const, name: "addressLine1" , constraints: { required: true }, get: ()=>data.addressLine1, set: (value: string)=>{data.addressLine1 = value;}, transform: (value: string): string =>value,getError: ()=>errors.addressLine1, setError: (value: __gf_Option<Array<string>>)=>{errors.addressLine1 = value;}, getTainted: ()=>tainted.addressLine1, setTainted: (value: __gf_Option<boolean>)=>{tainted.addressLine1 = value;}, validate: (): Array<string>=>{const fieldErrors = siteValidateField("addressLine1", data.addressLine1); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},addressLine2: {path: ["addressLine2" ]as const, name: "addressLine2" , constraints: { required: true }, get: ()=>data.addressLine2, set: (value: string | null)=>{data.addressLine2 = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.addressLine2, setError: (value: __gf_Option<Array<string>>)=>{errors.addressLine2 = value;}, getTainted: ()=>tainted.addressLine2, setTainted: (value: __gf_Option<boolean>)=>{tainted.addressLine2 = value;}, validate: (): Array<string>=>{const fieldErrors = siteValidateField("addressLine2", data.addressLine2); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},sublocalityLevel1: {path: ["sublocalityLevel1" ]as const, name: "sublocalityLevel1" , constraints: { required: true }, get: ()=>data.sublocalityLevel1, set: (value: string | null)=>{data.sublocalityLevel1 = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.sublocalityLevel1, setError: (value: __gf_Option<Array<string>>)=>{errors.sublocalityLevel1 = value;}, getTainted: ()=>tainted.sublocalityLevel1, setTainted: (value: __gf_Option<boolean>)=>{tainted.sublocalityLevel1 = value;}, validate: (): Array<string>=>{const fieldErrors = siteValidateField("sublocalityLevel1", data.sublocalityLevel1); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},locality: {path: ["locality" ]as const, name: "locality" , constraints: { required: true }, get: ()=>data.locality, set: (value: string)=>{data.locality = value;}, transform: (value: string): string =>value,getError: ()=>errors.locality, setError: (value: __gf_Option<Array<string>>)=>{errors.locality = value;}, getTainted: ()=>tainted.locality, setTainted: (value: __gf_Option<boolean>)=>{tainted.locality = value;}, validate: (): Array<string>=>{const fieldErrors = siteValidateField("locality", data.locality); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},administrativeAreaLevel3: {path: ["administrativeAreaLevel3" ]as const, name: "administrativeAreaLevel3" , constraints: { required: true }, get: ()=>data.administrativeAreaLevel3, set: (value: string | null)=>{data.administrativeAreaLevel3 = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.administrativeAreaLevel3, setError: (value: __gf_Option<Array<string>>)=>{errors.administrativeAreaLevel3 = value;}, getTainted: ()=>tainted.administrativeAreaLevel3, setTainted: (value: __gf_Option<boolean>)=>{tainted.administrativeAreaLevel3 = value;}, validate: (): Array<string>=>{const fieldErrors = siteValidateField("administrativeAreaLevel3", data.administrativeAreaLevel3); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},administrativeAreaLevel2: {path: ["administrativeAreaLevel2" ]as const, name: "administrativeAreaLevel2" , constraints: { required: true }, get: ()=>data.administrativeAreaLevel2, set: (value: string | null)=>{data.administrativeAreaLevel2 = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.administrativeAreaLevel2, setError: (value: __gf_Option<Array<string>>)=>{errors.administrativeAreaLevel2 = value;}, getTainted: ()=>tainted.administrativeAreaLevel2, setTainted: (value: __gf_Option<boolean>)=>{tainted.administrativeAreaLevel2 = value;}, validate: (): Array<string>=>{const fieldErrors = siteValidateField("administrativeAreaLevel2", data.administrativeAreaLevel2); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},administrativeAreaLevel1: {path: ["administrativeAreaLevel1" ]as const, name: "administrativeAreaLevel1" , constraints: { required: true }, get: ()=>data.administrativeAreaLevel1, set: (value: string)=>{data.administrativeAreaLevel1 = value;}, transform: (value: string): string =>value,getError: ()=>errors.administrativeAreaLevel1, setError: (value: __gf_Option<Array<string>>)=>{errors.administrativeAreaLevel1 = value;}, getTainted: ()=>tainted.administrativeAreaLevel1, setTainted: (value: __gf_Option<boolean>)=>{tainted.administrativeAreaLevel1 = value;}, validate: (): Array<string>=>{const fieldErrors = siteValidateField("administrativeAreaLevel1", data.administrativeAreaLevel1); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},country: {path: ["country" ]as const, name: "country" , constraints: { required: true }, get: ()=>data.country, set: (value: string)=>{data.country = value;}, transform: (value: string): string =>value,getError: ()=>errors.country, setError: (value: __gf_Option<Array<string>>)=>{errors.country = value;}, getTainted: ()=>tainted.country, setTainted: (value: __gf_Option<boolean>)=>{tainted.country = value;}, validate: (): Array<string>=>{const fieldErrors = siteValidateField("country", data.country); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},postalCode: {path: ["postalCode" ]as const, name: "postalCode" , constraints: { required: true }, get: ()=>data.postalCode, set: (value: string)=>{data.postalCode = value;}, transform: (value: string): string =>value,getError: ()=>errors.postalCode, setError: (value: __gf_Option<Array<string>>)=>{errors.postalCode = value;}, getTainted: ()=>tainted.postalCode, setTainted: (value: __gf_Option<boolean>)=>{tainted.postalCode = value;}, validate: (): Array<string>=>{const fieldErrors = siteValidateField("postalCode", data.postalCode); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},postalCodeSuffix: {path: ["postalCodeSuffix" ]as const, name: "postalCodeSuffix" , constraints: { required: true }, get: ()=>data.postalCodeSuffix, set: (value: string | null)=>{data.postalCodeSuffix = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.postalCodeSuffix, setError: (value: __gf_Option<Array<string>>)=>{errors.postalCodeSuffix = value;}, getTainted: ()=>tainted.postalCodeSuffix, setTainted: (value: __gf_Option<boolean>)=>{tainted.postalCodeSuffix = value;}, validate: (): Array<string>=>{const fieldErrors = siteValidateField("postalCodeSuffix", data.postalCodeSuffix); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},coordinates: {path: ["coordinates" ]as const, name: "coordinates" , constraints: { required: true }, get: ()=>data.coordinates, set: (value: Coordinates)=>{data.coordinates = value;}, transform: (value: Coordinates): Coordinates =>value,getError: ()=>errors.coordinates, setError: (value: __gf_Option<Array<string>>)=>{errors.coordinates = value;}, getTainted: ()=>tainted.coordinates, setTainted: (value: __gf_Option<boolean>)=>{tainted.coordinates = value;}, validate: (): Array<string>=>{const fieldErrors = siteValidateField("coordinates", data.coordinates); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Exit<Site, Array<{field: string; message: string}>>{return toExit(siteDeserialize(data));}function reset(newOverrides?: Partial<Site>): void {data = {...siteDefaultValue(),...newOverrides}; errors = {_errors: optionNone(), id: optionNone(), addressLine1: optionNone(), addressLine2: optionNone(), sublocalityLevel1: optionNone(), locality: optionNone(), administrativeAreaLevel3: optionNone(), administrativeAreaLevel2: optionNone(), administrativeAreaLevel1: optionNone(), country: optionNone(), postalCode: optionNone(), postalCodeSuffix: optionNone(), coordinates: optionNone(), }; tainted = {id: optionNone(), addressLine1: optionNone(), addressLine2: optionNone(), sublocalityLevel1: optionNone(), locality: optionNone(), administrativeAreaLevel3: optionNone(), administrativeAreaLevel2: optionNone(), administrativeAreaLevel1: optionNone(), country: optionNone(), postalCode: optionNone(), postalCodeSuffix: optionNone(), coordinates: optionNone(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function siteFromFormData(formData: FormData): Exit<Site, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.id = formData.get("id" )?? "" ;obj.addressLine1 = formData.get("addressLine1" )?? "" ;obj.addressLine2 = formData.get("addressLine2" )?? "" ;obj.sublocalityLevel1 = formData.get("sublocalityLevel1" )?? "" ;obj.locality = formData.get("locality" )?? "" ;obj.administrativeAreaLevel3 = formData.get("administrativeAreaLevel3" )?? "" ;obj.administrativeAreaLevel2 = formData.get("administrativeAreaLevel2" )?? "" ;obj.administrativeAreaLevel1 = formData.get("administrativeAreaLevel1" )?? "" ;obj.country = formData.get("country" )?? "" ;obj.postalCode = formData.get("postalCode" )?? "" ;obj.postalCodeSuffix = formData.get("postalCodeSuffix" )?? "" ;{const coordinatesObj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("coordinates." )){const fieldName = key.slice("coordinates." .length); const parts = fieldName.split("." ); let current = coordinatesObj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.coordinates = coordinatesObj;}return toExit(siteDeserialize(obj));}

export const Site = {
  defaultValue: siteDefaultValue,
  serialize: siteSerialize,
  serializeWithContext: siteSerializeWithContext,
  deserialize: siteDeserialize,
  deserializeWithContext: siteDeserializeWithContext,
  validateFields: siteValidateFields,
  hasShape: siteHasShape,
  is: siteIs,
  createForm: siteCreateForm,
  fromFormData: siteFromFormData
} as const;


export interface Metadata {
    createdAt: string;
    lastLogin: string | null;
    isActive: boolean;
    roles: string[];
}

export function metadataDefaultValue(): Metadata {return {createdAt: "",
                            lastLogin: null,
                            isActive: false,
                            roles: [], }as Metadata;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function metadataSerialize(value: Metadata): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(metadataSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function metadataSerializeWithContext(value: Metadata, ctx: __mf_SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Metadata" , __id,}; result["createdAt" ]= value.createdAt; result["lastLogin" ]= value.lastLogin; result["isActive" ]= value.isActive; result["roles" ]= value.roles; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function metadataDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: Metadata } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = metadataDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Metadata.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function metadataDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Metadata | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new __mf_DeserializeError([{field: "_root" , message: "Metadata.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("createdAt" in obj)){errors.push({field: "createdAt" , message: "missing required field" });}if(!("lastLogin" in obj)){errors.push({field: "lastLogin" , message: "missing required field" });}if(!("isActive" in obj)){errors.push({field: "isActive" , message: "missing required field" });}if(!("roles" in obj)){errors.push({field: "roles" , message: "missing required field" });}if(errors.length>0){throw new __mf_DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_createdAt = obj["createdAt" ]as string; instance.createdAt = __raw_createdAt; }{const __raw_lastLogin = obj["lastLogin" ]as string | null; instance.lastLogin = __raw_lastLogin; }{const __raw_isActive = obj["isActive" ]as boolean; instance.isActive = __raw_isActive; }{const __raw_roles = obj["roles" ]as string[]; if(Array.isArray(__raw_roles)){instance.roles = __raw_roles as string[];}}if(errors.length>0){throw new __mf_DeserializeError(errors);}return instance as Metadata;}export function metadataValidateField<K extends keyof Metadata>(_field: K, _value: Metadata[K]): Array<{field: string; message: string}>{return[]; }export function metadataValidateFields(_partial: Partial<Metadata>): Array<{field: string; message: string}>{return[]; }export function metadataHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "createdAt" in o && "lastLogin" in o && "isActive" in o && "roles" in o;}export function metadataIs(obj: unknown): obj is Metadata {if(!metadataHasShape(obj)){return false;}const result = metadataDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type MetadataErrors = {_errors: __gf_Option<Array<string>>; createdAt: __gf_Option<Array<string>>; lastLogin: __gf_Option<Array<string>>; isActive: __gf_Option<Array<string>>; roles: __gf_Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type MetadataTainted = {createdAt: __gf_Option<boolean>; lastLogin: __gf_Option<boolean>; isActive: __gf_Option<boolean>; roles: __gf_Option<boolean>; }; /** Type-safe field controllers for this form */export interface MetadataFieldControllers {readonly createdAt: FieldController<string>; readonly lastLogin: FieldController<string | null>; readonly isActive: FieldController<boolean>; readonly roles: ArrayFieldController<string>; }/** Gigaform instance containing reactive state and field controllers */export interface MetadataGigaform {readonly data: Metadata; readonly errors: MetadataErrors; readonly tainted: MetadataTainted; readonly fields: MetadataFieldControllers; validate(): Exit<Metadata, Array<{field: string; message: string}>>; reset(overrides?: Partial<Metadata>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function metadataCreateForm(overrides?: Partial<Metadata>): MetadataGigaform {let data = $state({...metadataDefaultValue(),...overrides}); let errors = $state<MetadataErrors>({_errors: optionNone(), createdAt: optionNone(), lastLogin: optionNone(), isActive: optionNone(), roles: optionNone(), }); let tainted = $state<MetadataTainted>({createdAt: optionNone(), lastLogin: optionNone(), isActive: optionNone(), roles: optionNone(), }); const fields: MetadataFieldControllers = {createdAt: {path: ["createdAt" ]as const, name: "createdAt" , constraints: { required: true }, get: ()=>data.createdAt, set: (value: string)=>{data.createdAt = value;}, transform: (value: string): string =>value,getError: ()=>errors.createdAt, setError: (value: __gf_Option<Array<string>>)=>{errors.createdAt = value;}, getTainted: ()=>tainted.createdAt, setTainted: (value: __gf_Option<boolean>)=>{tainted.createdAt = value;}, validate: (): Array<string>=>{const fieldErrors = metadataValidateField("createdAt", data.createdAt); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},lastLogin: {path: ["lastLogin" ]as const, name: "lastLogin" , constraints: { required: true }, get: ()=>data.lastLogin, set: (value: string | null)=>{data.lastLogin = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.lastLogin, setError: (value: __gf_Option<Array<string>>)=>{errors.lastLogin = value;}, getTainted: ()=>tainted.lastLogin, setTainted: (value: __gf_Option<boolean>)=>{tainted.lastLogin = value;}, validate: (): Array<string>=>{const fieldErrors = metadataValidateField("lastLogin", data.lastLogin); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},isActive: {path: ["isActive" ]as const, name: "isActive" , constraints: { required: true }, get: ()=>data.isActive, set: (value: boolean)=>{data.isActive = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.isActive, setError: (value: __gf_Option<Array<string>>)=>{errors.isActive = value;}, getTainted: ()=>tainted.isActive, setTainted: (value: __gf_Option<boolean>)=>{tainted.isActive = value;}, validate: (): Array<string>=>{const fieldErrors = metadataValidateField("isActive", data.isActive); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},roles: {path: ["roles" ]as const, name: "roles" , constraints: { required: true }, get: ()=>data.roles, set: (value: string[])=>{data.roles = value;}, transform: (value: string[]): string[] =>value,getError: ()=>errors.roles, setError: (value: __gf_Option<Array<string>>)=>{errors.roles = value;}, getTainted: ()=>tainted.roles, setTainted: (value: __gf_Option<boolean>)=>{tainted.roles = value;}, validate: (): Array<string>=>{const fieldErrors = metadataValidateField("roles", data.roles); return fieldErrors.map((e: {field: string; message: string})=>e.message);},at: (index: number)=>({path: ["roles" , index]as const, name: `roles.${index}` , constraints: {required: true}, get: ()=>data.roles[index]!, set: (value: string)=>{data.roles[index]= value;}, transform: (value: string): string =>value, getError: ()=>errors.roles, setError: (value: __gf_Option<Array<string>>)=>{errors.roles = value;}, getTainted: ()=>tainted.roles, setTainted: (value: __gf_Option<boolean>)=>{tainted.roles = value;}, validate: (): Array<string>=>[],}), push: (item: string)=>{data.roles.push(item);}, remove: (index: number)=>{data.roles.splice(index, 1);}, swap: (a: number, b: number)=>{const tmp = data.roles[a]!; data.roles[a]= data.roles[b]!; data.roles[b]= tmp;},},}; function validate(): Exit<Metadata, Array<{field: string; message: string}>>{return toExit(metadataDeserialize(data));}function reset(newOverrides?: Partial<Metadata>): void {data = {...metadataDefaultValue(),...newOverrides}; errors = {_errors: optionNone(), createdAt: optionNone(), lastLogin: optionNone(), isActive: optionNone(), roles: optionNone(), }; tainted = {createdAt: optionNone(), lastLogin: optionNone(), isActive: optionNone(), roles: optionNone(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function metadataFromFormData(formData: FormData): Exit<Metadata, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.createdAt = formData.get("createdAt" )?? "" ;obj.lastLogin = formData.get("lastLogin" )?? "" ;{const isActiveVal = formData.get("isActive" ); obj.isActive = isActiveVal === "true" || isActiveVal === "on" || isActiveVal === "1" ;}obj.roles = formData.getAll("roles" )as Array<string>;return toExit(metadataDeserialize(obj));}

export const Metadata = {
  defaultValue: metadataDefaultValue,
  serialize: metadataSerialize,
  serializeWithContext: metadataSerializeWithContext,
  deserialize: metadataDeserialize,
  deserializeWithContext: metadataDeserializeWithContext,
  validateFields: metadataValidateFields,
  hasShape: metadataHasShape,
  is: metadataIs,
  createForm: metadataCreateForm,
  fromFormData: metadataFromFormData
} as const;


export interface ColumnConfig {
    
    heading: string;
    dataPath: DataPath;
}

export function columnConfigDefaultValue(): ColumnConfig {return {heading: "",
                            dataPath: dataPathDefaultValue(), }as ColumnConfig;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function columnConfigSerialize(value: ColumnConfig): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(columnConfigSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function columnConfigSerializeWithContext(value: ColumnConfig, ctx: __mf_SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "ColumnConfig" , __id,}; result["heading" ]= value.heading; result["dataPath" ]= dataPathSerializeWithContext(value.dataPath, ctx); return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function columnConfigDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: ColumnConfig } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = columnConfigDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "ColumnConfig.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function columnConfigDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): ColumnConfig | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new __mf_DeserializeError([{field: "_root" , message: "ColumnConfig.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("heading" in obj)){errors.push({field: "heading" , message: "missing required field" });}if(!("dataPath" in obj)){errors.push({field: "dataPath" , message: "missing required field" });}if(errors.length>0){throw new __mf_DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_heading = obj["heading" ]as string; 
                if (__raw_heading.length === 0) {
                    errors.push({ field: "heading", message: "must not be empty" });
                }
 instance.heading = __raw_heading; }{const __raw_dataPath = obj["dataPath" ]as DataPath; {const __result = dataPathDeserializeWithContext(__raw_dataPath, ctx); ctx.assignOrDefer(instance, "dataPath" , __result);}}if(errors.length>0){throw new __mf_DeserializeError(errors);}return instance as ColumnConfig;}export function columnConfigValidateField<K extends keyof ColumnConfig>(_field: K, _value: ColumnConfig[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(_field){case "heading" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "heading", message: "must not be empty" });
                }
 break;}}return errors; }export function columnConfigValidateFields(_partial: Partial<ColumnConfig>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("heading" in _partial && _partial.heading!== undefined){const __val = _partial.heading as string; 
                if (__val.length === 0) {
                    errors.push({ field: "heading", message: "must not be empty" });
                }
}return errors; }export function columnConfigHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "heading" in o && "dataPath" in o;}export function columnConfigIs(obj: unknown): obj is ColumnConfig {if(!columnConfigHasShape(obj)){return false;}const result = columnConfigDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type ColumnConfigErrors = {_errors: __gf_Option<Array<string>>; heading: __gf_Option<Array<string>>; dataPath: __gf_Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type ColumnConfigTainted = {heading: __gf_Option<boolean>; dataPath: __gf_Option<boolean>; }; /** Type-safe field controllers for this form */export interface ColumnConfigFieldControllers {readonly heading: FieldController<string>; readonly dataPath: FieldController<DataPath>; }/** Gigaform instance containing reactive state and field controllers */export interface ColumnConfigGigaform {readonly data: ColumnConfig; readonly errors: ColumnConfigErrors; readonly tainted: ColumnConfigTainted; readonly fields: ColumnConfigFieldControllers; validate(): Exit<ColumnConfig, Array<{field: string; message: string}>>; reset(overrides?: Partial<ColumnConfig>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function columnConfigCreateForm(overrides?: Partial<ColumnConfig>): ColumnConfigGigaform {let data = $state({...columnConfigDefaultValue(),...overrides}); let errors = $state<ColumnConfigErrors>({_errors: optionNone(), heading: optionNone(), dataPath: optionNone(), }); let tainted = $state<ColumnConfigTainted>({heading: optionNone(), dataPath: optionNone(), }); const fields: ColumnConfigFieldControllers = {heading: {path: ["heading" ]as const, name: "heading" , constraints: { required: true }, get: ()=>data.heading, set: (value: string)=>{data.heading = value;}, transform: (value: string): string =>value,getError: ()=>errors.heading, setError: (value: __gf_Option<Array<string>>)=>{errors.heading = value;}, getTainted: ()=>tainted.heading, setTainted: (value: __gf_Option<boolean>)=>{tainted.heading = value;}, validate: (): Array<string>=>{const fieldErrors = columnConfigValidateField("heading", data.heading); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},dataPath: {path: ["dataPath" ]as const, name: "dataPath" , constraints: { required: true }, get: ()=>data.dataPath, set: (value: DataPath)=>{data.dataPath = value;}, transform: (value: DataPath): DataPath =>value,getError: ()=>errors.dataPath, setError: (value: __gf_Option<Array<string>>)=>{errors.dataPath = value;}, getTainted: ()=>tainted.dataPath, setTainted: (value: __gf_Option<boolean>)=>{tainted.dataPath = value;}, validate: (): Array<string>=>{const fieldErrors = columnConfigValidateField("dataPath", data.dataPath); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Exit<ColumnConfig, Array<{field: string; message: string}>>{return toExit(columnConfigDeserialize(data));}function reset(newOverrides?: Partial<ColumnConfig>): void {data = {...columnConfigDefaultValue(),...newOverrides}; errors = {_errors: optionNone(), heading: optionNone(), dataPath: optionNone(), }; tainted = {heading: optionNone(), dataPath: optionNone(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function columnConfigFromFormData(formData: FormData): Exit<ColumnConfig, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.heading = formData.get("heading" )?? "" ;{const dataPathObj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("dataPath." )){const fieldName = key.slice("dataPath." .length); const parts = fieldName.split("." ); let current = dataPathObj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.dataPath = dataPathObj;}return toExit(columnConfigDeserialize(obj));}

export const ColumnConfig = {
  defaultValue: columnConfigDefaultValue,
  serialize: columnConfigSerialize,
  serializeWithContext: columnConfigSerializeWithContext,
  deserialize: columnConfigDeserialize,
  deserializeWithContext: columnConfigDeserializeWithContext,
  validateFields: columnConfigValidateFields,
  hasShape: columnConfigHasShape,
  is: columnConfigIs,
  createForm: columnConfigCreateForm,
  fromFormData: columnConfigFromFormData
} as const;


export interface PhoneNumber {
    
    main: boolean;
    
    
    phoneType: string;
    
    
    number: string;
    
    canText: boolean;
    
    canCall: boolean;
}

export function phoneNumberDefaultValue(): PhoneNumber {return {main: false,
                            phoneType: "",
                            number: "",
                            canText: false,
                            canCall: false, }as PhoneNumber;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function phoneNumberSerialize(value: PhoneNumber): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(phoneNumberSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function phoneNumberSerializeWithContext(value: PhoneNumber, ctx: __mf_SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "PhoneNumber" , __id,}; result["main" ]= value.main; result["phoneType" ]= value.phoneType; result["number" ]= value.number; result["canText" ]= value.canText; result["canCall" ]= value.canCall; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function phoneNumberDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: PhoneNumber } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = phoneNumberDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "PhoneNumber.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function phoneNumberDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): PhoneNumber | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new __mf_DeserializeError([{field: "_root" , message: "PhoneNumber.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("main" in obj)){errors.push({field: "main" , message: "missing required field" });}if(!("phoneType" in obj)){errors.push({field: "phoneType" , message: "missing required field" });}if(!("number" in obj)){errors.push({field: "number" , message: "missing required field" });}if(!("canText" in obj)){errors.push({field: "canText" , message: "missing required field" });}if(!("canCall" in obj)){errors.push({field: "canCall" , message: "missing required field" });}if(errors.length>0){throw new __mf_DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_main = obj["main" ]as boolean; instance.main = __raw_main; }{const __raw_phoneType = obj["phoneType" ]as string; 
                if (__raw_phoneType.length === 0) {
                    errors.push({ field: "phoneType", message: "must not be empty" });
                }
 instance.phoneType = __raw_phoneType; }{const __raw_number = obj["number" ]as string; 
                if (__raw_number.length === 0) {
                    errors.push({ field: "number", message: "must not be empty" });
                }
 instance.number = __raw_number; }{const __raw_canText = obj["canText" ]as boolean; instance.canText = __raw_canText; }{const __raw_canCall = obj["canCall" ]as boolean; instance.canCall = __raw_canCall; }if(errors.length>0){throw new __mf_DeserializeError(errors);}return instance as PhoneNumber;}export function phoneNumberValidateField<K extends keyof PhoneNumber>(_field: K, _value: PhoneNumber[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(_field){case "phoneType" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "phoneType", message: "must not be empty" });
                }
 break;}case "number" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "number", message: "must not be empty" });
                }
 break;}}return errors; }export function phoneNumberValidateFields(_partial: Partial<PhoneNumber>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("phoneType" in _partial && _partial.phoneType!== undefined){const __val = _partial.phoneType as string; 
                if (__val.length === 0) {
                    errors.push({ field: "phoneType", message: "must not be empty" });
                }
}if("number" in _partial && _partial.number!== undefined){const __val = _partial.number as string; 
                if (__val.length === 0) {
                    errors.push({ field: "number", message: "must not be empty" });
                }
}return errors; }export function phoneNumberHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "main" in o && "phoneType" in o && "number" in o && "canText" in o && "canCall" in o;}export function phoneNumberIs(obj: unknown): obj is PhoneNumber {if(!phoneNumberHasShape(obj)){return false;}const result = phoneNumberDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type PhoneNumberErrors = {_errors: __gf_Option<Array<string>>; main: __gf_Option<Array<string>>; phoneType: __gf_Option<Array<string>>; number: __gf_Option<Array<string>>; canText: __gf_Option<Array<string>>; canCall: __gf_Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type PhoneNumberTainted = {main: __gf_Option<boolean>; phoneType: __gf_Option<boolean>; number: __gf_Option<boolean>; canText: __gf_Option<boolean>; canCall: __gf_Option<boolean>; }; /** Type-safe field controllers for this form */export interface PhoneNumberFieldControllers {readonly main: FieldController<boolean>; readonly phoneType: FieldController<string>; readonly number: FieldController<string>; readonly canText: FieldController<boolean>; readonly canCall: FieldController<boolean>; }/** Gigaform instance containing reactive state and field controllers */export interface PhoneNumberGigaform {readonly data: PhoneNumber; readonly errors: PhoneNumberErrors; readonly tainted: PhoneNumberTainted; readonly fields: PhoneNumberFieldControllers; validate(): Exit<PhoneNumber, Array<{field: string; message: string}>>; reset(overrides?: Partial<PhoneNumber>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function phoneNumberCreateForm(overrides?: Partial<PhoneNumber>): PhoneNumberGigaform {let data = $state({...phoneNumberDefaultValue(),...overrides}); let errors = $state<PhoneNumberErrors>({_errors: optionNone(), main: optionNone(), phoneType: optionNone(), number: optionNone(), canText: optionNone(), canCall: optionNone(), }); let tainted = $state<PhoneNumberTainted>({main: optionNone(), phoneType: optionNone(), number: optionNone(), canText: optionNone(), canCall: optionNone(), }); const fields: PhoneNumberFieldControllers = {main: {path: ["main" ]as const, name: "main" , constraints: { required: true }, label: "Main" , get: ()=>data.main, set: (value: boolean)=>{data.main = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.main, setError: (value: __gf_Option<Array<string>>)=>{errors.main = value;}, getTainted: ()=>tainted.main, setTainted: (value: __gf_Option<boolean>)=>{tainted.main = value;}, validate: (): Array<string>=>{const fieldErrors = phoneNumberValidateField("main", data.main); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},phoneType: {path: ["phoneType" ]as const, name: "phoneType" , constraints: { required: true }, label: "Phone Type" , get: ()=>data.phoneType, set: (value: string)=>{data.phoneType = value;}, transform: (value: string): string =>value,getError: ()=>errors.phoneType, setError: (value: __gf_Option<Array<string>>)=>{errors.phoneType = value;}, getTainted: ()=>tainted.phoneType, setTainted: (value: __gf_Option<boolean>)=>{tainted.phoneType = value;}, validate: (): Array<string>=>{const fieldErrors = phoneNumberValidateField("phoneType", data.phoneType); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},number: {path: ["number" ]as const, name: "number" , constraints: { required: true }, label: "Number" , get: ()=>data.number, set: (value: string)=>{data.number = value;}, transform: (value: string): string =>value,getError: ()=>errors.number, setError: (value: __gf_Option<Array<string>>)=>{errors.number = value;}, getTainted: ()=>tainted.number, setTainted: (value: __gf_Option<boolean>)=>{tainted.number = value;}, validate: (): Array<string>=>{const fieldErrors = phoneNumberValidateField("number", data.number); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},canText: {path: ["canText" ]as const, name: "canText" , constraints: { required: true }, label: "Can Text" , get: ()=>data.canText, set: (value: boolean)=>{data.canText = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.canText, setError: (value: __gf_Option<Array<string>>)=>{errors.canText = value;}, getTainted: ()=>tainted.canText, setTainted: (value: __gf_Option<boolean>)=>{tainted.canText = value;}, validate: (): Array<string>=>{const fieldErrors = phoneNumberValidateField("canText", data.canText); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},canCall: {path: ["canCall" ]as const, name: "canCall" , constraints: { required: true }, label: "Can Call" , get: ()=>data.canCall, set: (value: boolean)=>{data.canCall = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.canCall, setError: (value: __gf_Option<Array<string>>)=>{errors.canCall = value;}, getTainted: ()=>tainted.canCall, setTainted: (value: __gf_Option<boolean>)=>{tainted.canCall = value;}, validate: (): Array<string>=>{const fieldErrors = phoneNumberValidateField("canCall", data.canCall); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Exit<PhoneNumber, Array<{field: string; message: string}>>{return toExit(phoneNumberDeserialize(data));}function reset(newOverrides?: Partial<PhoneNumber>): void {data = {...phoneNumberDefaultValue(),...newOverrides}; errors = {_errors: optionNone(), main: optionNone(), phoneType: optionNone(), number: optionNone(), canText: optionNone(), canCall: optionNone(), }; tainted = {main: optionNone(), phoneType: optionNone(), number: optionNone(), canText: optionNone(), canCall: optionNone(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function phoneNumberFromFormData(formData: FormData): Exit<PhoneNumber, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; {const mainVal = formData.get("main" ); obj.main = mainVal === "true" || mainVal === "on" || mainVal === "1" ;}obj.phoneType = formData.get("phoneType" )?? "" ;obj.number = formData.get("number" )?? "" ;{const canTextVal = formData.get("canText" ); obj.canText = canTextVal === "true" || canTextVal === "on" || canTextVal === "1" ;}{const canCallVal = formData.get("canCall" ); obj.canCall = canCallVal === "true" || canCallVal === "on" || canCallVal === "1" ;}return toExit(phoneNumberDeserialize(obj));}

export const PhoneNumber = {
  defaultValue: phoneNumberDefaultValue,
  serialize: phoneNumberSerialize,
  serializeWithContext: phoneNumberSerializeWithContext,
  deserialize: phoneNumberDeserialize,
  deserializeWithContext: phoneNumberDeserializeWithContext,
  validateFields: phoneNumberValidateFields,
  hasShape: phoneNumberHasShape,
  is: phoneNumberIs,
  createForm: phoneNumberCreateForm,
  fromFormData: phoneNumberFromFormData
} as const;


export interface Gradient {
    startHue: number;
}

export function gradientDefaultValue(): Gradient {return {startHue: 0, }as Gradient;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function gradientSerialize(value: Gradient): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(gradientSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function gradientSerializeWithContext(value: Gradient, ctx: __mf_SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Gradient" , __id,}; result["startHue" ]= value.startHue; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function gradientDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: Gradient } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = gradientDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Gradient.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function gradientDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Gradient | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new __mf_DeserializeError([{field: "_root" , message: "Gradient.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("startHue" in obj)){errors.push({field: "startHue" , message: "missing required field" });}if(errors.length>0){throw new __mf_DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_startHue = obj["startHue" ]as number; instance.startHue = __raw_startHue; }if(errors.length>0){throw new __mf_DeserializeError(errors);}return instance as Gradient;}export function gradientValidateField<K extends keyof Gradient>(_field: K, _value: Gradient[K]): Array<{field: string; message: string}>{return[]; }export function gradientValidateFields(_partial: Partial<Gradient>): Array<{field: string; message: string}>{return[]; }export function gradientHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "startHue" in o;}export function gradientIs(obj: unknown): obj is Gradient {if(!gradientHasShape(obj)){return false;}const result = gradientDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type GradientErrors = {_errors: __gf_Option<Array<string>>; startHue: __gf_Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type GradientTainted = {startHue: __gf_Option<boolean>; }; /** Type-safe field controllers for this form */export interface GradientFieldControllers {readonly startHue: FieldController<number>; }/** Gigaform instance containing reactive state and field controllers */export interface GradientGigaform {readonly data: Gradient; readonly errors: GradientErrors; readonly tainted: GradientTainted; readonly fields: GradientFieldControllers; validate(): Exit<Gradient, Array<{field: string; message: string}>>; reset(overrides?: Partial<Gradient>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function gradientCreateForm(overrides?: Partial<Gradient>): GradientGigaform {let data = $state({...gradientDefaultValue(),...overrides}); let errors = $state<GradientErrors>({_errors: optionNone(), startHue: optionNone(), }); let tainted = $state<GradientTainted>({startHue: optionNone(), }); const fields: GradientFieldControllers = {startHue: {path: ["startHue" ]as const, name: "startHue" , constraints: { required: true }, get: ()=>data.startHue, set: (value: number)=>{data.startHue = value;}, transform: (value: number): number =>value,getError: ()=>errors.startHue, setError: (value: __gf_Option<Array<string>>)=>{errors.startHue = value;}, getTainted: ()=>tainted.startHue, setTainted: (value: __gf_Option<boolean>)=>{tainted.startHue = value;}, validate: (): Array<string>=>{const fieldErrors = gradientValidateField("startHue", data.startHue); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Exit<Gradient, Array<{field: string; message: string}>>{return toExit(gradientDeserialize(data));}function reset(newOverrides?: Partial<Gradient>): void {data = {...gradientDefaultValue(),...newOverrides}; errors = {_errors: optionNone(), startHue: optionNone(), }; tainted = {startHue: optionNone(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function gradientFromFormData(formData: FormData): Exit<Gradient, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; {const startHueStr = formData.get("startHue" ); obj.startHue = startHueStr? parseFloat(startHueStr as string): 0; if(obj.startHue!== undefined && isNaN(obj.startHue as number))obj.startHue = 0;}return toExit(gradientDeserialize(obj));}

export const Gradient = {
  defaultValue: gradientDefaultValue,
  serialize: gradientSerialize,
  serializeWithContext: gradientSerializeWithContext,
  deserialize: gradientDeserialize,
  deserializeWithContext: gradientDeserializeWithContext,
  validateFields: gradientValidateFields,
  hasShape: gradientHasShape,
  is: gradientIs,
  createForm: gradientCreateForm,
  fromFormData: gradientFromFormData
} as const;


export interface Product {
    
    id: string;
    
    
    name: string;
    
    
    quickCode: string;
    
    group: string | null;
    
    subgroup: string | null;
    
    unit: string | null;
    
    active: boolean;
    
    commission: boolean;
    
    favorite: boolean;
    defaults: ProductDefaults;
}

export function productDefaultValue(): Product {return {id: "",
                            name: "",
                            quickCode: "",
                            group: null,
                            subgroup: null,
                            unit: null,
                            active: false,
                            commission: false,
                            favorite: false,
                            defaults: productDefaultsDefaultValue(), }as Product;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function productSerialize(value: Product): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(productSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function productSerializeWithContext(value: Product, ctx: __mf_SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Product" , __id,}; result["id" ]= value.id; result["name" ]= value.name; result["quickCode" ]= value.quickCode; result["group" ]= value.group; result["subgroup" ]= value.subgroup; result["unit" ]= value.unit; result["active" ]= value.active; result["commission" ]= value.commission; result["favorite" ]= value.favorite; result["defaults" ]= productDefaultsSerializeWithContext(value.defaults, ctx); return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function productDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: Product } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = productDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Product.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function productDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Product | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new __mf_DeserializeError([{field: "_root" , message: "Product.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("id" in obj)){errors.push({field: "id" , message: "missing required field" });}if(!("name" in obj)){errors.push({field: "name" , message: "missing required field" });}if(!("quickCode" in obj)){errors.push({field: "quickCode" , message: "missing required field" });}if(!("group" in obj)){errors.push({field: "group" , message: "missing required field" });}if(!("subgroup" in obj)){errors.push({field: "subgroup" , message: "missing required field" });}if(!("unit" in obj)){errors.push({field: "unit" , message: "missing required field" });}if(!("active" in obj)){errors.push({field: "active" , message: "missing required field" });}if(!("commission" in obj)){errors.push({field: "commission" , message: "missing required field" });}if(!("favorite" in obj)){errors.push({field: "favorite" , message: "missing required field" });}if(!("defaults" in obj)){errors.push({field: "defaults" , message: "missing required field" });}if(errors.length>0){throw new __mf_DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_id = obj["id" ]as string; instance.id = __raw_id; }{const __raw_name = obj["name" ]as string; 
                if (__raw_name.length === 0) {
                    errors.push({ field: "name", message: "must not be empty" });
                }
 instance.name = __raw_name; }{const __raw_quickCode = obj["quickCode" ]as string; 
                if (__raw_quickCode.length === 0) {
                    errors.push({ field: "quickCode", message: "must not be empty" });
                }
 instance.quickCode = __raw_quickCode; }{const __raw_group = obj["group" ]as string | null; instance.group = __raw_group; }{const __raw_subgroup = obj["subgroup" ]as string | null; instance.subgroup = __raw_subgroup; }{const __raw_unit = obj["unit" ]as string | null; instance.unit = __raw_unit; }{const __raw_active = obj["active" ]as boolean; instance.active = __raw_active; }{const __raw_commission = obj["commission" ]as boolean; instance.commission = __raw_commission; }{const __raw_favorite = obj["favorite" ]as boolean; instance.favorite = __raw_favorite; }{const __raw_defaults = obj["defaults" ]as ProductDefaults; {const __result = productDefaultsDeserializeWithContext(__raw_defaults, ctx); ctx.assignOrDefer(instance, "defaults" , __result);}}if(errors.length>0){throw new __mf_DeserializeError(errors);}return instance as Product;}export function productValidateField<K extends keyof Product>(_field: K, _value: Product[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(_field){case "name" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "name", message: "must not be empty" });
                }
 break;}case "quickCode" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "quickCode", message: "must not be empty" });
                }
 break;}}return errors; }export function productValidateFields(_partial: Partial<Product>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("name" in _partial && _partial.name!== undefined){const __val = _partial.name as string; 
                if (__val.length === 0) {
                    errors.push({ field: "name", message: "must not be empty" });
                }
}if("quickCode" in _partial && _partial.quickCode!== undefined){const __val = _partial.quickCode as string; 
                if (__val.length === 0) {
                    errors.push({ field: "quickCode", message: "must not be empty" });
                }
}return errors; }export function productHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "id" in o && "name" in o && "quickCode" in o && "group" in o && "subgroup" in o && "unit" in o && "active" in o && "commission" in o && "favorite" in o && "defaults" in o;}export function productIs(obj: unknown): obj is Product {if(!productHasShape(obj)){return false;}const result = productDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type ProductErrors = {_errors: __gf_Option<Array<string>>; id: __gf_Option<Array<string>>; name: __gf_Option<Array<string>>; quickCode: __gf_Option<Array<string>>; group: __gf_Option<Array<string>>; subgroup: __gf_Option<Array<string>>; unit: __gf_Option<Array<string>>; active: __gf_Option<Array<string>>; commission: __gf_Option<Array<string>>; favorite: __gf_Option<Array<string>>; defaults: __gf_Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type ProductTainted = {id: __gf_Option<boolean>; name: __gf_Option<boolean>; quickCode: __gf_Option<boolean>; group: __gf_Option<boolean>; subgroup: __gf_Option<boolean>; unit: __gf_Option<boolean>; active: __gf_Option<boolean>; commission: __gf_Option<boolean>; favorite: __gf_Option<boolean>; defaults: __gf_Option<boolean>; }; /** Type-safe field controllers for this form */export interface ProductFieldControllers {readonly id: FieldController<string>; readonly name: FieldController<string>; readonly quickCode: FieldController<string>; readonly group: FieldController<string | null>; readonly subgroup: FieldController<string | null>; readonly unit: FieldController<string | null>; readonly active: FieldController<boolean>; readonly commission: FieldController<boolean>; readonly favorite: FieldController<boolean>; readonly defaults: FieldController<ProductDefaults>; }/** Gigaform instance containing reactive state and field controllers */export interface ProductGigaform {readonly data: Product; readonly errors: ProductErrors; readonly tainted: ProductTainted; readonly fields: ProductFieldControllers; validate(): Exit<Product, Array<{field: string; message: string}>>; reset(overrides?: Partial<Product>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function productCreateForm(overrides?: Partial<Product>): ProductGigaform {let data = $state({...productDefaultValue(),...overrides}); let errors = $state<ProductErrors>({_errors: optionNone(), id: optionNone(), name: optionNone(), quickCode: optionNone(), group: optionNone(), subgroup: optionNone(), unit: optionNone(), active: optionNone(), commission: optionNone(), favorite: optionNone(), defaults: optionNone(), }); let tainted = $state<ProductTainted>({id: optionNone(), name: optionNone(), quickCode: optionNone(), group: optionNone(), subgroup: optionNone(), unit: optionNone(), active: optionNone(), commission: optionNone(), favorite: optionNone(), defaults: optionNone(), }); const fields: ProductFieldControllers = {id: {path: ["id" ]as const, name: "id" , constraints: { required: true }, get: ()=>data.id, set: (value: string)=>{data.id = value;}, transform: (value: string): string =>value,getError: ()=>errors.id, setError: (value: __gf_Option<Array<string>>)=>{errors.id = value;}, getTainted: ()=>tainted.id, setTainted: (value: __gf_Option<boolean>)=>{tainted.id = value;}, validate: (): Array<string>=>{const fieldErrors = productValidateField("id", data.id); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},name: {path: ["name" ]as const, name: "name" , constraints: { required: true }, label: "Name" , get: ()=>data.name, set: (value: string)=>{data.name = value;}, transform: (value: string): string =>value,getError: ()=>errors.name, setError: (value: __gf_Option<Array<string>>)=>{errors.name = value;}, getTainted: ()=>tainted.name, setTainted: (value: __gf_Option<boolean>)=>{tainted.name = value;}, validate: (): Array<string>=>{const fieldErrors = productValidateField("name", data.name); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},quickCode: {path: ["quickCode" ]as const, name: "quickCode" , constraints: { required: true }, label: "Quick Code" , get: ()=>data.quickCode, set: (value: string)=>{data.quickCode = value;}, transform: (value: string): string =>value,getError: ()=>errors.quickCode, setError: (value: __gf_Option<Array<string>>)=>{errors.quickCode = value;}, getTainted: ()=>tainted.quickCode, setTainted: (value: __gf_Option<boolean>)=>{tainted.quickCode = value;}, validate: (): Array<string>=>{const fieldErrors = productValidateField("quickCode", data.quickCode); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},group: {path: ["group" ]as const, name: "group" , constraints: { required: true }, label: "Group" , get: ()=>data.group, set: (value: string | null)=>{data.group = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.group, setError: (value: __gf_Option<Array<string>>)=>{errors.group = value;}, getTainted: ()=>tainted.group, setTainted: (value: __gf_Option<boolean>)=>{tainted.group = value;}, validate: (): Array<string>=>{const fieldErrors = productValidateField("group", data.group); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},subgroup: {path: ["subgroup" ]as const, name: "subgroup" , constraints: { required: true }, label: "Subgroup" , get: ()=>data.subgroup, set: (value: string | null)=>{data.subgroup = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.subgroup, setError: (value: __gf_Option<Array<string>>)=>{errors.subgroup = value;}, getTainted: ()=>tainted.subgroup, setTainted: (value: __gf_Option<boolean>)=>{tainted.subgroup = value;}, validate: (): Array<string>=>{const fieldErrors = productValidateField("subgroup", data.subgroup); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},unit: {path: ["unit" ]as const, name: "unit" , constraints: { required: true }, label: "Unit" , get: ()=>data.unit, set: (value: string | null)=>{data.unit = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.unit, setError: (value: __gf_Option<Array<string>>)=>{errors.unit = value;}, getTainted: ()=>tainted.unit, setTainted: (value: __gf_Option<boolean>)=>{tainted.unit = value;}, validate: (): Array<string>=>{const fieldErrors = productValidateField("unit", data.unit); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},active: {path: ["active" ]as const, name: "active" , constraints: { required: true }, label: "Active" , get: ()=>data.active, set: (value: boolean)=>{data.active = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.active, setError: (value: __gf_Option<Array<string>>)=>{errors.active = value;}, getTainted: ()=>tainted.active, setTainted: (value: __gf_Option<boolean>)=>{tainted.active = value;}, validate: (): Array<string>=>{const fieldErrors = productValidateField("active", data.active); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},commission: {path: ["commission" ]as const, name: "commission" , constraints: { required: true }, label: "Commission" , get: ()=>data.commission, set: (value: boolean)=>{data.commission = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.commission, setError: (value: __gf_Option<Array<string>>)=>{errors.commission = value;}, getTainted: ()=>tainted.commission, setTainted: (value: __gf_Option<boolean>)=>{tainted.commission = value;}, validate: (): Array<string>=>{const fieldErrors = productValidateField("commission", data.commission); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},favorite: {path: ["favorite" ]as const, name: "favorite" , constraints: { required: true }, label: "Favorite" , get: ()=>data.favorite, set: (value: boolean)=>{data.favorite = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.favorite, setError: (value: __gf_Option<Array<string>>)=>{errors.favorite = value;}, getTainted: ()=>tainted.favorite, setTainted: (value: __gf_Option<boolean>)=>{tainted.favorite = value;}, validate: (): Array<string>=>{const fieldErrors = productValidateField("favorite", data.favorite); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},defaults: {path: ["defaults" ]as const, name: "defaults" , constraints: { required: true }, get: ()=>data.defaults, set: (value: ProductDefaults)=>{data.defaults = value;}, transform: (value: ProductDefaults): ProductDefaults =>value,getError: ()=>errors.defaults, setError: (value: __gf_Option<Array<string>>)=>{errors.defaults = value;}, getTainted: ()=>tainted.defaults, setTainted: (value: __gf_Option<boolean>)=>{tainted.defaults = value;}, validate: (): Array<string>=>{const fieldErrors = productValidateField("defaults", data.defaults); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Exit<Product, Array<{field: string; message: string}>>{return toExit(productDeserialize(data));}function reset(newOverrides?: Partial<Product>): void {data = {...productDefaultValue(),...newOverrides}; errors = {_errors: optionNone(), id: optionNone(), name: optionNone(), quickCode: optionNone(), group: optionNone(), subgroup: optionNone(), unit: optionNone(), active: optionNone(), commission: optionNone(), favorite: optionNone(), defaults: optionNone(), }; tainted = {id: optionNone(), name: optionNone(), quickCode: optionNone(), group: optionNone(), subgroup: optionNone(), unit: optionNone(), active: optionNone(), commission: optionNone(), favorite: optionNone(), defaults: optionNone(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function productFromFormData(formData: FormData): Exit<Product, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.id = formData.get("id" )?? "" ;obj.name = formData.get("name" )?? "" ;obj.quickCode = formData.get("quickCode" )?? "" ;obj.group = formData.get("group" )?? "" ;obj.subgroup = formData.get("subgroup" )?? "" ;obj.unit = formData.get("unit" )?? "" ;{const activeVal = formData.get("active" ); obj.active = activeVal === "true" || activeVal === "on" || activeVal === "1" ;}{const commissionVal = formData.get("commission" ); obj.commission = commissionVal === "true" || commissionVal === "on" || commissionVal === "1" ;}{const favoriteVal = formData.get("favorite" ); obj.favorite = favoriteVal === "true" || favoriteVal === "on" || favoriteVal === "1" ;}{const defaultsObj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("defaults." )){const fieldName = key.slice("defaults." .length); const parts = fieldName.split("." ); let current = defaultsObj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.defaults = defaultsObj;}return toExit(productDeserialize(obj));}

export const Product = {
  defaultValue: productDefaultValue,
  serialize: productSerialize,
  serializeWithContext: productSerializeWithContext,
  deserialize: productDeserialize,
  deserializeWithContext: productDeserializeWithContext,
  validateFields: productValidateFields,
  hasShape: productHasShape,
  is: productIs,
  createForm: productCreateForm,
  fromFormData: productFromFormData
} as const;


export interface YearlyRecurrenceRule {
    quantityOfYears: number;
}

export function yearlyRecurrenceRuleDefaultValue(): YearlyRecurrenceRule {return {quantityOfYears: 0, }as YearlyRecurrenceRule;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function yearlyRecurrenceRuleSerialize(value: YearlyRecurrenceRule): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(yearlyRecurrenceRuleSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function yearlyRecurrenceRuleSerializeWithContext(value: YearlyRecurrenceRule, ctx: __mf_SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "YearlyRecurrenceRule" , __id,}; result["quantityOfYears" ]= value.quantityOfYears; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function yearlyRecurrenceRuleDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: YearlyRecurrenceRule } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = yearlyRecurrenceRuleDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "YearlyRecurrenceRule.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function yearlyRecurrenceRuleDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): YearlyRecurrenceRule | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new __mf_DeserializeError([{field: "_root" , message: "YearlyRecurrenceRule.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("quantityOfYears" in obj)){errors.push({field: "quantityOfYears" , message: "missing required field" });}if(errors.length>0){throw new __mf_DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_quantityOfYears = obj["quantityOfYears" ]as number; instance.quantityOfYears = __raw_quantityOfYears; }if(errors.length>0){throw new __mf_DeserializeError(errors);}return instance as YearlyRecurrenceRule;}export function yearlyRecurrenceRuleValidateField<K extends keyof YearlyRecurrenceRule>(_field: K, _value: YearlyRecurrenceRule[K]): Array<{field: string; message: string}>{return[]; }export function yearlyRecurrenceRuleValidateFields(_partial: Partial<YearlyRecurrenceRule>): Array<{field: string; message: string}>{return[]; }export function yearlyRecurrenceRuleHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "quantityOfYears" in o;}export function yearlyRecurrenceRuleIs(obj: unknown): obj is YearlyRecurrenceRule {if(!yearlyRecurrenceRuleHasShape(obj)){return false;}const result = yearlyRecurrenceRuleDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type YearlyRecurrenceRuleErrors = {_errors: __gf_Option<Array<string>>; quantityOfYears: __gf_Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type YearlyRecurrenceRuleTainted = {quantityOfYears: __gf_Option<boolean>; }; /** Type-safe field controllers for this form */export interface YearlyRecurrenceRuleFieldControllers {readonly quantityOfYears: FieldController<number>; }/** Gigaform instance containing reactive state and field controllers */export interface YearlyRecurrenceRuleGigaform {readonly data: YearlyRecurrenceRule; readonly errors: YearlyRecurrenceRuleErrors; readonly tainted: YearlyRecurrenceRuleTainted; readonly fields: YearlyRecurrenceRuleFieldControllers; validate(): Exit<YearlyRecurrenceRule, Array<{field: string; message: string}>>; reset(overrides?: Partial<YearlyRecurrenceRule>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function yearlyRecurrenceRuleCreateForm(overrides?: Partial<YearlyRecurrenceRule>): YearlyRecurrenceRuleGigaform {let data = $state({...yearlyRecurrenceRuleDefaultValue(),...overrides}); let errors = $state<YearlyRecurrenceRuleErrors>({_errors: optionNone(), quantityOfYears: optionNone(), }); let tainted = $state<YearlyRecurrenceRuleTainted>({quantityOfYears: optionNone(), }); const fields: YearlyRecurrenceRuleFieldControllers = {quantityOfYears: {path: ["quantityOfYears" ]as const, name: "quantityOfYears" , constraints: { required: true }, get: ()=>data.quantityOfYears, set: (value: number)=>{data.quantityOfYears = value;}, transform: (value: number): number =>value,getError: ()=>errors.quantityOfYears, setError: (value: __gf_Option<Array<string>>)=>{errors.quantityOfYears = value;}, getTainted: ()=>tainted.quantityOfYears, setTainted: (value: __gf_Option<boolean>)=>{tainted.quantityOfYears = value;}, validate: (): Array<string>=>{const fieldErrors = yearlyRecurrenceRuleValidateField("quantityOfYears", data.quantityOfYears); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Exit<YearlyRecurrenceRule, Array<{field: string; message: string}>>{return toExit(yearlyRecurrenceRuleDeserialize(data));}function reset(newOverrides?: Partial<YearlyRecurrenceRule>): void {data = {...yearlyRecurrenceRuleDefaultValue(),...newOverrides}; errors = {_errors: optionNone(), quantityOfYears: optionNone(), }; tainted = {quantityOfYears: optionNone(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function yearlyRecurrenceRuleFromFormData(formData: FormData): Exit<YearlyRecurrenceRule, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; {const quantityOfYearsStr = formData.get("quantityOfYears" ); obj.quantityOfYears = quantityOfYearsStr? parseFloat(quantityOfYearsStr as string): 0; if(obj.quantityOfYears!== undefined && isNaN(obj.quantityOfYears as number))obj.quantityOfYears = 0;}return toExit(yearlyRecurrenceRuleDeserialize(obj));}

export const YearlyRecurrenceRule = {
  defaultValue: yearlyRecurrenceRuleDefaultValue,
  serialize: yearlyRecurrenceRuleSerialize,
  serializeWithContext: yearlyRecurrenceRuleSerializeWithContext,
  deserialize: yearlyRecurrenceRuleDeserialize,
  deserializeWithContext: yearlyRecurrenceRuleDeserializeWithContext,
  validateFields: yearlyRecurrenceRuleValidateFields,
  hasShape: yearlyRecurrenceRuleHasShape,
  is: yearlyRecurrenceRuleIs,
  createForm: yearlyRecurrenceRuleCreateForm,
  fromFormData: yearlyRecurrenceRuleFromFormData
} as const;


export interface AppointmentNotifications {
    
    personalScheduleChangeNotifications: string;
    
    allScheduleChangeNotifications: string;
}

export function appointmentNotificationsDefaultValue(): AppointmentNotifications {return {personalScheduleChangeNotifications: "",
                            allScheduleChangeNotifications: "", }as AppointmentNotifications;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function appointmentNotificationsSerialize(value: AppointmentNotifications): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(appointmentNotificationsSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function appointmentNotificationsSerializeWithContext(value: AppointmentNotifications, ctx: __mf_SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "AppointmentNotifications" , __id,}; result["personalScheduleChangeNotifications" ]= value.personalScheduleChangeNotifications; result["allScheduleChangeNotifications" ]= value.allScheduleChangeNotifications; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function appointmentNotificationsDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: AppointmentNotifications } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = appointmentNotificationsDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "AppointmentNotifications.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function appointmentNotificationsDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): AppointmentNotifications | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new __mf_DeserializeError([{field: "_root" , message: "AppointmentNotifications.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("personalScheduleChangeNotifications" in obj)){errors.push({field: "personalScheduleChangeNotifications" , message: "missing required field" });}if(!("allScheduleChangeNotifications" in obj)){errors.push({field: "allScheduleChangeNotifications" , message: "missing required field" });}if(errors.length>0){throw new __mf_DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_personalScheduleChangeNotifications = obj["personalScheduleChangeNotifications" ]as string; 
                if (__raw_personalScheduleChangeNotifications.length === 0) {
                    errors.push({ field: "personalScheduleChangeNotifications", message: "must not be empty" });
                }
 instance.personalScheduleChangeNotifications = __raw_personalScheduleChangeNotifications; }{const __raw_allScheduleChangeNotifications = obj["allScheduleChangeNotifications" ]as string; 
                if (__raw_allScheduleChangeNotifications.length === 0) {
                    errors.push({ field: "allScheduleChangeNotifications", message: "must not be empty" });
                }
 instance.allScheduleChangeNotifications = __raw_allScheduleChangeNotifications; }if(errors.length>0){throw new __mf_DeserializeError(errors);}return instance as AppointmentNotifications;}export function appointmentNotificationsValidateField<K extends keyof AppointmentNotifications>(_field: K, _value: AppointmentNotifications[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(_field){case "personalScheduleChangeNotifications" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "personalScheduleChangeNotifications", message: "must not be empty" });
                }
 break;}case "allScheduleChangeNotifications" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "allScheduleChangeNotifications", message: "must not be empty" });
                }
 break;}}return errors; }export function appointmentNotificationsValidateFields(_partial: Partial<AppointmentNotifications>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("personalScheduleChangeNotifications" in _partial && _partial.personalScheduleChangeNotifications!== undefined){const __val = _partial.personalScheduleChangeNotifications as string; 
                if (__val.length === 0) {
                    errors.push({ field: "personalScheduleChangeNotifications", message: "must not be empty" });
                }
}if("allScheduleChangeNotifications" in _partial && _partial.allScheduleChangeNotifications!== undefined){const __val = _partial.allScheduleChangeNotifications as string; 
                if (__val.length === 0) {
                    errors.push({ field: "allScheduleChangeNotifications", message: "must not be empty" });
                }
}return errors; }export function appointmentNotificationsHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "personalScheduleChangeNotifications" in o && "allScheduleChangeNotifications" in o;}export function appointmentNotificationsIs(obj: unknown): obj is AppointmentNotifications {if(!appointmentNotificationsHasShape(obj)){return false;}const result = appointmentNotificationsDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type AppointmentNotificationsErrors = {_errors: __gf_Option<Array<string>>; personalScheduleChangeNotifications: __gf_Option<Array<string>>; allScheduleChangeNotifications: __gf_Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type AppointmentNotificationsTainted = {personalScheduleChangeNotifications: __gf_Option<boolean>; allScheduleChangeNotifications: __gf_Option<boolean>; }; /** Type-safe field controllers for this form */export interface AppointmentNotificationsFieldControllers {readonly personalScheduleChangeNotifications: FieldController<string>; readonly allScheduleChangeNotifications: FieldController<string>; }/** Gigaform instance containing reactive state and field controllers */export interface AppointmentNotificationsGigaform {readonly data: AppointmentNotifications; readonly errors: AppointmentNotificationsErrors; readonly tainted: AppointmentNotificationsTainted; readonly fields: AppointmentNotificationsFieldControllers; validate(): Exit<AppointmentNotifications, Array<{field: string; message: string}>>; reset(overrides?: Partial<AppointmentNotifications>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function appointmentNotificationsCreateForm(overrides?: Partial<AppointmentNotifications>): AppointmentNotificationsGigaform {let data = $state({...appointmentNotificationsDefaultValue(),...overrides}); let errors = $state<AppointmentNotificationsErrors>({_errors: optionNone(), personalScheduleChangeNotifications: optionNone(), allScheduleChangeNotifications: optionNone(), }); let tainted = $state<AppointmentNotificationsTainted>({personalScheduleChangeNotifications: optionNone(), allScheduleChangeNotifications: optionNone(), }); const fields: AppointmentNotificationsFieldControllers = {personalScheduleChangeNotifications: {path: ["personalScheduleChangeNotifications" ]as const, name: "personalScheduleChangeNotifications" , constraints: { required: true }, get: ()=>data.personalScheduleChangeNotifications, set: (value: string)=>{data.personalScheduleChangeNotifications = value;}, transform: (value: string): string =>value,getError: ()=>errors.personalScheduleChangeNotifications, setError: (value: __gf_Option<Array<string>>)=>{errors.personalScheduleChangeNotifications = value;}, getTainted: ()=>tainted.personalScheduleChangeNotifications, setTainted: (value: __gf_Option<boolean>)=>{tainted.personalScheduleChangeNotifications = value;}, validate: (): Array<string>=>{const fieldErrors = appointmentNotificationsValidateField("personalScheduleChangeNotifications", data.personalScheduleChangeNotifications); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},allScheduleChangeNotifications: {path: ["allScheduleChangeNotifications" ]as const, name: "allScheduleChangeNotifications" , constraints: { required: true }, get: ()=>data.allScheduleChangeNotifications, set: (value: string)=>{data.allScheduleChangeNotifications = value;}, transform: (value: string): string =>value,getError: ()=>errors.allScheduleChangeNotifications, setError: (value: __gf_Option<Array<string>>)=>{errors.allScheduleChangeNotifications = value;}, getTainted: ()=>tainted.allScheduleChangeNotifications, setTainted: (value: __gf_Option<boolean>)=>{tainted.allScheduleChangeNotifications = value;}, validate: (): Array<string>=>{const fieldErrors = appointmentNotificationsValidateField("allScheduleChangeNotifications", data.allScheduleChangeNotifications); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Exit<AppointmentNotifications, Array<{field: string; message: string}>>{return toExit(appointmentNotificationsDeserialize(data));}function reset(newOverrides?: Partial<AppointmentNotifications>): void {data = {...appointmentNotificationsDefaultValue(),...newOverrides}; errors = {_errors: optionNone(), personalScheduleChangeNotifications: optionNone(), allScheduleChangeNotifications: optionNone(), }; tainted = {personalScheduleChangeNotifications: optionNone(), allScheduleChangeNotifications: optionNone(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function appointmentNotificationsFromFormData(formData: FormData): Exit<AppointmentNotifications, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.personalScheduleChangeNotifications = formData.get("personalScheduleChangeNotifications" )?? "" ;obj.allScheduleChangeNotifications = formData.get("allScheduleChangeNotifications" )?? "" ;return toExit(appointmentNotificationsDeserialize(obj));}

export const AppointmentNotifications = {
  defaultValue: appointmentNotificationsDefaultValue,
  serialize: appointmentNotificationsSerialize,
  serializeWithContext: appointmentNotificationsSerializeWithContext,
  deserialize: appointmentNotificationsDeserialize,
  deserializeWithContext: appointmentNotificationsDeserializeWithContext,
  validateFields: appointmentNotificationsValidateFields,
  hasShape: appointmentNotificationsHasShape,
  is: appointmentNotificationsIs,
  createForm: appointmentNotificationsCreateForm,
  fromFormData: appointmentNotificationsFromFormData
} as const;


export interface DirectionHue {
    bearing: number;
    hue: number;
}

export function directionHueDefaultValue(): DirectionHue {return {bearing: 0,
                            hue: 0, }as DirectionHue;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function directionHueSerialize(value: DirectionHue): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(directionHueSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function directionHueSerializeWithContext(value: DirectionHue, ctx: __mf_SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "DirectionHue" , __id,}; result["bearing" ]= value.bearing; result["hue" ]= value.hue; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function directionHueDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: DirectionHue } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = directionHueDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "DirectionHue.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function directionHueDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): DirectionHue | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new __mf_DeserializeError([{field: "_root" , message: "DirectionHue.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("bearing" in obj)){errors.push({field: "bearing" , message: "missing required field" });}if(!("hue" in obj)){errors.push({field: "hue" , message: "missing required field" });}if(errors.length>0){throw new __mf_DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_bearing = obj["bearing" ]as number; instance.bearing = __raw_bearing; }{const __raw_hue = obj["hue" ]as number; instance.hue = __raw_hue; }if(errors.length>0){throw new __mf_DeserializeError(errors);}return instance as DirectionHue;}export function directionHueValidateField<K extends keyof DirectionHue>(_field: K, _value: DirectionHue[K]): Array<{field: string; message: string}>{return[]; }export function directionHueValidateFields(_partial: Partial<DirectionHue>): Array<{field: string; message: string}>{return[]; }export function directionHueHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "bearing" in o && "hue" in o;}export function directionHueIs(obj: unknown): obj is DirectionHue {if(!directionHueHasShape(obj)){return false;}const result = directionHueDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type DirectionHueErrors = {_errors: __gf_Option<Array<string>>; bearing: __gf_Option<Array<string>>; hue: __gf_Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type DirectionHueTainted = {bearing: __gf_Option<boolean>; hue: __gf_Option<boolean>; }; /** Type-safe field controllers for this form */export interface DirectionHueFieldControllers {readonly bearing: FieldController<number>; readonly hue: FieldController<number>; }/** Gigaform instance containing reactive state and field controllers */export interface DirectionHueGigaform {readonly data: DirectionHue; readonly errors: DirectionHueErrors; readonly tainted: DirectionHueTainted; readonly fields: DirectionHueFieldControllers; validate(): Exit<DirectionHue, Array<{field: string; message: string}>>; reset(overrides?: Partial<DirectionHue>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function directionHueCreateForm(overrides?: Partial<DirectionHue>): DirectionHueGigaform {let data = $state({...directionHueDefaultValue(),...overrides}); let errors = $state<DirectionHueErrors>({_errors: optionNone(), bearing: optionNone(), hue: optionNone(), }); let tainted = $state<DirectionHueTainted>({bearing: optionNone(), hue: optionNone(), }); const fields: DirectionHueFieldControllers = {bearing: {path: ["bearing" ]as const, name: "bearing" , constraints: { required: true }, get: ()=>data.bearing, set: (value: number)=>{data.bearing = value;}, transform: (value: number): number =>value,getError: ()=>errors.bearing, setError: (value: __gf_Option<Array<string>>)=>{errors.bearing = value;}, getTainted: ()=>tainted.bearing, setTainted: (value: __gf_Option<boolean>)=>{tainted.bearing = value;}, validate: (): Array<string>=>{const fieldErrors = directionHueValidateField("bearing", data.bearing); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},hue: {path: ["hue" ]as const, name: "hue" , constraints: { required: true }, get: ()=>data.hue, set: (value: number)=>{data.hue = value;}, transform: (value: number): number =>value,getError: ()=>errors.hue, setError: (value: __gf_Option<Array<string>>)=>{errors.hue = value;}, getTainted: ()=>tainted.hue, setTainted: (value: __gf_Option<boolean>)=>{tainted.hue = value;}, validate: (): Array<string>=>{const fieldErrors = directionHueValidateField("hue", data.hue); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Exit<DirectionHue, Array<{field: string; message: string}>>{return toExit(directionHueDeserialize(data));}function reset(newOverrides?: Partial<DirectionHue>): void {data = {...directionHueDefaultValue(),...newOverrides}; errors = {_errors: optionNone(), bearing: optionNone(), hue: optionNone(), }; tainted = {bearing: optionNone(), hue: optionNone(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function directionHueFromFormData(formData: FormData): Exit<DirectionHue, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; {const bearingStr = formData.get("bearing" ); obj.bearing = bearingStr? parseFloat(bearingStr as string): 0; if(obj.bearing!== undefined && isNaN(obj.bearing as number))obj.bearing = 0;}{const hueStr = formData.get("hue" ); obj.hue = hueStr? parseFloat(hueStr as string): 0; if(obj.hue!== undefined && isNaN(obj.hue as number))obj.hue = 0;}return toExit(directionHueDeserialize(obj));}

export const DirectionHue = {
  defaultValue: directionHueDefaultValue,
  serialize: directionHueSerialize,
  serializeWithContext: directionHueSerializeWithContext,
  deserialize: directionHueDeserialize,
  deserializeWithContext: directionHueDeserializeWithContext,
  validateFields: directionHueValidateFields,
  hasShape: directionHueHasShape,
  is: directionHueIs,
  createForm: directionHueCreateForm,
  fromFormData: directionHueFromFormData
} as const;


export interface MonthlyRecurrenceRule {
    quantityOfMonths: number;
    day: number;
    
    name: string;
}

export function monthlyRecurrenceRuleDefaultValue(): MonthlyRecurrenceRule {return {quantityOfMonths: 0,
                            day: 0,
                            name: "", }as MonthlyRecurrenceRule;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function monthlyRecurrenceRuleSerialize(value: MonthlyRecurrenceRule): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(monthlyRecurrenceRuleSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function monthlyRecurrenceRuleSerializeWithContext(value: MonthlyRecurrenceRule, ctx: __mf_SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "MonthlyRecurrenceRule" , __id,}; result["quantityOfMonths" ]= value.quantityOfMonths; result["day" ]= value.day; result["name" ]= value.name; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function monthlyRecurrenceRuleDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: MonthlyRecurrenceRule } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = monthlyRecurrenceRuleDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "MonthlyRecurrenceRule.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function monthlyRecurrenceRuleDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): MonthlyRecurrenceRule | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new __mf_DeserializeError([{field: "_root" , message: "MonthlyRecurrenceRule.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("quantityOfMonths" in obj)){errors.push({field: "quantityOfMonths" , message: "missing required field" });}if(!("day" in obj)){errors.push({field: "day" , message: "missing required field" });}if(!("name" in obj)){errors.push({field: "name" , message: "missing required field" });}if(errors.length>0){throw new __mf_DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_quantityOfMonths = obj["quantityOfMonths" ]as number; instance.quantityOfMonths = __raw_quantityOfMonths; }{const __raw_day = obj["day" ]as number; instance.day = __raw_day; }{const __raw_name = obj["name" ]as string; 
                if (__raw_name.length === 0) {
                    errors.push({ field: "name", message: "must not be empty" });
                }
 instance.name = __raw_name; }if(errors.length>0){throw new __mf_DeserializeError(errors);}return instance as MonthlyRecurrenceRule;}export function monthlyRecurrenceRuleValidateField<K extends keyof MonthlyRecurrenceRule>(_field: K, _value: MonthlyRecurrenceRule[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(_field){case "name" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "name", message: "must not be empty" });
                }
 break;}}return errors; }export function monthlyRecurrenceRuleValidateFields(_partial: Partial<MonthlyRecurrenceRule>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("name" in _partial && _partial.name!== undefined){const __val = _partial.name as string; 
                if (__val.length === 0) {
                    errors.push({ field: "name", message: "must not be empty" });
                }
}return errors; }export function monthlyRecurrenceRuleHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "quantityOfMonths" in o && "day" in o && "name" in o;}export function monthlyRecurrenceRuleIs(obj: unknown): obj is MonthlyRecurrenceRule {if(!monthlyRecurrenceRuleHasShape(obj)){return false;}const result = monthlyRecurrenceRuleDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type MonthlyRecurrenceRuleErrors = {_errors: __gf_Option<Array<string>>; quantityOfMonths: __gf_Option<Array<string>>; day: __gf_Option<Array<string>>; name: __gf_Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type MonthlyRecurrenceRuleTainted = {quantityOfMonths: __gf_Option<boolean>; day: __gf_Option<boolean>; name: __gf_Option<boolean>; }; /** Type-safe field controllers for this form */export interface MonthlyRecurrenceRuleFieldControllers {readonly quantityOfMonths: FieldController<number>; readonly day: FieldController<number>; readonly name: FieldController<string>; }/** Gigaform instance containing reactive state and field controllers */export interface MonthlyRecurrenceRuleGigaform {readonly data: MonthlyRecurrenceRule; readonly errors: MonthlyRecurrenceRuleErrors; readonly tainted: MonthlyRecurrenceRuleTainted; readonly fields: MonthlyRecurrenceRuleFieldControllers; validate(): Exit<MonthlyRecurrenceRule, Array<{field: string; message: string}>>; reset(overrides?: Partial<MonthlyRecurrenceRule>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function monthlyRecurrenceRuleCreateForm(overrides?: Partial<MonthlyRecurrenceRule>): MonthlyRecurrenceRuleGigaform {let data = $state({...monthlyRecurrenceRuleDefaultValue(),...overrides}); let errors = $state<MonthlyRecurrenceRuleErrors>({_errors: optionNone(), quantityOfMonths: optionNone(), day: optionNone(), name: optionNone(), }); let tainted = $state<MonthlyRecurrenceRuleTainted>({quantityOfMonths: optionNone(), day: optionNone(), name: optionNone(), }); const fields: MonthlyRecurrenceRuleFieldControllers = {quantityOfMonths: {path: ["quantityOfMonths" ]as const, name: "quantityOfMonths" , constraints: { required: true }, get: ()=>data.quantityOfMonths, set: (value: number)=>{data.quantityOfMonths = value;}, transform: (value: number): number =>value,getError: ()=>errors.quantityOfMonths, setError: (value: __gf_Option<Array<string>>)=>{errors.quantityOfMonths = value;}, getTainted: ()=>tainted.quantityOfMonths, setTainted: (value: __gf_Option<boolean>)=>{tainted.quantityOfMonths = value;}, validate: (): Array<string>=>{const fieldErrors = monthlyRecurrenceRuleValidateField("quantityOfMonths", data.quantityOfMonths); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},day: {path: ["day" ]as const, name: "day" , constraints: { required: true }, get: ()=>data.day, set: (value: number)=>{data.day = value;}, transform: (value: number): number =>value,getError: ()=>errors.day, setError: (value: __gf_Option<Array<string>>)=>{errors.day = value;}, getTainted: ()=>tainted.day, setTainted: (value: __gf_Option<boolean>)=>{tainted.day = value;}, validate: (): Array<string>=>{const fieldErrors = monthlyRecurrenceRuleValidateField("day", data.day); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},name: {path: ["name" ]as const, name: "name" , constraints: { required: true }, get: ()=>data.name, set: (value: string)=>{data.name = value;}, transform: (value: string): string =>value,getError: ()=>errors.name, setError: (value: __gf_Option<Array<string>>)=>{errors.name = value;}, getTainted: ()=>tainted.name, setTainted: (value: __gf_Option<boolean>)=>{tainted.name = value;}, validate: (): Array<string>=>{const fieldErrors = monthlyRecurrenceRuleValidateField("name", data.name); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Exit<MonthlyRecurrenceRule, Array<{field: string; message: string}>>{return toExit(monthlyRecurrenceRuleDeserialize(data));}function reset(newOverrides?: Partial<MonthlyRecurrenceRule>): void {data = {...monthlyRecurrenceRuleDefaultValue(),...newOverrides}; errors = {_errors: optionNone(), quantityOfMonths: optionNone(), day: optionNone(), name: optionNone(), }; tainted = {quantityOfMonths: optionNone(), day: optionNone(), name: optionNone(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function monthlyRecurrenceRuleFromFormData(formData: FormData): Exit<MonthlyRecurrenceRule, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; {const quantityOfMonthsStr = formData.get("quantityOfMonths" ); obj.quantityOfMonths = quantityOfMonthsStr? parseFloat(quantityOfMonthsStr as string): 0; if(obj.quantityOfMonths!== undefined && isNaN(obj.quantityOfMonths as number))obj.quantityOfMonths = 0;}{const dayStr = formData.get("day" ); obj.day = dayStr? parseFloat(dayStr as string): 0; if(obj.day!== undefined && isNaN(obj.day as number))obj.day = 0;}obj.name = formData.get("name" )?? "" ;return toExit(monthlyRecurrenceRuleDeserialize(obj));}

export const MonthlyRecurrenceRule = {
  defaultValue: monthlyRecurrenceRuleDefaultValue,
  serialize: monthlyRecurrenceRuleSerialize,
  serializeWithContext: monthlyRecurrenceRuleSerializeWithContext,
  deserialize: monthlyRecurrenceRuleDeserialize,
  deserializeWithContext: monthlyRecurrenceRuleDeserializeWithContext,
  validateFields: monthlyRecurrenceRuleValidateFields,
  hasShape: monthlyRecurrenceRuleHasShape,
  is: monthlyRecurrenceRuleIs,
  createForm: monthlyRecurrenceRuleCreateForm,
  fromFormData: monthlyRecurrenceRuleFromFormData
} as const;


export interface Represents {
    
    in: string | Employee;
    
    out: string | Account;
    id: string;
    dateStarted: string;
}

export function representsDefaultValue(): Represents {return {in: "",
                            out: "",
                            id: "",
                            dateStarted: "", }as Represents;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function representsSerialize(value: Represents): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(representsSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function representsSerializeWithContext(value: Represents, ctx: __mf_SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Represents" , __id,}; result["in" ]= value.in; result["out" ]= value.out; result["id" ]= value.id; result["dateStarted" ]= value.dateStarted; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function representsDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: Represents } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = representsDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Represents.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function representsDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Represents | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new __mf_DeserializeError([{field: "_root" , message: "Represents.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("in" in obj)){errors.push({field: "in" , message: "missing required field" });}if(!("out" in obj)){errors.push({field: "out" , message: "missing required field" });}if(!("id" in obj)){errors.push({field: "id" , message: "missing required field" });}if(!("dateStarted" in obj)){errors.push({field: "dateStarted" , message: "missing required field" });}if(errors.length>0){throw new __mf_DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_in = obj["in" ]as string | Employee; instance.in = __raw_in; }{const __raw_out = obj["out" ]as string | Account; instance.out = __raw_out; }{const __raw_id = obj["id" ]as string; instance.id = __raw_id; }{const __raw_dateStarted = obj["dateStarted" ]as string; instance.dateStarted = __raw_dateStarted; }if(errors.length>0){throw new __mf_DeserializeError(errors);}return instance as Represents;}export function representsValidateField<K extends keyof Represents>(_field: K, _value: Represents[K]): Array<{field: string; message: string}>{return[]; }export function representsValidateFields(_partial: Partial<Represents>): Array<{field: string; message: string}>{return[]; }export function representsHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "in" in o && "out" in o && "id" in o && "dateStarted" in o;}export function representsIs(obj: unknown): obj is Represents {if(!representsHasShape(obj)){return false;}const result = representsDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type RepresentsErrors = {_errors: __gf_Option<Array<string>>; in: __gf_Option<Array<string>>; out: __gf_Option<Array<string>>; id: __gf_Option<Array<string>>; dateStarted: __gf_Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type RepresentsTainted = {in: __gf_Option<boolean>; out: __gf_Option<boolean>; id: __gf_Option<boolean>; dateStarted: __gf_Option<boolean>; }; /** Type-safe field controllers for this form */export interface RepresentsFieldControllers {readonly in: FieldController<string | Employee>; readonly out: FieldController<string | Account>; readonly id: FieldController<string>; readonly dateStarted: FieldController<string>; }/** Gigaform instance containing reactive state and field controllers */export interface RepresentsGigaform {readonly data: Represents; readonly errors: RepresentsErrors; readonly tainted: RepresentsTainted; readonly fields: RepresentsFieldControllers; validate(): Exit<Represents, Array<{field: string; message: string}>>; reset(overrides?: Partial<Represents>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function representsCreateForm(overrides?: Partial<Represents>): RepresentsGigaform {let data = $state({...representsDefaultValue(),...overrides}); let errors = $state<RepresentsErrors>({_errors: optionNone(), in: optionNone(), out: optionNone(), id: optionNone(), dateStarted: optionNone(), }); let tainted = $state<RepresentsTainted>({in: optionNone(), out: optionNone(), id: optionNone(), dateStarted: optionNone(), }); const fields: RepresentsFieldControllers = {in: {path: ["in" ]as const, name: "in" , constraints: { required: true }, get: ()=>data.in, set: (value: string | Employee)=>{data.in = value;}, transform: (value: string | Employee): string | Employee =>value,getError: ()=>errors.in, setError: (value: __gf_Option<Array<string>>)=>{errors.in = value;}, getTainted: ()=>tainted.in, setTainted: (value: __gf_Option<boolean>)=>{tainted.in = value;}, validate: (): Array<string>=>{const fieldErrors = representsValidateField("in", data.in); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},out: {path: ["out" ]as const, name: "out" , constraints: { required: true }, get: ()=>data.out, set: (value: string | Account)=>{data.out = value;}, transform: (value: string | Account): string | Account =>value,getError: ()=>errors.out, setError: (value: __gf_Option<Array<string>>)=>{errors.out = value;}, getTainted: ()=>tainted.out, setTainted: (value: __gf_Option<boolean>)=>{tainted.out = value;}, validate: (): Array<string>=>{const fieldErrors = representsValidateField("out", data.out); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},id: {path: ["id" ]as const, name: "id" , constraints: { required: true }, get: ()=>data.id, set: (value: string)=>{data.id = value;}, transform: (value: string): string =>value,getError: ()=>errors.id, setError: (value: __gf_Option<Array<string>>)=>{errors.id = value;}, getTainted: ()=>tainted.id, setTainted: (value: __gf_Option<boolean>)=>{tainted.id = value;}, validate: (): Array<string>=>{const fieldErrors = representsValidateField("id", data.id); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},dateStarted: {path: ["dateStarted" ]as const, name: "dateStarted" , constraints: { required: true }, get: ()=>data.dateStarted, set: (value: string)=>{data.dateStarted = value;}, transform: (value: string): string =>value,getError: ()=>errors.dateStarted, setError: (value: __gf_Option<Array<string>>)=>{errors.dateStarted = value;}, getTainted: ()=>tainted.dateStarted, setTainted: (value: __gf_Option<boolean>)=>{tainted.dateStarted = value;}, validate: (): Array<string>=>{const fieldErrors = representsValidateField("dateStarted", data.dateStarted); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Exit<Represents, Array<{field: string; message: string}>>{return toExit(representsDeserialize(data));}function reset(newOverrides?: Partial<Represents>): void {data = {...representsDefaultValue(),...newOverrides}; errors = {_errors: optionNone(), in: optionNone(), out: optionNone(), id: optionNone(), dateStarted: optionNone(), }; tainted = {in: optionNone(), out: optionNone(), id: optionNone(), dateStarted: optionNone(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function representsFromFormData(formData: FormData): Exit<Represents, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.in = formData.get("in" )?? "" ;obj.out = formData.get("out" )?? "" ;obj.id = formData.get("id" )?? "" ;obj.dateStarted = formData.get("dateStarted" )?? "" ;return toExit(representsDeserialize(obj));}

export const Represents = {
  defaultValue: representsDefaultValue,
  serialize: representsSerialize,
  serializeWithContext: representsSerializeWithContext,
  deserialize: representsDeserialize,
  deserializeWithContext: representsDeserializeWithContext,
  validateFields: representsValidateFields,
  hasShape: representsHasShape,
  is: representsIs,
  createForm: representsCreateForm,
  fromFormData: representsFromFormData
} as const;


export interface Payment {
    id: string;
    date: string;
}

export function paymentDefaultValue(): Payment {return {id: "",
                            date: "", }as Payment;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function paymentSerialize(value: Payment): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(paymentSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function paymentSerializeWithContext(value: Payment, ctx: __mf_SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Payment" , __id,}; result["id" ]= value.id; result["date" ]= value.date; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function paymentDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: Payment } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = paymentDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Payment.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function paymentDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Payment | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new __mf_DeserializeError([{field: "_root" , message: "Payment.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("id" in obj)){errors.push({field: "id" , message: "missing required field" });}if(!("date" in obj)){errors.push({field: "date" , message: "missing required field" });}if(errors.length>0){throw new __mf_DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_id = obj["id" ]as string; instance.id = __raw_id; }{const __raw_date = obj["date" ]as string; instance.date = __raw_date; }if(errors.length>0){throw new __mf_DeserializeError(errors);}return instance as Payment;}export function paymentValidateField<K extends keyof Payment>(_field: K, _value: Payment[K]): Array<{field: string; message: string}>{return[]; }export function paymentValidateFields(_partial: Partial<Payment>): Array<{field: string; message: string}>{return[]; }export function paymentHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "id" in o && "date" in o;}export function paymentIs(obj: unknown): obj is Payment {if(!paymentHasShape(obj)){return false;}const result = paymentDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type PaymentErrors = {_errors: __gf_Option<Array<string>>; id: __gf_Option<Array<string>>; date: __gf_Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type PaymentTainted = {id: __gf_Option<boolean>; date: __gf_Option<boolean>; }; /** Type-safe field controllers for this form */export interface PaymentFieldControllers {readonly id: FieldController<string>; readonly date: FieldController<string>; }/** Gigaform instance containing reactive state and field controllers */export interface PaymentGigaform {readonly data: Payment; readonly errors: PaymentErrors; readonly tainted: PaymentTainted; readonly fields: PaymentFieldControllers; validate(): Exit<Payment, Array<{field: string; message: string}>>; reset(overrides?: Partial<Payment>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function paymentCreateForm(overrides?: Partial<Payment>): PaymentGigaform {let data = $state({...paymentDefaultValue(),...overrides}); let errors = $state<PaymentErrors>({_errors: optionNone(), id: optionNone(), date: optionNone(), }); let tainted = $state<PaymentTainted>({id: optionNone(), date: optionNone(), }); const fields: PaymentFieldControllers = {id: {path: ["id" ]as const, name: "id" , constraints: { required: true }, get: ()=>data.id, set: (value: string)=>{data.id = value;}, transform: (value: string): string =>value,getError: ()=>errors.id, setError: (value: __gf_Option<Array<string>>)=>{errors.id = value;}, getTainted: ()=>tainted.id, setTainted: (value: __gf_Option<boolean>)=>{tainted.id = value;}, validate: (): Array<string>=>{const fieldErrors = paymentValidateField("id", data.id); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},date: {path: ["date" ]as const, name: "date" , constraints: { required: true }, get: ()=>data.date, set: (value: string)=>{data.date = value;}, transform: (value: string): string =>value,getError: ()=>errors.date, setError: (value: __gf_Option<Array<string>>)=>{errors.date = value;}, getTainted: ()=>tainted.date, setTainted: (value: __gf_Option<boolean>)=>{tainted.date = value;}, validate: (): Array<string>=>{const fieldErrors = paymentValidateField("date", data.date); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Exit<Payment, Array<{field: string; message: string}>>{return toExit(paymentDeserialize(data));}function reset(newOverrides?: Partial<Payment>): void {data = {...paymentDefaultValue(),...newOverrides}; errors = {_errors: optionNone(), id: optionNone(), date: optionNone(), }; tainted = {id: optionNone(), date: optionNone(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function paymentFromFormData(formData: FormData): Exit<Payment, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.id = formData.get("id" )?? "" ;obj.date = formData.get("date" )?? "" ;return toExit(paymentDeserialize(obj));}

export const Payment = {
  defaultValue: paymentDefaultValue,
  serialize: paymentSerialize,
  serializeWithContext: paymentSerializeWithContext,
  deserialize: paymentDeserialize,
  deserializeWithContext: paymentDeserializeWithContext,
  validateFields: paymentValidateFields,
  hasShape: paymentHasShape,
  is: paymentIs,
  createForm: paymentCreateForm,
  fromFormData: paymentFromFormData
} as const;


export interface Settings {
    appointmentNotifications: AppointmentNotifications | null;
    commissions: Commissions | null;
    scheduleSettings: ScheduleSettings;
    accountOverviewSettings: OverviewSettings;
    serviceOverviewSettings: OverviewSettings;
    appointmentOverviewSettings: OverviewSettings;
    leadOverviewSettings: OverviewSettings;
    packageOverviewSettings: OverviewSettings;
    productOverviewSettings: OverviewSettings;
    orderOverviewSettings: OverviewSettings;
    taxRateOverviewSettings: OverviewSettings;
    
    homePage: Page;
}

export function settingsDefaultValue(): Settings {return {appointmentNotifications: null,
                            commissions: null,
                            scheduleSettings: scheduleSettingsDefaultValue(),
                            accountOverviewSettings: overviewSettingsDefaultValue(),
                            serviceOverviewSettings: overviewSettingsDefaultValue(),
                            appointmentOverviewSettings: overviewSettingsDefaultValue(),
                            leadOverviewSettings: overviewSettingsDefaultValue(),
                            packageOverviewSettings: overviewSettingsDefaultValue(),
                            productOverviewSettings: overviewSettingsDefaultValue(),
                            orderOverviewSettings: overviewSettingsDefaultValue(),
                            taxRateOverviewSettings: overviewSettingsDefaultValue(),
                            homePage: "UserHome", }as Settings;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function settingsSerialize(value: Settings): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(settingsSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function settingsSerializeWithContext(value: Settings, ctx: __mf_SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Settings" , __id,}; if(value.appointmentNotifications!== null){result["appointmentNotifications" ]= appointmentNotificationsSerializeWithContext(value.appointmentNotifications, ctx); }else {result["appointmentNotifications" ]= null;}if(value.commissions!== null){result["commissions" ]= commissionsSerializeWithContext(value.commissions, ctx); }else {result["commissions" ]= null;}result["scheduleSettings" ]= scheduleSettingsSerializeWithContext(value.scheduleSettings, ctx); result["accountOverviewSettings" ]= overviewSettingsSerializeWithContext(value.accountOverviewSettings, ctx); result["serviceOverviewSettings" ]= overviewSettingsSerializeWithContext(value.serviceOverviewSettings, ctx); result["appointmentOverviewSettings" ]= overviewSettingsSerializeWithContext(value.appointmentOverviewSettings, ctx); result["leadOverviewSettings" ]= overviewSettingsSerializeWithContext(value.leadOverviewSettings, ctx); result["packageOverviewSettings" ]= overviewSettingsSerializeWithContext(value.packageOverviewSettings, ctx); result["productOverviewSettings" ]= overviewSettingsSerializeWithContext(value.productOverviewSettings, ctx); result["orderOverviewSettings" ]= overviewSettingsSerializeWithContext(value.orderOverviewSettings, ctx); result["taxRateOverviewSettings" ]= overviewSettingsSerializeWithContext(value.taxRateOverviewSettings, ctx); result["homePage" ]= pageSerializeWithContext(value.homePage, ctx); return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function settingsDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: Settings } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = settingsDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Settings.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function settingsDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Settings | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new __mf_DeserializeError([{field: "_root" , message: "Settings.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("appointmentNotifications" in obj)){errors.push({field: "appointmentNotifications" , message: "missing required field" });}if(!("commissions" in obj)){errors.push({field: "commissions" , message: "missing required field" });}if(!("scheduleSettings" in obj)){errors.push({field: "scheduleSettings" , message: "missing required field" });}if(!("accountOverviewSettings" in obj)){errors.push({field: "accountOverviewSettings" , message: "missing required field" });}if(!("serviceOverviewSettings" in obj)){errors.push({field: "serviceOverviewSettings" , message: "missing required field" });}if(!("appointmentOverviewSettings" in obj)){errors.push({field: "appointmentOverviewSettings" , message: "missing required field" });}if(!("leadOverviewSettings" in obj)){errors.push({field: "leadOverviewSettings" , message: "missing required field" });}if(!("packageOverviewSettings" in obj)){errors.push({field: "packageOverviewSettings" , message: "missing required field" });}if(!("productOverviewSettings" in obj)){errors.push({field: "productOverviewSettings" , message: "missing required field" });}if(!("orderOverviewSettings" in obj)){errors.push({field: "orderOverviewSettings" , message: "missing required field" });}if(!("taxRateOverviewSettings" in obj)){errors.push({field: "taxRateOverviewSettings" , message: "missing required field" });}if(!("homePage" in obj)){errors.push({field: "homePage" , message: "missing required field" });}if(errors.length>0){throw new __mf_DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_appointmentNotifications = obj["appointmentNotifications" ]as AppointmentNotifications | null; if(__raw_appointmentNotifications === null){instance.appointmentNotifications = null;}else {const __result = appointmentNotificationsDeserializeWithContext(__raw_appointmentNotifications, ctx); ctx.assignOrDefer(instance, "appointmentNotifications" , __result); }}{const __raw_commissions = obj["commissions" ]as Commissions | null; if(__raw_commissions === null){instance.commissions = null;}else {const __result = commissionsDeserializeWithContext(__raw_commissions, ctx); ctx.assignOrDefer(instance, "commissions" , __result); }}{const __raw_scheduleSettings = obj["scheduleSettings" ]as ScheduleSettings; {const __result = scheduleSettingsDeserializeWithContext(__raw_scheduleSettings, ctx); ctx.assignOrDefer(instance, "scheduleSettings" , __result);}}{const __raw_accountOverviewSettings = obj["accountOverviewSettings" ]as OverviewSettings; {const __result = overviewSettingsDeserializeWithContext(__raw_accountOverviewSettings, ctx); ctx.assignOrDefer(instance, "accountOverviewSettings" , __result);}}{const __raw_serviceOverviewSettings = obj["serviceOverviewSettings" ]as OverviewSettings; {const __result = overviewSettingsDeserializeWithContext(__raw_serviceOverviewSettings, ctx); ctx.assignOrDefer(instance, "serviceOverviewSettings" , __result);}}{const __raw_appointmentOverviewSettings = obj["appointmentOverviewSettings" ]as OverviewSettings; {const __result = overviewSettingsDeserializeWithContext(__raw_appointmentOverviewSettings, ctx); ctx.assignOrDefer(instance, "appointmentOverviewSettings" , __result);}}{const __raw_leadOverviewSettings = obj["leadOverviewSettings" ]as OverviewSettings; {const __result = overviewSettingsDeserializeWithContext(__raw_leadOverviewSettings, ctx); ctx.assignOrDefer(instance, "leadOverviewSettings" , __result);}}{const __raw_packageOverviewSettings = obj["packageOverviewSettings" ]as OverviewSettings; {const __result = overviewSettingsDeserializeWithContext(__raw_packageOverviewSettings, ctx); ctx.assignOrDefer(instance, "packageOverviewSettings" , __result);}}{const __raw_productOverviewSettings = obj["productOverviewSettings" ]as OverviewSettings; {const __result = overviewSettingsDeserializeWithContext(__raw_productOverviewSettings, ctx); ctx.assignOrDefer(instance, "productOverviewSettings" , __result);}}{const __raw_orderOverviewSettings = obj["orderOverviewSettings" ]as OverviewSettings; {const __result = overviewSettingsDeserializeWithContext(__raw_orderOverviewSettings, ctx); ctx.assignOrDefer(instance, "orderOverviewSettings" , __result);}}{const __raw_taxRateOverviewSettings = obj["taxRateOverviewSettings" ]as OverviewSettings; {const __result = overviewSettingsDeserializeWithContext(__raw_taxRateOverviewSettings, ctx); ctx.assignOrDefer(instance, "taxRateOverviewSettings" , __result);}}{const __raw_homePage = obj["homePage" ]as Page; {const __result = pageDeserializeWithContext(__raw_homePage, ctx); ctx.assignOrDefer(instance, "homePage" , __result);}}if(errors.length>0){throw new __mf_DeserializeError(errors);}return instance as Settings;}export function settingsValidateField<K extends keyof Settings>(_field: K, _value: Settings[K]): Array<{field: string; message: string}>{return[]; }export function settingsValidateFields(_partial: Partial<Settings>): Array<{field: string; message: string}>{return[]; }export function settingsHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "appointmentNotifications" in o && "commissions" in o && "scheduleSettings" in o && "accountOverviewSettings" in o && "serviceOverviewSettings" in o && "appointmentOverviewSettings" in o && "leadOverviewSettings" in o && "packageOverviewSettings" in o && "productOverviewSettings" in o && "orderOverviewSettings" in o && "taxRateOverviewSettings" in o && "homePage" in o;}export function settingsIs(obj: unknown): obj is Settings {if(!settingsHasShape(obj)){return false;}const result = settingsDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type SettingsErrors = {_errors: __gf_Option<Array<string>>; appointmentNotifications: __gf_Option<Array<string>>; commissions: __gf_Option<Array<string>>; scheduleSettings: __gf_Option<Array<string>>; accountOverviewSettings: __gf_Option<Array<string>>; serviceOverviewSettings: __gf_Option<Array<string>>; appointmentOverviewSettings: __gf_Option<Array<string>>; leadOverviewSettings: __gf_Option<Array<string>>; packageOverviewSettings: __gf_Option<Array<string>>; productOverviewSettings: __gf_Option<Array<string>>; orderOverviewSettings: __gf_Option<Array<string>>; taxRateOverviewSettings: __gf_Option<Array<string>>; homePage: __gf_Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type SettingsTainted = {appointmentNotifications: __gf_Option<boolean>; commissions: __gf_Option<boolean>; scheduleSettings: __gf_Option<boolean>; accountOverviewSettings: __gf_Option<boolean>; serviceOverviewSettings: __gf_Option<boolean>; appointmentOverviewSettings: __gf_Option<boolean>; leadOverviewSettings: __gf_Option<boolean>; packageOverviewSettings: __gf_Option<boolean>; productOverviewSettings: __gf_Option<boolean>; orderOverviewSettings: __gf_Option<boolean>; taxRateOverviewSettings: __gf_Option<boolean>; homePage: __gf_Option<boolean>; }; /** Type-safe field controllers for this form */export interface SettingsFieldControllers {readonly appointmentNotifications: FieldController<AppointmentNotifications | null>; readonly commissions: FieldController<Commissions | null>; readonly scheduleSettings: FieldController<ScheduleSettings>; readonly accountOverviewSettings: FieldController<OverviewSettings>; readonly serviceOverviewSettings: FieldController<OverviewSettings>; readonly appointmentOverviewSettings: FieldController<OverviewSettings>; readonly leadOverviewSettings: FieldController<OverviewSettings>; readonly packageOverviewSettings: FieldController<OverviewSettings>; readonly productOverviewSettings: FieldController<OverviewSettings>; readonly orderOverviewSettings: FieldController<OverviewSettings>; readonly taxRateOverviewSettings: FieldController<OverviewSettings>; readonly homePage: FieldController<Page>; }/** Gigaform instance containing reactive state and field controllers */export interface SettingsGigaform {readonly data: Settings; readonly errors: SettingsErrors; readonly tainted: SettingsTainted; readonly fields: SettingsFieldControllers; validate(): Exit<Settings, Array<{field: string; message: string}>>; reset(overrides?: Partial<Settings>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function settingsCreateForm(overrides?: Partial<Settings>): SettingsGigaform {let data = $state({...settingsDefaultValue(),...overrides}); let errors = $state<SettingsErrors>({_errors: optionNone(), appointmentNotifications: optionNone(), commissions: optionNone(), scheduleSettings: optionNone(), accountOverviewSettings: optionNone(), serviceOverviewSettings: optionNone(), appointmentOverviewSettings: optionNone(), leadOverviewSettings: optionNone(), packageOverviewSettings: optionNone(), productOverviewSettings: optionNone(), orderOverviewSettings: optionNone(), taxRateOverviewSettings: optionNone(), homePage: optionNone(), }); let tainted = $state<SettingsTainted>({appointmentNotifications: optionNone(), commissions: optionNone(), scheduleSettings: optionNone(), accountOverviewSettings: optionNone(), serviceOverviewSettings: optionNone(), appointmentOverviewSettings: optionNone(), leadOverviewSettings: optionNone(), packageOverviewSettings: optionNone(), productOverviewSettings: optionNone(), orderOverviewSettings: optionNone(), taxRateOverviewSettings: optionNone(), homePage: optionNone(), }); const fields: SettingsFieldControllers = {appointmentNotifications: {path: ["appointmentNotifications" ]as const, name: "appointmentNotifications" , constraints: { required: true }, get: ()=>data.appointmentNotifications, set: (value: AppointmentNotifications | null)=>{data.appointmentNotifications = value;}, transform: (value: AppointmentNotifications | null): AppointmentNotifications | null =>value,getError: ()=>errors.appointmentNotifications, setError: (value: __gf_Option<Array<string>>)=>{errors.appointmentNotifications = value;}, getTainted: ()=>tainted.appointmentNotifications, setTainted: (value: __gf_Option<boolean>)=>{tainted.appointmentNotifications = value;}, validate: (): Array<string>=>{const fieldErrors = settingsValidateField("appointmentNotifications", data.appointmentNotifications); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},commissions: {path: ["commissions" ]as const, name: "commissions" , constraints: { required: true }, get: ()=>data.commissions, set: (value: Commissions | null)=>{data.commissions = value;}, transform: (value: Commissions | null): Commissions | null =>value,getError: ()=>errors.commissions, setError: (value: __gf_Option<Array<string>>)=>{errors.commissions = value;}, getTainted: ()=>tainted.commissions, setTainted: (value: __gf_Option<boolean>)=>{tainted.commissions = value;}, validate: (): Array<string>=>{const fieldErrors = settingsValidateField("commissions", data.commissions); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},scheduleSettings: {path: ["scheduleSettings" ]as const, name: "scheduleSettings" , constraints: { required: true }, get: ()=>data.scheduleSettings, set: (value: ScheduleSettings)=>{data.scheduleSettings = value;}, transform: (value: ScheduleSettings): ScheduleSettings =>value,getError: ()=>errors.scheduleSettings, setError: (value: __gf_Option<Array<string>>)=>{errors.scheduleSettings = value;}, getTainted: ()=>tainted.scheduleSettings, setTainted: (value: __gf_Option<boolean>)=>{tainted.scheduleSettings = value;}, validate: (): Array<string>=>{const fieldErrors = settingsValidateField("scheduleSettings", data.scheduleSettings); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},accountOverviewSettings: {path: ["accountOverviewSettings" ]as const, name: "accountOverviewSettings" , constraints: { required: true }, get: ()=>data.accountOverviewSettings, set: (value: OverviewSettings)=>{data.accountOverviewSettings = value;}, transform: (value: OverviewSettings): OverviewSettings =>value,getError: ()=>errors.accountOverviewSettings, setError: (value: __gf_Option<Array<string>>)=>{errors.accountOverviewSettings = value;}, getTainted: ()=>tainted.accountOverviewSettings, setTainted: (value: __gf_Option<boolean>)=>{tainted.accountOverviewSettings = value;}, validate: (): Array<string>=>{const fieldErrors = settingsValidateField("accountOverviewSettings", data.accountOverviewSettings); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},serviceOverviewSettings: {path: ["serviceOverviewSettings" ]as const, name: "serviceOverviewSettings" , constraints: { required: true }, get: ()=>data.serviceOverviewSettings, set: (value: OverviewSettings)=>{data.serviceOverviewSettings = value;}, transform: (value: OverviewSettings): OverviewSettings =>value,getError: ()=>errors.serviceOverviewSettings, setError: (value: __gf_Option<Array<string>>)=>{errors.serviceOverviewSettings = value;}, getTainted: ()=>tainted.serviceOverviewSettings, setTainted: (value: __gf_Option<boolean>)=>{tainted.serviceOverviewSettings = value;}, validate: (): Array<string>=>{const fieldErrors = settingsValidateField("serviceOverviewSettings", data.serviceOverviewSettings); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},appointmentOverviewSettings: {path: ["appointmentOverviewSettings" ]as const, name: "appointmentOverviewSettings" , constraints: { required: true }, get: ()=>data.appointmentOverviewSettings, set: (value: OverviewSettings)=>{data.appointmentOverviewSettings = value;}, transform: (value: OverviewSettings): OverviewSettings =>value,getError: ()=>errors.appointmentOverviewSettings, setError: (value: __gf_Option<Array<string>>)=>{errors.appointmentOverviewSettings = value;}, getTainted: ()=>tainted.appointmentOverviewSettings, setTainted: (value: __gf_Option<boolean>)=>{tainted.appointmentOverviewSettings = value;}, validate: (): Array<string>=>{const fieldErrors = settingsValidateField("appointmentOverviewSettings", data.appointmentOverviewSettings); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},leadOverviewSettings: {path: ["leadOverviewSettings" ]as const, name: "leadOverviewSettings" , constraints: { required: true }, get: ()=>data.leadOverviewSettings, set: (value: OverviewSettings)=>{data.leadOverviewSettings = value;}, transform: (value: OverviewSettings): OverviewSettings =>value,getError: ()=>errors.leadOverviewSettings, setError: (value: __gf_Option<Array<string>>)=>{errors.leadOverviewSettings = value;}, getTainted: ()=>tainted.leadOverviewSettings, setTainted: (value: __gf_Option<boolean>)=>{tainted.leadOverviewSettings = value;}, validate: (): Array<string>=>{const fieldErrors = settingsValidateField("leadOverviewSettings", data.leadOverviewSettings); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},packageOverviewSettings: {path: ["packageOverviewSettings" ]as const, name: "packageOverviewSettings" , constraints: { required: true }, get: ()=>data.packageOverviewSettings, set: (value: OverviewSettings)=>{data.packageOverviewSettings = value;}, transform: (value: OverviewSettings): OverviewSettings =>value,getError: ()=>errors.packageOverviewSettings, setError: (value: __gf_Option<Array<string>>)=>{errors.packageOverviewSettings = value;}, getTainted: ()=>tainted.packageOverviewSettings, setTainted: (value: __gf_Option<boolean>)=>{tainted.packageOverviewSettings = value;}, validate: (): Array<string>=>{const fieldErrors = settingsValidateField("packageOverviewSettings", data.packageOverviewSettings); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},productOverviewSettings: {path: ["productOverviewSettings" ]as const, name: "productOverviewSettings" , constraints: { required: true }, get: ()=>data.productOverviewSettings, set: (value: OverviewSettings)=>{data.productOverviewSettings = value;}, transform: (value: OverviewSettings): OverviewSettings =>value,getError: ()=>errors.productOverviewSettings, setError: (value: __gf_Option<Array<string>>)=>{errors.productOverviewSettings = value;}, getTainted: ()=>tainted.productOverviewSettings, setTainted: (value: __gf_Option<boolean>)=>{tainted.productOverviewSettings = value;}, validate: (): Array<string>=>{const fieldErrors = settingsValidateField("productOverviewSettings", data.productOverviewSettings); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},orderOverviewSettings: {path: ["orderOverviewSettings" ]as const, name: "orderOverviewSettings" , constraints: { required: true }, get: ()=>data.orderOverviewSettings, set: (value: OverviewSettings)=>{data.orderOverviewSettings = value;}, transform: (value: OverviewSettings): OverviewSettings =>value,getError: ()=>errors.orderOverviewSettings, setError: (value: __gf_Option<Array<string>>)=>{errors.orderOverviewSettings = value;}, getTainted: ()=>tainted.orderOverviewSettings, setTainted: (value: __gf_Option<boolean>)=>{tainted.orderOverviewSettings = value;}, validate: (): Array<string>=>{const fieldErrors = settingsValidateField("orderOverviewSettings", data.orderOverviewSettings); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},taxRateOverviewSettings: {path: ["taxRateOverviewSettings" ]as const, name: "taxRateOverviewSettings" , constraints: { required: true }, get: ()=>data.taxRateOverviewSettings, set: (value: OverviewSettings)=>{data.taxRateOverviewSettings = value;}, transform: (value: OverviewSettings): OverviewSettings =>value,getError: ()=>errors.taxRateOverviewSettings, setError: (value: __gf_Option<Array<string>>)=>{errors.taxRateOverviewSettings = value;}, getTainted: ()=>tainted.taxRateOverviewSettings, setTainted: (value: __gf_Option<boolean>)=>{tainted.taxRateOverviewSettings = value;}, validate: (): Array<string>=>{const fieldErrors = settingsValidateField("taxRateOverviewSettings", data.taxRateOverviewSettings); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},homePage: {path: ["homePage" ]as const, name: "homePage" , constraints: { required: true }, get: ()=>data.homePage, set: (value: Page)=>{data.homePage = value;}, transform: (value: Page): Page =>value,getError: ()=>errors.homePage, setError: (value: __gf_Option<Array<string>>)=>{errors.homePage = value;}, getTainted: ()=>tainted.homePage, setTainted: (value: __gf_Option<boolean>)=>{tainted.homePage = value;}, validate: (): Array<string>=>{const fieldErrors = settingsValidateField("homePage", data.homePage); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Exit<Settings, Array<{field: string; message: string}>>{return toExit(settingsDeserialize(data));}function reset(newOverrides?: Partial<Settings>): void {data = {...settingsDefaultValue(),...newOverrides}; errors = {_errors: optionNone(), appointmentNotifications: optionNone(), commissions: optionNone(), scheduleSettings: optionNone(), accountOverviewSettings: optionNone(), serviceOverviewSettings: optionNone(), appointmentOverviewSettings: optionNone(), leadOverviewSettings: optionNone(), packageOverviewSettings: optionNone(), productOverviewSettings: optionNone(), orderOverviewSettings: optionNone(), taxRateOverviewSettings: optionNone(), homePage: optionNone(), }; tainted = {appointmentNotifications: optionNone(), commissions: optionNone(), scheduleSettings: optionNone(), accountOverviewSettings: optionNone(), serviceOverviewSettings: optionNone(), appointmentOverviewSettings: optionNone(), leadOverviewSettings: optionNone(), packageOverviewSettings: optionNone(), productOverviewSettings: optionNone(), orderOverviewSettings: optionNone(), taxRateOverviewSettings: optionNone(), homePage: optionNone(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function settingsFromFormData(formData: FormData): Exit<Settings, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.appointmentNotifications = formData.get("appointmentNotifications" )?? "" ;obj.commissions = formData.get("commissions" )?? "" ;{const scheduleSettingsObj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("scheduleSettings." )){const fieldName = key.slice("scheduleSettings." .length); const parts = fieldName.split("." ); let current = scheduleSettingsObj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.scheduleSettings = scheduleSettingsObj;}{const accountOverviewSettingsObj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("accountOverviewSettings." )){const fieldName = key.slice("accountOverviewSettings." .length); const parts = fieldName.split("." ); let current = accountOverviewSettingsObj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.accountOverviewSettings = accountOverviewSettingsObj;}{const serviceOverviewSettingsObj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("serviceOverviewSettings." )){const fieldName = key.slice("serviceOverviewSettings." .length); const parts = fieldName.split("." ); let current = serviceOverviewSettingsObj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.serviceOverviewSettings = serviceOverviewSettingsObj;}{const appointmentOverviewSettingsObj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("appointmentOverviewSettings." )){const fieldName = key.slice("appointmentOverviewSettings." .length); const parts = fieldName.split("." ); let current = appointmentOverviewSettingsObj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.appointmentOverviewSettings = appointmentOverviewSettingsObj;}{const leadOverviewSettingsObj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("leadOverviewSettings." )){const fieldName = key.slice("leadOverviewSettings." .length); const parts = fieldName.split("." ); let current = leadOverviewSettingsObj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.leadOverviewSettings = leadOverviewSettingsObj;}{const packageOverviewSettingsObj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("packageOverviewSettings." )){const fieldName = key.slice("packageOverviewSettings." .length); const parts = fieldName.split("." ); let current = packageOverviewSettingsObj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.packageOverviewSettings = packageOverviewSettingsObj;}{const productOverviewSettingsObj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("productOverviewSettings." )){const fieldName = key.slice("productOverviewSettings." .length); const parts = fieldName.split("." ); let current = productOverviewSettingsObj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.productOverviewSettings = productOverviewSettingsObj;}{const orderOverviewSettingsObj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("orderOverviewSettings." )){const fieldName = key.slice("orderOverviewSettings." .length); const parts = fieldName.split("." ); let current = orderOverviewSettingsObj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.orderOverviewSettings = orderOverviewSettingsObj;}{const taxRateOverviewSettingsObj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("taxRateOverviewSettings." )){const fieldName = key.slice("taxRateOverviewSettings." .length); const parts = fieldName.split("." ); let current = taxRateOverviewSettingsObj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.taxRateOverviewSettings = taxRateOverviewSettingsObj;}{const homePageObj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("homePage." )){const fieldName = key.slice("homePage." .length); const parts = fieldName.split("." ); let current = homePageObj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.homePage = homePageObj;}return toExit(settingsDeserialize(obj));}

export const Settings = {
  defaultValue: settingsDefaultValue,
  serialize: settingsSerialize,
  serializeWithContext: settingsSerializeWithContext,
  deserialize: settingsDeserialize,
  deserializeWithContext: settingsDeserializeWithContext,
  validateFields: settingsValidateFields,
  hasShape: settingsHasShape,
  is: settingsIs,
  createForm: settingsCreateForm,
  fromFormData: settingsFromFormData
} as const;


export interface Color {
    red: number;
    green: number;
    blue: number;
}

export function colorDefaultValue(): Color {return {red: 0,
                            green: 0,
                            blue: 0, }as Color;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function colorSerialize(value: Color): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(colorSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function colorSerializeWithContext(value: Color, ctx: __mf_SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Color" , __id,}; result["red" ]= value.red; result["green" ]= value.green; result["blue" ]= value.blue; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function colorDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: Color } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = colorDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Color.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function colorDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Color | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new __mf_DeserializeError([{field: "_root" , message: "Color.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("red" in obj)){errors.push({field: "red" , message: "missing required field" });}if(!("green" in obj)){errors.push({field: "green" , message: "missing required field" });}if(!("blue" in obj)){errors.push({field: "blue" , message: "missing required field" });}if(errors.length>0){throw new __mf_DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_red = obj["red" ]as number; instance.red = __raw_red; }{const __raw_green = obj["green" ]as number; instance.green = __raw_green; }{const __raw_blue = obj["blue" ]as number; instance.blue = __raw_blue; }if(errors.length>0){throw new __mf_DeserializeError(errors);}return instance as Color;}export function colorValidateField<K extends keyof Color>(_field: K, _value: Color[K]): Array<{field: string; message: string}>{return[]; }export function colorValidateFields(_partial: Partial<Color>): Array<{field: string; message: string}>{return[]; }export function colorHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "red" in o && "green" in o && "blue" in o;}export function colorIs(obj: unknown): obj is Color {if(!colorHasShape(obj)){return false;}const result = colorDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type ColorErrors = {_errors: __gf_Option<Array<string>>; red: __gf_Option<Array<string>>; green: __gf_Option<Array<string>>; blue: __gf_Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type ColorTainted = {red: __gf_Option<boolean>; green: __gf_Option<boolean>; blue: __gf_Option<boolean>; }; /** Type-safe field controllers for this form */export interface ColorFieldControllers {readonly red: FieldController<number>; readonly green: FieldController<number>; readonly blue: FieldController<number>; }/** Gigaform instance containing reactive state and field controllers */export interface ColorGigaform {readonly data: Color; readonly errors: ColorErrors; readonly tainted: ColorTainted; readonly fields: ColorFieldControllers; validate(): Exit<Color, Array<{field: string; message: string}>>; reset(overrides?: Partial<Color>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function colorCreateForm(overrides?: Partial<Color>): ColorGigaform {let data = $state({...colorDefaultValue(),...overrides}); let errors = $state<ColorErrors>({_errors: optionNone(), red: optionNone(), green: optionNone(), blue: optionNone(), }); let tainted = $state<ColorTainted>({red: optionNone(), green: optionNone(), blue: optionNone(), }); const fields: ColorFieldControllers = {red: {path: ["red" ]as const, name: "red" , constraints: { required: true }, get: ()=>data.red, set: (value: number)=>{data.red = value;}, transform: (value: number): number =>value,getError: ()=>errors.red, setError: (value: __gf_Option<Array<string>>)=>{errors.red = value;}, getTainted: ()=>tainted.red, setTainted: (value: __gf_Option<boolean>)=>{tainted.red = value;}, validate: (): Array<string>=>{const fieldErrors = colorValidateField("red", data.red); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},green: {path: ["green" ]as const, name: "green" , constraints: { required: true }, get: ()=>data.green, set: (value: number)=>{data.green = value;}, transform: (value: number): number =>value,getError: ()=>errors.green, setError: (value: __gf_Option<Array<string>>)=>{errors.green = value;}, getTainted: ()=>tainted.green, setTainted: (value: __gf_Option<boolean>)=>{tainted.green = value;}, validate: (): Array<string>=>{const fieldErrors = colorValidateField("green", data.green); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},blue: {path: ["blue" ]as const, name: "blue" , constraints: { required: true }, get: ()=>data.blue, set: (value: number)=>{data.blue = value;}, transform: (value: number): number =>value,getError: ()=>errors.blue, setError: (value: __gf_Option<Array<string>>)=>{errors.blue = value;}, getTainted: ()=>tainted.blue, setTainted: (value: __gf_Option<boolean>)=>{tainted.blue = value;}, validate: (): Array<string>=>{const fieldErrors = colorValidateField("blue", data.blue); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Exit<Color, Array<{field: string; message: string}>>{return toExit(colorDeserialize(data));}function reset(newOverrides?: Partial<Color>): void {data = {...colorDefaultValue(),...newOverrides}; errors = {_errors: optionNone(), red: optionNone(), green: optionNone(), blue: optionNone(), }; tainted = {red: optionNone(), green: optionNone(), blue: optionNone(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function colorFromFormData(formData: FormData): Exit<Color, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; {const redStr = formData.get("red" ); obj.red = redStr? parseFloat(redStr as string): 0; if(obj.red!== undefined && isNaN(obj.red as number))obj.red = 0;}{const greenStr = formData.get("green" ); obj.green = greenStr? parseFloat(greenStr as string): 0; if(obj.green!== undefined && isNaN(obj.green as number))obj.green = 0;}{const blueStr = formData.get("blue" ); obj.blue = blueStr? parseFloat(blueStr as string): 0; if(obj.blue!== undefined && isNaN(obj.blue as number))obj.blue = 0;}return toExit(colorDeserialize(obj));}

export const Color = {
  defaultValue: colorDefaultValue,
  serialize: colorSerialize,
  serializeWithContext: colorSerializeWithContext,
  deserialize: colorDeserialize,
  deserializeWithContext: colorDeserializeWithContext,
  validateFields: colorValidateFields,
  hasShape: colorHasShape,
  is: colorIs,
  createForm: colorCreateForm,
  fromFormData: colorFromFormData
} as const;


export interface CompanyName {
    
    
    companyName: string;
}

export function companyNameDefaultValue(): CompanyName {return {companyName: "", }as CompanyName;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function companyNameSerialize(value: CompanyName): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(companyNameSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function companyNameSerializeWithContext(value: CompanyName, ctx: __mf_SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "CompanyName" , __id,}; result["companyName" ]= value.companyName; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function companyNameDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: CompanyName } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = companyNameDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "CompanyName.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function companyNameDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): CompanyName | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new __mf_DeserializeError([{field: "_root" , message: "CompanyName.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("companyName" in obj)){errors.push({field: "companyName" , message: "missing required field" });}if(errors.length>0){throw new __mf_DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_companyName = obj["companyName" ]as string; 
                if (__raw_companyName.length === 0) {
                    errors.push({ field: "companyName", message: "must not be empty" });
                }
 instance.companyName = __raw_companyName; }if(errors.length>0){throw new __mf_DeserializeError(errors);}return instance as CompanyName;}export function companyNameValidateField<K extends keyof CompanyName>(_field: K, _value: CompanyName[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(_field){case "companyName" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "companyName", message: "must not be empty" });
                }
 break;}}return errors; }export function companyNameValidateFields(_partial: Partial<CompanyName>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("companyName" in _partial && _partial.companyName!== undefined){const __val = _partial.companyName as string; 
                if (__val.length === 0) {
                    errors.push({ field: "companyName", message: "must not be empty" });
                }
}return errors; }export function companyNameHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "companyName" in o;}export function companyNameIs(obj: unknown): obj is CompanyName {if(!companyNameHasShape(obj)){return false;}const result = companyNameDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type CompanyNameErrors = {_errors: __gf_Option<Array<string>>; companyName: __gf_Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type CompanyNameTainted = {companyName: __gf_Option<boolean>; }; /** Type-safe field controllers for this form */export interface CompanyNameFieldControllers {readonly companyName: FieldController<string>; }/** Gigaform instance containing reactive state and field controllers */export interface CompanyNameGigaform {readonly data: CompanyName; readonly errors: CompanyNameErrors; readonly tainted: CompanyNameTainted; readonly fields: CompanyNameFieldControllers; validate(): Exit<CompanyName, Array<{field: string; message: string}>>; reset(overrides?: Partial<CompanyName>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function companyNameCreateForm(overrides?: Partial<CompanyName>): CompanyNameGigaform {let data = $state({...companyNameDefaultValue(),...overrides}); let errors = $state<CompanyNameErrors>({_errors: optionNone(), companyName: optionNone(), }); let tainted = $state<CompanyNameTainted>({companyName: optionNone(), }); const fields: CompanyNameFieldControllers = {companyName: {path: ["companyName" ]as const, name: "companyName" , constraints: { required: true }, label: "Company Name" , get: ()=>data.companyName, set: (value: string)=>{data.companyName = value;}, transform: (value: string): string =>value,getError: ()=>errors.companyName, setError: (value: __gf_Option<Array<string>>)=>{errors.companyName = value;}, getTainted: ()=>tainted.companyName, setTainted: (value: __gf_Option<boolean>)=>{tainted.companyName = value;}, validate: (): Array<string>=>{const fieldErrors = companyNameValidateField("companyName", data.companyName); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Exit<CompanyName, Array<{field: string; message: string}>>{return toExit(companyNameDeserialize(data));}function reset(newOverrides?: Partial<CompanyName>): void {data = {...companyNameDefaultValue(),...newOverrides}; errors = {_errors: optionNone(), companyName: optionNone(), }; tainted = {companyName: optionNone(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function companyNameFromFormData(formData: FormData): Exit<CompanyName, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.companyName = formData.get("companyName" )?? "" ;return toExit(companyNameDeserialize(obj));}

export const CompanyName = {
  defaultValue: companyNameDefaultValue,
  serialize: companyNameSerialize,
  serializeWithContext: companyNameSerializeWithContext,
  deserialize: companyNameDeserialize,
  deserializeWithContext: companyNameDeserializeWithContext,
  validateFields: companyNameValidateFields,
  hasShape: companyNameHasShape,
  is: companyNameIs,
  createForm: companyNameCreateForm,
  fromFormData: companyNameFromFormData
} as const;


export interface Appointment {
    
    id: string;
    
    
    title: string;
    
    
    status: Status;
    
    begins: string;
    
    duration: number;
    
    timeZone: string;
    
    offsetMs: number;
    
    allDay: boolean;
    
    multiDay: boolean;
    
    employees: (string | Employee)[];
    
    
    location: string | Site;
    
    description: string | null;
    
    
    colors: Colors;
    
    recurrenceRule: RecurrenceRule | null;
}

export function appointmentDefaultValue(): Appointment {return {id: "",
                            title: "",
                            status: "Scheduled",
                            begins: "",
                            duration: 0,
                            timeZone: "",
                            offsetMs: 0,
                            allDay: false,
                            multiDay: false,
                            employees: [],
                            location: "",
                            description: null,
                            colors: { main: "#000000", hover: "#333333", active: "#666666" },
                            recurrenceRule: null, }as Appointment;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function appointmentSerialize(value: Appointment): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(appointmentSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function appointmentSerializeWithContext(value: Appointment, ctx: __mf_SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Appointment" , __id,}; result["id" ]= value.id; result["title" ]= value.title; result["status" ]= statusSerializeWithContext(value.status, ctx); result["begins" ]= value.begins; result["duration" ]= value.duration; result["timeZone" ]= value.timeZone; result["offsetMs" ]= value.offsetMs; result["allDay" ]= value.allDay; result["multiDay" ]= value.multiDay; result["employees" ]= value.employees; result["location" ]= value.location; result["description" ]= value.description; result["colors" ]= colorsSerializeWithContext(value.colors, ctx); if(value.recurrenceRule!== null){result["recurrenceRule" ]= recurrenceRuleSerializeWithContext(value.recurrenceRule, ctx); }else {result["recurrenceRule" ]= null;}return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function appointmentDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: Appointment } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = appointmentDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Appointment.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function appointmentDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Appointment | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new __mf_DeserializeError([{field: "_root" , message: "Appointment.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("id" in obj)){errors.push({field: "id" , message: "missing required field" });}if(!("title" in obj)){errors.push({field: "title" , message: "missing required field" });}if(!("status" in obj)){errors.push({field: "status" , message: "missing required field" });}if(!("begins" in obj)){errors.push({field: "begins" , message: "missing required field" });}if(!("duration" in obj)){errors.push({field: "duration" , message: "missing required field" });}if(!("timeZone" in obj)){errors.push({field: "timeZone" , message: "missing required field" });}if(!("offsetMs" in obj)){errors.push({field: "offsetMs" , message: "missing required field" });}if(!("allDay" in obj)){errors.push({field: "allDay" , message: "missing required field" });}if(!("multiDay" in obj)){errors.push({field: "multiDay" , message: "missing required field" });}if(!("employees" in obj)){errors.push({field: "employees" , message: "missing required field" });}if(!("location" in obj)){errors.push({field: "location" , message: "missing required field" });}if(!("description" in obj)){errors.push({field: "description" , message: "missing required field" });}if(!("colors" in obj)){errors.push({field: "colors" , message: "missing required field" });}if(!("recurrenceRule" in obj)){errors.push({field: "recurrenceRule" , message: "missing required field" });}if(errors.length>0){throw new __mf_DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_id = obj["id" ]as string; instance.id = __raw_id; }{const __raw_title = obj["title" ]as string; 
                if (__raw_title.length === 0) {
                    errors.push({ field: "title", message: "must not be empty" });
                }
 instance.title = __raw_title; }{const __raw_status = obj["status" ]as Status; {const __result = statusDeserializeWithContext(__raw_status, ctx); ctx.assignOrDefer(instance, "status" , __result);}}{const __raw_begins = obj["begins" ]as string; instance.begins = __raw_begins; }{const __raw_duration = obj["duration" ]as number; instance.duration = __raw_duration; }{const __raw_timeZone = obj["timeZone" ]as string; instance.timeZone = __raw_timeZone; }{const __raw_offsetMs = obj["offsetMs" ]as number; instance.offsetMs = __raw_offsetMs; }{const __raw_allDay = obj["allDay" ]as boolean; instance.allDay = __raw_allDay; }{const __raw_multiDay = obj["multiDay" ]as boolean; instance.multiDay = __raw_multiDay; }{const __raw_employees = obj["employees" ]as (string | Employee)[]; if(Array.isArray(__raw_employees)){instance.employees = __raw_employees as (string | Employee)[];}}{const __raw_location = obj["location" ]as string | Site; instance.location = __raw_location; }{const __raw_description = obj["description" ]as string | null; instance.description = __raw_description; }{const __raw_colors = obj["colors" ]as Colors; {const __result = colorsDeserializeWithContext(__raw_colors, ctx); ctx.assignOrDefer(instance, "colors" , __result);}}{const __raw_recurrenceRule = obj["recurrenceRule" ]as RecurrenceRule | null; if(__raw_recurrenceRule === null){instance.recurrenceRule = null;}else {const __result = recurrenceRuleDeserializeWithContext(__raw_recurrenceRule, ctx); ctx.assignOrDefer(instance, "recurrenceRule" , __result); }}if(errors.length>0){throw new __mf_DeserializeError(errors);}return instance as Appointment;}export function appointmentValidateField<K extends keyof Appointment>(_field: K, _value: Appointment[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(_field){case "title" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "title", message: "must not be empty" });
                }
 break;}}return errors; }export function appointmentValidateFields(_partial: Partial<Appointment>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("title" in _partial && _partial.title!== undefined){const __val = _partial.title as string; 
                if (__val.length === 0) {
                    errors.push({ field: "title", message: "must not be empty" });
                }
}return errors; }export function appointmentHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "id" in o && "title" in o && "status" in o && "begins" in o && "duration" in o && "timeZone" in o && "offsetMs" in o && "allDay" in o && "multiDay" in o && "employees" in o && "location" in o && "description" in o && "colors" in o && "recurrenceRule" in o;}export function appointmentIs(obj: unknown): obj is Appointment {if(!appointmentHasShape(obj)){return false;}const result = appointmentDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type AppointmentErrors = {_errors: __gf_Option<Array<string>>; id: __gf_Option<Array<string>>; title: __gf_Option<Array<string>>; status: __gf_Option<Array<string>>; begins: __gf_Option<Array<string>>; duration: __gf_Option<Array<string>>; timeZone: __gf_Option<Array<string>>; offsetMs: __gf_Option<Array<string>>; allDay: __gf_Option<Array<string>>; multiDay: __gf_Option<Array<string>>; employees: __gf_Option<Array<string>>; location: __gf_Option<Array<string>>; description: __gf_Option<Array<string>>; colors: __gf_Option<Array<string>>; recurrenceRule: __gf_Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type AppointmentTainted = {id: __gf_Option<boolean>; title: __gf_Option<boolean>; status: __gf_Option<boolean>; begins: __gf_Option<boolean>; duration: __gf_Option<boolean>; timeZone: __gf_Option<boolean>; offsetMs: __gf_Option<boolean>; allDay: __gf_Option<boolean>; multiDay: __gf_Option<boolean>; employees: __gf_Option<boolean>; location: __gf_Option<boolean>; description: __gf_Option<boolean>; colors: __gf_Option<boolean>; recurrenceRule: __gf_Option<boolean>; }; /** Type-safe field controllers for this form */export interface AppointmentFieldControllers {readonly id: FieldController<string>; readonly title: FieldController<string>; readonly status: FieldController<Status>; readonly begins: FieldController<string>; readonly duration: FieldController<number>; readonly timeZone: FieldController<string>; readonly offsetMs: FieldController<number>; readonly allDay: FieldController<boolean>; readonly multiDay: FieldController<boolean>; readonly employees: ArrayFieldController<(string | Employee)>; readonly location: FieldController<string | Site>; readonly description: FieldController<string | null>; readonly colors: FieldController<Colors>; readonly recurrenceRule: FieldController<RecurrenceRule | null>; }/** Gigaform instance containing reactive state and field controllers */export interface AppointmentGigaform {readonly data: Appointment; readonly errors: AppointmentErrors; readonly tainted: AppointmentTainted; readonly fields: AppointmentFieldControllers; validate(): Exit<Appointment, Array<{field: string; message: string}>>; reset(overrides?: Partial<Appointment>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function appointmentCreateForm(overrides?: Partial<Appointment>): AppointmentGigaform {let data = $state({...appointmentDefaultValue(),...overrides}); let errors = $state<AppointmentErrors>({_errors: optionNone(), id: optionNone(), title: optionNone(), status: optionNone(), begins: optionNone(), duration: optionNone(), timeZone: optionNone(), offsetMs: optionNone(), allDay: optionNone(), multiDay: optionNone(), employees: optionNone(), location: optionNone(), description: optionNone(), colors: optionNone(), recurrenceRule: optionNone(), }); let tainted = $state<AppointmentTainted>({id: optionNone(), title: optionNone(), status: optionNone(), begins: optionNone(), duration: optionNone(), timeZone: optionNone(), offsetMs: optionNone(), allDay: optionNone(), multiDay: optionNone(), employees: optionNone(), location: optionNone(), description: optionNone(), colors: optionNone(), recurrenceRule: optionNone(), }); const fields: AppointmentFieldControllers = {id: {path: ["id" ]as const, name: "id" , constraints: { required: true }, get: ()=>data.id, set: (value: string)=>{data.id = value;}, transform: (value: string): string =>value,getError: ()=>errors.id, setError: (value: __gf_Option<Array<string>>)=>{errors.id = value;}, getTainted: ()=>tainted.id, setTainted: (value: __gf_Option<boolean>)=>{tainted.id = value;}, validate: (): Array<string>=>{const fieldErrors = appointmentValidateField("id", data.id); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},title: {path: ["title" ]as const, name: "title" , constraints: { required: true }, label: "Title" , get: ()=>data.title, set: (value: string)=>{data.title = value;}, transform: (value: string): string =>value,getError: ()=>errors.title, setError: (value: __gf_Option<Array<string>>)=>{errors.title = value;}, getTainted: ()=>tainted.title, setTainted: (value: __gf_Option<boolean>)=>{tainted.title = value;}, validate: (): Array<string>=>{const fieldErrors = appointmentValidateField("title", data.title); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},status: {path: ["status" ]as const, name: "status" , constraints: { required: true }, label: "Status" , get: ()=>data.status, set: (value: Status)=>{data.status = value;}, transform: (value: Status): Status =>value,getError: ()=>errors.status, setError: (value: __gf_Option<Array<string>>)=>{errors.status = value;}, getTainted: ()=>tainted.status, setTainted: (value: __gf_Option<boolean>)=>{tainted.status = value;}, validate: (): Array<string>=>{const fieldErrors = appointmentValidateField("status", data.status); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},begins: {path: ["begins" ]as const, name: "begins" , constraints: { required: true }, label: "Begins" , get: ()=>data.begins, set: (value: string)=>{data.begins = value;}, transform: (value: string): string =>value,getError: ()=>errors.begins, setError: (value: __gf_Option<Array<string>>)=>{errors.begins = value;}, getTainted: ()=>tainted.begins, setTainted: (value: __gf_Option<boolean>)=>{tainted.begins = value;}, validate: (): Array<string>=>{const fieldErrors = appointmentValidateField("begins", data.begins); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},duration: {path: ["duration" ]as const, name: "duration" , constraints: { required: true }, label: "Duration" , get: ()=>data.duration, set: (value: number)=>{data.duration = value;}, transform: (value: number): number =>value,getError: ()=>errors.duration, setError: (value: __gf_Option<Array<string>>)=>{errors.duration = value;}, getTainted: ()=>tainted.duration, setTainted: (value: __gf_Option<boolean>)=>{tainted.duration = value;}, validate: (): Array<string>=>{const fieldErrors = appointmentValidateField("duration", data.duration); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},timeZone: {path: ["timeZone" ]as const, name: "timeZone" , constraints: { required: true }, label: "Time Zone" , get: ()=>data.timeZone, set: (value: string)=>{data.timeZone = value;}, transform: (value: string): string =>value,getError: ()=>errors.timeZone, setError: (value: __gf_Option<Array<string>>)=>{errors.timeZone = value;}, getTainted: ()=>tainted.timeZone, setTainted: (value: __gf_Option<boolean>)=>{tainted.timeZone = value;}, validate: (): Array<string>=>{const fieldErrors = appointmentValidateField("timeZone", data.timeZone); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},offsetMs: {path: ["offsetMs" ]as const, name: "offsetMs" , constraints: { required: true }, get: ()=>data.offsetMs, set: (value: number)=>{data.offsetMs = value;}, transform: (value: number): number =>value,getError: ()=>errors.offsetMs, setError: (value: __gf_Option<Array<string>>)=>{errors.offsetMs = value;}, getTainted: ()=>tainted.offsetMs, setTainted: (value: __gf_Option<boolean>)=>{tainted.offsetMs = value;}, validate: (): Array<string>=>{const fieldErrors = appointmentValidateField("offsetMs", data.offsetMs); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},allDay: {path: ["allDay" ]as const, name: "allDay" , constraints: { required: true }, label: "All Day" , get: ()=>data.allDay, set: (value: boolean)=>{data.allDay = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.allDay, setError: (value: __gf_Option<Array<string>>)=>{errors.allDay = value;}, getTainted: ()=>tainted.allDay, setTainted: (value: __gf_Option<boolean>)=>{tainted.allDay = value;}, validate: (): Array<string>=>{const fieldErrors = appointmentValidateField("allDay", data.allDay); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},multiDay: {path: ["multiDay" ]as const, name: "multiDay" , constraints: { required: true }, label: "Multi Day" , get: ()=>data.multiDay, set: (value: boolean)=>{data.multiDay = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.multiDay, setError: (value: __gf_Option<Array<string>>)=>{errors.multiDay = value;}, getTainted: ()=>tainted.multiDay, setTainted: (value: __gf_Option<boolean>)=>{tainted.multiDay = value;}, validate: (): Array<string>=>{const fieldErrors = appointmentValidateField("multiDay", data.multiDay); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},employees: {path: ["employees" ]as const, name: "employees" , constraints: { required: true }, label: "Employees" , get: ()=>data.employees, set: (value: (string | Employee)[])=>{data.employees = value;}, transform: (value: (string | Employee)[]): (string | Employee)[] =>value,getError: ()=>errors.employees, setError: (value: __gf_Option<Array<string>>)=>{errors.employees = value;}, getTainted: ()=>tainted.employees, setTainted: (value: __gf_Option<boolean>)=>{tainted.employees = value;}, validate: (): Array<string>=>{const fieldErrors = appointmentValidateField("employees", data.employees); return fieldErrors.map((e: {field: string; message: string})=>e.message);},at: (index: number)=>({path: ["employees" , index]as const, name: `employees.${index}` , constraints: {required: true}, get: ()=>data.employees[index]!, set: (value: (string | Employee))=>{data.employees[index]= value;}, transform: (value: (string | Employee)): (string | Employee) =>value, getError: ()=>errors.employees, setError: (value: __gf_Option<Array<string>>)=>{errors.employees = value;}, getTainted: ()=>tainted.employees, setTainted: (value: __gf_Option<boolean>)=>{tainted.employees = value;}, validate: (): Array<string>=>[],}), push: (item: (string | Employee))=>{data.employees.push(item);}, remove: (index: number)=>{data.employees.splice(index, 1);}, swap: (a: number, b: number)=>{const tmp = data.employees[a]!; data.employees[a]= data.employees[b]!; data.employees[b]= tmp;},},location: {path: ["location" ]as const, name: "location" , constraints: { required: true }, label: "Location" , get: ()=>data.location, set: (value: string | Site)=>{data.location = value;}, transform: (value: string | Site): string | Site =>value,getError: ()=>errors.location, setError: (value: __gf_Option<Array<string>>)=>{errors.location = value;}, getTainted: ()=>tainted.location, setTainted: (value: __gf_Option<boolean>)=>{tainted.location = value;}, validate: (): Array<string>=>{const fieldErrors = appointmentValidateField("location", data.location); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},description: {path: ["description" ]as const, name: "description" , constraints: { required: true }, label: "Description" , get: ()=>data.description, set: (value: string | null)=>{data.description = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.description, setError: (value: __gf_Option<Array<string>>)=>{errors.description = value;}, getTainted: ()=>tainted.description, setTainted: (value: __gf_Option<boolean>)=>{tainted.description = value;}, validate: (): Array<string>=>{const fieldErrors = appointmentValidateField("description", data.description); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},colors: {path: ["colors" ]as const, name: "colors" , constraints: { required: true }, get: ()=>data.colors, set: (value: Colors)=>{data.colors = value;}, transform: (value: Colors): Colors =>value,getError: ()=>errors.colors, setError: (value: __gf_Option<Array<string>>)=>{errors.colors = value;}, getTainted: ()=>tainted.colors, setTainted: (value: __gf_Option<boolean>)=>{tainted.colors = value;}, validate: (): Array<string>=>{const fieldErrors = appointmentValidateField("colors", data.colors); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},recurrenceRule: {path: ["recurrenceRule" ]as const, name: "recurrenceRule" , constraints: { required: true }, get: ()=>data.recurrenceRule, set: (value: RecurrenceRule | null)=>{data.recurrenceRule = value;}, transform: (value: RecurrenceRule | null): RecurrenceRule | null =>value,getError: ()=>errors.recurrenceRule, setError: (value: __gf_Option<Array<string>>)=>{errors.recurrenceRule = value;}, getTainted: ()=>tainted.recurrenceRule, setTainted: (value: __gf_Option<boolean>)=>{tainted.recurrenceRule = value;}, validate: (): Array<string>=>{const fieldErrors = appointmentValidateField("recurrenceRule", data.recurrenceRule); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Exit<Appointment, Array<{field: string; message: string}>>{return toExit(appointmentDeserialize(data));}function reset(newOverrides?: Partial<Appointment>): void {data = {...appointmentDefaultValue(),...newOverrides}; errors = {_errors: optionNone(), id: optionNone(), title: optionNone(), status: optionNone(), begins: optionNone(), duration: optionNone(), timeZone: optionNone(), offsetMs: optionNone(), allDay: optionNone(), multiDay: optionNone(), employees: optionNone(), location: optionNone(), description: optionNone(), colors: optionNone(), recurrenceRule: optionNone(), }; tainted = {id: optionNone(), title: optionNone(), status: optionNone(), begins: optionNone(), duration: optionNone(), timeZone: optionNone(), offsetMs: optionNone(), allDay: optionNone(), multiDay: optionNone(), employees: optionNone(), location: optionNone(), description: optionNone(), colors: optionNone(), recurrenceRule: optionNone(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function appointmentFromFormData(formData: FormData): Exit<Appointment, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.id = formData.get("id" )?? "" ;obj.title = formData.get("title" )?? "" ;{const statusObj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("status." )){const fieldName = key.slice("status." .length); const parts = fieldName.split("." ); let current = statusObj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.status = statusObj;}obj.begins = formData.get("begins" )?? "" ;{const durationStr = formData.get("duration" ); obj.duration = durationStr? parseFloat(durationStr as string): 0; if(obj.duration!== undefined && isNaN(obj.duration as number))obj.duration = 0;}obj.timeZone = formData.get("timeZone" )?? "" ;{const offsetMsStr = formData.get("offsetMs" ); obj.offsetMs = offsetMsStr? parseFloat(offsetMsStr as string): 0; if(obj.offsetMs!== undefined && isNaN(obj.offsetMs as number))obj.offsetMs = 0;}{const allDayVal = formData.get("allDay" ); obj.allDay = allDayVal === "true" || allDayVal === "on" || allDayVal === "1" ;}{const multiDayVal = formData.get("multiDay" ); obj.multiDay = multiDayVal === "true" || multiDayVal === "on" || multiDayVal === "1" ;}{const employeesItems: Array<Record<string, unknown>>= []; let idx = 0; while(formData.has("employees." + idx + "." )|| idx === 0){const hasAny = Array.from(formData.keys()).some(k =>k.startsWith("employees." + idx + "." )); if(!hasAny && idx>0)break; if(hasAny){const item: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("employees." + idx + "." )){const fieldName = key.slice("employees." .length + String(idx).length + 1); item[fieldName]= value;}}employeesItems.push(item);}idx ++; if(idx>1000)break;}obj.employees = employeesItems;}obj.location = formData.get("location" )?? "" ;obj.description = formData.get("description" )?? "" ;{const colorsObj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("colors." )){const fieldName = key.slice("colors." .length); const parts = fieldName.split("." ); let current = colorsObj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.colors = colorsObj;}obj.recurrenceRule = formData.get("recurrenceRule" )?? "" ;return toExit(appointmentDeserialize(obj));}

export const Appointment = {
  defaultValue: appointmentDefaultValue,
  serialize: appointmentSerialize,
  serializeWithContext: appointmentSerializeWithContext,
  deserialize: appointmentDeserialize,
  deserializeWithContext: appointmentDeserializeWithContext,
  validateFields: appointmentValidateFields,
  hasShape: appointmentHasShape,
  is: appointmentIs,
  createForm: appointmentCreateForm,
  fromFormData: appointmentFromFormData
} as const;


export interface Package {
    
    id: string;
    
    date: string;
}

export function packageDefaultValue(): Package {return {id: "",
                            date: "", }as Package;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function packageSerialize(value: Package): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(packageSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function packageSerializeWithContext(value: Package, ctx: __mf_SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Package" , __id,}; result["id" ]= value.id; result["date" ]= value.date; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function packageDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: Package } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = packageDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Package.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function packageDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Package | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new __mf_DeserializeError([{field: "_root" , message: "Package.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("id" in obj)){errors.push({field: "id" , message: "missing required field" });}if(!("date" in obj)){errors.push({field: "date" , message: "missing required field" });}if(errors.length>0){throw new __mf_DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_id = obj["id" ]as string; instance.id = __raw_id; }{const __raw_date = obj["date" ]as string; instance.date = __raw_date; }if(errors.length>0){throw new __mf_DeserializeError(errors);}return instance as Package;}export function packageValidateField<K extends keyof Package>(_field: K, _value: Package[K]): Array<{field: string; message: string}>{return[]; }export function packageValidateFields(_partial: Partial<Package>): Array<{field: string; message: string}>{return[]; }export function packageHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "id" in o && "date" in o;}export function packageIs(obj: unknown): obj is Package {if(!packageHasShape(obj)){return false;}const result = packageDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type PackageErrors = {_errors: __gf_Option<Array<string>>; id: __gf_Option<Array<string>>; date: __gf_Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type PackageTainted = {id: __gf_Option<boolean>; date: __gf_Option<boolean>; }; /** Type-safe field controllers for this form */export interface PackageFieldControllers {readonly id: FieldController<string>; readonly date: FieldController<string>; }/** Gigaform instance containing reactive state and field controllers */export interface PackageGigaform {readonly data: Package; readonly errors: PackageErrors; readonly tainted: PackageTainted; readonly fields: PackageFieldControllers; validate(): Exit<Package, Array<{field: string; message: string}>>; reset(overrides?: Partial<Package>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function packageCreateForm(overrides?: Partial<Package>): PackageGigaform {let data = $state({...packageDefaultValue(),...overrides}); let errors = $state<PackageErrors>({_errors: optionNone(), id: optionNone(), date: optionNone(), }); let tainted = $state<PackageTainted>({id: optionNone(), date: optionNone(), }); const fields: PackageFieldControllers = {id: {path: ["id" ]as const, name: "id" , constraints: { required: true }, get: ()=>data.id, set: (value: string)=>{data.id = value;}, transform: (value: string): string =>value,getError: ()=>errors.id, setError: (value: __gf_Option<Array<string>>)=>{errors.id = value;}, getTainted: ()=>tainted.id, setTainted: (value: __gf_Option<boolean>)=>{tainted.id = value;}, validate: (): Array<string>=>{const fieldErrors = packageValidateField("id", data.id); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},date: {path: ["date" ]as const, name: "date" , constraints: { required: true }, label: "Date" , get: ()=>data.date, set: (value: string)=>{data.date = value;}, transform: (value: string): string =>value,getError: ()=>errors.date, setError: (value: __gf_Option<Array<string>>)=>{errors.date = value;}, getTainted: ()=>tainted.date, setTainted: (value: __gf_Option<boolean>)=>{tainted.date = value;}, validate: (): Array<string>=>{const fieldErrors = packageValidateField("date", data.date); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Exit<Package, Array<{field: string; message: string}>>{return toExit(packageDeserialize(data));}function reset(newOverrides?: Partial<Package>): void {data = {...packageDefaultValue(),...newOverrides}; errors = {_errors: optionNone(), id: optionNone(), date: optionNone(), }; tainted = {id: optionNone(), date: optionNone(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function packageFromFormData(formData: FormData): Exit<Package, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.id = formData.get("id" )?? "" ;obj.date = formData.get("date" )?? "" ;return toExit(packageDeserialize(obj));}

export const Package = {
  defaultValue: packageDefaultValue,
  serialize: packageSerialize,
  serializeWithContext: packageSerializeWithContext,
  deserialize: packageDeserialize,
  deserializeWithContext: packageDeserializeWithContext,
  validateFields: packageValidateFields,
  hasShape: packageHasShape,
  is: packageIs,
  createForm: packageCreateForm,
  fromFormData: packageFromFormData
} as const;


export interface ScheduleSettings {
    daysPerWeek: number;
    
    rowHeight: RowHeight;
    visibleRoutes: string[];
    detailedCards: boolean;
}

export function scheduleSettingsDefaultValue(): ScheduleSettings {return {daysPerWeek: 0,
                            rowHeight: "Medium",
                            visibleRoutes: [],
                            detailedCards: false, }as ScheduleSettings;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function scheduleSettingsSerialize(value: ScheduleSettings): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(scheduleSettingsSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function scheduleSettingsSerializeWithContext(value: ScheduleSettings, ctx: __mf_SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "ScheduleSettings" , __id,}; result["daysPerWeek" ]= value.daysPerWeek; result["rowHeight" ]= rowHeightSerializeWithContext(value.rowHeight, ctx); result["visibleRoutes" ]= value.visibleRoutes; result["detailedCards" ]= value.detailedCards; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function scheduleSettingsDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: ScheduleSettings } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = scheduleSettingsDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "ScheduleSettings.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function scheduleSettingsDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): ScheduleSettings | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new __mf_DeserializeError([{field: "_root" , message: "ScheduleSettings.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("daysPerWeek" in obj)){errors.push({field: "daysPerWeek" , message: "missing required field" });}if(!("rowHeight" in obj)){errors.push({field: "rowHeight" , message: "missing required field" });}if(!("visibleRoutes" in obj)){errors.push({field: "visibleRoutes" , message: "missing required field" });}if(!("detailedCards" in obj)){errors.push({field: "detailedCards" , message: "missing required field" });}if(errors.length>0){throw new __mf_DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_daysPerWeek = obj["daysPerWeek" ]as number; instance.daysPerWeek = __raw_daysPerWeek; }{const __raw_rowHeight = obj["rowHeight" ]as RowHeight; {const __result = rowHeightDeserializeWithContext(__raw_rowHeight, ctx); ctx.assignOrDefer(instance, "rowHeight" , __result);}}{const __raw_visibleRoutes = obj["visibleRoutes" ]as string[]; if(Array.isArray(__raw_visibleRoutes)){instance.visibleRoutes = __raw_visibleRoutes as string[];}}{const __raw_detailedCards = obj["detailedCards" ]as boolean; instance.detailedCards = __raw_detailedCards; }if(errors.length>0){throw new __mf_DeserializeError(errors);}return instance as ScheduleSettings;}export function scheduleSettingsValidateField<K extends keyof ScheduleSettings>(_field: K, _value: ScheduleSettings[K]): Array<{field: string; message: string}>{return[]; }export function scheduleSettingsValidateFields(_partial: Partial<ScheduleSettings>): Array<{field: string; message: string}>{return[]; }export function scheduleSettingsHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "daysPerWeek" in o && "rowHeight" in o && "visibleRoutes" in o && "detailedCards" in o;}export function scheduleSettingsIs(obj: unknown): obj is ScheduleSettings {if(!scheduleSettingsHasShape(obj)){return false;}const result = scheduleSettingsDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type ScheduleSettingsErrors = {_errors: __gf_Option<Array<string>>; daysPerWeek: __gf_Option<Array<string>>; rowHeight: __gf_Option<Array<string>>; visibleRoutes: __gf_Option<Array<string>>; detailedCards: __gf_Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type ScheduleSettingsTainted = {daysPerWeek: __gf_Option<boolean>; rowHeight: __gf_Option<boolean>; visibleRoutes: __gf_Option<boolean>; detailedCards: __gf_Option<boolean>; }; /** Type-safe field controllers for this form */export interface ScheduleSettingsFieldControllers {readonly daysPerWeek: FieldController<number>; readonly rowHeight: FieldController<RowHeight>; readonly visibleRoutes: ArrayFieldController<string>; readonly detailedCards: FieldController<boolean>; }/** Gigaform instance containing reactive state and field controllers */export interface ScheduleSettingsGigaform {readonly data: ScheduleSettings; readonly errors: ScheduleSettingsErrors; readonly tainted: ScheduleSettingsTainted; readonly fields: ScheduleSettingsFieldControllers; validate(): Exit<ScheduleSettings, Array<{field: string; message: string}>>; reset(overrides?: Partial<ScheduleSettings>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function scheduleSettingsCreateForm(overrides?: Partial<ScheduleSettings>): ScheduleSettingsGigaform {let data = $state({...scheduleSettingsDefaultValue(),...overrides}); let errors = $state<ScheduleSettingsErrors>({_errors: optionNone(), daysPerWeek: optionNone(), rowHeight: optionNone(), visibleRoutes: optionNone(), detailedCards: optionNone(), }); let tainted = $state<ScheduleSettingsTainted>({daysPerWeek: optionNone(), rowHeight: optionNone(), visibleRoutes: optionNone(), detailedCards: optionNone(), }); const fields: ScheduleSettingsFieldControllers = {daysPerWeek: {path: ["daysPerWeek" ]as const, name: "daysPerWeek" , constraints: { required: true }, get: ()=>data.daysPerWeek, set: (value: number)=>{data.daysPerWeek = value;}, transform: (value: number): number =>value,getError: ()=>errors.daysPerWeek, setError: (value: __gf_Option<Array<string>>)=>{errors.daysPerWeek = value;}, getTainted: ()=>tainted.daysPerWeek, setTainted: (value: __gf_Option<boolean>)=>{tainted.daysPerWeek = value;}, validate: (): Array<string>=>{const fieldErrors = scheduleSettingsValidateField("daysPerWeek", data.daysPerWeek); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},rowHeight: {path: ["rowHeight" ]as const, name: "rowHeight" , constraints: { required: true }, get: ()=>data.rowHeight, set: (value: RowHeight)=>{data.rowHeight = value;}, transform: (value: RowHeight): RowHeight =>value,getError: ()=>errors.rowHeight, setError: (value: __gf_Option<Array<string>>)=>{errors.rowHeight = value;}, getTainted: ()=>tainted.rowHeight, setTainted: (value: __gf_Option<boolean>)=>{tainted.rowHeight = value;}, validate: (): Array<string>=>{const fieldErrors = scheduleSettingsValidateField("rowHeight", data.rowHeight); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},visibleRoutes: {path: ["visibleRoutes" ]as const, name: "visibleRoutes" , constraints: { required: true }, get: ()=>data.visibleRoutes, set: (value: string[])=>{data.visibleRoutes = value;}, transform: (value: string[]): string[] =>value,getError: ()=>errors.visibleRoutes, setError: (value: __gf_Option<Array<string>>)=>{errors.visibleRoutes = value;}, getTainted: ()=>tainted.visibleRoutes, setTainted: (value: __gf_Option<boolean>)=>{tainted.visibleRoutes = value;}, validate: (): Array<string>=>{const fieldErrors = scheduleSettingsValidateField("visibleRoutes", data.visibleRoutes); return fieldErrors.map((e: {field: string; message: string})=>e.message);},at: (index: number)=>({path: ["visibleRoutes" , index]as const, name: `visibleRoutes.${index}` , constraints: {required: true}, get: ()=>data.visibleRoutes[index]!, set: (value: string)=>{data.visibleRoutes[index]= value;}, transform: (value: string): string =>value, getError: ()=>errors.visibleRoutes, setError: (value: __gf_Option<Array<string>>)=>{errors.visibleRoutes = value;}, getTainted: ()=>tainted.visibleRoutes, setTainted: (value: __gf_Option<boolean>)=>{tainted.visibleRoutes = value;}, validate: (): Array<string>=>[],}), push: (item: string)=>{data.visibleRoutes.push(item);}, remove: (index: number)=>{data.visibleRoutes.splice(index, 1);}, swap: (a: number, b: number)=>{const tmp = data.visibleRoutes[a]!; data.visibleRoutes[a]= data.visibleRoutes[b]!; data.visibleRoutes[b]= tmp;},},detailedCards: {path: ["detailedCards" ]as const, name: "detailedCards" , constraints: { required: true }, get: ()=>data.detailedCards, set: (value: boolean)=>{data.detailedCards = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.detailedCards, setError: (value: __gf_Option<Array<string>>)=>{errors.detailedCards = value;}, getTainted: ()=>tainted.detailedCards, setTainted: (value: __gf_Option<boolean>)=>{tainted.detailedCards = value;}, validate: (): Array<string>=>{const fieldErrors = scheduleSettingsValidateField("detailedCards", data.detailedCards); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Exit<ScheduleSettings, Array<{field: string; message: string}>>{return toExit(scheduleSettingsDeserialize(data));}function reset(newOverrides?: Partial<ScheduleSettings>): void {data = {...scheduleSettingsDefaultValue(),...newOverrides}; errors = {_errors: optionNone(), daysPerWeek: optionNone(), rowHeight: optionNone(), visibleRoutes: optionNone(), detailedCards: optionNone(), }; tainted = {daysPerWeek: optionNone(), rowHeight: optionNone(), visibleRoutes: optionNone(), detailedCards: optionNone(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function scheduleSettingsFromFormData(formData: FormData): Exit<ScheduleSettings, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; {const daysPerWeekStr = formData.get("daysPerWeek" ); obj.daysPerWeek = daysPerWeekStr? parseFloat(daysPerWeekStr as string): 0; if(obj.daysPerWeek!== undefined && isNaN(obj.daysPerWeek as number))obj.daysPerWeek = 0;}{const rowHeightObj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("rowHeight." )){const fieldName = key.slice("rowHeight." .length); const parts = fieldName.split("." ); let current = rowHeightObj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.rowHeight = rowHeightObj;}obj.visibleRoutes = formData.getAll("visibleRoutes" )as Array<string>;{const detailedCardsVal = formData.get("detailedCards" ); obj.detailedCards = detailedCardsVal === "true" || detailedCardsVal === "on" || detailedCardsVal === "1" ;}return toExit(scheduleSettingsDeserialize(obj));}

export const ScheduleSettings = {
  defaultValue: scheduleSettingsDefaultValue,
  serialize: scheduleSettingsSerialize,
  serializeWithContext: scheduleSettingsSerializeWithContext,
  deserialize: scheduleSettingsDeserialize,
  deserializeWithContext: scheduleSettingsDeserializeWithContext,
  validateFields: scheduleSettingsValidateFields,
  hasShape: scheduleSettingsHasShape,
  is: scheduleSettingsIs,
  createForm: scheduleSettingsCreateForm,
  fromFormData: scheduleSettingsFromFormData
} as const;


export interface DailyRecurrenceRule {
    quantityOfDays: number;
}

export function dailyRecurrenceRuleDefaultValue(): DailyRecurrenceRule {return {quantityOfDays: 0, }as DailyRecurrenceRule;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function dailyRecurrenceRuleSerialize(value: DailyRecurrenceRule): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(dailyRecurrenceRuleSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function dailyRecurrenceRuleSerializeWithContext(value: DailyRecurrenceRule, ctx: __mf_SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "DailyRecurrenceRule" , __id,}; result["quantityOfDays" ]= value.quantityOfDays; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function dailyRecurrenceRuleDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: DailyRecurrenceRule } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = dailyRecurrenceRuleDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "DailyRecurrenceRule.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function dailyRecurrenceRuleDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): DailyRecurrenceRule | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new __mf_DeserializeError([{field: "_root" , message: "DailyRecurrenceRule.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("quantityOfDays" in obj)){errors.push({field: "quantityOfDays" , message: "missing required field" });}if(errors.length>0){throw new __mf_DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_quantityOfDays = obj["quantityOfDays" ]as number; instance.quantityOfDays = __raw_quantityOfDays; }if(errors.length>0){throw new __mf_DeserializeError(errors);}return instance as DailyRecurrenceRule;}export function dailyRecurrenceRuleValidateField<K extends keyof DailyRecurrenceRule>(_field: K, _value: DailyRecurrenceRule[K]): Array<{field: string; message: string}>{return[]; }export function dailyRecurrenceRuleValidateFields(_partial: Partial<DailyRecurrenceRule>): Array<{field: string; message: string}>{return[]; }export function dailyRecurrenceRuleHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "quantityOfDays" in o;}export function dailyRecurrenceRuleIs(obj: unknown): obj is DailyRecurrenceRule {if(!dailyRecurrenceRuleHasShape(obj)){return false;}const result = dailyRecurrenceRuleDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type DailyRecurrenceRuleErrors = {_errors: __gf_Option<Array<string>>; quantityOfDays: __gf_Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type DailyRecurrenceRuleTainted = {quantityOfDays: __gf_Option<boolean>; }; /** Type-safe field controllers for this form */export interface DailyRecurrenceRuleFieldControllers {readonly quantityOfDays: FieldController<number>; }/** Gigaform instance containing reactive state and field controllers */export interface DailyRecurrenceRuleGigaform {readonly data: DailyRecurrenceRule; readonly errors: DailyRecurrenceRuleErrors; readonly tainted: DailyRecurrenceRuleTainted; readonly fields: DailyRecurrenceRuleFieldControllers; validate(): Exit<DailyRecurrenceRule, Array<{field: string; message: string}>>; reset(overrides?: Partial<DailyRecurrenceRule>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function dailyRecurrenceRuleCreateForm(overrides?: Partial<DailyRecurrenceRule>): DailyRecurrenceRuleGigaform {let data = $state({...dailyRecurrenceRuleDefaultValue(),...overrides}); let errors = $state<DailyRecurrenceRuleErrors>({_errors: optionNone(), quantityOfDays: optionNone(), }); let tainted = $state<DailyRecurrenceRuleTainted>({quantityOfDays: optionNone(), }); const fields: DailyRecurrenceRuleFieldControllers = {quantityOfDays: {path: ["quantityOfDays" ]as const, name: "quantityOfDays" , constraints: { required: true }, get: ()=>data.quantityOfDays, set: (value: number)=>{data.quantityOfDays = value;}, transform: (value: number): number =>value,getError: ()=>errors.quantityOfDays, setError: (value: __gf_Option<Array<string>>)=>{errors.quantityOfDays = value;}, getTainted: ()=>tainted.quantityOfDays, setTainted: (value: __gf_Option<boolean>)=>{tainted.quantityOfDays = value;}, validate: (): Array<string>=>{const fieldErrors = dailyRecurrenceRuleValidateField("quantityOfDays", data.quantityOfDays); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Exit<DailyRecurrenceRule, Array<{field: string; message: string}>>{return toExit(dailyRecurrenceRuleDeserialize(data));}function reset(newOverrides?: Partial<DailyRecurrenceRule>): void {data = {...dailyRecurrenceRuleDefaultValue(),...newOverrides}; errors = {_errors: optionNone(), quantityOfDays: optionNone(), }; tainted = {quantityOfDays: optionNone(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function dailyRecurrenceRuleFromFormData(formData: FormData): Exit<DailyRecurrenceRule, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; {const quantityOfDaysStr = formData.get("quantityOfDays" ); obj.quantityOfDays = quantityOfDaysStr? parseFloat(quantityOfDaysStr as string): 0; if(obj.quantityOfDays!== undefined && isNaN(obj.quantityOfDays as number))obj.quantityOfDays = 0;}return toExit(dailyRecurrenceRuleDeserialize(obj));}

export const DailyRecurrenceRule = {
  defaultValue: dailyRecurrenceRuleDefaultValue,
  serialize: dailyRecurrenceRuleSerialize,
  serializeWithContext: dailyRecurrenceRuleSerializeWithContext,
  deserialize: dailyRecurrenceRuleDeserialize,
  deserializeWithContext: dailyRecurrenceRuleDeserializeWithContext,
  validateFields: dailyRecurrenceRuleValidateFields,
  hasShape: dailyRecurrenceRuleHasShape,
  is: dailyRecurrenceRuleIs,
  createForm: dailyRecurrenceRuleCreateForm,
  fromFormData: dailyRecurrenceRuleFromFormData
} as const;


export interface SignUpCredentials {
    firstName: FirstName;
    lastName: LastName;
    email: EmailParts;
    password: Password;
    rememberMe: boolean;
}

export function signUpCredentialsDefaultValue(): SignUpCredentials {return {firstName: firstNameDefaultValue(),
                            lastName: lastNameDefaultValue(),
                            email: emailPartsDefaultValue(),
                            password: passwordDefaultValue(),
                            rememberMe: false, }as SignUpCredentials;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function signUpCredentialsSerialize(value: SignUpCredentials): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(signUpCredentialsSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function signUpCredentialsSerializeWithContext(value: SignUpCredentials, ctx: __mf_SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "SignUpCredentials" , __id,}; result["firstName" ]= firstNameSerializeWithContext(value.firstName, ctx); result["lastName" ]= lastNameSerializeWithContext(value.lastName, ctx); result["email" ]= emailPartsSerializeWithContext(value.email, ctx); result["password" ]= passwordSerializeWithContext(value.password, ctx); result["rememberMe" ]= value.rememberMe; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function signUpCredentialsDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: SignUpCredentials } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = signUpCredentialsDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "SignUpCredentials.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function signUpCredentialsDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): SignUpCredentials | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new __mf_DeserializeError([{field: "_root" , message: "SignUpCredentials.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("firstName" in obj)){errors.push({field: "firstName" , message: "missing required field" });}if(!("lastName" in obj)){errors.push({field: "lastName" , message: "missing required field" });}if(!("email" in obj)){errors.push({field: "email" , message: "missing required field" });}if(!("password" in obj)){errors.push({field: "password" , message: "missing required field" });}if(!("rememberMe" in obj)){errors.push({field: "rememberMe" , message: "missing required field" });}if(errors.length>0){throw new __mf_DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_firstName = obj["firstName" ]as FirstName; {const __result = firstNameDeserializeWithContext(__raw_firstName, ctx); ctx.assignOrDefer(instance, "firstName" , __result);}}{const __raw_lastName = obj["lastName" ]as LastName; {const __result = lastNameDeserializeWithContext(__raw_lastName, ctx); ctx.assignOrDefer(instance, "lastName" , __result);}}{const __raw_email = obj["email" ]as EmailParts; {const __result = emailPartsDeserializeWithContext(__raw_email, ctx); ctx.assignOrDefer(instance, "email" , __result);}}{const __raw_password = obj["password" ]as Password; {const __result = passwordDeserializeWithContext(__raw_password, ctx); ctx.assignOrDefer(instance, "password" , __result);}}{const __raw_rememberMe = obj["rememberMe" ]as boolean; instance.rememberMe = __raw_rememberMe; }if(errors.length>0){throw new __mf_DeserializeError(errors);}return instance as SignUpCredentials;}export function signUpCredentialsValidateField<K extends keyof SignUpCredentials>(_field: K, _value: SignUpCredentials[K]): Array<{field: string; message: string}>{return[]; }export function signUpCredentialsValidateFields(_partial: Partial<SignUpCredentials>): Array<{field: string; message: string}>{return[]; }export function signUpCredentialsHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "firstName" in o && "lastName" in o && "email" in o && "password" in o && "rememberMe" in o;}export function signUpCredentialsIs(obj: unknown): obj is SignUpCredentials {if(!signUpCredentialsHasShape(obj)){return false;}const result = signUpCredentialsDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type SignUpCredentialsErrors = {_errors: __gf_Option<Array<string>>; firstName: __gf_Option<Array<string>>; lastName: __gf_Option<Array<string>>; email: __gf_Option<Array<string>>; password: __gf_Option<Array<string>>; rememberMe: __gf_Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type SignUpCredentialsTainted = {firstName: __gf_Option<boolean>; lastName: __gf_Option<boolean>; email: __gf_Option<boolean>; password: __gf_Option<boolean>; rememberMe: __gf_Option<boolean>; }; /** Type-safe field controllers for this form */export interface SignUpCredentialsFieldControllers {readonly firstName: FieldController<FirstName>; readonly lastName: FieldController<LastName>; readonly email: FieldController<EmailParts>; readonly password: FieldController<Password>; readonly rememberMe: FieldController<boolean>; }/** Gigaform instance containing reactive state and field controllers */export interface SignUpCredentialsGigaform {readonly data: SignUpCredentials; readonly errors: SignUpCredentialsErrors; readonly tainted: SignUpCredentialsTainted; readonly fields: SignUpCredentialsFieldControllers; validate(): Exit<SignUpCredentials, Array<{field: string; message: string}>>; reset(overrides?: Partial<SignUpCredentials>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function signUpCredentialsCreateForm(overrides?: Partial<SignUpCredentials>): SignUpCredentialsGigaform {let data = $state({...signUpCredentialsDefaultValue(),...overrides}); let errors = $state<SignUpCredentialsErrors>({_errors: optionNone(), firstName: optionNone(), lastName: optionNone(), email: optionNone(), password: optionNone(), rememberMe: optionNone(), }); let tainted = $state<SignUpCredentialsTainted>({firstName: optionNone(), lastName: optionNone(), email: optionNone(), password: optionNone(), rememberMe: optionNone(), }); const fields: SignUpCredentialsFieldControllers = {firstName: {path: ["firstName" ]as const, name: "firstName" , constraints: { required: true }, get: ()=>data.firstName, set: (value: FirstName)=>{data.firstName = value;}, transform: (value: FirstName): FirstName =>value,getError: ()=>errors.firstName, setError: (value: __gf_Option<Array<string>>)=>{errors.firstName = value;}, getTainted: ()=>tainted.firstName, setTainted: (value: __gf_Option<boolean>)=>{tainted.firstName = value;}, validate: (): Array<string>=>{const fieldErrors = signUpCredentialsValidateField("firstName", data.firstName); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},lastName: {path: ["lastName" ]as const, name: "lastName" , constraints: { required: true }, get: ()=>data.lastName, set: (value: LastName)=>{data.lastName = value;}, transform: (value: LastName): LastName =>value,getError: ()=>errors.lastName, setError: (value: __gf_Option<Array<string>>)=>{errors.lastName = value;}, getTainted: ()=>tainted.lastName, setTainted: (value: __gf_Option<boolean>)=>{tainted.lastName = value;}, validate: (): Array<string>=>{const fieldErrors = signUpCredentialsValidateField("lastName", data.lastName); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},email: {path: ["email" ]as const, name: "email" , constraints: { required: true }, get: ()=>data.email, set: (value: EmailParts)=>{data.email = value;}, transform: (value: EmailParts): EmailParts =>value,getError: ()=>errors.email, setError: (value: __gf_Option<Array<string>>)=>{errors.email = value;}, getTainted: ()=>tainted.email, setTainted: (value: __gf_Option<boolean>)=>{tainted.email = value;}, validate: (): Array<string>=>{const fieldErrors = signUpCredentialsValidateField("email", data.email); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},password: {path: ["password" ]as const, name: "password" , constraints: { required: true }, get: ()=>data.password, set: (value: Password)=>{data.password = value;}, transform: (value: Password): Password =>value,getError: ()=>errors.password, setError: (value: __gf_Option<Array<string>>)=>{errors.password = value;}, getTainted: ()=>tainted.password, setTainted: (value: __gf_Option<boolean>)=>{tainted.password = value;}, validate: (): Array<string>=>{const fieldErrors = signUpCredentialsValidateField("password", data.password); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},rememberMe: {path: ["rememberMe" ]as const, name: "rememberMe" , constraints: { required: true }, get: ()=>data.rememberMe, set: (value: boolean)=>{data.rememberMe = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.rememberMe, setError: (value: __gf_Option<Array<string>>)=>{errors.rememberMe = value;}, getTainted: ()=>tainted.rememberMe, setTainted: (value: __gf_Option<boolean>)=>{tainted.rememberMe = value;}, validate: (): Array<string>=>{const fieldErrors = signUpCredentialsValidateField("rememberMe", data.rememberMe); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Exit<SignUpCredentials, Array<{field: string; message: string}>>{return toExit(signUpCredentialsDeserialize(data));}function reset(newOverrides?: Partial<SignUpCredentials>): void {data = {...signUpCredentialsDefaultValue(),...newOverrides}; errors = {_errors: optionNone(), firstName: optionNone(), lastName: optionNone(), email: optionNone(), password: optionNone(), rememberMe: optionNone(), }; tainted = {firstName: optionNone(), lastName: optionNone(), email: optionNone(), password: optionNone(), rememberMe: optionNone(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function signUpCredentialsFromFormData(formData: FormData): Exit<SignUpCredentials, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; {const firstNameObj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("firstName." )){const fieldName = key.slice("firstName." .length); const parts = fieldName.split("." ); let current = firstNameObj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.firstName = firstNameObj;}{const lastNameObj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("lastName." )){const fieldName = key.slice("lastName." .length); const parts = fieldName.split("." ); let current = lastNameObj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.lastName = lastNameObj;}{const emailObj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("email." )){const fieldName = key.slice("email." .length); const parts = fieldName.split("." ); let current = emailObj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.email = emailObj;}{const passwordObj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("password." )){const fieldName = key.slice("password." .length); const parts = fieldName.split("." ); let current = passwordObj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.password = passwordObj;}{const rememberMeVal = formData.get("rememberMe" ); obj.rememberMe = rememberMeVal === "true" || rememberMeVal === "on" || rememberMeVal === "1" ;}return toExit(signUpCredentialsDeserialize(obj));}

export const SignUpCredentials = {
  defaultValue: signUpCredentialsDefaultValue,
  serialize: signUpCredentialsSerialize,
  serializeWithContext: signUpCredentialsSerializeWithContext,
  deserialize: signUpCredentialsDeserialize,
  deserializeWithContext: signUpCredentialsDeserializeWithContext,
  validateFields: signUpCredentialsValidateFields,
  hasShape: signUpCredentialsHasShape,
  is: signUpCredentialsIs,
  createForm: signUpCredentialsCreateForm,
  fromFormData: signUpCredentialsFromFormData
} as const;


export interface OverviewSettings {
    
    rowHeight: RowHeight;
    
    cardOrRow: OverviewDisplay;
    perPage: number;
    columnConfigs: ColumnConfig[];
}

export function overviewSettingsDefaultValue(): OverviewSettings {return {rowHeight: "Medium",
                            cardOrRow: "Table",
                            perPage: 0,
                            columnConfigs: [], }as OverviewSettings;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function overviewSettingsSerialize(value: OverviewSettings): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(overviewSettingsSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function overviewSettingsSerializeWithContext(value: OverviewSettings, ctx: __mf_SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "OverviewSettings" , __id,}; result["rowHeight" ]= rowHeightSerializeWithContext(value.rowHeight, ctx); result["cardOrRow" ]= overviewDisplaySerializeWithContext(value.cardOrRow, ctx); result["perPage" ]= value.perPage; result["columnConfigs" ]= value.columnConfigs.map((item)=>columnConfigSerializeWithContext(item, ctx)); return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function overviewSettingsDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: OverviewSettings } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = overviewSettingsDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "OverviewSettings.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function overviewSettingsDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): OverviewSettings | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new __mf_DeserializeError([{field: "_root" , message: "OverviewSettings.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("rowHeight" in obj)){errors.push({field: "rowHeight" , message: "missing required field" });}if(!("cardOrRow" in obj)){errors.push({field: "cardOrRow" , message: "missing required field" });}if(!("perPage" in obj)){errors.push({field: "perPage" , message: "missing required field" });}if(!("columnConfigs" in obj)){errors.push({field: "columnConfigs" , message: "missing required field" });}if(errors.length>0){throw new __mf_DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_rowHeight = obj["rowHeight" ]as RowHeight; {const __result = rowHeightDeserializeWithContext(__raw_rowHeight, ctx); ctx.assignOrDefer(instance, "rowHeight" , __result);}}{const __raw_cardOrRow = obj["cardOrRow" ]as OverviewDisplay; {const __result = overviewDisplayDeserializeWithContext(__raw_cardOrRow, ctx); ctx.assignOrDefer(instance, "cardOrRow" , __result);}}{const __raw_perPage = obj["perPage" ]as number; instance.perPage = __raw_perPage; }{const __raw_columnConfigs = obj["columnConfigs" ]as ColumnConfig[]; if(Array.isArray(__raw_columnConfigs)){instance.columnConfigs = __raw_columnConfigs as ColumnConfig[];}}if(errors.length>0){throw new __mf_DeserializeError(errors);}return instance as OverviewSettings;}export function overviewSettingsValidateField<K extends keyof OverviewSettings>(_field: K, _value: OverviewSettings[K]): Array<{field: string; message: string}>{return[]; }export function overviewSettingsValidateFields(_partial: Partial<OverviewSettings>): Array<{field: string; message: string}>{return[]; }export function overviewSettingsHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "rowHeight" in o && "cardOrRow" in o && "perPage" in o && "columnConfigs" in o;}export function overviewSettingsIs(obj: unknown): obj is OverviewSettings {if(!overviewSettingsHasShape(obj)){return false;}const result = overviewSettingsDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type OverviewSettingsErrors = {_errors: __gf_Option<Array<string>>; rowHeight: __gf_Option<Array<string>>; cardOrRow: __gf_Option<Array<string>>; perPage: __gf_Option<Array<string>>; columnConfigs: __gf_Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type OverviewSettingsTainted = {rowHeight: __gf_Option<boolean>; cardOrRow: __gf_Option<boolean>; perPage: __gf_Option<boolean>; columnConfigs: __gf_Option<boolean>; }; /** Type-safe field controllers for this form */export interface OverviewSettingsFieldControllers {readonly rowHeight: FieldController<RowHeight>; readonly cardOrRow: FieldController<OverviewDisplay>; readonly perPage: FieldController<number>; readonly columnConfigs: ArrayFieldController<ColumnConfig>; }/** Gigaform instance containing reactive state and field controllers */export interface OverviewSettingsGigaform {readonly data: OverviewSettings; readonly errors: OverviewSettingsErrors; readonly tainted: OverviewSettingsTainted; readonly fields: OverviewSettingsFieldControllers; validate(): Exit<OverviewSettings, Array<{field: string; message: string}>>; reset(overrides?: Partial<OverviewSettings>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function overviewSettingsCreateForm(overrides?: Partial<OverviewSettings>): OverviewSettingsGigaform {let data = $state({...overviewSettingsDefaultValue(),...overrides}); let errors = $state<OverviewSettingsErrors>({_errors: optionNone(), rowHeight: optionNone(), cardOrRow: optionNone(), perPage: optionNone(), columnConfigs: optionNone(), }); let tainted = $state<OverviewSettingsTainted>({rowHeight: optionNone(), cardOrRow: optionNone(), perPage: optionNone(), columnConfigs: optionNone(), }); const fields: OverviewSettingsFieldControllers = {rowHeight: {path: ["rowHeight" ]as const, name: "rowHeight" , constraints: { required: true }, get: ()=>data.rowHeight, set: (value: RowHeight)=>{data.rowHeight = value;}, transform: (value: RowHeight): RowHeight =>value,getError: ()=>errors.rowHeight, setError: (value: __gf_Option<Array<string>>)=>{errors.rowHeight = value;}, getTainted: ()=>tainted.rowHeight, setTainted: (value: __gf_Option<boolean>)=>{tainted.rowHeight = value;}, validate: (): Array<string>=>{const fieldErrors = overviewSettingsValidateField("rowHeight", data.rowHeight); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},cardOrRow: {path: ["cardOrRow" ]as const, name: "cardOrRow" , constraints: { required: true }, get: ()=>data.cardOrRow, set: (value: OverviewDisplay)=>{data.cardOrRow = value;}, transform: (value: OverviewDisplay): OverviewDisplay =>value,getError: ()=>errors.cardOrRow, setError: (value: __gf_Option<Array<string>>)=>{errors.cardOrRow = value;}, getTainted: ()=>tainted.cardOrRow, setTainted: (value: __gf_Option<boolean>)=>{tainted.cardOrRow = value;}, validate: (): Array<string>=>{const fieldErrors = overviewSettingsValidateField("cardOrRow", data.cardOrRow); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},perPage: {path: ["perPage" ]as const, name: "perPage" , constraints: { required: true }, get: ()=>data.perPage, set: (value: number)=>{data.perPage = value;}, transform: (value: number): number =>value,getError: ()=>errors.perPage, setError: (value: __gf_Option<Array<string>>)=>{errors.perPage = value;}, getTainted: ()=>tainted.perPage, setTainted: (value: __gf_Option<boolean>)=>{tainted.perPage = value;}, validate: (): Array<string>=>{const fieldErrors = overviewSettingsValidateField("perPage", data.perPage); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},columnConfigs: {path: ["columnConfigs" ]as const, name: "columnConfigs" , constraints: { required: true }, get: ()=>data.columnConfigs, set: (value: ColumnConfig[])=>{data.columnConfigs = value;}, transform: (value: ColumnConfig[]): ColumnConfig[] =>value,getError: ()=>errors.columnConfigs, setError: (value: __gf_Option<Array<string>>)=>{errors.columnConfigs = value;}, getTainted: ()=>tainted.columnConfigs, setTainted: (value: __gf_Option<boolean>)=>{tainted.columnConfigs = value;}, validate: (): Array<string>=>{const fieldErrors = overviewSettingsValidateField("columnConfigs", data.columnConfigs); return fieldErrors.map((e: {field: string; message: string})=>e.message);},at: (index: number)=>({path: ["columnConfigs" , index]as const, name: `columnConfigs.${index}` , constraints: {required: true}, get: ()=>data.columnConfigs[index]!, set: (value: ColumnConfig)=>{data.columnConfigs[index]= value;}, transform: (value: ColumnConfig): ColumnConfig =>value, getError: ()=>errors.columnConfigs, setError: (value: __gf_Option<Array<string>>)=>{errors.columnConfigs = value;}, getTainted: ()=>tainted.columnConfigs, setTainted: (value: __gf_Option<boolean>)=>{tainted.columnConfigs = value;}, validate: (): Array<string>=>[],}), push: (item: ColumnConfig)=>{data.columnConfigs.push(item);}, remove: (index: number)=>{data.columnConfigs.splice(index, 1);}, swap: (a: number, b: number)=>{const tmp = data.columnConfigs[a]!; data.columnConfigs[a]= data.columnConfigs[b]!; data.columnConfigs[b]= tmp;},},}; function validate(): Exit<OverviewSettings, Array<{field: string; message: string}>>{return toExit(overviewSettingsDeserialize(data));}function reset(newOverrides?: Partial<OverviewSettings>): void {data = {...overviewSettingsDefaultValue(),...newOverrides}; errors = {_errors: optionNone(), rowHeight: optionNone(), cardOrRow: optionNone(), perPage: optionNone(), columnConfigs: optionNone(), }; tainted = {rowHeight: optionNone(), cardOrRow: optionNone(), perPage: optionNone(), columnConfigs: optionNone(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function overviewSettingsFromFormData(formData: FormData): Exit<OverviewSettings, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; {const rowHeightObj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("rowHeight." )){const fieldName = key.slice("rowHeight." .length); const parts = fieldName.split("." ); let current = rowHeightObj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.rowHeight = rowHeightObj;}{const cardOrRowObj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("cardOrRow." )){const fieldName = key.slice("cardOrRow." .length); const parts = fieldName.split("." ); let current = cardOrRowObj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.cardOrRow = cardOrRowObj;}{const perPageStr = formData.get("perPage" ); obj.perPage = perPageStr? parseFloat(perPageStr as string): 0; if(obj.perPage!== undefined && isNaN(obj.perPage as number))obj.perPage = 0;}{const columnConfigsItems: Array<Record<string, unknown>>= []; let idx = 0; while(formData.has("columnConfigs." + idx + "." )|| idx === 0){const hasAny = Array.from(formData.keys()).some(k =>k.startsWith("columnConfigs." + idx + "." )); if(!hasAny && idx>0)break; if(hasAny){const item: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("columnConfigs." + idx + "." )){const fieldName = key.slice("columnConfigs." .length + String(idx).length + 1); item[fieldName]= value;}}columnConfigsItems.push(item);}idx ++; if(idx>1000)break;}obj.columnConfigs = columnConfigsItems;}return toExit(overviewSettingsDeserialize(obj));}

export const OverviewSettings = {
  defaultValue: overviewSettingsDefaultValue,
  serialize: overviewSettingsSerialize,
  serializeWithContext: overviewSettingsSerializeWithContext,
  deserialize: overviewSettingsDeserialize,
  deserializeWithContext: overviewSettingsDeserializeWithContext,
  validateFields: overviewSettingsValidateFields,
  hasShape: overviewSettingsHasShape,
  is: overviewSettingsIs,
  createForm: overviewSettingsCreateForm,
  fromFormData: overviewSettingsFromFormData
} as const;


export interface FirstName {
    
    name: string;
}

export function firstNameDefaultValue(): FirstName {return {name: "", }as FirstName;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function firstNameSerialize(value: FirstName): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(firstNameSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function firstNameSerializeWithContext(value: FirstName, ctx: __mf_SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "FirstName" , __id,}; result["name" ]= value.name; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function firstNameDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: FirstName } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = firstNameDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "FirstName.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function firstNameDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): FirstName | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new __mf_DeserializeError([{field: "_root" , message: "FirstName.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("name" in obj)){errors.push({field: "name" , message: "missing required field" });}if(errors.length>0){throw new __mf_DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_name = obj["name" ]as string; 
                if (__raw_name.length === 0) {
                    errors.push({ field: "name", message: "must not be empty" });
                }
 instance.name = __raw_name; }if(errors.length>0){throw new __mf_DeserializeError(errors);}return instance as FirstName;}export function firstNameValidateField<K extends keyof FirstName>(_field: K, _value: FirstName[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(_field){case "name" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "name", message: "must not be empty" });
                }
 break;}}return errors; }export function firstNameValidateFields(_partial: Partial<FirstName>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("name" in _partial && _partial.name!== undefined){const __val = _partial.name as string; 
                if (__val.length === 0) {
                    errors.push({ field: "name", message: "must not be empty" });
                }
}return errors; }export function firstNameHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "name" in o;}export function firstNameIs(obj: unknown): obj is FirstName {if(!firstNameHasShape(obj)){return false;}const result = firstNameDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type FirstNameErrors = {_errors: __gf_Option<Array<string>>; name: __gf_Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type FirstNameTainted = {name: __gf_Option<boolean>; }; /** Type-safe field controllers for this form */export interface FirstNameFieldControllers {readonly name: FieldController<string>; }/** Gigaform instance containing reactive state and field controllers */export interface FirstNameGigaform {readonly data: FirstName; readonly errors: FirstNameErrors; readonly tainted: FirstNameTainted; readonly fields: FirstNameFieldControllers; validate(): Exit<FirstName, Array<{field: string; message: string}>>; reset(overrides?: Partial<FirstName>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function firstNameCreateForm(overrides?: Partial<FirstName>): FirstNameGigaform {let data = $state({...firstNameDefaultValue(),...overrides}); let errors = $state<FirstNameErrors>({_errors: optionNone(), name: optionNone(), }); let tainted = $state<FirstNameTainted>({name: optionNone(), }); const fields: FirstNameFieldControllers = {name: {path: ["name" ]as const, name: "name" , constraints: { required: true }, get: ()=>data.name, set: (value: string)=>{data.name = value;}, transform: (value: string): string =>value,getError: ()=>errors.name, setError: (value: __gf_Option<Array<string>>)=>{errors.name = value;}, getTainted: ()=>tainted.name, setTainted: (value: __gf_Option<boolean>)=>{tainted.name = value;}, validate: (): Array<string>=>{const fieldErrors = firstNameValidateField("name", data.name); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Exit<FirstName, Array<{field: string; message: string}>>{return toExit(firstNameDeserialize(data));}function reset(newOverrides?: Partial<FirstName>): void {data = {...firstNameDefaultValue(),...newOverrides}; errors = {_errors: optionNone(), name: optionNone(), }; tainted = {name: optionNone(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function firstNameFromFormData(formData: FormData): Exit<FirstName, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.name = formData.get("name" )?? "" ;return toExit(firstNameDeserialize(obj));}

export const FirstName = {
  defaultValue: firstNameDefaultValue,
  serialize: firstNameSerialize,
  serializeWithContext: firstNameSerializeWithContext,
  deserialize: firstNameDeserialize,
  deserializeWithContext: firstNameDeserializeWithContext,
  validateFields: firstNameValidateFields,
  hasShape: firstNameHasShape,
  is: firstNameIs,
  createForm: firstNameCreateForm,
  fromFormData: firstNameFromFormData
} as const;


export interface Account {
    
    id: string;
    
    
    taxRate: string | TaxRate;
    
    
    site: string | Site;
    
    salesRep: Represents[] | null;
    
    orders: Ordered[];
    
    activity: Did[];
    
    customFields: [string, string][];
    
    accountName: AccountName;
    
    
    sector: Sector;
    
    memo: string | null;
    
    phones: PhoneNumber[];
    
    email: Email;
    
    
    leadSource: string;
    
    colors: Colors;
    
    needsReview: boolean;
    
    hasAlert: boolean;
    
    
    accountType: string;
    
    
    subtype: string;
    
    isTaxExempt: boolean;
    
    
    paymentTerms: string;
    
    tags: string[];
    
    dateAdded: string;
}

export function accountDefaultValue(): Account {return {id: "",
                            taxRate: "",
                            site: "",
                            salesRep: null,
                            orders: [],
                            activity: [],
                            customFields: [],
                            accountName: accountNameDefaultValue(),
                            sector: "Residential",
                            memo: null,
                            phones: [],
                            email: emailDefaultValue(),
                            leadSource: "",
                            colors: colorsDefaultValue(),
                            needsReview: false,
                            hasAlert: false,
                            accountType: "",
                            subtype: "",
                            isTaxExempt: false,
                            paymentTerms: "",
                            tags: [],
                            dateAdded: "", }as Account;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function accountSerialize(value: Account): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(accountSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function accountSerializeWithContext(value: Account, ctx: __mf_SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Account" , __id,}; result["id" ]= value.id; result["taxRate" ]= value.taxRate; result["site" ]= value.site; if(value.salesRep!== null){result["salesRep" ]= value.salesRep; }else {result["salesRep" ]= null;}result["orders" ]= value.orders.map((item)=>orderedSerializeWithContext(item, ctx)); result["activity" ]= value.activity.map((item)=>didSerializeWithContext(item, ctx)); result["customFields" ]= value.customFields; result["accountName" ]= accountNameSerializeWithContext(value.accountName, ctx); result["sector" ]= sectorSerializeWithContext(value.sector, ctx); result["memo" ]= value.memo; result["phones" ]= value.phones.map((item)=>phoneNumberSerializeWithContext(item, ctx)); result["email" ]= emailSerializeWithContext(value.email, ctx); result["leadSource" ]= value.leadSource; result["colors" ]= colorsSerializeWithContext(value.colors, ctx); result["needsReview" ]= value.needsReview; result["hasAlert" ]= value.hasAlert; result["accountType" ]= value.accountType; result["subtype" ]= value.subtype; result["isTaxExempt" ]= value.isTaxExempt; result["paymentTerms" ]= value.paymentTerms; result["tags" ]= value.tags; result["dateAdded" ]= value.dateAdded; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function accountDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: Account } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = accountDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Account.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function accountDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Account | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new __mf_DeserializeError([{field: "_root" , message: "Account.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("id" in obj)){errors.push({field: "id" , message: "missing required field" });}if(!("taxRate" in obj)){errors.push({field: "taxRate" , message: "missing required field" });}if(!("site" in obj)){errors.push({field: "site" , message: "missing required field" });}if(!("salesRep" in obj)){errors.push({field: "salesRep" , message: "missing required field" });}if(!("orders" in obj)){errors.push({field: "orders" , message: "missing required field" });}if(!("activity" in obj)){errors.push({field: "activity" , message: "missing required field" });}if(!("customFields" in obj)){errors.push({field: "customFields" , message: "missing required field" });}if(!("accountName" in obj)){errors.push({field: "accountName" , message: "missing required field" });}if(!("sector" in obj)){errors.push({field: "sector" , message: "missing required field" });}if(!("memo" in obj)){errors.push({field: "memo" , message: "missing required field" });}if(!("phones" in obj)){errors.push({field: "phones" , message: "missing required field" });}if(!("email" in obj)){errors.push({field: "email" , message: "missing required field" });}if(!("leadSource" in obj)){errors.push({field: "leadSource" , message: "missing required field" });}if(!("colors" in obj)){errors.push({field: "colors" , message: "missing required field" });}if(!("needsReview" in obj)){errors.push({field: "needsReview" , message: "missing required field" });}if(!("hasAlert" in obj)){errors.push({field: "hasAlert" , message: "missing required field" });}if(!("accountType" in obj)){errors.push({field: "accountType" , message: "missing required field" });}if(!("subtype" in obj)){errors.push({field: "subtype" , message: "missing required field" });}if(!("isTaxExempt" in obj)){errors.push({field: "isTaxExempt" , message: "missing required field" });}if(!("paymentTerms" in obj)){errors.push({field: "paymentTerms" , message: "missing required field" });}if(!("tags" in obj)){errors.push({field: "tags" , message: "missing required field" });}if(!("dateAdded" in obj)){errors.push({field: "dateAdded" , message: "missing required field" });}if(errors.length>0){throw new __mf_DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_id = obj["id" ]as string; instance.id = __raw_id; }{const __raw_taxRate = obj["taxRate" ]as string | TaxRate; instance.taxRate = __raw_taxRate; }{const __raw_site = obj["site" ]as string | Site; instance.site = __raw_site; }{const __raw_salesRep = obj["salesRep" ]as Represents[] | null; if(__raw_salesRep === null){instance.salesRep = null;}else {instance.salesRep = __raw_salesRep; }}{const __raw_orders = obj["orders" ]as Ordered[]; if(Array.isArray(__raw_orders)){instance.orders = __raw_orders as Ordered[];}}{const __raw_activity = obj["activity" ]as Did[]; if(Array.isArray(__raw_activity)){instance.activity = __raw_activity as Did[];}}{const __raw_customFields = obj["customFields" ]as [string, string][]; if(Array.isArray(__raw_customFields)){instance.customFields = __raw_customFields as [string, string][];}}{const __raw_accountName = obj["accountName" ]as AccountName; {const __result = accountNameDeserializeWithContext(__raw_accountName, ctx); ctx.assignOrDefer(instance, "accountName" , __result);}}{const __raw_sector = obj["sector" ]as Sector; {const __result = sectorDeserializeWithContext(__raw_sector, ctx); ctx.assignOrDefer(instance, "sector" , __result);}}{const __raw_memo = obj["memo" ]as string | null; instance.memo = __raw_memo; }{const __raw_phones = obj["phones" ]as PhoneNumber[]; if(Array.isArray(__raw_phones)){instance.phones = __raw_phones as PhoneNumber[];}}{const __raw_email = obj["email" ]as Email; {const __result = emailDeserializeWithContext(__raw_email, ctx); ctx.assignOrDefer(instance, "email" , __result);}}{const __raw_leadSource = obj["leadSource" ]as string; 
                if (__raw_leadSource.length === 0) {
                    errors.push({ field: "leadSource", message: "must not be empty" });
                }
 instance.leadSource = __raw_leadSource; }{const __raw_colors = obj["colors" ]as Colors; {const __result = colorsDeserializeWithContext(__raw_colors, ctx); ctx.assignOrDefer(instance, "colors" , __result);}}{const __raw_needsReview = obj["needsReview" ]as boolean; instance.needsReview = __raw_needsReview; }{const __raw_hasAlert = obj["hasAlert" ]as boolean; instance.hasAlert = __raw_hasAlert; }{const __raw_accountType = obj["accountType" ]as string; 
                if (__raw_accountType.length === 0) {
                    errors.push({ field: "accountType", message: "must not be empty" });
                }
 instance.accountType = __raw_accountType; }{const __raw_subtype = obj["subtype" ]as string; 
                if (__raw_subtype.length === 0) {
                    errors.push({ field: "subtype", message: "must not be empty" });
                }
 instance.subtype = __raw_subtype; }{const __raw_isTaxExempt = obj["isTaxExempt" ]as boolean; instance.isTaxExempt = __raw_isTaxExempt; }{const __raw_paymentTerms = obj["paymentTerms" ]as string; 
                if (__raw_paymentTerms.length === 0) {
                    errors.push({ field: "paymentTerms", message: "must not be empty" });
                }
 instance.paymentTerms = __raw_paymentTerms; }{const __raw_tags = obj["tags" ]as string[]; if(Array.isArray(__raw_tags)){instance.tags = __raw_tags as string[];}}{const __raw_dateAdded = obj["dateAdded" ]as string; instance.dateAdded = __raw_dateAdded; }if(errors.length>0){throw new __mf_DeserializeError(errors);}return instance as Account;}export function accountValidateField<K extends keyof Account>(_field: K, _value: Account[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(_field){case "leadSource" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "leadSource", message: "must not be empty" });
                }
 break;}case "accountType" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "accountType", message: "must not be empty" });
                }
 break;}case "subtype" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "subtype", message: "must not be empty" });
                }
 break;}case "paymentTerms" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "paymentTerms", message: "must not be empty" });
                }
 break;}}return errors; }export function accountValidateFields(_partial: Partial<Account>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("leadSource" in _partial && _partial.leadSource!== undefined){const __val = _partial.leadSource as string; 
                if (__val.length === 0) {
                    errors.push({ field: "leadSource", message: "must not be empty" });
                }
}if("accountType" in _partial && _partial.accountType!== undefined){const __val = _partial.accountType as string; 
                if (__val.length === 0) {
                    errors.push({ field: "accountType", message: "must not be empty" });
                }
}if("subtype" in _partial && _partial.subtype!== undefined){const __val = _partial.subtype as string; 
                if (__val.length === 0) {
                    errors.push({ field: "subtype", message: "must not be empty" });
                }
}if("paymentTerms" in _partial && _partial.paymentTerms!== undefined){const __val = _partial.paymentTerms as string; 
                if (__val.length === 0) {
                    errors.push({ field: "paymentTerms", message: "must not be empty" });
                }
}return errors; }export function accountHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "id" in o && "taxRate" in o && "site" in o && "salesRep" in o && "orders" in o && "activity" in o && "customFields" in o && "accountName" in o && "sector" in o && "memo" in o && "phones" in o && "email" in o && "leadSource" in o && "colors" in o && "needsReview" in o && "hasAlert" in o && "accountType" in o && "subtype" in o && "isTaxExempt" in o && "paymentTerms" in o && "tags" in o && "dateAdded" in o;}export function accountIs(obj: unknown): obj is Account {if(!accountHasShape(obj)){return false;}const result = accountDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type AccountErrors = {_errors: __gf_Option<Array<string>>; id: __gf_Option<Array<string>>; taxRate: __gf_Option<Array<string>>; site: __gf_Option<Array<string>>; salesRep: __gf_Option<Array<string>>; orders: __gf_Option<Array<string>>; activity: __gf_Option<Array<string>>; customFields: __gf_Option<Array<string>>; accountName: __gf_Option<Array<string>>; sector: __gf_Option<Array<string>>; memo: __gf_Option<Array<string>>; phones: __gf_Option<Array<string>>; email: __gf_Option<Array<string>>; leadSource: __gf_Option<Array<string>>; colors: __gf_Option<Array<string>>; needsReview: __gf_Option<Array<string>>; hasAlert: __gf_Option<Array<string>>; accountType: __gf_Option<Array<string>>; subtype: __gf_Option<Array<string>>; isTaxExempt: __gf_Option<Array<string>>; paymentTerms: __gf_Option<Array<string>>; tags: __gf_Option<Array<string>>; dateAdded: __gf_Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type AccountTainted = {id: __gf_Option<boolean>; taxRate: __gf_Option<boolean>; site: __gf_Option<boolean>; salesRep: __gf_Option<boolean>; orders: __gf_Option<boolean>; activity: __gf_Option<boolean>; customFields: __gf_Option<boolean>; accountName: __gf_Option<boolean>; sector: __gf_Option<boolean>; memo: __gf_Option<boolean>; phones: __gf_Option<boolean>; email: __gf_Option<boolean>; leadSource: __gf_Option<boolean>; colors: __gf_Option<boolean>; needsReview: __gf_Option<boolean>; hasAlert: __gf_Option<boolean>; accountType: __gf_Option<boolean>; subtype: __gf_Option<boolean>; isTaxExempt: __gf_Option<boolean>; paymentTerms: __gf_Option<boolean>; tags: __gf_Option<boolean>; dateAdded: __gf_Option<boolean>; }; /** Type-safe field controllers for this form */export interface AccountFieldControllers {readonly id: FieldController<string>; readonly taxRate: FieldController<string | TaxRate>; readonly site: FieldController<string | Site>; readonly salesRep: FieldController<Represents[] | null>; readonly orders: ArrayFieldController<Ordered>; readonly activity: ArrayFieldController<Did>; readonly customFields: ArrayFieldController<[string, string]>; readonly accountName: FieldController<AccountName>; readonly sector: FieldController<Sector>; readonly memo: FieldController<string | null>; readonly phones: ArrayFieldController<PhoneNumber>; readonly email: FieldController<Email>; readonly leadSource: FieldController<string>; readonly colors: FieldController<Colors>; readonly needsReview: FieldController<boolean>; readonly hasAlert: FieldController<boolean>; readonly accountType: FieldController<string>; readonly subtype: FieldController<string>; readonly isTaxExempt: FieldController<boolean>; readonly paymentTerms: FieldController<string>; readonly tags: ArrayFieldController<string>; readonly dateAdded: FieldController<string>; }/** Gigaform instance containing reactive state and field controllers */export interface AccountGigaform {readonly data: Account; readonly errors: AccountErrors; readonly tainted: AccountTainted; readonly fields: AccountFieldControllers; validate(): Exit<Account, Array<{field: string; message: string}>>; reset(overrides?: Partial<Account>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function accountCreateForm(overrides?: Partial<Account>): AccountGigaform {let data = $state({...accountDefaultValue(),...overrides}); let errors = $state<AccountErrors>({_errors: optionNone(), id: optionNone(), taxRate: optionNone(), site: optionNone(), salesRep: optionNone(), orders: optionNone(), activity: optionNone(), customFields: optionNone(), accountName: optionNone(), sector: optionNone(), memo: optionNone(), phones: optionNone(), email: optionNone(), leadSource: optionNone(), colors: optionNone(), needsReview: optionNone(), hasAlert: optionNone(), accountType: optionNone(), subtype: optionNone(), isTaxExempt: optionNone(), paymentTerms: optionNone(), tags: optionNone(), dateAdded: optionNone(), }); let tainted = $state<AccountTainted>({id: optionNone(), taxRate: optionNone(), site: optionNone(), salesRep: optionNone(), orders: optionNone(), activity: optionNone(), customFields: optionNone(), accountName: optionNone(), sector: optionNone(), memo: optionNone(), phones: optionNone(), email: optionNone(), leadSource: optionNone(), colors: optionNone(), needsReview: optionNone(), hasAlert: optionNone(), accountType: optionNone(), subtype: optionNone(), isTaxExempt: optionNone(), paymentTerms: optionNone(), tags: optionNone(), dateAdded: optionNone(), }); const fields: AccountFieldControllers = {id: {path: ["id" ]as const, name: "id" , constraints: { required: true }, get: ()=>data.id, set: (value: string)=>{data.id = value;}, transform: (value: string): string =>value,getError: ()=>errors.id, setError: (value: __gf_Option<Array<string>>)=>{errors.id = value;}, getTainted: ()=>tainted.id, setTainted: (value: __gf_Option<boolean>)=>{tainted.id = value;}, validate: (): Array<string>=>{const fieldErrors = accountValidateField("id", data.id); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},taxRate: {path: ["taxRate" ]as const, name: "taxRate" , constraints: { required: true }, label: "Tax Rate" , get: ()=>data.taxRate, set: (value: string | TaxRate)=>{data.taxRate = value;}, transform: (value: string | TaxRate): string | TaxRate =>value,getError: ()=>errors.taxRate, setError: (value: __gf_Option<Array<string>>)=>{errors.taxRate = value;}, getTainted: ()=>tainted.taxRate, setTainted: (value: __gf_Option<boolean>)=>{tainted.taxRate = value;}, validate: (): Array<string>=>{const fieldErrors = accountValidateField("taxRate", data.taxRate); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},site: {path: ["site" ]as const, name: "site" , constraints: { required: true }, label: "Site" , get: ()=>data.site, set: (value: string | Site)=>{data.site = value;}, transform: (value: string | Site): string | Site =>value,getError: ()=>errors.site, setError: (value: __gf_Option<Array<string>>)=>{errors.site = value;}, getTainted: ()=>tainted.site, setTainted: (value: __gf_Option<boolean>)=>{tainted.site = value;}, validate: (): Array<string>=>{const fieldErrors = accountValidateField("site", data.site); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},salesRep: {path: ["salesRep" ]as const, name: "salesRep" , constraints: { required: true }, label: "Sales Rep" , get: ()=>data.salesRep, set: (value: Represents[] | null)=>{data.salesRep = value;}, transform: (value: Represents[] | null): Represents[] | null =>value,getError: ()=>errors.salesRep, setError: (value: __gf_Option<Array<string>>)=>{errors.salesRep = value;}, getTainted: ()=>tainted.salesRep, setTainted: (value: __gf_Option<boolean>)=>{tainted.salesRep = value;}, validate: (): Array<string>=>{const fieldErrors = accountValidateField("salesRep", data.salesRep); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},orders: {path: ["orders" ]as const, name: "orders" , constraints: { required: true }, get: ()=>data.orders, set: (value: Ordered[])=>{data.orders = value;}, transform: (value: Ordered[]): Ordered[] =>value,getError: ()=>errors.orders, setError: (value: __gf_Option<Array<string>>)=>{errors.orders = value;}, getTainted: ()=>tainted.orders, setTainted: (value: __gf_Option<boolean>)=>{tainted.orders = value;}, validate: (): Array<string>=>{const fieldErrors = accountValidateField("orders", data.orders); return fieldErrors.map((e: {field: string; message: string})=>e.message);},at: (index: number)=>({path: ["orders" , index]as const, name: `orders.${index}` , constraints: {required: true}, get: ()=>data.orders[index]!, set: (value: Ordered)=>{data.orders[index]= value;}, transform: (value: Ordered): Ordered =>value, getError: ()=>errors.orders, setError: (value: __gf_Option<Array<string>>)=>{errors.orders = value;}, getTainted: ()=>tainted.orders, setTainted: (value: __gf_Option<boolean>)=>{tainted.orders = value;}, validate: (): Array<string>=>[],}), push: (item: Ordered)=>{data.orders.push(item);}, remove: (index: number)=>{data.orders.splice(index, 1);}, swap: (a: number, b: number)=>{const tmp = data.orders[a]!; data.orders[a]= data.orders[b]!; data.orders[b]= tmp;},},activity: {path: ["activity" ]as const, name: "activity" , constraints: { required: true }, get: ()=>data.activity, set: (value: Did[])=>{data.activity = value;}, transform: (value: Did[]): Did[] =>value,getError: ()=>errors.activity, setError: (value: __gf_Option<Array<string>>)=>{errors.activity = value;}, getTainted: ()=>tainted.activity, setTainted: (value: __gf_Option<boolean>)=>{tainted.activity = value;}, validate: (): Array<string>=>{const fieldErrors = accountValidateField("activity", data.activity); return fieldErrors.map((e: {field: string; message: string})=>e.message);},at: (index: number)=>({path: ["activity" , index]as const, name: `activity.${index}` , constraints: {required: true}, get: ()=>data.activity[index]!, set: (value: Did)=>{data.activity[index]= value;}, transform: (value: Did): Did =>value, getError: ()=>errors.activity, setError: (value: __gf_Option<Array<string>>)=>{errors.activity = value;}, getTainted: ()=>tainted.activity, setTainted: (value: __gf_Option<boolean>)=>{tainted.activity = value;}, validate: (): Array<string>=>[],}), push: (item: Did)=>{data.activity.push(item);}, remove: (index: number)=>{data.activity.splice(index, 1);}, swap: (a: number, b: number)=>{const tmp = data.activity[a]!; data.activity[a]= data.activity[b]!; data.activity[b]= tmp;},},customFields: {path: ["customFields" ]as const, name: "customFields" , constraints: { required: true }, get: ()=>data.customFields, set: (value: [string, string][])=>{data.customFields = value;}, transform: (value: [string, string][]): [string, string][] =>value,getError: ()=>errors.customFields, setError: (value: __gf_Option<Array<string>>)=>{errors.customFields = value;}, getTainted: ()=>tainted.customFields, setTainted: (value: __gf_Option<boolean>)=>{tainted.customFields = value;}, validate: (): Array<string>=>{const fieldErrors = accountValidateField("customFields", data.customFields); return fieldErrors.map((e: {field: string; message: string})=>e.message);},at: (index: number)=>({path: ["customFields" , index]as const, name: `customFields.${index}` , constraints: {required: true}, get: ()=>data.customFields[index]!, set: (value: [string, string])=>{data.customFields[index]= value;}, transform: (value: [string, string]): [string, string] =>value, getError: ()=>errors.customFields, setError: (value: __gf_Option<Array<string>>)=>{errors.customFields = value;}, getTainted: ()=>tainted.customFields, setTainted: (value: __gf_Option<boolean>)=>{tainted.customFields = value;}, validate: (): Array<string>=>[],}), push: (item: [string, string])=>{data.customFields.push(item);}, remove: (index: number)=>{data.customFields.splice(index, 1);}, swap: (a: number, b: number)=>{const tmp = data.customFields[a]!; data.customFields[a]= data.customFields[b]!; data.customFields[b]= tmp;},},accountName: {path: ["accountName" ]as const, name: "accountName" , constraints: { required: true }, get: ()=>data.accountName, set: (value: AccountName)=>{data.accountName = value;}, transform: (value: AccountName): AccountName =>value,getError: ()=>errors.accountName, setError: (value: __gf_Option<Array<string>>)=>{errors.accountName = value;}, getTainted: ()=>tainted.accountName, setTainted: (value: __gf_Option<boolean>)=>{tainted.accountName = value;}, validate: (): Array<string>=>{const fieldErrors = accountValidateField("accountName", data.accountName); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},sector: {path: ["sector" ]as const, name: "sector" , constraints: { required: true }, label: "Sector" , get: ()=>data.sector, set: (value: Sector)=>{data.sector = value;}, transform: (value: Sector): Sector =>value,getError: ()=>errors.sector, setError: (value: __gf_Option<Array<string>>)=>{errors.sector = value;}, getTainted: ()=>tainted.sector, setTainted: (value: __gf_Option<boolean>)=>{tainted.sector = value;}, validate: (): Array<string>=>{const fieldErrors = accountValidateField("sector", data.sector); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},memo: {path: ["memo" ]as const, name: "memo" , constraints: { required: true }, label: "Memo" , get: ()=>data.memo, set: (value: string | null)=>{data.memo = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.memo, setError: (value: __gf_Option<Array<string>>)=>{errors.memo = value;}, getTainted: ()=>tainted.memo, setTainted: (value: __gf_Option<boolean>)=>{tainted.memo = value;}, validate: (): Array<string>=>{const fieldErrors = accountValidateField("memo", data.memo); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},phones: {path: ["phones" ]as const, name: "phones" , constraints: { required: true }, get: ()=>data.phones, set: (value: PhoneNumber[])=>{data.phones = value;}, transform: (value: PhoneNumber[]): PhoneNumber[] =>value,getError: ()=>errors.phones, setError: (value: __gf_Option<Array<string>>)=>{errors.phones = value;}, getTainted: ()=>tainted.phones, setTainted: (value: __gf_Option<boolean>)=>{tainted.phones = value;}, validate: (): Array<string>=>{const fieldErrors = accountValidateField("phones", data.phones); return fieldErrors.map((e: {field: string; message: string})=>e.message);},at: (index: number)=>({path: ["phones" , index]as const, name: `phones.${index}` , constraints: {required: true}, get: ()=>data.phones[index]!, set: (value: PhoneNumber)=>{data.phones[index]= value;}, transform: (value: PhoneNumber): PhoneNumber =>value, getError: ()=>errors.phones, setError: (value: __gf_Option<Array<string>>)=>{errors.phones = value;}, getTainted: ()=>tainted.phones, setTainted: (value: __gf_Option<boolean>)=>{tainted.phones = value;}, validate: (): Array<string>=>[],}), push: (item: PhoneNumber)=>{data.phones.push(item);}, remove: (index: number)=>{data.phones.splice(index, 1);}, swap: (a: number, b: number)=>{const tmp = data.phones[a]!; data.phones[a]= data.phones[b]!; data.phones[b]= tmp;},},email: {path: ["email" ]as const, name: "email" , constraints: { required: true }, label: "Email" , get: ()=>data.email, set: (value: Email)=>{data.email = value;}, transform: (value: Email): Email =>value,getError: ()=>errors.email, setError: (value: __gf_Option<Array<string>>)=>{errors.email = value;}, getTainted: ()=>tainted.email, setTainted: (value: __gf_Option<boolean>)=>{tainted.email = value;}, validate: (): Array<string>=>{const fieldErrors = accountValidateField("email", data.email); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},leadSource: {path: ["leadSource" ]as const, name: "leadSource" , constraints: { required: true }, label: "Lead Source" , get: ()=>data.leadSource, set: (value: string)=>{data.leadSource = value;}, transform: (value: string): string =>value,getError: ()=>errors.leadSource, setError: (value: __gf_Option<Array<string>>)=>{errors.leadSource = value;}, getTainted: ()=>tainted.leadSource, setTainted: (value: __gf_Option<boolean>)=>{tainted.leadSource = value;}, validate: (): Array<string>=>{const fieldErrors = accountValidateField("leadSource", data.leadSource); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},colors: {path: ["colors" ]as const, name: "colors" , constraints: { required: true }, get: ()=>data.colors, set: (value: Colors)=>{data.colors = value;}, transform: (value: Colors): Colors =>value,getError: ()=>errors.colors, setError: (value: __gf_Option<Array<string>>)=>{errors.colors = value;}, getTainted: ()=>tainted.colors, setTainted: (value: __gf_Option<boolean>)=>{tainted.colors = value;}, validate: (): Array<string>=>{const fieldErrors = accountValidateField("colors", data.colors); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},needsReview: {path: ["needsReview" ]as const, name: "needsReview" , constraints: { required: true }, label: "Needs Review" , get: ()=>data.needsReview, set: (value: boolean)=>{data.needsReview = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.needsReview, setError: (value: __gf_Option<Array<string>>)=>{errors.needsReview = value;}, getTainted: ()=>tainted.needsReview, setTainted: (value: __gf_Option<boolean>)=>{tainted.needsReview = value;}, validate: (): Array<string>=>{const fieldErrors = accountValidateField("needsReview", data.needsReview); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},hasAlert: {path: ["hasAlert" ]as const, name: "hasAlert" , constraints: { required: true }, label: "Has Alert" , get: ()=>data.hasAlert, set: (value: boolean)=>{data.hasAlert = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.hasAlert, setError: (value: __gf_Option<Array<string>>)=>{errors.hasAlert = value;}, getTainted: ()=>tainted.hasAlert, setTainted: (value: __gf_Option<boolean>)=>{tainted.hasAlert = value;}, validate: (): Array<string>=>{const fieldErrors = accountValidateField("hasAlert", data.hasAlert); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},accountType: {path: ["accountType" ]as const, name: "accountType" , constraints: { required: true }, label: "Account Type" , get: ()=>data.accountType, set: (value: string)=>{data.accountType = value;}, transform: (value: string): string =>value,getError: ()=>errors.accountType, setError: (value: __gf_Option<Array<string>>)=>{errors.accountType = value;}, getTainted: ()=>tainted.accountType, setTainted: (value: __gf_Option<boolean>)=>{tainted.accountType = value;}, validate: (): Array<string>=>{const fieldErrors = accountValidateField("accountType", data.accountType); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},subtype: {path: ["subtype" ]as const, name: "subtype" , constraints: { required: true }, label: "Subtype" , get: ()=>data.subtype, set: (value: string)=>{data.subtype = value;}, transform: (value: string): string =>value,getError: ()=>errors.subtype, setError: (value: __gf_Option<Array<string>>)=>{errors.subtype = value;}, getTainted: ()=>tainted.subtype, setTainted: (value: __gf_Option<boolean>)=>{tainted.subtype = value;}, validate: (): Array<string>=>{const fieldErrors = accountValidateField("subtype", data.subtype); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},isTaxExempt: {path: ["isTaxExempt" ]as const, name: "isTaxExempt" , constraints: { required: true }, label: "Tax Exempt" , get: ()=>data.isTaxExempt, set: (value: boolean)=>{data.isTaxExempt = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.isTaxExempt, setError: (value: __gf_Option<Array<string>>)=>{errors.isTaxExempt = value;}, getTainted: ()=>tainted.isTaxExempt, setTainted: (value: __gf_Option<boolean>)=>{tainted.isTaxExempt = value;}, validate: (): Array<string>=>{const fieldErrors = accountValidateField("isTaxExempt", data.isTaxExempt); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},paymentTerms: {path: ["paymentTerms" ]as const, name: "paymentTerms" , constraints: { required: true }, label: "Payment Terms" , get: ()=>data.paymentTerms, set: (value: string)=>{data.paymentTerms = value;}, transform: (value: string): string =>value,getError: ()=>errors.paymentTerms, setError: (value: __gf_Option<Array<string>>)=>{errors.paymentTerms = value;}, getTainted: ()=>tainted.paymentTerms, setTainted: (value: __gf_Option<boolean>)=>{tainted.paymentTerms = value;}, validate: (): Array<string>=>{const fieldErrors = accountValidateField("paymentTerms", data.paymentTerms); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},tags: {path: ["tags" ]as const, name: "tags" , constraints: { required: true }, label: "Tags" , get: ()=>data.tags, set: (value: string[])=>{data.tags = value;}, transform: (value: string[]): string[] =>value,getError: ()=>errors.tags, setError: (value: __gf_Option<Array<string>>)=>{errors.tags = value;}, getTainted: ()=>tainted.tags, setTainted: (value: __gf_Option<boolean>)=>{tainted.tags = value;}, validate: (): Array<string>=>{const fieldErrors = accountValidateField("tags", data.tags); return fieldErrors.map((e: {field: string; message: string})=>e.message);},at: (index: number)=>({path: ["tags" , index]as const, name: `tags.${index}` , constraints: {required: true}, get: ()=>data.tags[index]!, set: (value: string)=>{data.tags[index]= value;}, transform: (value: string): string =>value, getError: ()=>errors.tags, setError: (value: __gf_Option<Array<string>>)=>{errors.tags = value;}, getTainted: ()=>tainted.tags, setTainted: (value: __gf_Option<boolean>)=>{tainted.tags = value;}, validate: (): Array<string>=>[],}), push: (item: string)=>{data.tags.push(item);}, remove: (index: number)=>{data.tags.splice(index, 1);}, swap: (a: number, b: number)=>{const tmp = data.tags[a]!; data.tags[a]= data.tags[b]!; data.tags[b]= tmp;},},dateAdded: {path: ["dateAdded" ]as const, name: "dateAdded" , constraints: { required: true }, get: ()=>data.dateAdded, set: (value: string)=>{data.dateAdded = value;}, transform: (value: string): string =>value,getError: ()=>errors.dateAdded, setError: (value: __gf_Option<Array<string>>)=>{errors.dateAdded = value;}, getTainted: ()=>tainted.dateAdded, setTainted: (value: __gf_Option<boolean>)=>{tainted.dateAdded = value;}, validate: (): Array<string>=>{const fieldErrors = accountValidateField("dateAdded", data.dateAdded); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Exit<Account, Array<{field: string; message: string}>>{return toExit(accountDeserialize(data));}function reset(newOverrides?: Partial<Account>): void {data = {...accountDefaultValue(),...newOverrides}; errors = {_errors: optionNone(), id: optionNone(), taxRate: optionNone(), site: optionNone(), salesRep: optionNone(), orders: optionNone(), activity: optionNone(), customFields: optionNone(), accountName: optionNone(), sector: optionNone(), memo: optionNone(), phones: optionNone(), email: optionNone(), leadSource: optionNone(), colors: optionNone(), needsReview: optionNone(), hasAlert: optionNone(), accountType: optionNone(), subtype: optionNone(), isTaxExempt: optionNone(), paymentTerms: optionNone(), tags: optionNone(), dateAdded: optionNone(), }; tainted = {id: optionNone(), taxRate: optionNone(), site: optionNone(), salesRep: optionNone(), orders: optionNone(), activity: optionNone(), customFields: optionNone(), accountName: optionNone(), sector: optionNone(), memo: optionNone(), phones: optionNone(), email: optionNone(), leadSource: optionNone(), colors: optionNone(), needsReview: optionNone(), hasAlert: optionNone(), accountType: optionNone(), subtype: optionNone(), isTaxExempt: optionNone(), paymentTerms: optionNone(), tags: optionNone(), dateAdded: optionNone(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function accountFromFormData(formData: FormData): Exit<Account, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.id = formData.get("id" )?? "" ;obj.taxRate = formData.get("taxRate" )?? "" ;obj.site = formData.get("site" )?? "" ;obj.salesRep = formData.get("salesRep" )?? "" ;{const ordersItems: Array<Record<string, unknown>>= []; let idx = 0; while(formData.has("orders." + idx + "." )|| idx === 0){const hasAny = Array.from(formData.keys()).some(k =>k.startsWith("orders." + idx + "." )); if(!hasAny && idx>0)break; if(hasAny){const item: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("orders." + idx + "." )){const fieldName = key.slice("orders." .length + String(idx).length + 1); item[fieldName]= value;}}ordersItems.push(item);}idx ++; if(idx>1000)break;}obj.orders = ordersItems;}{const activityItems: Array<Record<string, unknown>>= []; let idx = 0; while(formData.has("activity." + idx + "." )|| idx === 0){const hasAny = Array.from(formData.keys()).some(k =>k.startsWith("activity." + idx + "." )); if(!hasAny && idx>0)break; if(hasAny){const item: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("activity." + idx + "." )){const fieldName = key.slice("activity." .length + String(idx).length + 1); item[fieldName]= value;}}activityItems.push(item);}idx ++; if(idx>1000)break;}obj.activity = activityItems;}{const customFieldsItems: Array<Record<string, unknown>>= []; let idx = 0; while(formData.has("customFields." + idx + "." )|| idx === 0){const hasAny = Array.from(formData.keys()).some(k =>k.startsWith("customFields." + idx + "." )); if(!hasAny && idx>0)break; if(hasAny){const item: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("customFields." + idx + "." )){const fieldName = key.slice("customFields." .length + String(idx).length + 1); item[fieldName]= value;}}customFieldsItems.push(item);}idx ++; if(idx>1000)break;}obj.customFields = customFieldsItems;}{const accountNameObj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("accountName." )){const fieldName = key.slice("accountName." .length); const parts = fieldName.split("." ); let current = accountNameObj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.accountName = accountNameObj;}{const sectorObj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("sector." )){const fieldName = key.slice("sector." .length); const parts = fieldName.split("." ); let current = sectorObj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.sector = sectorObj;}obj.memo = formData.get("memo" )?? "" ;{const phonesItems: Array<Record<string, unknown>>= []; let idx = 0; while(formData.has("phones." + idx + "." )|| idx === 0){const hasAny = Array.from(formData.keys()).some(k =>k.startsWith("phones." + idx + "." )); if(!hasAny && idx>0)break; if(hasAny){const item: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("phones." + idx + "." )){const fieldName = key.slice("phones." .length + String(idx).length + 1); item[fieldName]= value;}}phonesItems.push(item);}idx ++; if(idx>1000)break;}obj.phones = phonesItems;}{const emailObj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("email." )){const fieldName = key.slice("email." .length); const parts = fieldName.split("." ); let current = emailObj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.email = emailObj;}obj.leadSource = formData.get("leadSource" )?? "" ;{const colorsObj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("colors." )){const fieldName = key.slice("colors." .length); const parts = fieldName.split("." ); let current = colorsObj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.colors = colorsObj;}{const needsReviewVal = formData.get("needsReview" ); obj.needsReview = needsReviewVal === "true" || needsReviewVal === "on" || needsReviewVal === "1" ;}{const hasAlertVal = formData.get("hasAlert" ); obj.hasAlert = hasAlertVal === "true" || hasAlertVal === "on" || hasAlertVal === "1" ;}obj.accountType = formData.get("accountType" )?? "" ;obj.subtype = formData.get("subtype" )?? "" ;{const isTaxExemptVal = formData.get("isTaxExempt" ); obj.isTaxExempt = isTaxExemptVal === "true" || isTaxExemptVal === "on" || isTaxExemptVal === "1" ;}obj.paymentTerms = formData.get("paymentTerms" )?? "" ;obj.tags = formData.getAll("tags" )as Array<string>;obj.dateAdded = formData.get("dateAdded" )?? "" ;return toExit(accountDeserialize(obj));}

export const Account = {
  defaultValue: accountDefaultValue,
  serialize: accountSerialize,
  serializeWithContext: accountSerializeWithContext,
  deserialize: accountDeserialize,
  deserializeWithContext: accountDeserializeWithContext,
  validateFields: accountValidateFields,
  hasShape: accountHasShape,
  is: accountIs,
  createForm: accountCreateForm,
  fromFormData: accountFromFormData
} as const;


export interface Edited {
    
    fieldName: string;
    oldValue: string | null;
    newValue: string | null;
}

export function editedDefaultValue(): Edited {return {fieldName: "",
                            oldValue: null,
                            newValue: null, }as Edited;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function editedSerialize(value: Edited): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(editedSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function editedSerializeWithContext(value: Edited, ctx: __mf_SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Edited" , __id,}; result["fieldName" ]= value.fieldName; result["oldValue" ]= value.oldValue; result["newValue" ]= value.newValue; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function editedDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: Edited } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = editedDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Edited.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function editedDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Edited | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new __mf_DeserializeError([{field: "_root" , message: "Edited.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("fieldName" in obj)){errors.push({field: "fieldName" , message: "missing required field" });}if(!("oldValue" in obj)){errors.push({field: "oldValue" , message: "missing required field" });}if(!("newValue" in obj)){errors.push({field: "newValue" , message: "missing required field" });}if(errors.length>0){throw new __mf_DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_fieldName = obj["fieldName" ]as string; 
                if (__raw_fieldName.length === 0) {
                    errors.push({ field: "fieldName", message: "must not be empty" });
                }
 instance.fieldName = __raw_fieldName; }{const __raw_oldValue = obj["oldValue" ]as string | null; instance.oldValue = __raw_oldValue; }{const __raw_newValue = obj["newValue" ]as string | null; instance.newValue = __raw_newValue; }if(errors.length>0){throw new __mf_DeserializeError(errors);}return instance as Edited;}export function editedValidateField<K extends keyof Edited>(_field: K, _value: Edited[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(_field){case "fieldName" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "fieldName", message: "must not be empty" });
                }
 break;}}return errors; }export function editedValidateFields(_partial: Partial<Edited>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("fieldName" in _partial && _partial.fieldName!== undefined){const __val = _partial.fieldName as string; 
                if (__val.length === 0) {
                    errors.push({ field: "fieldName", message: "must not be empty" });
                }
}return errors; }export function editedHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "fieldName" in o && "oldValue" in o && "newValue" in o;}export function editedIs(obj: unknown): obj is Edited {if(!editedHasShape(obj)){return false;}const result = editedDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type EditedErrors = {_errors: __gf_Option<Array<string>>; fieldName: __gf_Option<Array<string>>; oldValue: __gf_Option<Array<string>>; newValue: __gf_Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type EditedTainted = {fieldName: __gf_Option<boolean>; oldValue: __gf_Option<boolean>; newValue: __gf_Option<boolean>; }; /** Type-safe field controllers for this form */export interface EditedFieldControllers {readonly fieldName: FieldController<string>; readonly oldValue: FieldController<string | null>; readonly newValue: FieldController<string | null>; }/** Gigaform instance containing reactive state and field controllers */export interface EditedGigaform {readonly data: Edited; readonly errors: EditedErrors; readonly tainted: EditedTainted; readonly fields: EditedFieldControllers; validate(): Exit<Edited, Array<{field: string; message: string}>>; reset(overrides?: Partial<Edited>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function editedCreateForm(overrides?: Partial<Edited>): EditedGigaform {let data = $state({...editedDefaultValue(),...overrides}); let errors = $state<EditedErrors>({_errors: optionNone(), fieldName: optionNone(), oldValue: optionNone(), newValue: optionNone(), }); let tainted = $state<EditedTainted>({fieldName: optionNone(), oldValue: optionNone(), newValue: optionNone(), }); const fields: EditedFieldControllers = {fieldName: {path: ["fieldName" ]as const, name: "fieldName" , constraints: { required: true }, get: ()=>data.fieldName, set: (value: string)=>{data.fieldName = value;}, transform: (value: string): string =>value,getError: ()=>errors.fieldName, setError: (value: __gf_Option<Array<string>>)=>{errors.fieldName = value;}, getTainted: ()=>tainted.fieldName, setTainted: (value: __gf_Option<boolean>)=>{tainted.fieldName = value;}, validate: (): Array<string>=>{const fieldErrors = editedValidateField("fieldName", data.fieldName); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},oldValue: {path: ["oldValue" ]as const, name: "oldValue" , constraints: { required: true }, get: ()=>data.oldValue, set: (value: string | null)=>{data.oldValue = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.oldValue, setError: (value: __gf_Option<Array<string>>)=>{errors.oldValue = value;}, getTainted: ()=>tainted.oldValue, setTainted: (value: __gf_Option<boolean>)=>{tainted.oldValue = value;}, validate: (): Array<string>=>{const fieldErrors = editedValidateField("oldValue", data.oldValue); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},newValue: {path: ["newValue" ]as const, name: "newValue" , constraints: { required: true }, get: ()=>data.newValue, set: (value: string | null)=>{data.newValue = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.newValue, setError: (value: __gf_Option<Array<string>>)=>{errors.newValue = value;}, getTainted: ()=>tainted.newValue, setTainted: (value: __gf_Option<boolean>)=>{tainted.newValue = value;}, validate: (): Array<string>=>{const fieldErrors = editedValidateField("newValue", data.newValue); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Exit<Edited, Array<{field: string; message: string}>>{return toExit(editedDeserialize(data));}function reset(newOverrides?: Partial<Edited>): void {data = {...editedDefaultValue(),...newOverrides}; errors = {_errors: optionNone(), fieldName: optionNone(), oldValue: optionNone(), newValue: optionNone(), }; tainted = {fieldName: optionNone(), oldValue: optionNone(), newValue: optionNone(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function editedFromFormData(formData: FormData): Exit<Edited, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.fieldName = formData.get("fieldName" )?? "" ;obj.oldValue = formData.get("oldValue" )?? "" ;obj.newValue = formData.get("newValue" )?? "" ;return toExit(editedDeserialize(obj));}

export const Edited = {
  defaultValue: editedDefaultValue,
  serialize: editedSerialize,
  serializeWithContext: editedSerializeWithContext,
  deserialize: editedDeserialize,
  deserializeWithContext: editedDeserializeWithContext,
  validateFields: editedValidateFields,
  hasShape: editedHasShape,
  is: editedIs,
  createForm: editedCreateForm,
  fromFormData: editedFromFormData
} as const;


export interface Order {
    
    id: string;
    
    
    account: string | Account;
    
    
    stage: OrderStage;
    
    number: number;
    
    payments: (string | Payment)[];
    
    
    opportunity: string;
    
    
    reference: string;
    
    
    leadSource: string;
    
    
    salesRep: string | Employee;
    
    
    group: string;
    
    
    subgroup: string;
    
    isPosted: boolean;
    
    needsReview: boolean;
    
    
    actionItem: string;
    
    upsale: number;
    
    dateCreated: string;
    
    
    appointment: string | Appointment;
    
    lastTechs: (string | Employee)[];
    
    package: (string | Package)[] | null;
    
    promotion: (string | Promotion)[] | null;
    
    balance: number;
    
    due: string;
    
    total: number;
    
    
    site: string | Site;
    
    billedItems: BilledItem[];
    
    
    memo: string;
    
    discount: number;
    
    tip: number;
    
    commissions: number[];
}

export function orderDefaultValue(): Order {return {id: "",
                            account: "",
                            stage: "Estimate",
                            number: 0,
                            payments: [],
                            opportunity: "",
                            reference: "",
                            leadSource: "",
                            salesRep: "",
                            group: "",
                            subgroup: "",
                            isPosted: false,
                            needsReview: false,
                            actionItem: "",
                            upsale: 0,
                            dateCreated: "",
                            appointment: "",
                            lastTechs: [],
                            package: null,
                            promotion: null,
                            balance: 0,
                            due: "",
                            total: 0,
                            site: "",
                            billedItems: [],
                            memo: "",
                            discount: 0,
                            tip: 0,
                            commissions: [], }as Order;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function orderSerialize(value: Order): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(orderSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function orderSerializeWithContext(value: Order, ctx: __mf_SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Order" , __id,}; result["id" ]= value.id; result["account" ]= value.account; result["stage" ]= orderStageSerializeWithContext(value.stage, ctx); result["number" ]= value.number; result["payments" ]= value.payments; result["opportunity" ]= value.opportunity; result["reference" ]= value.reference; result["leadSource" ]= value.leadSource; result["salesRep" ]= value.salesRep; result["group" ]= value.group; result["subgroup" ]= value.subgroup; result["isPosted" ]= value.isPosted; result["needsReview" ]= value.needsReview; result["actionItem" ]= value.actionItem; result["upsale" ]= value.upsale; result["dateCreated" ]= value.dateCreated; result["appointment" ]= value.appointment; result["lastTechs" ]= value.lastTechs; if(value.package!== null){result["package" ]= value.package; }else {result["package" ]= null;}if(value.promotion!== null){result["promotion" ]= value.promotion; }else {result["promotion" ]= null;}result["balance" ]= value.balance; result["due" ]= value.due; result["total" ]= value.total; result["site" ]= value.site; result["billedItems" ]= value.billedItems.map((item)=>billedItemSerializeWithContext(item, ctx)); result["memo" ]= value.memo; result["discount" ]= value.discount; result["tip" ]= value.tip; result["commissions" ]= value.commissions; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function orderDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: Order } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = orderDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Order.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function orderDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Order | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new __mf_DeserializeError([{field: "_root" , message: "Order.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("id" in obj)){errors.push({field: "id" , message: "missing required field" });}if(!("account" in obj)){errors.push({field: "account" , message: "missing required field" });}if(!("stage" in obj)){errors.push({field: "stage" , message: "missing required field" });}if(!("number" in obj)){errors.push({field: "number" , message: "missing required field" });}if(!("payments" in obj)){errors.push({field: "payments" , message: "missing required field" });}if(!("opportunity" in obj)){errors.push({field: "opportunity" , message: "missing required field" });}if(!("reference" in obj)){errors.push({field: "reference" , message: "missing required field" });}if(!("leadSource" in obj)){errors.push({field: "leadSource" , message: "missing required field" });}if(!("salesRep" in obj)){errors.push({field: "salesRep" , message: "missing required field" });}if(!("group" in obj)){errors.push({field: "group" , message: "missing required field" });}if(!("subgroup" in obj)){errors.push({field: "subgroup" , message: "missing required field" });}if(!("isPosted" in obj)){errors.push({field: "isPosted" , message: "missing required field" });}if(!("needsReview" in obj)){errors.push({field: "needsReview" , message: "missing required field" });}if(!("actionItem" in obj)){errors.push({field: "actionItem" , message: "missing required field" });}if(!("upsale" in obj)){errors.push({field: "upsale" , message: "missing required field" });}if(!("dateCreated" in obj)){errors.push({field: "dateCreated" , message: "missing required field" });}if(!("appointment" in obj)){errors.push({field: "appointment" , message: "missing required field" });}if(!("lastTechs" in obj)){errors.push({field: "lastTechs" , message: "missing required field" });}if(!("package" in obj)){errors.push({field: "package" , message: "missing required field" });}if(!("promotion" in obj)){errors.push({field: "promotion" , message: "missing required field" });}if(!("balance" in obj)){errors.push({field: "balance" , message: "missing required field" });}if(!("due" in obj)){errors.push({field: "due" , message: "missing required field" });}if(!("total" in obj)){errors.push({field: "total" , message: "missing required field" });}if(!("site" in obj)){errors.push({field: "site" , message: "missing required field" });}if(!("billedItems" in obj)){errors.push({field: "billedItems" , message: "missing required field" });}if(!("memo" in obj)){errors.push({field: "memo" , message: "missing required field" });}if(!("discount" in obj)){errors.push({field: "discount" , message: "missing required field" });}if(!("tip" in obj)){errors.push({field: "tip" , message: "missing required field" });}if(!("commissions" in obj)){errors.push({field: "commissions" , message: "missing required field" });}if(errors.length>0){throw new __mf_DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_id = obj["id" ]as string; instance.id = __raw_id; }{const __raw_account = obj["account" ]as string | Account; instance.account = __raw_account; }{const __raw_stage = obj["stage" ]as OrderStage; {const __result = orderStageDeserializeWithContext(__raw_stage, ctx); ctx.assignOrDefer(instance, "stage" , __result);}}{const __raw_number = obj["number" ]as number; instance.number = __raw_number; }{const __raw_payments = obj["payments" ]as (string | Payment)[]; if(Array.isArray(__raw_payments)){instance.payments = __raw_payments as (string | Payment)[];}}{const __raw_opportunity = obj["opportunity" ]as string; 
                if (__raw_opportunity.length === 0) {
                    errors.push({ field: "opportunity", message: "must not be empty" });
                }
 instance.opportunity = __raw_opportunity; }{const __raw_reference = obj["reference" ]as string; 
                if (__raw_reference.length === 0) {
                    errors.push({ field: "reference", message: "must not be empty" });
                }
 instance.reference = __raw_reference; }{const __raw_leadSource = obj["leadSource" ]as string; 
                if (__raw_leadSource.length === 0) {
                    errors.push({ field: "leadSource", message: "must not be empty" });
                }
 instance.leadSource = __raw_leadSource; }{const __raw_salesRep = obj["salesRep" ]as string | Employee; instance.salesRep = __raw_salesRep; }{const __raw_group = obj["group" ]as string; 
                if (__raw_group.length === 0) {
                    errors.push({ field: "group", message: "must not be empty" });
                }
 instance.group = __raw_group; }{const __raw_subgroup = obj["subgroup" ]as string; 
                if (__raw_subgroup.length === 0) {
                    errors.push({ field: "subgroup", message: "must not be empty" });
                }
 instance.subgroup = __raw_subgroup; }{const __raw_isPosted = obj["isPosted" ]as boolean; instance.isPosted = __raw_isPosted; }{const __raw_needsReview = obj["needsReview" ]as boolean; instance.needsReview = __raw_needsReview; }{const __raw_actionItem = obj["actionItem" ]as string; 
                if (__raw_actionItem.length === 0) {
                    errors.push({ field: "actionItem", message: "must not be empty" });
                }
 instance.actionItem = __raw_actionItem; }{const __raw_upsale = obj["upsale" ]as number; instance.upsale = __raw_upsale; }{const __raw_dateCreated = obj["dateCreated" ]as string; instance.dateCreated = __raw_dateCreated; }{const __raw_appointment = obj["appointment" ]as string | Appointment; instance.appointment = __raw_appointment; }{const __raw_lastTechs = obj["lastTechs" ]as (string | Employee)[]; if(Array.isArray(__raw_lastTechs)){instance.lastTechs = __raw_lastTechs as (string | Employee)[];}}{const __raw_package = obj["package" ]as (string | Package)[] | null; if(__raw_package === null){instance.package = null;}else {instance.package = __raw_package; }}{const __raw_promotion = obj["promotion" ]as (string | Promotion)[] | null; if(__raw_promotion === null){instance.promotion = null;}else {instance.promotion = __raw_promotion; }}{const __raw_balance = obj["balance" ]as number; instance.balance = __raw_balance; }{const __raw_due = obj["due" ]as string; instance.due = __raw_due; }{const __raw_total = obj["total" ]as number; instance.total = __raw_total; }{const __raw_site = obj["site" ]as string | Site; instance.site = __raw_site; }{const __raw_billedItems = obj["billedItems" ]as BilledItem[]; if(Array.isArray(__raw_billedItems)){instance.billedItems = __raw_billedItems as BilledItem[];}}{const __raw_memo = obj["memo" ]as string; 
                if (__raw_memo.length === 0) {
                    errors.push({ field: "memo", message: "must not be empty" });
                }
 instance.memo = __raw_memo; }{const __raw_discount = obj["discount" ]as number; instance.discount = __raw_discount; }{const __raw_tip = obj["tip" ]as number; instance.tip = __raw_tip; }{const __raw_commissions = obj["commissions" ]as number[]; if(Array.isArray(__raw_commissions)){instance.commissions = __raw_commissions as number[];}}if(errors.length>0){throw new __mf_DeserializeError(errors);}return instance as Order;}export function orderValidateField<K extends keyof Order>(_field: K, _value: Order[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(_field){case "opportunity" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "opportunity", message: "must not be empty" });
                }
 break;}case "reference" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "reference", message: "must not be empty" });
                }
 break;}case "leadSource" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "leadSource", message: "must not be empty" });
                }
 break;}case "group" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "group", message: "must not be empty" });
                }
 break;}case "subgroup" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "subgroup", message: "must not be empty" });
                }
 break;}case "actionItem" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "actionItem", message: "must not be empty" });
                }
 break;}case "memo" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "memo", message: "must not be empty" });
                }
 break;}}return errors; }export function orderValidateFields(_partial: Partial<Order>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("opportunity" in _partial && _partial.opportunity!== undefined){const __val = _partial.opportunity as string; 
                if (__val.length === 0) {
                    errors.push({ field: "opportunity", message: "must not be empty" });
                }
}if("reference" in _partial && _partial.reference!== undefined){const __val = _partial.reference as string; 
                if (__val.length === 0) {
                    errors.push({ field: "reference", message: "must not be empty" });
                }
}if("leadSource" in _partial && _partial.leadSource!== undefined){const __val = _partial.leadSource as string; 
                if (__val.length === 0) {
                    errors.push({ field: "leadSource", message: "must not be empty" });
                }
}if("group" in _partial && _partial.group!== undefined){const __val = _partial.group as string; 
                if (__val.length === 0) {
                    errors.push({ field: "group", message: "must not be empty" });
                }
}if("subgroup" in _partial && _partial.subgroup!== undefined){const __val = _partial.subgroup as string; 
                if (__val.length === 0) {
                    errors.push({ field: "subgroup", message: "must not be empty" });
                }
}if("actionItem" in _partial && _partial.actionItem!== undefined){const __val = _partial.actionItem as string; 
                if (__val.length === 0) {
                    errors.push({ field: "actionItem", message: "must not be empty" });
                }
}if("memo" in _partial && _partial.memo!== undefined){const __val = _partial.memo as string; 
                if (__val.length === 0) {
                    errors.push({ field: "memo", message: "must not be empty" });
                }
}return errors; }export function orderHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "id" in o && "account" in o && "stage" in o && "number" in o && "payments" in o && "opportunity" in o && "reference" in o && "leadSource" in o && "salesRep" in o && "group" in o && "subgroup" in o && "isPosted" in o && "needsReview" in o && "actionItem" in o && "upsale" in o && "dateCreated" in o && "appointment" in o && "lastTechs" in o && "package" in o && "promotion" in o && "balance" in o && "due" in o && "total" in o && "site" in o && "billedItems" in o && "memo" in o && "discount" in o && "tip" in o && "commissions" in o;}export function orderIs(obj: unknown): obj is Order {if(!orderHasShape(obj)){return false;}const result = orderDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type OrderErrors = {_errors: __gf_Option<Array<string>>; id: __gf_Option<Array<string>>; account: __gf_Option<Array<string>>; stage: __gf_Option<Array<string>>; number: __gf_Option<Array<string>>; payments: __gf_Option<Array<string>>; opportunity: __gf_Option<Array<string>>; reference: __gf_Option<Array<string>>; leadSource: __gf_Option<Array<string>>; salesRep: __gf_Option<Array<string>>; group: __gf_Option<Array<string>>; subgroup: __gf_Option<Array<string>>; isPosted: __gf_Option<Array<string>>; needsReview: __gf_Option<Array<string>>; actionItem: __gf_Option<Array<string>>; upsale: __gf_Option<Array<string>>; dateCreated: __gf_Option<Array<string>>; appointment: __gf_Option<Array<string>>; lastTechs: __gf_Option<Array<string>>; package: __gf_Option<Array<string>>; promotion: __gf_Option<Array<string>>; balance: __gf_Option<Array<string>>; due: __gf_Option<Array<string>>; total: __gf_Option<Array<string>>; site: __gf_Option<Array<string>>; billedItems: __gf_Option<Array<string>>; memo: __gf_Option<Array<string>>; discount: __gf_Option<Array<string>>; tip: __gf_Option<Array<string>>; commissions: __gf_Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type OrderTainted = {id: __gf_Option<boolean>; account: __gf_Option<boolean>; stage: __gf_Option<boolean>; number: __gf_Option<boolean>; payments: __gf_Option<boolean>; opportunity: __gf_Option<boolean>; reference: __gf_Option<boolean>; leadSource: __gf_Option<boolean>; salesRep: __gf_Option<boolean>; group: __gf_Option<boolean>; subgroup: __gf_Option<boolean>; isPosted: __gf_Option<boolean>; needsReview: __gf_Option<boolean>; actionItem: __gf_Option<boolean>; upsale: __gf_Option<boolean>; dateCreated: __gf_Option<boolean>; appointment: __gf_Option<boolean>; lastTechs: __gf_Option<boolean>; package: __gf_Option<boolean>; promotion: __gf_Option<boolean>; balance: __gf_Option<boolean>; due: __gf_Option<boolean>; total: __gf_Option<boolean>; site: __gf_Option<boolean>; billedItems: __gf_Option<boolean>; memo: __gf_Option<boolean>; discount: __gf_Option<boolean>; tip: __gf_Option<boolean>; commissions: __gf_Option<boolean>; }; /** Type-safe field controllers for this form */export interface OrderFieldControllers {readonly id: FieldController<string>; readonly account: FieldController<string | Account>; readonly stage: FieldController<OrderStage>; readonly number: FieldController<number>; readonly payments: ArrayFieldController<(string | Payment)>; readonly opportunity: FieldController<string>; readonly reference: FieldController<string>; readonly leadSource: FieldController<string>; readonly salesRep: FieldController<string | Employee>; readonly group: FieldController<string>; readonly subgroup: FieldController<string>; readonly isPosted: FieldController<boolean>; readonly needsReview: FieldController<boolean>; readonly actionItem: FieldController<string>; readonly upsale: FieldController<number>; readonly dateCreated: FieldController<string>; readonly appointment: FieldController<string | Appointment>; readonly lastTechs: ArrayFieldController<(string | Employee)>; readonly package: FieldController<(string | Package)[] | null>; readonly promotion: FieldController<(string | Promotion)[] | null>; readonly balance: FieldController<number>; readonly due: FieldController<string>; readonly total: FieldController<number>; readonly site: FieldController<string | Site>; readonly billedItems: ArrayFieldController<BilledItem>; readonly memo: FieldController<string>; readonly discount: FieldController<number>; readonly tip: FieldController<number>; readonly commissions: ArrayFieldController<number>; }/** Gigaform instance containing reactive state and field controllers */export interface OrderGigaform {readonly data: Order; readonly errors: OrderErrors; readonly tainted: OrderTainted; readonly fields: OrderFieldControllers; validate(): Exit<Order, Array<{field: string; message: string}>>; reset(overrides?: Partial<Order>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function orderCreateForm(overrides?: Partial<Order>): OrderGigaform {let data = $state({...orderDefaultValue(),...overrides}); let errors = $state<OrderErrors>({_errors: optionNone(), id: optionNone(), account: optionNone(), stage: optionNone(), number: optionNone(), payments: optionNone(), opportunity: optionNone(), reference: optionNone(), leadSource: optionNone(), salesRep: optionNone(), group: optionNone(), subgroup: optionNone(), isPosted: optionNone(), needsReview: optionNone(), actionItem: optionNone(), upsale: optionNone(), dateCreated: optionNone(), appointment: optionNone(), lastTechs: optionNone(), package: optionNone(), promotion: optionNone(), balance: optionNone(), due: optionNone(), total: optionNone(), site: optionNone(), billedItems: optionNone(), memo: optionNone(), discount: optionNone(), tip: optionNone(), commissions: optionNone(), }); let tainted = $state<OrderTainted>({id: optionNone(), account: optionNone(), stage: optionNone(), number: optionNone(), payments: optionNone(), opportunity: optionNone(), reference: optionNone(), leadSource: optionNone(), salesRep: optionNone(), group: optionNone(), subgroup: optionNone(), isPosted: optionNone(), needsReview: optionNone(), actionItem: optionNone(), upsale: optionNone(), dateCreated: optionNone(), appointment: optionNone(), lastTechs: optionNone(), package: optionNone(), promotion: optionNone(), balance: optionNone(), due: optionNone(), total: optionNone(), site: optionNone(), billedItems: optionNone(), memo: optionNone(), discount: optionNone(), tip: optionNone(), commissions: optionNone(), }); const fields: OrderFieldControllers = {id: {path: ["id" ]as const, name: "id" , constraints: { required: true }, get: ()=>data.id, set: (value: string)=>{data.id = value;}, transform: (value: string): string =>value,getError: ()=>errors.id, setError: (value: __gf_Option<Array<string>>)=>{errors.id = value;}, getTainted: ()=>tainted.id, setTainted: (value: __gf_Option<boolean>)=>{tainted.id = value;}, validate: (): Array<string>=>{const fieldErrors = orderValidateField("id", data.id); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},account: {path: ["account" ]as const, name: "account" , constraints: { required: true }, label: "Account" , get: ()=>data.account, set: (value: string | Account)=>{data.account = value;}, transform: (value: string | Account): string | Account =>value,getError: ()=>errors.account, setError: (value: __gf_Option<Array<string>>)=>{errors.account = value;}, getTainted: ()=>tainted.account, setTainted: (value: __gf_Option<boolean>)=>{tainted.account = value;}, validate: (): Array<string>=>{const fieldErrors = orderValidateField("account", data.account); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},stage: {path: ["stage" ]as const, name: "stage" , constraints: { required: true }, label: "Stage" , get: ()=>data.stage, set: (value: OrderStage)=>{data.stage = value;}, transform: (value: OrderStage): OrderStage =>value,getError: ()=>errors.stage, setError: (value: __gf_Option<Array<string>>)=>{errors.stage = value;}, getTainted: ()=>tainted.stage, setTainted: (value: __gf_Option<boolean>)=>{tainted.stage = value;}, validate: (): Array<string>=>{const fieldErrors = orderValidateField("stage", data.stage); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},number: {path: ["number" ]as const, name: "number" , constraints: { required: true }, get: ()=>data.number, set: (value: number)=>{data.number = value;}, transform: (value: number): number =>value,getError: ()=>errors.number, setError: (value: __gf_Option<Array<string>>)=>{errors.number = value;}, getTainted: ()=>tainted.number, setTainted: (value: __gf_Option<boolean>)=>{tainted.number = value;}, validate: (): Array<string>=>{const fieldErrors = orderValidateField("number", data.number); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},payments: {path: ["payments" ]as const, name: "payments" , constraints: { required: true }, get: ()=>data.payments, set: (value: (string | Payment)[])=>{data.payments = value;}, transform: (value: (string | Payment)[]): (string | Payment)[] =>value,getError: ()=>errors.payments, setError: (value: __gf_Option<Array<string>>)=>{errors.payments = value;}, getTainted: ()=>tainted.payments, setTainted: (value: __gf_Option<boolean>)=>{tainted.payments = value;}, validate: (): Array<string>=>{const fieldErrors = orderValidateField("payments", data.payments); return fieldErrors.map((e: {field: string; message: string})=>e.message);},at: (index: number)=>({path: ["payments" , index]as const, name: `payments.${index}` , constraints: {required: true}, get: ()=>data.payments[index]!, set: (value: (string | Payment))=>{data.payments[index]= value;}, transform: (value: (string | Payment)): (string | Payment) =>value, getError: ()=>errors.payments, setError: (value: __gf_Option<Array<string>>)=>{errors.payments = value;}, getTainted: ()=>tainted.payments, setTainted: (value: __gf_Option<boolean>)=>{tainted.payments = value;}, validate: (): Array<string>=>[],}), push: (item: (string | Payment))=>{data.payments.push(item);}, remove: (index: number)=>{data.payments.splice(index, 1);}, swap: (a: number, b: number)=>{const tmp = data.payments[a]!; data.payments[a]= data.payments[b]!; data.payments[b]= tmp;},},opportunity: {path: ["opportunity" ]as const, name: "opportunity" , constraints: { required: true }, label: "Opportunity" , get: ()=>data.opportunity, set: (value: string)=>{data.opportunity = value;}, transform: (value: string): string =>value,getError: ()=>errors.opportunity, setError: (value: __gf_Option<Array<string>>)=>{errors.opportunity = value;}, getTainted: ()=>tainted.opportunity, setTainted: (value: __gf_Option<boolean>)=>{tainted.opportunity = value;}, validate: (): Array<string>=>{const fieldErrors = orderValidateField("opportunity", data.opportunity); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},reference: {path: ["reference" ]as const, name: "reference" , constraints: { required: true }, label: "Reference" , get: ()=>data.reference, set: (value: string)=>{data.reference = value;}, transform: (value: string): string =>value,getError: ()=>errors.reference, setError: (value: __gf_Option<Array<string>>)=>{errors.reference = value;}, getTainted: ()=>tainted.reference, setTainted: (value: __gf_Option<boolean>)=>{tainted.reference = value;}, validate: (): Array<string>=>{const fieldErrors = orderValidateField("reference", data.reference); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},leadSource: {path: ["leadSource" ]as const, name: "leadSource" , constraints: { required: true }, label: "Lead Source" , get: ()=>data.leadSource, set: (value: string)=>{data.leadSource = value;}, transform: (value: string): string =>value,getError: ()=>errors.leadSource, setError: (value: __gf_Option<Array<string>>)=>{errors.leadSource = value;}, getTainted: ()=>tainted.leadSource, setTainted: (value: __gf_Option<boolean>)=>{tainted.leadSource = value;}, validate: (): Array<string>=>{const fieldErrors = orderValidateField("leadSource", data.leadSource); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},salesRep: {path: ["salesRep" ]as const, name: "salesRep" , constraints: { required: true }, label: "Sales Rep" , get: ()=>data.salesRep, set: (value: string | Employee)=>{data.salesRep = value;}, transform: (value: string | Employee): string | Employee =>value,getError: ()=>errors.salesRep, setError: (value: __gf_Option<Array<string>>)=>{errors.salesRep = value;}, getTainted: ()=>tainted.salesRep, setTainted: (value: __gf_Option<boolean>)=>{tainted.salesRep = value;}, validate: (): Array<string>=>{const fieldErrors = orderValidateField("salesRep", data.salesRep); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},group: {path: ["group" ]as const, name: "group" , constraints: { required: true }, label: "Group" , get: ()=>data.group, set: (value: string)=>{data.group = value;}, transform: (value: string): string =>value,getError: ()=>errors.group, setError: (value: __gf_Option<Array<string>>)=>{errors.group = value;}, getTainted: ()=>tainted.group, setTainted: (value: __gf_Option<boolean>)=>{tainted.group = value;}, validate: (): Array<string>=>{const fieldErrors = orderValidateField("group", data.group); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},subgroup: {path: ["subgroup" ]as const, name: "subgroup" , constraints: { required: true }, label: "Subgroup" , get: ()=>data.subgroup, set: (value: string)=>{data.subgroup = value;}, transform: (value: string): string =>value,getError: ()=>errors.subgroup, setError: (value: __gf_Option<Array<string>>)=>{errors.subgroup = value;}, getTainted: ()=>tainted.subgroup, setTainted: (value: __gf_Option<boolean>)=>{tainted.subgroup = value;}, validate: (): Array<string>=>{const fieldErrors = orderValidateField("subgroup", data.subgroup); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},isPosted: {path: ["isPosted" ]as const, name: "isPosted" , constraints: { required: true }, label: "Posted" , get: ()=>data.isPosted, set: (value: boolean)=>{data.isPosted = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.isPosted, setError: (value: __gf_Option<Array<string>>)=>{errors.isPosted = value;}, getTainted: ()=>tainted.isPosted, setTainted: (value: __gf_Option<boolean>)=>{tainted.isPosted = value;}, validate: (): Array<string>=>{const fieldErrors = orderValidateField("isPosted", data.isPosted); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},needsReview: {path: ["needsReview" ]as const, name: "needsReview" , constraints: { required: true }, label: "Needs Review" , get: ()=>data.needsReview, set: (value: boolean)=>{data.needsReview = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.needsReview, setError: (value: __gf_Option<Array<string>>)=>{errors.needsReview = value;}, getTainted: ()=>tainted.needsReview, setTainted: (value: __gf_Option<boolean>)=>{tainted.needsReview = value;}, validate: (): Array<string>=>{const fieldErrors = orderValidateField("needsReview", data.needsReview); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},actionItem: {path: ["actionItem" ]as const, name: "actionItem" , constraints: { required: true }, label: "Action Item" , get: ()=>data.actionItem, set: (value: string)=>{data.actionItem = value;}, transform: (value: string): string =>value,getError: ()=>errors.actionItem, setError: (value: __gf_Option<Array<string>>)=>{errors.actionItem = value;}, getTainted: ()=>tainted.actionItem, setTainted: (value: __gf_Option<boolean>)=>{tainted.actionItem = value;}, validate: (): Array<string>=>{const fieldErrors = orderValidateField("actionItem", data.actionItem); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},upsale: {path: ["upsale" ]as const, name: "upsale" , constraints: { required: true }, get: ()=>data.upsale, set: (value: number)=>{data.upsale = value;}, transform: (value: number): number =>value,getError: ()=>errors.upsale, setError: (value: __gf_Option<Array<string>>)=>{errors.upsale = value;}, getTainted: ()=>tainted.upsale, setTainted: (value: __gf_Option<boolean>)=>{tainted.upsale = value;}, validate: (): Array<string>=>{const fieldErrors = orderValidateField("upsale", data.upsale); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},dateCreated: {path: ["dateCreated" ]as const, name: "dateCreated" , constraints: { required: true }, get: ()=>data.dateCreated, set: (value: string)=>{data.dateCreated = value;}, transform: (value: string): string =>value,getError: ()=>errors.dateCreated, setError: (value: __gf_Option<Array<string>>)=>{errors.dateCreated = value;}, getTainted: ()=>tainted.dateCreated, setTainted: (value: __gf_Option<boolean>)=>{tainted.dateCreated = value;}, validate: (): Array<string>=>{const fieldErrors = orderValidateField("dateCreated", data.dateCreated); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},appointment: {path: ["appointment" ]as const, name: "appointment" , constraints: { required: true }, label: "Appointment" , get: ()=>data.appointment, set: (value: string | Appointment)=>{data.appointment = value;}, transform: (value: string | Appointment): string | Appointment =>value,getError: ()=>errors.appointment, setError: (value: __gf_Option<Array<string>>)=>{errors.appointment = value;}, getTainted: ()=>tainted.appointment, setTainted: (value: __gf_Option<boolean>)=>{tainted.appointment = value;}, validate: (): Array<string>=>{const fieldErrors = orderValidateField("appointment", data.appointment); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},lastTechs: {path: ["lastTechs" ]as const, name: "lastTechs" , constraints: { required: true }, label: "Technicians" , get: ()=>data.lastTechs, set: (value: (string | Employee)[])=>{data.lastTechs = value;}, transform: (value: (string | Employee)[]): (string | Employee)[] =>value,getError: ()=>errors.lastTechs, setError: (value: __gf_Option<Array<string>>)=>{errors.lastTechs = value;}, getTainted: ()=>tainted.lastTechs, setTainted: (value: __gf_Option<boolean>)=>{tainted.lastTechs = value;}, validate: (): Array<string>=>{const fieldErrors = orderValidateField("lastTechs", data.lastTechs); return fieldErrors.map((e: {field: string; message: string})=>e.message);},at: (index: number)=>({path: ["lastTechs" , index]as const, name: `lastTechs.${index}` , constraints: {required: true}, get: ()=>data.lastTechs[index]!, set: (value: (string | Employee))=>{data.lastTechs[index]= value;}, transform: (value: (string | Employee)): (string | Employee) =>value, getError: ()=>errors.lastTechs, setError: (value: __gf_Option<Array<string>>)=>{errors.lastTechs = value;}, getTainted: ()=>tainted.lastTechs, setTainted: (value: __gf_Option<boolean>)=>{tainted.lastTechs = value;}, validate: (): Array<string>=>[],}), push: (item: (string | Employee))=>{data.lastTechs.push(item);}, remove: (index: number)=>{data.lastTechs.splice(index, 1);}, swap: (a: number, b: number)=>{const tmp = data.lastTechs[a]!; data.lastTechs[a]= data.lastTechs[b]!; data.lastTechs[b]= tmp;},},package: {path: ["package" ]as const, name: "package" , constraints: { required: true }, get: ()=>data.package, set: (value: (string | Package)[] | null)=>{data.package = value;}, transform: (value: (string | Package)[] | null): (string | Package)[] | null =>value,getError: ()=>errors.package, setError: (value: __gf_Option<Array<string>>)=>{errors.package = value;}, getTainted: ()=>tainted.package, setTainted: (value: __gf_Option<boolean>)=>{tainted.package = value;}, validate: (): Array<string>=>{const fieldErrors = orderValidateField("package", data.package); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},promotion: {path: ["promotion" ]as const, name: "promotion" , constraints: { required: true }, get: ()=>data.promotion, set: (value: (string | Promotion)[] | null)=>{data.promotion = value;}, transform: (value: (string | Promotion)[] | null): (string | Promotion)[] | null =>value,getError: ()=>errors.promotion, setError: (value: __gf_Option<Array<string>>)=>{errors.promotion = value;}, getTainted: ()=>tainted.promotion, setTainted: (value: __gf_Option<boolean>)=>{tainted.promotion = value;}, validate: (): Array<string>=>{const fieldErrors = orderValidateField("promotion", data.promotion); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},balance: {path: ["balance" ]as const, name: "balance" , constraints: { required: true }, get: ()=>data.balance, set: (value: number)=>{data.balance = value;}, transform: (value: number): number =>value,getError: ()=>errors.balance, setError: (value: __gf_Option<Array<string>>)=>{errors.balance = value;}, getTainted: ()=>tainted.balance, setTainted: (value: __gf_Option<boolean>)=>{tainted.balance = value;}, validate: (): Array<string>=>{const fieldErrors = orderValidateField("balance", data.balance); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},due: {path: ["due" ]as const, name: "due" , constraints: { required: true }, label: "Due" , get: ()=>data.due, set: (value: string)=>{data.due = value;}, transform: (value: string): string =>value,getError: ()=>errors.due, setError: (value: __gf_Option<Array<string>>)=>{errors.due = value;}, getTainted: ()=>tainted.due, setTainted: (value: __gf_Option<boolean>)=>{tainted.due = value;}, validate: (): Array<string>=>{const fieldErrors = orderValidateField("due", data.due); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},total: {path: ["total" ]as const, name: "total" , constraints: { required: true }, get: ()=>data.total, set: (value: number)=>{data.total = value;}, transform: (value: number): number =>value,getError: ()=>errors.total, setError: (value: __gf_Option<Array<string>>)=>{errors.total = value;}, getTainted: ()=>tainted.total, setTainted: (value: __gf_Option<boolean>)=>{tainted.total = value;}, validate: (): Array<string>=>{const fieldErrors = orderValidateField("total", data.total); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},site: {path: ["site" ]as const, name: "site" , constraints: { required: true }, label: "Site" , get: ()=>data.site, set: (value: string | Site)=>{data.site = value;}, transform: (value: string | Site): string | Site =>value,getError: ()=>errors.site, setError: (value: __gf_Option<Array<string>>)=>{errors.site = value;}, getTainted: ()=>tainted.site, setTainted: (value: __gf_Option<boolean>)=>{tainted.site = value;}, validate: (): Array<string>=>{const fieldErrors = orderValidateField("site", data.site); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},billedItems: {path: ["billedItems" ]as const, name: "billedItems" , constraints: { required: true }, get: ()=>data.billedItems, set: (value: BilledItem[])=>{data.billedItems = value;}, transform: (value: BilledItem[]): BilledItem[] =>value,getError: ()=>errors.billedItems, setError: (value: __gf_Option<Array<string>>)=>{errors.billedItems = value;}, getTainted: ()=>tainted.billedItems, setTainted: (value: __gf_Option<boolean>)=>{tainted.billedItems = value;}, validate: (): Array<string>=>{const fieldErrors = orderValidateField("billedItems", data.billedItems); return fieldErrors.map((e: {field: string; message: string})=>e.message);},at: (index: number)=>({path: ["billedItems" , index]as const, name: `billedItems.${index}` , constraints: {required: true}, get: ()=>data.billedItems[index]!, set: (value: BilledItem)=>{data.billedItems[index]= value;}, transform: (value: BilledItem): BilledItem =>value, getError: ()=>errors.billedItems, setError: (value: __gf_Option<Array<string>>)=>{errors.billedItems = value;}, getTainted: ()=>tainted.billedItems, setTainted: (value: __gf_Option<boolean>)=>{tainted.billedItems = value;}, validate: (): Array<string>=>[],}), push: (item: BilledItem)=>{data.billedItems.push(item);}, remove: (index: number)=>{data.billedItems.splice(index, 1);}, swap: (a: number, b: number)=>{const tmp = data.billedItems[a]!; data.billedItems[a]= data.billedItems[b]!; data.billedItems[b]= tmp;},},memo: {path: ["memo" ]as const, name: "memo" , constraints: { required: true }, label: "Memo" , get: ()=>data.memo, set: (value: string)=>{data.memo = value;}, transform: (value: string): string =>value,getError: ()=>errors.memo, setError: (value: __gf_Option<Array<string>>)=>{errors.memo = value;}, getTainted: ()=>tainted.memo, setTainted: (value: __gf_Option<boolean>)=>{tainted.memo = value;}, validate: (): Array<string>=>{const fieldErrors = orderValidateField("memo", data.memo); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},discount: {path: ["discount" ]as const, name: "discount" , constraints: { required: true }, get: ()=>data.discount, set: (value: number)=>{data.discount = value;}, transform: (value: number): number =>value,getError: ()=>errors.discount, setError: (value: __gf_Option<Array<string>>)=>{errors.discount = value;}, getTainted: ()=>tainted.discount, setTainted: (value: __gf_Option<boolean>)=>{tainted.discount = value;}, validate: (): Array<string>=>{const fieldErrors = orderValidateField("discount", data.discount); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},tip: {path: ["tip" ]as const, name: "tip" , constraints: { required: true }, get: ()=>data.tip, set: (value: number)=>{data.tip = value;}, transform: (value: number): number =>value,getError: ()=>errors.tip, setError: (value: __gf_Option<Array<string>>)=>{errors.tip = value;}, getTainted: ()=>tainted.tip, setTainted: (value: __gf_Option<boolean>)=>{tainted.tip = value;}, validate: (): Array<string>=>{const fieldErrors = orderValidateField("tip", data.tip); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},commissions: {path: ["commissions" ]as const, name: "commissions" , constraints: { required: true }, get: ()=>data.commissions, set: (value: number[])=>{data.commissions = value;}, transform: (value: number[]): number[] =>value,getError: ()=>errors.commissions, setError: (value: __gf_Option<Array<string>>)=>{errors.commissions = value;}, getTainted: ()=>tainted.commissions, setTainted: (value: __gf_Option<boolean>)=>{tainted.commissions = value;}, validate: (): Array<string>=>{const fieldErrors = orderValidateField("commissions", data.commissions); return fieldErrors.map((e: {field: string; message: string})=>e.message);},at: (index: number)=>({path: ["commissions" , index]as const, name: `commissions.${index}` , constraints: {required: true}, get: ()=>data.commissions[index]!, set: (value: number)=>{data.commissions[index]= value;}, transform: (value: number): number =>value, getError: ()=>errors.commissions, setError: (value: __gf_Option<Array<string>>)=>{errors.commissions = value;}, getTainted: ()=>tainted.commissions, setTainted: (value: __gf_Option<boolean>)=>{tainted.commissions = value;}, validate: (): Array<string>=>[],}), push: (item: number)=>{data.commissions.push(item);}, remove: (index: number)=>{data.commissions.splice(index, 1);}, swap: (a: number, b: number)=>{const tmp = data.commissions[a]!; data.commissions[a]= data.commissions[b]!; data.commissions[b]= tmp;},},}; function validate(): Exit<Order, Array<{field: string; message: string}>>{return toExit(orderDeserialize(data));}function reset(newOverrides?: Partial<Order>): void {data = {...orderDefaultValue(),...newOverrides}; errors = {_errors: optionNone(), id: optionNone(), account: optionNone(), stage: optionNone(), number: optionNone(), payments: optionNone(), opportunity: optionNone(), reference: optionNone(), leadSource: optionNone(), salesRep: optionNone(), group: optionNone(), subgroup: optionNone(), isPosted: optionNone(), needsReview: optionNone(), actionItem: optionNone(), upsale: optionNone(), dateCreated: optionNone(), appointment: optionNone(), lastTechs: optionNone(), package: optionNone(), promotion: optionNone(), balance: optionNone(), due: optionNone(), total: optionNone(), site: optionNone(), billedItems: optionNone(), memo: optionNone(), discount: optionNone(), tip: optionNone(), commissions: optionNone(), }; tainted = {id: optionNone(), account: optionNone(), stage: optionNone(), number: optionNone(), payments: optionNone(), opportunity: optionNone(), reference: optionNone(), leadSource: optionNone(), salesRep: optionNone(), group: optionNone(), subgroup: optionNone(), isPosted: optionNone(), needsReview: optionNone(), actionItem: optionNone(), upsale: optionNone(), dateCreated: optionNone(), appointment: optionNone(), lastTechs: optionNone(), package: optionNone(), promotion: optionNone(), balance: optionNone(), due: optionNone(), total: optionNone(), site: optionNone(), billedItems: optionNone(), memo: optionNone(), discount: optionNone(), tip: optionNone(), commissions: optionNone(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function orderFromFormData(formData: FormData): Exit<Order, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.id = formData.get("id" )?? "" ;obj.account = formData.get("account" )?? "" ;{const stageObj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("stage." )){const fieldName = key.slice("stage." .length); const parts = fieldName.split("." ); let current = stageObj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.stage = stageObj;}{const numberStr = formData.get("number" ); obj.number = numberStr? parseFloat(numberStr as string): 0; if(obj.number!== undefined && isNaN(obj.number as number))obj.number = 0;}{const paymentsItems: Array<Record<string, unknown>>= []; let idx = 0; while(formData.has("payments." + idx + "." )|| idx === 0){const hasAny = Array.from(formData.keys()).some(k =>k.startsWith("payments." + idx + "." )); if(!hasAny && idx>0)break; if(hasAny){const item: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("payments." + idx + "." )){const fieldName = key.slice("payments." .length + String(idx).length + 1); item[fieldName]= value;}}paymentsItems.push(item);}idx ++; if(idx>1000)break;}obj.payments = paymentsItems;}obj.opportunity = formData.get("opportunity" )?? "" ;obj.reference = formData.get("reference" )?? "" ;obj.leadSource = formData.get("leadSource" )?? "" ;obj.salesRep = formData.get("salesRep" )?? "" ;obj.group = formData.get("group" )?? "" ;obj.subgroup = formData.get("subgroup" )?? "" ;{const isPostedVal = formData.get("isPosted" ); obj.isPosted = isPostedVal === "true" || isPostedVal === "on" || isPostedVal === "1" ;}{const needsReviewVal = formData.get("needsReview" ); obj.needsReview = needsReviewVal === "true" || needsReviewVal === "on" || needsReviewVal === "1" ;}obj.actionItem = formData.get("actionItem" )?? "" ;{const upsaleStr = formData.get("upsale" ); obj.upsale = upsaleStr? parseFloat(upsaleStr as string): 0; if(obj.upsale!== undefined && isNaN(obj.upsale as number))obj.upsale = 0;}obj.dateCreated = formData.get("dateCreated" )?? "" ;obj.appointment = formData.get("appointment" )?? "" ;{const lastTechsItems: Array<Record<string, unknown>>= []; let idx = 0; while(formData.has("lastTechs." + idx + "." )|| idx === 0){const hasAny = Array.from(formData.keys()).some(k =>k.startsWith("lastTechs." + idx + "." )); if(!hasAny && idx>0)break; if(hasAny){const item: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("lastTechs." + idx + "." )){const fieldName = key.slice("lastTechs." .length + String(idx).length + 1); item[fieldName]= value;}}lastTechsItems.push(item);}idx ++; if(idx>1000)break;}obj.lastTechs = lastTechsItems;}obj.package = formData.get("package" )?? "" ;obj.promotion = formData.get("promotion" )?? "" ;{const balanceStr = formData.get("balance" ); obj.balance = balanceStr? parseFloat(balanceStr as string): 0; if(obj.balance!== undefined && isNaN(obj.balance as number))obj.balance = 0;}obj.due = formData.get("due" )?? "" ;{const totalStr = formData.get("total" ); obj.total = totalStr? parseFloat(totalStr as string): 0; if(obj.total!== undefined && isNaN(obj.total as number))obj.total = 0;}obj.site = formData.get("site" )?? "" ;{const billedItemsItems: Array<Record<string, unknown>>= []; let idx = 0; while(formData.has("billedItems." + idx + "." )|| idx === 0){const hasAny = Array.from(formData.keys()).some(k =>k.startsWith("billedItems." + idx + "." )); if(!hasAny && idx>0)break; if(hasAny){const item: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("billedItems." + idx + "." )){const fieldName = key.slice("billedItems." .length + String(idx).length + 1); item[fieldName]= value;}}billedItemsItems.push(item);}idx ++; if(idx>1000)break;}obj.billedItems = billedItemsItems;}obj.memo = formData.get("memo" )?? "" ;{const discountStr = formData.get("discount" ); obj.discount = discountStr? parseFloat(discountStr as string): 0; if(obj.discount!== undefined && isNaN(obj.discount as number))obj.discount = 0;}{const tipStr = formData.get("tip" ); obj.tip = tipStr? parseFloat(tipStr as string): 0; if(obj.tip!== undefined && isNaN(obj.tip as number))obj.tip = 0;}obj.commissions = formData.getAll("commissions" ).map(v =>parseFloat(v as string)).filter(n =>!isNaN(n));return toExit(orderDeserialize(obj));}

export const Order = {
  defaultValue: orderDefaultValue,
  serialize: orderSerialize,
  serializeWithContext: orderSerializeWithContext,
  deserialize: orderDeserialize,
  deserializeWithContext: orderDeserializeWithContext,
  validateFields: orderValidateFields,
  hasShape: orderHasShape,
  is: orderIs,
  createForm: orderCreateForm,
  fromFormData: orderFromFormData
} as const;


export interface Commented {
    
    comment: string;
    replyTo: string | null;
}

export function commentedDefaultValue(): Commented {return {comment: "",
                            replyTo: null, }as Commented;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function commentedSerialize(value: Commented): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(commentedSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function commentedSerializeWithContext(value: Commented, ctx: __mf_SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Commented" , __id,}; result["comment" ]= value.comment; result["replyTo" ]= value.replyTo; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function commentedDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: Commented } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = commentedDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Commented.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function commentedDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Commented | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new __mf_DeserializeError([{field: "_root" , message: "Commented.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("comment" in obj)){errors.push({field: "comment" , message: "missing required field" });}if(!("replyTo" in obj)){errors.push({field: "replyTo" , message: "missing required field" });}if(errors.length>0){throw new __mf_DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_comment = obj["comment" ]as string; 
                if (__raw_comment.length === 0) {
                    errors.push({ field: "comment", message: "must not be empty" });
                }
 instance.comment = __raw_comment; }{const __raw_replyTo = obj["replyTo" ]as string | null; instance.replyTo = __raw_replyTo; }if(errors.length>0){throw new __mf_DeserializeError(errors);}return instance as Commented;}export function commentedValidateField<K extends keyof Commented>(_field: K, _value: Commented[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(_field){case "comment" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "comment", message: "must not be empty" });
                }
 break;}}return errors; }export function commentedValidateFields(_partial: Partial<Commented>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("comment" in _partial && _partial.comment!== undefined){const __val = _partial.comment as string; 
                if (__val.length === 0) {
                    errors.push({ field: "comment", message: "must not be empty" });
                }
}return errors; }export function commentedHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "comment" in o && "replyTo" in o;}export function commentedIs(obj: unknown): obj is Commented {if(!commentedHasShape(obj)){return false;}const result = commentedDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type CommentedErrors = {_errors: __gf_Option<Array<string>>; comment: __gf_Option<Array<string>>; replyTo: __gf_Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type CommentedTainted = {comment: __gf_Option<boolean>; replyTo: __gf_Option<boolean>; }; /** Type-safe field controllers for this form */export interface CommentedFieldControllers {readonly comment: FieldController<string>; readonly replyTo: FieldController<string | null>; }/** Gigaform instance containing reactive state and field controllers */export interface CommentedGigaform {readonly data: Commented; readonly errors: CommentedErrors; readonly tainted: CommentedTainted; readonly fields: CommentedFieldControllers; validate(): Exit<Commented, Array<{field: string; message: string}>>; reset(overrides?: Partial<Commented>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function commentedCreateForm(overrides?: Partial<Commented>): CommentedGigaform {let data = $state({...commentedDefaultValue(),...overrides}); let errors = $state<CommentedErrors>({_errors: optionNone(), comment: optionNone(), replyTo: optionNone(), }); let tainted = $state<CommentedTainted>({comment: optionNone(), replyTo: optionNone(), }); const fields: CommentedFieldControllers = {comment: {path: ["comment" ]as const, name: "comment" , constraints: { required: true }, get: ()=>data.comment, set: (value: string)=>{data.comment = value;}, transform: (value: string): string =>value,getError: ()=>errors.comment, setError: (value: __gf_Option<Array<string>>)=>{errors.comment = value;}, getTainted: ()=>tainted.comment, setTainted: (value: __gf_Option<boolean>)=>{tainted.comment = value;}, validate: (): Array<string>=>{const fieldErrors = commentedValidateField("comment", data.comment); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},replyTo: {path: ["replyTo" ]as const, name: "replyTo" , constraints: { required: true }, get: ()=>data.replyTo, set: (value: string | null)=>{data.replyTo = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.replyTo, setError: (value: __gf_Option<Array<string>>)=>{errors.replyTo = value;}, getTainted: ()=>tainted.replyTo, setTainted: (value: __gf_Option<boolean>)=>{tainted.replyTo = value;}, validate: (): Array<string>=>{const fieldErrors = commentedValidateField("replyTo", data.replyTo); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Exit<Commented, Array<{field: string; message: string}>>{return toExit(commentedDeserialize(data));}function reset(newOverrides?: Partial<Commented>): void {data = {...commentedDefaultValue(),...newOverrides}; errors = {_errors: optionNone(), comment: optionNone(), replyTo: optionNone(), }; tainted = {comment: optionNone(), replyTo: optionNone(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function commentedFromFormData(formData: FormData): Exit<Commented, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.comment = formData.get("comment" )?? "" ;obj.replyTo = formData.get("replyTo" )?? "" ;return toExit(commentedDeserialize(obj));}

export const Commented = {
  defaultValue: commentedDefaultValue,
  serialize: commentedSerialize,
  serializeWithContext: commentedSerializeWithContext,
  deserialize: commentedDeserialize,
  deserializeWithContext: commentedDeserializeWithContext,
  validateFields: commentedValidateFields,
  hasShape: commentedHasShape,
  is: commentedIs,
  createForm: commentedCreateForm,
  fromFormData: commentedFromFormData
} as const;


export interface Custom {
    mappings: DirectionHue[];
}

export function customDefaultValue(): Custom {return {mappings: [], }as Custom;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function customSerialize(value: Custom): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(customSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function customSerializeWithContext(value: Custom, ctx: __mf_SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Custom" , __id,}; result["mappings" ]= value.mappings.map((item)=>directionHueSerializeWithContext(item, ctx)); return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function customDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: Custom } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = customDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Custom.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function customDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Custom | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new __mf_DeserializeError([{field: "_root" , message: "Custom.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("mappings" in obj)){errors.push({field: "mappings" , message: "missing required field" });}if(errors.length>0){throw new __mf_DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_mappings = obj["mappings" ]as DirectionHue[]; if(Array.isArray(__raw_mappings)){instance.mappings = __raw_mappings as DirectionHue[];}}if(errors.length>0){throw new __mf_DeserializeError(errors);}return instance as Custom;}export function customValidateField<K extends keyof Custom>(_field: K, _value: Custom[K]): Array<{field: string; message: string}>{return[]; }export function customValidateFields(_partial: Partial<Custom>): Array<{field: string; message: string}>{return[]; }export function customHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "mappings" in o;}export function customIs(obj: unknown): obj is Custom {if(!customHasShape(obj)){return false;}const result = customDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type CustomErrors = {_errors: __gf_Option<Array<string>>; mappings: __gf_Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type CustomTainted = {mappings: __gf_Option<boolean>; }; /** Type-safe field controllers for this form */export interface CustomFieldControllers {readonly mappings: ArrayFieldController<DirectionHue>; }/** Gigaform instance containing reactive state and field controllers */export interface CustomGigaform {readonly data: Custom; readonly errors: CustomErrors; readonly tainted: CustomTainted; readonly fields: CustomFieldControllers; validate(): Exit<Custom, Array<{field: string; message: string}>>; reset(overrides?: Partial<Custom>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function customCreateForm(overrides?: Partial<Custom>): CustomGigaform {let data = $state({...customDefaultValue(),...overrides}); let errors = $state<CustomErrors>({_errors: optionNone(), mappings: optionNone(), }); let tainted = $state<CustomTainted>({mappings: optionNone(), }); const fields: CustomFieldControllers = {mappings: {path: ["mappings" ]as const, name: "mappings" , constraints: { required: true }, get: ()=>data.mappings, set: (value: DirectionHue[])=>{data.mappings = value;}, transform: (value: DirectionHue[]): DirectionHue[] =>value,getError: ()=>errors.mappings, setError: (value: __gf_Option<Array<string>>)=>{errors.mappings = value;}, getTainted: ()=>tainted.mappings, setTainted: (value: __gf_Option<boolean>)=>{tainted.mappings = value;}, validate: (): Array<string>=>{const fieldErrors = customValidateField("mappings", data.mappings); return fieldErrors.map((e: {field: string; message: string})=>e.message);},at: (index: number)=>({path: ["mappings" , index]as const, name: `mappings.${index}` , constraints: {required: true}, get: ()=>data.mappings[index]!, set: (value: DirectionHue)=>{data.mappings[index]= value;}, transform: (value: DirectionHue): DirectionHue =>value, getError: ()=>errors.mappings, setError: (value: __gf_Option<Array<string>>)=>{errors.mappings = value;}, getTainted: ()=>tainted.mappings, setTainted: (value: __gf_Option<boolean>)=>{tainted.mappings = value;}, validate: (): Array<string>=>[],}), push: (item: DirectionHue)=>{data.mappings.push(item);}, remove: (index: number)=>{data.mappings.splice(index, 1);}, swap: (a: number, b: number)=>{const tmp = data.mappings[a]!; data.mappings[a]= data.mappings[b]!; data.mappings[b]= tmp;},},}; function validate(): Exit<Custom, Array<{field: string; message: string}>>{return toExit(customDeserialize(data));}function reset(newOverrides?: Partial<Custom>): void {data = {...customDefaultValue(),...newOverrides}; errors = {_errors: optionNone(), mappings: optionNone(), }; tainted = {mappings: optionNone(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function customFromFormData(formData: FormData): Exit<Custom, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; {const mappingsItems: Array<Record<string, unknown>>= []; let idx = 0; while(formData.has("mappings." + idx + "." )|| idx === 0){const hasAny = Array.from(formData.keys()).some(k =>k.startsWith("mappings." + idx + "." )); if(!hasAny && idx>0)break; if(hasAny){const item: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("mappings." + idx + "." )){const fieldName = key.slice("mappings." .length + String(idx).length + 1); item[fieldName]= value;}}mappingsItems.push(item);}idx ++; if(idx>1000)break;}obj.mappings = mappingsItems;}return toExit(customDeserialize(obj));}

export const Custom = {
  defaultValue: customDefaultValue,
  serialize: customSerialize,
  serializeWithContext: customSerializeWithContext,
  deserialize: customDeserialize,
  deserializeWithContext: customDeserializeWithContext,
  validateFields: customValidateFields,
  hasShape: customHasShape,
  is: customIs,
  createForm: customCreateForm,
  fromFormData: customFromFormData
} as const;


export interface Colors {
    
    main: string;
    
    hover: string;
    
    active: string;
}

export function colorsDefaultValue(): Colors {return {main: "",
                            hover: "",
                            active: "", }as Colors;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function colorsSerialize(value: Colors): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(colorsSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function colorsSerializeWithContext(value: Colors, ctx: __mf_SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Colors" , __id,}; result["main" ]= value.main; result["hover" ]= value.hover; result["active" ]= value.active; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function colorsDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: Colors } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = colorsDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Colors.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function colorsDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Colors | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new __mf_DeserializeError([{field: "_root" , message: "Colors.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("main" in obj)){errors.push({field: "main" , message: "missing required field" });}if(!("hover" in obj)){errors.push({field: "hover" , message: "missing required field" });}if(!("active" in obj)){errors.push({field: "active" , message: "missing required field" });}if(errors.length>0){throw new __mf_DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_main = obj["main" ]as string; 
                if (__raw_main.length === 0) {
                    errors.push({ field: "main", message: "must not be empty" });
                }
 instance.main = __raw_main; }{const __raw_hover = obj["hover" ]as string; 
                if (__raw_hover.length === 0) {
                    errors.push({ field: "hover", message: "must not be empty" });
                }
 instance.hover = __raw_hover; }{const __raw_active = obj["active" ]as string; 
                if (__raw_active.length === 0) {
                    errors.push({ field: "active", message: "must not be empty" });
                }
 instance.active = __raw_active; }if(errors.length>0){throw new __mf_DeserializeError(errors);}return instance as Colors;}export function colorsValidateField<K extends keyof Colors>(_field: K, _value: Colors[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(_field){case "main" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "main", message: "must not be empty" });
                }
 break;}case "hover" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "hover", message: "must not be empty" });
                }
 break;}case "active" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "active", message: "must not be empty" });
                }
 break;}}return errors; }export function colorsValidateFields(_partial: Partial<Colors>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("main" in _partial && _partial.main!== undefined){const __val = _partial.main as string; 
                if (__val.length === 0) {
                    errors.push({ field: "main", message: "must not be empty" });
                }
}if("hover" in _partial && _partial.hover!== undefined){const __val = _partial.hover as string; 
                if (__val.length === 0) {
                    errors.push({ field: "hover", message: "must not be empty" });
                }
}if("active" in _partial && _partial.active!== undefined){const __val = _partial.active as string; 
                if (__val.length === 0) {
                    errors.push({ field: "active", message: "must not be empty" });
                }
}return errors; }export function colorsHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "main" in o && "hover" in o && "active" in o;}export function colorsIs(obj: unknown): obj is Colors {if(!colorsHasShape(obj)){return false;}const result = colorsDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type ColorsErrors = {_errors: __gf_Option<Array<string>>; main: __gf_Option<Array<string>>; hover: __gf_Option<Array<string>>; active: __gf_Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type ColorsTainted = {main: __gf_Option<boolean>; hover: __gf_Option<boolean>; active: __gf_Option<boolean>; }; /** Type-safe field controllers for this form */export interface ColorsFieldControllers {readonly main: FieldController<string>; readonly hover: FieldController<string>; readonly active: FieldController<string>; }/** Gigaform instance containing reactive state and field controllers */export interface ColorsGigaform {readonly data: Colors; readonly errors: ColorsErrors; readonly tainted: ColorsTainted; readonly fields: ColorsFieldControllers; validate(): Exit<Colors, Array<{field: string; message: string}>>; reset(overrides?: Partial<Colors>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function colorsCreateForm(overrides?: Partial<Colors>): ColorsGigaform {let data = $state({...colorsDefaultValue(),...overrides}); let errors = $state<ColorsErrors>({_errors: optionNone(), main: optionNone(), hover: optionNone(), active: optionNone(), }); let tainted = $state<ColorsTainted>({main: optionNone(), hover: optionNone(), active: optionNone(), }); const fields: ColorsFieldControllers = {main: {path: ["main" ]as const, name: "main" , constraints: { required: true }, get: ()=>data.main, set: (value: string)=>{data.main = value;}, transform: (value: string): string =>value,getError: ()=>errors.main, setError: (value: __gf_Option<Array<string>>)=>{errors.main = value;}, getTainted: ()=>tainted.main, setTainted: (value: __gf_Option<boolean>)=>{tainted.main = value;}, validate: (): Array<string>=>{const fieldErrors = colorsValidateField("main", data.main); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},hover: {path: ["hover" ]as const, name: "hover" , constraints: { required: true }, get: ()=>data.hover, set: (value: string)=>{data.hover = value;}, transform: (value: string): string =>value,getError: ()=>errors.hover, setError: (value: __gf_Option<Array<string>>)=>{errors.hover = value;}, getTainted: ()=>tainted.hover, setTainted: (value: __gf_Option<boolean>)=>{tainted.hover = value;}, validate: (): Array<string>=>{const fieldErrors = colorsValidateField("hover", data.hover); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},active: {path: ["active" ]as const, name: "active" , constraints: { required: true }, get: ()=>data.active, set: (value: string)=>{data.active = value;}, transform: (value: string): string =>value,getError: ()=>errors.active, setError: (value: __gf_Option<Array<string>>)=>{errors.active = value;}, getTainted: ()=>tainted.active, setTainted: (value: __gf_Option<boolean>)=>{tainted.active = value;}, validate: (): Array<string>=>{const fieldErrors = colorsValidateField("active", data.active); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Exit<Colors, Array<{field: string; message: string}>>{return toExit(colorsDeserialize(data));}function reset(newOverrides?: Partial<Colors>): void {data = {...colorsDefaultValue(),...newOverrides}; errors = {_errors: optionNone(), main: optionNone(), hover: optionNone(), active: optionNone(), }; tainted = {main: optionNone(), hover: optionNone(), active: optionNone(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function colorsFromFormData(formData: FormData): Exit<Colors, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.main = formData.get("main" )?? "" ;obj.hover = formData.get("hover" )?? "" ;obj.active = formData.get("active" )?? "" ;return toExit(colorsDeserialize(obj));}

export const Colors = {
  defaultValue: colorsDefaultValue,
  serialize: colorsSerialize,
  serializeWithContext: colorsSerializeWithContext,
  deserialize: colorsDeserialize,
  deserializeWithContext: colorsDeserializeWithContext,
  validateFields: colorsValidateFields,
  hasShape: colorsHasShape,
  is: colorsIs,
  createForm: colorsCreateForm,
  fromFormData: colorsFromFormData
} as const;


export interface ProductDefaults {
    
    price: number;
    
    
    description: string;
}

export function productDefaultsDefaultValue(): ProductDefaults {return {price: 0,
                            description: "", }as ProductDefaults;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function productDefaultsSerialize(value: ProductDefaults): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(productDefaultsSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function productDefaultsSerializeWithContext(value: ProductDefaults, ctx: __mf_SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "ProductDefaults" , __id,}; result["price" ]= value.price; result["description" ]= value.description; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function productDefaultsDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: ProductDefaults } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = productDefaultsDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "ProductDefaults.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function productDefaultsDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): ProductDefaults | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new __mf_DeserializeError([{field: "_root" , message: "ProductDefaults.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("price" in obj)){errors.push({field: "price" , message: "missing required field" });}if(!("description" in obj)){errors.push({field: "description" , message: "missing required field" });}if(errors.length>0){throw new __mf_DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_price = obj["price" ]as number; instance.price = __raw_price; }{const __raw_description = obj["description" ]as string; 
                if (__raw_description.length === 0) {
                    errors.push({ field: "description", message: "must not be empty" });
                }
 instance.description = __raw_description; }if(errors.length>0){throw new __mf_DeserializeError(errors);}return instance as ProductDefaults;}export function productDefaultsValidateField<K extends keyof ProductDefaults>(_field: K, _value: ProductDefaults[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(_field){case "description" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "description", message: "must not be empty" });
                }
 break;}}return errors; }export function productDefaultsValidateFields(_partial: Partial<ProductDefaults>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("description" in _partial && _partial.description!== undefined){const __val = _partial.description as string; 
                if (__val.length === 0) {
                    errors.push({ field: "description", message: "must not be empty" });
                }
}return errors; }export function productDefaultsHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "price" in o && "description" in o;}export function productDefaultsIs(obj: unknown): obj is ProductDefaults {if(!productDefaultsHasShape(obj)){return false;}const result = productDefaultsDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type ProductDefaultsErrors = {_errors: __gf_Option<Array<string>>; price: __gf_Option<Array<string>>; description: __gf_Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type ProductDefaultsTainted = {price: __gf_Option<boolean>; description: __gf_Option<boolean>; }; /** Type-safe field controllers for this form */export interface ProductDefaultsFieldControllers {readonly price: FieldController<number>; readonly description: FieldController<string>; }/** Gigaform instance containing reactive state and field controllers */export interface ProductDefaultsGigaform {readonly data: ProductDefaults; readonly errors: ProductDefaultsErrors; readonly tainted: ProductDefaultsTainted; readonly fields: ProductDefaultsFieldControllers; validate(): Exit<ProductDefaults, Array<{field: string; message: string}>>; reset(overrides?: Partial<ProductDefaults>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function productDefaultsCreateForm(overrides?: Partial<ProductDefaults>): ProductDefaultsGigaform {let data = $state({...productDefaultsDefaultValue(),...overrides}); let errors = $state<ProductDefaultsErrors>({_errors: optionNone(), price: optionNone(), description: optionNone(), }); let tainted = $state<ProductDefaultsTainted>({price: optionNone(), description: optionNone(), }); const fields: ProductDefaultsFieldControllers = {price: {path: ["price" ]as const, name: "price" , constraints: { required: true }, label: "Price" , get: ()=>data.price, set: (value: number)=>{data.price = value;}, transform: (value: number): number =>value,getError: ()=>errors.price, setError: (value: __gf_Option<Array<string>>)=>{errors.price = value;}, getTainted: ()=>tainted.price, setTainted: (value: __gf_Option<boolean>)=>{tainted.price = value;}, validate: (): Array<string>=>{const fieldErrors = productDefaultsValidateField("price", data.price); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},description: {path: ["description" ]as const, name: "description" , constraints: { required: true }, label: "Description" , get: ()=>data.description, set: (value: string)=>{data.description = value;}, transform: (value: string): string =>value,getError: ()=>errors.description, setError: (value: __gf_Option<Array<string>>)=>{errors.description = value;}, getTainted: ()=>tainted.description, setTainted: (value: __gf_Option<boolean>)=>{tainted.description = value;}, validate: (): Array<string>=>{const fieldErrors = productDefaultsValidateField("description", data.description); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Exit<ProductDefaults, Array<{field: string; message: string}>>{return toExit(productDefaultsDeserialize(data));}function reset(newOverrides?: Partial<ProductDefaults>): void {data = {...productDefaultsDefaultValue(),...newOverrides}; errors = {_errors: optionNone(), price: optionNone(), description: optionNone(), }; tainted = {price: optionNone(), description: optionNone(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function productDefaultsFromFormData(formData: FormData): Exit<ProductDefaults, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; {const priceStr = formData.get("price" ); obj.price = priceStr? parseFloat(priceStr as string): 0; if(obj.price!== undefined && isNaN(obj.price as number))obj.price = 0;}obj.description = formData.get("description" )?? "" ;return toExit(productDefaultsDeserialize(obj));}

export const ProductDefaults = {
  defaultValue: productDefaultsDefaultValue,
  serialize: productDefaultsSerialize,
  serializeWithContext: productDefaultsSerializeWithContext,
  deserialize: productDefaultsDeserialize,
  deserializeWithContext: productDefaultsDeserializeWithContext,
  validateFields: productDefaultsValidateFields,
  hasShape: productDefaultsHasShape,
  is: productDefaultsIs,
  createForm: productDefaultsCreateForm,
  fromFormData: productDefaultsFromFormData
} as const;


export interface Viewed {
    durationSeconds: number | null;
    source: string | null;
}

export function viewedDefaultValue(): Viewed {return {durationSeconds: null,
                            source: null, }as Viewed;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function viewedSerialize(value: Viewed): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(viewedSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function viewedSerializeWithContext(value: Viewed, ctx: __mf_SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Viewed" , __id,}; result["durationSeconds" ]= value.durationSeconds; result["source" ]= value.source; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function viewedDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: Viewed } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = viewedDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Viewed.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function viewedDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Viewed | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new __mf_DeserializeError([{field: "_root" , message: "Viewed.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("durationSeconds" in obj)){errors.push({field: "durationSeconds" , message: "missing required field" });}if(!("source" in obj)){errors.push({field: "source" , message: "missing required field" });}if(errors.length>0){throw new __mf_DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_durationSeconds = obj["durationSeconds" ]as number | null; instance.durationSeconds = __raw_durationSeconds; }{const __raw_source = obj["source" ]as string | null; instance.source = __raw_source; }if(errors.length>0){throw new __mf_DeserializeError(errors);}return instance as Viewed;}export function viewedValidateField<K extends keyof Viewed>(_field: K, _value: Viewed[K]): Array<{field: string; message: string}>{return[]; }export function viewedValidateFields(_partial: Partial<Viewed>): Array<{field: string; message: string}>{return[]; }export function viewedHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "durationSeconds" in o && "source" in o;}export function viewedIs(obj: unknown): obj is Viewed {if(!viewedHasShape(obj)){return false;}const result = viewedDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type ViewedErrors = {_errors: __gf_Option<Array<string>>; durationSeconds: __gf_Option<Array<string>>; source: __gf_Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type ViewedTainted = {durationSeconds: __gf_Option<boolean>; source: __gf_Option<boolean>; }; /** Type-safe field controllers for this form */export interface ViewedFieldControllers {readonly durationSeconds: FieldController<number | null>; readonly source: FieldController<string | null>; }/** Gigaform instance containing reactive state and field controllers */export interface ViewedGigaform {readonly data: Viewed; readonly errors: ViewedErrors; readonly tainted: ViewedTainted; readonly fields: ViewedFieldControllers; validate(): Exit<Viewed, Array<{field: string; message: string}>>; reset(overrides?: Partial<Viewed>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function viewedCreateForm(overrides?: Partial<Viewed>): ViewedGigaform {let data = $state({...viewedDefaultValue(),...overrides}); let errors = $state<ViewedErrors>({_errors: optionNone(), durationSeconds: optionNone(), source: optionNone(), }); let tainted = $state<ViewedTainted>({durationSeconds: optionNone(), source: optionNone(), }); const fields: ViewedFieldControllers = {durationSeconds: {path: ["durationSeconds" ]as const, name: "durationSeconds" , constraints: { required: true }, get: ()=>data.durationSeconds, set: (value: number | null)=>{data.durationSeconds = value;}, transform: (value: number | null): number | null =>value,getError: ()=>errors.durationSeconds, setError: (value: __gf_Option<Array<string>>)=>{errors.durationSeconds = value;}, getTainted: ()=>tainted.durationSeconds, setTainted: (value: __gf_Option<boolean>)=>{tainted.durationSeconds = value;}, validate: (): Array<string>=>{const fieldErrors = viewedValidateField("durationSeconds", data.durationSeconds); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},source: {path: ["source" ]as const, name: "source" , constraints: { required: true }, get: ()=>data.source, set: (value: string | null)=>{data.source = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.source, setError: (value: __gf_Option<Array<string>>)=>{errors.source = value;}, getTainted: ()=>tainted.source, setTainted: (value: __gf_Option<boolean>)=>{tainted.source = value;}, validate: (): Array<string>=>{const fieldErrors = viewedValidateField("source", data.source); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Exit<Viewed, Array<{field: string; message: string}>>{return toExit(viewedDeserialize(data));}function reset(newOverrides?: Partial<Viewed>): void {data = {...viewedDefaultValue(),...newOverrides}; errors = {_errors: optionNone(), durationSeconds: optionNone(), source: optionNone(), }; tainted = {durationSeconds: optionNone(), source: optionNone(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function viewedFromFormData(formData: FormData): Exit<Viewed, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; {const durationSecondsStr = formData.get("durationSeconds" ); obj.durationSeconds = durationSecondsStr? parseFloat(durationSecondsStr as string): 0; if(obj.durationSeconds!== undefined && isNaN(obj.durationSeconds as number))obj.durationSeconds = 0;}obj.source = formData.get("source" )?? "" ;return toExit(viewedDeserialize(obj));}

export const Viewed = {
  defaultValue: viewedDefaultValue,
  serialize: viewedSerialize,
  serializeWithContext: viewedSerializeWithContext,
  deserialize: viewedDeserialize,
  deserializeWithContext: viewedDeserializeWithContext,
  validateFields: viewedValidateFields,
  hasShape: viewedHasShape,
  is: viewedIs,
  createForm: viewedCreateForm,
  fromFormData: viewedFromFormData
} as const;


export interface WeeklyRecurrenceRule {
    quantityOfWeeks: number;
    weekdays: Weekday[];
}

export function weeklyRecurrenceRuleDefaultValue(): WeeklyRecurrenceRule {return {quantityOfWeeks: 0,
                            weekdays: [], }as WeeklyRecurrenceRule;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function weeklyRecurrenceRuleSerialize(value: WeeklyRecurrenceRule): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(weeklyRecurrenceRuleSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function weeklyRecurrenceRuleSerializeWithContext(value: WeeklyRecurrenceRule, ctx: __mf_SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "WeeklyRecurrenceRule" , __id,}; result["quantityOfWeeks" ]= value.quantityOfWeeks; result["weekdays" ]= value.weekdays.map((item)=>weekdaySerializeWithContext(item, ctx)); return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function weeklyRecurrenceRuleDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: WeeklyRecurrenceRule } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = weeklyRecurrenceRuleDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "WeeklyRecurrenceRule.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function weeklyRecurrenceRuleDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): WeeklyRecurrenceRule | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new __mf_DeserializeError([{field: "_root" , message: "WeeklyRecurrenceRule.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("quantityOfWeeks" in obj)){errors.push({field: "quantityOfWeeks" , message: "missing required field" });}if(!("weekdays" in obj)){errors.push({field: "weekdays" , message: "missing required field" });}if(errors.length>0){throw new __mf_DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_quantityOfWeeks = obj["quantityOfWeeks" ]as number; instance.quantityOfWeeks = __raw_quantityOfWeeks; }{const __raw_weekdays = obj["weekdays" ]as Weekday[]; if(Array.isArray(__raw_weekdays)){instance.weekdays = __raw_weekdays as Weekday[];}}if(errors.length>0){throw new __mf_DeserializeError(errors);}return instance as WeeklyRecurrenceRule;}export function weeklyRecurrenceRuleValidateField<K extends keyof WeeklyRecurrenceRule>(_field: K, _value: WeeklyRecurrenceRule[K]): Array<{field: string; message: string}>{return[]; }export function weeklyRecurrenceRuleValidateFields(_partial: Partial<WeeklyRecurrenceRule>): Array<{field: string; message: string}>{return[]; }export function weeklyRecurrenceRuleHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "quantityOfWeeks" in o && "weekdays" in o;}export function weeklyRecurrenceRuleIs(obj: unknown): obj is WeeklyRecurrenceRule {if(!weeklyRecurrenceRuleHasShape(obj)){return false;}const result = weeklyRecurrenceRuleDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type WeeklyRecurrenceRuleErrors = {_errors: __gf_Option<Array<string>>; quantityOfWeeks: __gf_Option<Array<string>>; weekdays: __gf_Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type WeeklyRecurrenceRuleTainted = {quantityOfWeeks: __gf_Option<boolean>; weekdays: __gf_Option<boolean>; }; /** Type-safe field controllers for this form */export interface WeeklyRecurrenceRuleFieldControllers {readonly quantityOfWeeks: FieldController<number>; readonly weekdays: ArrayFieldController<Weekday>; }/** Gigaform instance containing reactive state and field controllers */export interface WeeklyRecurrenceRuleGigaform {readonly data: WeeklyRecurrenceRule; readonly errors: WeeklyRecurrenceRuleErrors; readonly tainted: WeeklyRecurrenceRuleTainted; readonly fields: WeeklyRecurrenceRuleFieldControllers; validate(): Exit<WeeklyRecurrenceRule, Array<{field: string; message: string}>>; reset(overrides?: Partial<WeeklyRecurrenceRule>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function weeklyRecurrenceRuleCreateForm(overrides?: Partial<WeeklyRecurrenceRule>): WeeklyRecurrenceRuleGigaform {let data = $state({...weeklyRecurrenceRuleDefaultValue(),...overrides}); let errors = $state<WeeklyRecurrenceRuleErrors>({_errors: optionNone(), quantityOfWeeks: optionNone(), weekdays: optionNone(), }); let tainted = $state<WeeklyRecurrenceRuleTainted>({quantityOfWeeks: optionNone(), weekdays: optionNone(), }); const fields: WeeklyRecurrenceRuleFieldControllers = {quantityOfWeeks: {path: ["quantityOfWeeks" ]as const, name: "quantityOfWeeks" , constraints: { required: true }, get: ()=>data.quantityOfWeeks, set: (value: number)=>{data.quantityOfWeeks = value;}, transform: (value: number): number =>value,getError: ()=>errors.quantityOfWeeks, setError: (value: __gf_Option<Array<string>>)=>{errors.quantityOfWeeks = value;}, getTainted: ()=>tainted.quantityOfWeeks, setTainted: (value: __gf_Option<boolean>)=>{tainted.quantityOfWeeks = value;}, validate: (): Array<string>=>{const fieldErrors = weeklyRecurrenceRuleValidateField("quantityOfWeeks", data.quantityOfWeeks); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},weekdays: {path: ["weekdays" ]as const, name: "weekdays" , constraints: { required: true }, get: ()=>data.weekdays, set: (value: Weekday[])=>{data.weekdays = value;}, transform: (value: Weekday[]): Weekday[] =>value,getError: ()=>errors.weekdays, setError: (value: __gf_Option<Array<string>>)=>{errors.weekdays = value;}, getTainted: ()=>tainted.weekdays, setTainted: (value: __gf_Option<boolean>)=>{tainted.weekdays = value;}, validate: (): Array<string>=>{const fieldErrors = weeklyRecurrenceRuleValidateField("weekdays", data.weekdays); return fieldErrors.map((e: {field: string; message: string})=>e.message);},at: (index: number)=>({path: ["weekdays" , index]as const, name: `weekdays.${index}` , constraints: {required: true}, get: ()=>data.weekdays[index]!, set: (value: Weekday)=>{data.weekdays[index]= value;}, transform: (value: Weekday): Weekday =>value, getError: ()=>errors.weekdays, setError: (value: __gf_Option<Array<string>>)=>{errors.weekdays = value;}, getTainted: ()=>tainted.weekdays, setTainted: (value: __gf_Option<boolean>)=>{tainted.weekdays = value;}, validate: (): Array<string>=>[],}), push: (item: Weekday)=>{data.weekdays.push(item);}, remove: (index: number)=>{data.weekdays.splice(index, 1);}, swap: (a: number, b: number)=>{const tmp = data.weekdays[a]!; data.weekdays[a]= data.weekdays[b]!; data.weekdays[b]= tmp;},},}; function validate(): Exit<WeeklyRecurrenceRule, Array<{field: string; message: string}>>{return toExit(weeklyRecurrenceRuleDeserialize(data));}function reset(newOverrides?: Partial<WeeklyRecurrenceRule>): void {data = {...weeklyRecurrenceRuleDefaultValue(),...newOverrides}; errors = {_errors: optionNone(), quantityOfWeeks: optionNone(), weekdays: optionNone(), }; tainted = {quantityOfWeeks: optionNone(), weekdays: optionNone(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function weeklyRecurrenceRuleFromFormData(formData: FormData): Exit<WeeklyRecurrenceRule, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; {const quantityOfWeeksStr = formData.get("quantityOfWeeks" ); obj.quantityOfWeeks = quantityOfWeeksStr? parseFloat(quantityOfWeeksStr as string): 0; if(obj.quantityOfWeeks!== undefined && isNaN(obj.quantityOfWeeks as number))obj.quantityOfWeeks = 0;}{const weekdaysItems: Array<Record<string, unknown>>= []; let idx = 0; while(formData.has("weekdays." + idx + "." )|| idx === 0){const hasAny = Array.from(formData.keys()).some(k =>k.startsWith("weekdays." + idx + "." )); if(!hasAny && idx>0)break; if(hasAny){const item: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("weekdays." + idx + "." )){const fieldName = key.slice("weekdays." .length + String(idx).length + 1); item[fieldName]= value;}}weekdaysItems.push(item);}idx ++; if(idx>1000)break;}obj.weekdays = weekdaysItems;}return toExit(weeklyRecurrenceRuleDeserialize(obj));}

export const WeeklyRecurrenceRule = {
  defaultValue: weeklyRecurrenceRuleDefaultValue,
  serialize: weeklyRecurrenceRuleSerialize,
  serializeWithContext: weeklyRecurrenceRuleSerializeWithContext,
  deserialize: weeklyRecurrenceRuleDeserialize,
  deserializeWithContext: weeklyRecurrenceRuleDeserializeWithContext,
  validateFields: weeklyRecurrenceRuleValidateFields,
  hasShape: weeklyRecurrenceRuleHasShape,
  is: weeklyRecurrenceRuleIs,
  createForm: weeklyRecurrenceRuleCreateForm,
  fromFormData: weeklyRecurrenceRuleFromFormData
} as const;


export interface Paid {
    amount: number | null;
    currency: string | null;
    paymentMethod: string | null;
}

export function paidDefaultValue(): Paid {return {amount: null,
                            currency: null,
                            paymentMethod: null, }as Paid;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function paidSerialize(value: Paid): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(paidSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function paidSerializeWithContext(value: Paid, ctx: __mf_SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Paid" , __id,}; result["amount" ]= value.amount; result["currency" ]= value.currency; result["paymentMethod" ]= value.paymentMethod; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function paidDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: Paid } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = paidDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Paid.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function paidDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Paid | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new __mf_DeserializeError([{field: "_root" , message: "Paid.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("amount" in obj)){errors.push({field: "amount" , message: "missing required field" });}if(!("currency" in obj)){errors.push({field: "currency" , message: "missing required field" });}if(!("paymentMethod" in obj)){errors.push({field: "paymentMethod" , message: "missing required field" });}if(errors.length>0){throw new __mf_DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_amount = obj["amount" ]as number | null; instance.amount = __raw_amount; }{const __raw_currency = obj["currency" ]as string | null; instance.currency = __raw_currency; }{const __raw_paymentMethod = obj["paymentMethod" ]as string | null; instance.paymentMethod = __raw_paymentMethod; }if(errors.length>0){throw new __mf_DeserializeError(errors);}return instance as Paid;}export function paidValidateField<K extends keyof Paid>(_field: K, _value: Paid[K]): Array<{field: string; message: string}>{return[]; }export function paidValidateFields(_partial: Partial<Paid>): Array<{field: string; message: string}>{return[]; }export function paidHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "amount" in o && "currency" in o && "paymentMethod" in o;}export function paidIs(obj: unknown): obj is Paid {if(!paidHasShape(obj)){return false;}const result = paidDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type PaidErrors = {_errors: __gf_Option<Array<string>>; amount: __gf_Option<Array<string>>; currency: __gf_Option<Array<string>>; paymentMethod: __gf_Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type PaidTainted = {amount: __gf_Option<boolean>; currency: __gf_Option<boolean>; paymentMethod: __gf_Option<boolean>; }; /** Type-safe field controllers for this form */export interface PaidFieldControllers {readonly amount: FieldController<number | null>; readonly currency: FieldController<string | null>; readonly paymentMethod: FieldController<string | null>; }/** Gigaform instance containing reactive state and field controllers */export interface PaidGigaform {readonly data: Paid; readonly errors: PaidErrors; readonly tainted: PaidTainted; readonly fields: PaidFieldControllers; validate(): Exit<Paid, Array<{field: string; message: string}>>; reset(overrides?: Partial<Paid>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function paidCreateForm(overrides?: Partial<Paid>): PaidGigaform {let data = $state({...paidDefaultValue(),...overrides}); let errors = $state<PaidErrors>({_errors: optionNone(), amount: optionNone(), currency: optionNone(), paymentMethod: optionNone(), }); let tainted = $state<PaidTainted>({amount: optionNone(), currency: optionNone(), paymentMethod: optionNone(), }); const fields: PaidFieldControllers = {amount: {path: ["amount" ]as const, name: "amount" , constraints: { required: true }, get: ()=>data.amount, set: (value: number | null)=>{data.amount = value;}, transform: (value: number | null): number | null =>value,getError: ()=>errors.amount, setError: (value: __gf_Option<Array<string>>)=>{errors.amount = value;}, getTainted: ()=>tainted.amount, setTainted: (value: __gf_Option<boolean>)=>{tainted.amount = value;}, validate: (): Array<string>=>{const fieldErrors = paidValidateField("amount", data.amount); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},currency: {path: ["currency" ]as const, name: "currency" , constraints: { required: true }, get: ()=>data.currency, set: (value: string | null)=>{data.currency = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.currency, setError: (value: __gf_Option<Array<string>>)=>{errors.currency = value;}, getTainted: ()=>tainted.currency, setTainted: (value: __gf_Option<boolean>)=>{tainted.currency = value;}, validate: (): Array<string>=>{const fieldErrors = paidValidateField("currency", data.currency); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},paymentMethod: {path: ["paymentMethod" ]as const, name: "paymentMethod" , constraints: { required: true }, get: ()=>data.paymentMethod, set: (value: string | null)=>{data.paymentMethod = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.paymentMethod, setError: (value: __gf_Option<Array<string>>)=>{errors.paymentMethod = value;}, getTainted: ()=>tainted.paymentMethod, setTainted: (value: __gf_Option<boolean>)=>{tainted.paymentMethod = value;}, validate: (): Array<string>=>{const fieldErrors = paidValidateField("paymentMethod", data.paymentMethod); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Exit<Paid, Array<{field: string; message: string}>>{return toExit(paidDeserialize(data));}function reset(newOverrides?: Partial<Paid>): void {data = {...paidDefaultValue(),...newOverrides}; errors = {_errors: optionNone(), amount: optionNone(), currency: optionNone(), paymentMethod: optionNone(), }; tainted = {amount: optionNone(), currency: optionNone(), paymentMethod: optionNone(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function paidFromFormData(formData: FormData): Exit<Paid, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; {const amountStr = formData.get("amount" ); obj.amount = amountStr? parseFloat(amountStr as string): 0; if(obj.amount!== undefined && isNaN(obj.amount as number))obj.amount = 0;}obj.currency = formData.get("currency" )?? "" ;obj.paymentMethod = formData.get("paymentMethod" )?? "" ;return toExit(paidDeserialize(obj));}

export const Paid = {
  defaultValue: paidDefaultValue,
  serialize: paidSerialize,
  serializeWithContext: paidSerializeWithContext,
  deserialize: paidDeserialize,
  deserializeWithContext: paidDeserializeWithContext,
  validateFields: paidValidateFields,
  hasShape: paidHasShape,
  is: paidIs,
  createForm: paidCreateForm,
  fromFormData: paidFromFormData
} as const;


export interface TaxRate {
    
    id: string;
    
    
    name: string;
    
    
    taxAgency: string;
    
    zip: number;
    
    
    city: string;
    
    
    county: string;
    
    
    state: string;
    
    isActive: boolean;
    
    
    description: string;
    
    
    taxComponents: { [key: string]: number };
}

export function taxRateDefaultValue(): TaxRate {return {id: "",
                            name: "",
                            taxAgency: "",
                            zip: 0,
                            city: "",
                            county: "",
                            state: "",
                            isActive: false,
                            description: "",
                            taxComponents: {}, }as TaxRate;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function taxRateSerialize(value: TaxRate): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(taxRateSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function taxRateSerializeWithContext(value: TaxRate, ctx: __mf_SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "TaxRate" , __id,}; result["id" ]= value.id; result["name" ]= value.name; result["taxAgency" ]= value.taxAgency; result["zip" ]= value.zip; result["city" ]= value.city; result["county" ]= value.county; result["state" ]= value.state; result["isActive" ]= value.isActive; result["description" ]= value.description; result["taxComponents" ]= value.taxComponents; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function taxRateDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: TaxRate } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = taxRateDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "TaxRate.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function taxRateDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): TaxRate | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new __mf_DeserializeError([{field: "_root" , message: "TaxRate.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("id" in obj)){errors.push({field: "id" , message: "missing required field" });}if(!("name" in obj)){errors.push({field: "name" , message: "missing required field" });}if(!("taxAgency" in obj)){errors.push({field: "taxAgency" , message: "missing required field" });}if(!("zip" in obj)){errors.push({field: "zip" , message: "missing required field" });}if(!("city" in obj)){errors.push({field: "city" , message: "missing required field" });}if(!("county" in obj)){errors.push({field: "county" , message: "missing required field" });}if(!("state" in obj)){errors.push({field: "state" , message: "missing required field" });}if(!("isActive" in obj)){errors.push({field: "isActive" , message: "missing required field" });}if(!("description" in obj)){errors.push({field: "description" , message: "missing required field" });}if(!("taxComponents" in obj)){errors.push({field: "taxComponents" , message: "missing required field" });}if(errors.length>0){throw new __mf_DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_id = obj["id" ]as string; instance.id = __raw_id; }{const __raw_name = obj["name" ]as string; 
                if (__raw_name.length === 0) {
                    errors.push({ field: "name", message: "must not be empty" });
                }
 instance.name = __raw_name; }{const __raw_taxAgency = obj["taxAgency" ]as string; 
                if (__raw_taxAgency.length === 0) {
                    errors.push({ field: "taxAgency", message: "must not be empty" });
                }
 instance.taxAgency = __raw_taxAgency; }{const __raw_zip = obj["zip" ]as number; instance.zip = __raw_zip; }{const __raw_city = obj["city" ]as string; 
                if (__raw_city.length === 0) {
                    errors.push({ field: "city", message: "must not be empty" });
                }
 instance.city = __raw_city; }{const __raw_county = obj["county" ]as string; 
                if (__raw_county.length === 0) {
                    errors.push({ field: "county", message: "must not be empty" });
                }
 instance.county = __raw_county; }{const __raw_state = obj["state" ]as string; 
                if (__raw_state.length === 0) {
                    errors.push({ field: "state", message: "must not be empty" });
                }
 instance.state = __raw_state; }{const __raw_isActive = obj["isActive" ]as boolean; instance.isActive = __raw_isActive; }{const __raw_description = obj["description" ]as string; 
                if (__raw_description.length === 0) {
                    errors.push({ field: "description", message: "must not be empty" });
                }
 instance.description = __raw_description; }{const __raw_taxComponents = obj["taxComponents" ]as { [key: string]: number }; instance.taxComponents = __raw_taxComponents; }if(errors.length>0){throw new __mf_DeserializeError(errors);}return instance as TaxRate;}export function taxRateValidateField<K extends keyof TaxRate>(_field: K, _value: TaxRate[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(_field){case "name" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "name", message: "must not be empty" });
                }
 break;}case "taxAgency" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "taxAgency", message: "must not be empty" });
                }
 break;}case "city" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "city", message: "must not be empty" });
                }
 break;}case "county" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "county", message: "must not be empty" });
                }
 break;}case "state" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "state", message: "must not be empty" });
                }
 break;}case "description" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "description", message: "must not be empty" });
                }
 break;}}return errors; }export function taxRateValidateFields(_partial: Partial<TaxRate>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("name" in _partial && _partial.name!== undefined){const __val = _partial.name as string; 
                if (__val.length === 0) {
                    errors.push({ field: "name", message: "must not be empty" });
                }
}if("taxAgency" in _partial && _partial.taxAgency!== undefined){const __val = _partial.taxAgency as string; 
                if (__val.length === 0) {
                    errors.push({ field: "taxAgency", message: "must not be empty" });
                }
}if("city" in _partial && _partial.city!== undefined){const __val = _partial.city as string; 
                if (__val.length === 0) {
                    errors.push({ field: "city", message: "must not be empty" });
                }
}if("county" in _partial && _partial.county!== undefined){const __val = _partial.county as string; 
                if (__val.length === 0) {
                    errors.push({ field: "county", message: "must not be empty" });
                }
}if("state" in _partial && _partial.state!== undefined){const __val = _partial.state as string; 
                if (__val.length === 0) {
                    errors.push({ field: "state", message: "must not be empty" });
                }
}if("description" in _partial && _partial.description!== undefined){const __val = _partial.description as string; 
                if (__val.length === 0) {
                    errors.push({ field: "description", message: "must not be empty" });
                }
}return errors; }export function taxRateHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "id" in o && "name" in o && "taxAgency" in o && "zip" in o && "city" in o && "county" in o && "state" in o && "isActive" in o && "description" in o && "taxComponents" in o;}export function taxRateIs(obj: unknown): obj is TaxRate {if(!taxRateHasShape(obj)){return false;}const result = taxRateDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type TaxRateErrors = {_errors: __gf_Option<Array<string>>; id: __gf_Option<Array<string>>; name: __gf_Option<Array<string>>; taxAgency: __gf_Option<Array<string>>; zip: __gf_Option<Array<string>>; city: __gf_Option<Array<string>>; county: __gf_Option<Array<string>>; state: __gf_Option<Array<string>>; isActive: __gf_Option<Array<string>>; description: __gf_Option<Array<string>>; taxComponents: __gf_Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type TaxRateTainted = {id: __gf_Option<boolean>; name: __gf_Option<boolean>; taxAgency: __gf_Option<boolean>; zip: __gf_Option<boolean>; city: __gf_Option<boolean>; county: __gf_Option<boolean>; state: __gf_Option<boolean>; isActive: __gf_Option<boolean>; description: __gf_Option<boolean>; taxComponents: __gf_Option<boolean>; }; /** Type-safe field controllers for this form */export interface TaxRateFieldControllers {readonly id: FieldController<string>; readonly name: FieldController<string>; readonly taxAgency: FieldController<string>; readonly zip: FieldController<number>; readonly city: FieldController<string>; readonly county: FieldController<string>; readonly state: FieldController<string>; readonly isActive: FieldController<boolean>; readonly description: FieldController<string>; readonly taxComponents: FieldController<{ [key: string]: number }>; }/** Gigaform instance containing reactive state and field controllers */export interface TaxRateGigaform {readonly data: TaxRate; readonly errors: TaxRateErrors; readonly tainted: TaxRateTainted; readonly fields: TaxRateFieldControllers; validate(): Exit<TaxRate, Array<{field: string; message: string}>>; reset(overrides?: Partial<TaxRate>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function taxRateCreateForm(overrides?: Partial<TaxRate>): TaxRateGigaform {let data = $state({...taxRateDefaultValue(),...overrides}); let errors = $state<TaxRateErrors>({_errors: optionNone(), id: optionNone(), name: optionNone(), taxAgency: optionNone(), zip: optionNone(), city: optionNone(), county: optionNone(), state: optionNone(), isActive: optionNone(), description: optionNone(), taxComponents: optionNone(), }); let tainted = $state<TaxRateTainted>({id: optionNone(), name: optionNone(), taxAgency: optionNone(), zip: optionNone(), city: optionNone(), county: optionNone(), state: optionNone(), isActive: optionNone(), description: optionNone(), taxComponents: optionNone(), }); const fields: TaxRateFieldControllers = {id: {path: ["id" ]as const, name: "id" , constraints: { required: true }, get: ()=>data.id, set: (value: string)=>{data.id = value;}, transform: (value: string): string =>value,getError: ()=>errors.id, setError: (value: __gf_Option<Array<string>>)=>{errors.id = value;}, getTainted: ()=>tainted.id, setTainted: (value: __gf_Option<boolean>)=>{tainted.id = value;}, validate: (): Array<string>=>{const fieldErrors = taxRateValidateField("id", data.id); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},name: {path: ["name" ]as const, name: "name" , constraints: { required: true }, label: "Name" , get: ()=>data.name, set: (value: string)=>{data.name = value;}, transform: (value: string): string =>value,getError: ()=>errors.name, setError: (value: __gf_Option<Array<string>>)=>{errors.name = value;}, getTainted: ()=>tainted.name, setTainted: (value: __gf_Option<boolean>)=>{tainted.name = value;}, validate: (): Array<string>=>{const fieldErrors = taxRateValidateField("name", data.name); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},taxAgency: {path: ["taxAgency" ]as const, name: "taxAgency" , constraints: { required: true }, label: "Tax Agency" , get: ()=>data.taxAgency, set: (value: string)=>{data.taxAgency = value;}, transform: (value: string): string =>value,getError: ()=>errors.taxAgency, setError: (value: __gf_Option<Array<string>>)=>{errors.taxAgency = value;}, getTainted: ()=>tainted.taxAgency, setTainted: (value: __gf_Option<boolean>)=>{tainted.taxAgency = value;}, validate: (): Array<string>=>{const fieldErrors = taxRateValidateField("taxAgency", data.taxAgency); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},zip: {path: ["zip" ]as const, name: "zip" , constraints: { required: true }, label: "Zip" , get: ()=>data.zip, set: (value: number)=>{data.zip = value;}, transform: (value: number): number =>value,getError: ()=>errors.zip, setError: (value: __gf_Option<Array<string>>)=>{errors.zip = value;}, getTainted: ()=>tainted.zip, setTainted: (value: __gf_Option<boolean>)=>{tainted.zip = value;}, validate: (): Array<string>=>{const fieldErrors = taxRateValidateField("zip", data.zip); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},city: {path: ["city" ]as const, name: "city" , constraints: { required: true }, label: "City" , get: ()=>data.city, set: (value: string)=>{data.city = value;}, transform: (value: string): string =>value,getError: ()=>errors.city, setError: (value: __gf_Option<Array<string>>)=>{errors.city = value;}, getTainted: ()=>tainted.city, setTainted: (value: __gf_Option<boolean>)=>{tainted.city = value;}, validate: (): Array<string>=>{const fieldErrors = taxRateValidateField("city", data.city); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},county: {path: ["county" ]as const, name: "county" , constraints: { required: true }, label: "County" , get: ()=>data.county, set: (value: string)=>{data.county = value;}, transform: (value: string): string =>value,getError: ()=>errors.county, setError: (value: __gf_Option<Array<string>>)=>{errors.county = value;}, getTainted: ()=>tainted.county, setTainted: (value: __gf_Option<boolean>)=>{tainted.county = value;}, validate: (): Array<string>=>{const fieldErrors = taxRateValidateField("county", data.county); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},state: {path: ["state" ]as const, name: "state" , constraints: { required: true }, label: "State" , get: ()=>data.state, set: (value: string)=>{data.state = value;}, transform: (value: string): string =>value,getError: ()=>errors.state, setError: (value: __gf_Option<Array<string>>)=>{errors.state = value;}, getTainted: ()=>tainted.state, setTainted: (value: __gf_Option<boolean>)=>{tainted.state = value;}, validate: (): Array<string>=>{const fieldErrors = taxRateValidateField("state", data.state); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},isActive: {path: ["isActive" ]as const, name: "isActive" , constraints: { required: true }, label: "Active" , get: ()=>data.isActive, set: (value: boolean)=>{data.isActive = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.isActive, setError: (value: __gf_Option<Array<string>>)=>{errors.isActive = value;}, getTainted: ()=>tainted.isActive, setTainted: (value: __gf_Option<boolean>)=>{tainted.isActive = value;}, validate: (): Array<string>=>{const fieldErrors = taxRateValidateField("isActive", data.isActive); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},description: {path: ["description" ]as const, name: "description" , constraints: { required: true }, label: "Description" , get: ()=>data.description, set: (value: string)=>{data.description = value;}, transform: (value: string): string =>value,getError: ()=>errors.description, setError: (value: __gf_Option<Array<string>>)=>{errors.description = value;}, getTainted: ()=>tainted.description, setTainted: (value: __gf_Option<boolean>)=>{tainted.description = value;}, validate: (): Array<string>=>{const fieldErrors = taxRateValidateField("description", data.description); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},taxComponents: {path: ["taxComponents" ]as const, name: "taxComponents" , constraints: { required: true }, get: ()=>data.taxComponents, set: (value: { [key: string]: number })=>{data.taxComponents = value;}, transform: (value: { [key: string]: number }): { [key: string]: number } =>value,getError: ()=>errors.taxComponents, setError: (value: __gf_Option<Array<string>>)=>{errors.taxComponents = value;}, getTainted: ()=>tainted.taxComponents, setTainted: (value: __gf_Option<boolean>)=>{tainted.taxComponents = value;}, validate: (): Array<string>=>{const fieldErrors = taxRateValidateField("taxComponents", data.taxComponents); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Exit<TaxRate, Array<{field: string; message: string}>>{return toExit(taxRateDeserialize(data));}function reset(newOverrides?: Partial<TaxRate>): void {data = {...taxRateDefaultValue(),...newOverrides}; errors = {_errors: optionNone(), id: optionNone(), name: optionNone(), taxAgency: optionNone(), zip: optionNone(), city: optionNone(), county: optionNone(), state: optionNone(), isActive: optionNone(), description: optionNone(), taxComponents: optionNone(), }; tainted = {id: optionNone(), name: optionNone(), taxAgency: optionNone(), zip: optionNone(), city: optionNone(), county: optionNone(), state: optionNone(), isActive: optionNone(), description: optionNone(), taxComponents: optionNone(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function taxRateFromFormData(formData: FormData): Exit<TaxRate, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.id = formData.get("id" )?? "" ;obj.name = formData.get("name" )?? "" ;obj.taxAgency = formData.get("taxAgency" )?? "" ;{const zipStr = formData.get("zip" ); obj.zip = zipStr? parseFloat(zipStr as string): 0; if(obj.zip!== undefined && isNaN(obj.zip as number))obj.zip = 0;}obj.city = formData.get("city" )?? "" ;obj.county = formData.get("county" )?? "" ;obj.state = formData.get("state" )?? "" ;{const isActiveVal = formData.get("isActive" ); obj.isActive = isActiveVal === "true" || isActiveVal === "on" || isActiveVal === "1" ;}obj.description = formData.get("description" )?? "" ;obj.taxComponents = formData.get("taxComponents" )?? "" ;return toExit(taxRateDeserialize(obj));}

export const TaxRate = {
  defaultValue: taxRateDefaultValue,
  serialize: taxRateSerialize,
  serializeWithContext: taxRateSerializeWithContext,
  deserialize: taxRateDeserialize,
  deserializeWithContext: taxRateDeserializeWithContext,
  validateFields: taxRateValidateFields,
  hasShape: taxRateHasShape,
  is: taxRateIs,
  createForm: taxRateCreateForm,
  fromFormData: taxRateFromFormData
} as const;


export interface Address {
    
    street: string;
    
    city: string;
    
    state: string;
    
    zipcode: string;
}

export function addressDefaultValue(): Address {return {street: "",
                            city: "",
                            state: "",
                            zipcode: "", }as Address;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function addressSerialize(value: Address): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(addressSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function addressSerializeWithContext(value: Address, ctx: __mf_SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Address" , __id,}; result["street" ]= value.street; result["city" ]= value.city; result["state" ]= value.state; result["zipcode" ]= value.zipcode; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function addressDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: Address } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = addressDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Address.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function addressDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Address | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new __mf_DeserializeError([{field: "_root" , message: "Address.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("street" in obj)){errors.push({field: "street" , message: "missing required field" });}if(!("city" in obj)){errors.push({field: "city" , message: "missing required field" });}if(!("state" in obj)){errors.push({field: "state" , message: "missing required field" });}if(!("zipcode" in obj)){errors.push({field: "zipcode" , message: "missing required field" });}if(errors.length>0){throw new __mf_DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_street = obj["street" ]as string; 
                if (__raw_street.length === 0) {
                    errors.push({ field: "street", message: "must not be empty" });
                }
 instance.street = __raw_street; }{const __raw_city = obj["city" ]as string; 
                if (__raw_city.length === 0) {
                    errors.push({ field: "city", message: "must not be empty" });
                }
 instance.city = __raw_city; }{const __raw_state = obj["state" ]as string; 
                if (__raw_state.length === 0) {
                    errors.push({ field: "state", message: "must not be empty" });
                }
 instance.state = __raw_state; }{const __raw_zipcode = obj["zipcode" ]as string; 
                if (__raw_zipcode.length === 0) {
                    errors.push({ field: "zipcode", message: "must not be empty" });
                }
 instance.zipcode = __raw_zipcode; }if(errors.length>0){throw new __mf_DeserializeError(errors);}return instance as Address;}export function addressValidateField<K extends keyof Address>(_field: K, _value: Address[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(_field){case "street" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "street", message: "must not be empty" });
                }
 break;}case "city" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "city", message: "must not be empty" });
                }
 break;}case "state" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "state", message: "must not be empty" });
                }
 break;}case "zipcode" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "zipcode", message: "must not be empty" });
                }
 break;}}return errors; }export function addressValidateFields(_partial: Partial<Address>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("street" in _partial && _partial.street!== undefined){const __val = _partial.street as string; 
                if (__val.length === 0) {
                    errors.push({ field: "street", message: "must not be empty" });
                }
}if("city" in _partial && _partial.city!== undefined){const __val = _partial.city as string; 
                if (__val.length === 0) {
                    errors.push({ field: "city", message: "must not be empty" });
                }
}if("state" in _partial && _partial.state!== undefined){const __val = _partial.state as string; 
                if (__val.length === 0) {
                    errors.push({ field: "state", message: "must not be empty" });
                }
}if("zipcode" in _partial && _partial.zipcode!== undefined){const __val = _partial.zipcode as string; 
                if (__val.length === 0) {
                    errors.push({ field: "zipcode", message: "must not be empty" });
                }
}return errors; }export function addressHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "street" in o && "city" in o && "state" in o && "zipcode" in o;}export function addressIs(obj: unknown): obj is Address {if(!addressHasShape(obj)){return false;}const result = addressDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type AddressErrors = {_errors: __gf_Option<Array<string>>; street: __gf_Option<Array<string>>; city: __gf_Option<Array<string>>; state: __gf_Option<Array<string>>; zipcode: __gf_Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type AddressTainted = {street: __gf_Option<boolean>; city: __gf_Option<boolean>; state: __gf_Option<boolean>; zipcode: __gf_Option<boolean>; }; /** Type-safe field controllers for this form */export interface AddressFieldControllers {readonly street: FieldController<string>; readonly city: FieldController<string>; readonly state: FieldController<string>; readonly zipcode: FieldController<string>; }/** Gigaform instance containing reactive state and field controllers */export interface AddressGigaform {readonly data: Address; readonly errors: AddressErrors; readonly tainted: AddressTainted; readonly fields: AddressFieldControllers; validate(): Exit<Address, Array<{field: string; message: string}>>; reset(overrides?: Partial<Address>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function addressCreateForm(overrides?: Partial<Address>): AddressGigaform {let data = $state({...addressDefaultValue(),...overrides}); let errors = $state<AddressErrors>({_errors: optionNone(), street: optionNone(), city: optionNone(), state: optionNone(), zipcode: optionNone(), }); let tainted = $state<AddressTainted>({street: optionNone(), city: optionNone(), state: optionNone(), zipcode: optionNone(), }); const fields: AddressFieldControllers = {street: {path: ["street" ]as const, name: "street" , constraints: { required: true }, get: ()=>data.street, set: (value: string)=>{data.street = value;}, transform: (value: string): string =>value,getError: ()=>errors.street, setError: (value: __gf_Option<Array<string>>)=>{errors.street = value;}, getTainted: ()=>tainted.street, setTainted: (value: __gf_Option<boolean>)=>{tainted.street = value;}, validate: (): Array<string>=>{const fieldErrors = addressValidateField("street", data.street); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},city: {path: ["city" ]as const, name: "city" , constraints: { required: true }, get: ()=>data.city, set: (value: string)=>{data.city = value;}, transform: (value: string): string =>value,getError: ()=>errors.city, setError: (value: __gf_Option<Array<string>>)=>{errors.city = value;}, getTainted: ()=>tainted.city, setTainted: (value: __gf_Option<boolean>)=>{tainted.city = value;}, validate: (): Array<string>=>{const fieldErrors = addressValidateField("city", data.city); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},state: {path: ["state" ]as const, name: "state" , constraints: { required: true }, get: ()=>data.state, set: (value: string)=>{data.state = value;}, transform: (value: string): string =>value,getError: ()=>errors.state, setError: (value: __gf_Option<Array<string>>)=>{errors.state = value;}, getTainted: ()=>tainted.state, setTainted: (value: __gf_Option<boolean>)=>{tainted.state = value;}, validate: (): Array<string>=>{const fieldErrors = addressValidateField("state", data.state); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},zipcode: {path: ["zipcode" ]as const, name: "zipcode" , constraints: { required: true }, get: ()=>data.zipcode, set: (value: string)=>{data.zipcode = value;}, transform: (value: string): string =>value,getError: ()=>errors.zipcode, setError: (value: __gf_Option<Array<string>>)=>{errors.zipcode = value;}, getTainted: ()=>tainted.zipcode, setTainted: (value: __gf_Option<boolean>)=>{tainted.zipcode = value;}, validate: (): Array<string>=>{const fieldErrors = addressValidateField("zipcode", data.zipcode); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Exit<Address, Array<{field: string; message: string}>>{return toExit(addressDeserialize(data));}function reset(newOverrides?: Partial<Address>): void {data = {...addressDefaultValue(),...newOverrides}; errors = {_errors: optionNone(), street: optionNone(), city: optionNone(), state: optionNone(), zipcode: optionNone(), }; tainted = {street: optionNone(), city: optionNone(), state: optionNone(), zipcode: optionNone(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function addressFromFormData(formData: FormData): Exit<Address, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.street = formData.get("street" )?? "" ;obj.city = formData.get("city" )?? "" ;obj.state = formData.get("state" )?? "" ;obj.zipcode = formData.get("zipcode" )?? "" ;return toExit(addressDeserialize(obj));}

export const Address = {
  defaultValue: addressDefaultValue,
  serialize: addressSerialize,
  serializeWithContext: addressSerializeWithContext,
  deserialize: addressDeserialize,
  deserializeWithContext: addressDeserializeWithContext,
  validateFields: addressValidateFields,
  hasShape: addressHasShape,
  is: addressIs,
  createForm: addressCreateForm,
  fromFormData: addressFromFormData
} as const;


export interface Lead {
    
    id: string;
    
    number: number | null;
    
    accepted: boolean;
    
    probability: number;
    
    
    priority: Priority;
    
    dueDate: string | null;
    
    closeDate: string | null;
    
    value: number;
    
    
    stage: LeadStage;
    
    
    status: string;
    
    description: string | null;
    
    
    nextStep: NextStep;
    
    favorite: boolean;
    
    dateAdded: string | null;
    
    taxRate: (string | TaxRate) | null;
    
    
    sector: Sector;
    
    leadName: AccountName;
    
    phones: PhoneNumber[];
    
    email: Email;
    
    leadSource: string | null;
    
    
    site: string | Site;
    
    
    memo: string;
    
    needsReview: boolean;
    
    hasAlert: boolean;
    
    salesRep: Represents[] | null;
    
    color: string | null;
    
    
    accountType: string;
    
    
    subtype: string;
    
    isTaxExempt: boolean;
    
    
    paymentTerms: string;
    
    tags: string[];
    
    customFields: [string, string][];
}

export function leadDefaultValue(): Lead {return {id: "",
                            number: null,
                            accepted: false,
                            probability: 0,
                            priority: "Medium",
                            dueDate: null,
                            closeDate: null,
                            value: 0,
                            stage: "Open",
                            status: "",
                            description: null,
                            nextStep: "InitialContact",
                            favorite: false,
                            dateAdded: null,
                            taxRate: null,
                            sector: "Residential",
                            leadName: accountNameDefaultValue(),
                            phones: [],
                            email: emailDefaultValue(),
                            leadSource: null,
                            site: "",
                            memo: "",
                            needsReview: false,
                            hasAlert: false,
                            salesRep: null,
                            color: null,
                            accountType: "",
                            subtype: "",
                            isTaxExempt: false,
                            paymentTerms: "",
                            tags: [],
                            customFields: [], }as Lead;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function leadSerialize(value: Lead): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(leadSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function leadSerializeWithContext(value: Lead, ctx: __mf_SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Lead" , __id,}; result["id" ]= value.id; result["number" ]= value.number; result["accepted" ]= value.accepted; result["probability" ]= value.probability; result["priority" ]= prioritySerializeWithContext(value.priority, ctx); result["dueDate" ]= value.dueDate; result["closeDate" ]= value.closeDate; result["value" ]= value.value; result["stage" ]= leadStageSerializeWithContext(value.stage, ctx); result["status" ]= value.status; result["description" ]= value.description; result["nextStep" ]= nextStepSerializeWithContext(value.nextStep, ctx); result["favorite" ]= value.favorite; result["dateAdded" ]= value.dateAdded; if(value.taxRate!== null){result["taxRate" ]= value.taxRate; }else {result["taxRate" ]= null;}result["sector" ]= sectorSerializeWithContext(value.sector, ctx); result["leadName" ]= accountNameSerializeWithContext(value.leadName, ctx); result["phones" ]= value.phones.map((item)=>phoneNumberSerializeWithContext(item, ctx)); result["email" ]= emailSerializeWithContext(value.email, ctx); result["leadSource" ]= value.leadSource; result["site" ]= value.site; result["memo" ]= value.memo; result["needsReview" ]= value.needsReview; result["hasAlert" ]= value.hasAlert; if(value.salesRep!== null){result["salesRep" ]= value.salesRep; }else {result["salesRep" ]= null;}result["color" ]= value.color; result["accountType" ]= value.accountType; result["subtype" ]= value.subtype; result["isTaxExempt" ]= value.isTaxExempt; result["paymentTerms" ]= value.paymentTerms; result["tags" ]= value.tags; result["customFields" ]= value.customFields; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function leadDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: Lead } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = leadDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Lead.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function leadDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Lead | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new __mf_DeserializeError([{field: "_root" , message: "Lead.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("id" in obj)){errors.push({field: "id" , message: "missing required field" });}if(!("number" in obj)){errors.push({field: "number" , message: "missing required field" });}if(!("accepted" in obj)){errors.push({field: "accepted" , message: "missing required field" });}if(!("probability" in obj)){errors.push({field: "probability" , message: "missing required field" });}if(!("priority" in obj)){errors.push({field: "priority" , message: "missing required field" });}if(!("dueDate" in obj)){errors.push({field: "dueDate" , message: "missing required field" });}if(!("closeDate" in obj)){errors.push({field: "closeDate" , message: "missing required field" });}if(!("value" in obj)){errors.push({field: "value" , message: "missing required field" });}if(!("stage" in obj)){errors.push({field: "stage" , message: "missing required field" });}if(!("status" in obj)){errors.push({field: "status" , message: "missing required field" });}if(!("description" in obj)){errors.push({field: "description" , message: "missing required field" });}if(!("nextStep" in obj)){errors.push({field: "nextStep" , message: "missing required field" });}if(!("favorite" in obj)){errors.push({field: "favorite" , message: "missing required field" });}if(!("dateAdded" in obj)){errors.push({field: "dateAdded" , message: "missing required field" });}if(!("taxRate" in obj)){errors.push({field: "taxRate" , message: "missing required field" });}if(!("sector" in obj)){errors.push({field: "sector" , message: "missing required field" });}if(!("leadName" in obj)){errors.push({field: "leadName" , message: "missing required field" });}if(!("phones" in obj)){errors.push({field: "phones" , message: "missing required field" });}if(!("email" in obj)){errors.push({field: "email" , message: "missing required field" });}if(!("leadSource" in obj)){errors.push({field: "leadSource" , message: "missing required field" });}if(!("site" in obj)){errors.push({field: "site" , message: "missing required field" });}if(!("memo" in obj)){errors.push({field: "memo" , message: "missing required field" });}if(!("needsReview" in obj)){errors.push({field: "needsReview" , message: "missing required field" });}if(!("hasAlert" in obj)){errors.push({field: "hasAlert" , message: "missing required field" });}if(!("salesRep" in obj)){errors.push({field: "salesRep" , message: "missing required field" });}if(!("color" in obj)){errors.push({field: "color" , message: "missing required field" });}if(!("accountType" in obj)){errors.push({field: "accountType" , message: "missing required field" });}if(!("subtype" in obj)){errors.push({field: "subtype" , message: "missing required field" });}if(!("isTaxExempt" in obj)){errors.push({field: "isTaxExempt" , message: "missing required field" });}if(!("paymentTerms" in obj)){errors.push({field: "paymentTerms" , message: "missing required field" });}if(!("tags" in obj)){errors.push({field: "tags" , message: "missing required field" });}if(!("customFields" in obj)){errors.push({field: "customFields" , message: "missing required field" });}if(errors.length>0){throw new __mf_DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_id = obj["id" ]as string; instance.id = __raw_id; }{const __raw_number = obj["number" ]as number | null; instance.number = __raw_number; }{const __raw_accepted = obj["accepted" ]as boolean; instance.accepted = __raw_accepted; }{const __raw_probability = obj["probability" ]as number; instance.probability = __raw_probability; }{const __raw_priority = obj["priority" ]as Priority; {const __result = priorityDeserializeWithContext(__raw_priority, ctx); ctx.assignOrDefer(instance, "priority" , __result);}}{const __raw_dueDate = obj["dueDate" ]as string | null; instance.dueDate = __raw_dueDate; }{const __raw_closeDate = obj["closeDate" ]as string | null; instance.closeDate = __raw_closeDate; }{const __raw_value = obj["value" ]as number; instance.value = __raw_value; }{const __raw_stage = obj["stage" ]as LeadStage; {const __result = leadStageDeserializeWithContext(__raw_stage, ctx); ctx.assignOrDefer(instance, "stage" , __result);}}{const __raw_status = obj["status" ]as string; 
                if (__raw_status.length === 0) {
                    errors.push({ field: "status", message: "must not be empty" });
                }
 instance.status = __raw_status; }{const __raw_description = obj["description" ]as string | null; instance.description = __raw_description; }{const __raw_nextStep = obj["nextStep" ]as NextStep; {const __result = nextStepDeserializeWithContext(__raw_nextStep, ctx); ctx.assignOrDefer(instance, "nextStep" , __result);}}{const __raw_favorite = obj["favorite" ]as boolean; instance.favorite = __raw_favorite; }{const __raw_dateAdded = obj["dateAdded" ]as string | null; instance.dateAdded = __raw_dateAdded; }{const __raw_taxRate = obj["taxRate" ]as (string | TaxRate) | null; if(__raw_taxRate === null){instance.taxRate = null;}else {instance.taxRate = __raw_taxRate; }}{const __raw_sector = obj["sector" ]as Sector; {const __result = sectorDeserializeWithContext(__raw_sector, ctx); ctx.assignOrDefer(instance, "sector" , __result);}}{const __raw_leadName = obj["leadName" ]as AccountName; {const __result = accountNameDeserializeWithContext(__raw_leadName, ctx); ctx.assignOrDefer(instance, "leadName" , __result);}}{const __raw_phones = obj["phones" ]as PhoneNumber[]; if(Array.isArray(__raw_phones)){instance.phones = __raw_phones as PhoneNumber[];}}{const __raw_email = obj["email" ]as Email; {const __result = emailDeserializeWithContext(__raw_email, ctx); ctx.assignOrDefer(instance, "email" , __result);}}{const __raw_leadSource = obj["leadSource" ]as string | null; instance.leadSource = __raw_leadSource; }{const __raw_site = obj["site" ]as string | Site; instance.site = __raw_site; }{const __raw_memo = obj["memo" ]as string; 
                if (__raw_memo.length === 0) {
                    errors.push({ field: "memo", message: "must not be empty" });
                }
 instance.memo = __raw_memo; }{const __raw_needsReview = obj["needsReview" ]as boolean; instance.needsReview = __raw_needsReview; }{const __raw_hasAlert = obj["hasAlert" ]as boolean; instance.hasAlert = __raw_hasAlert; }{const __raw_salesRep = obj["salesRep" ]as Represents[] | null; if(__raw_salesRep === null){instance.salesRep = null;}else {instance.salesRep = __raw_salesRep; }}{const __raw_color = obj["color" ]as string | null; instance.color = __raw_color; }{const __raw_accountType = obj["accountType" ]as string; 
                if (__raw_accountType.length === 0) {
                    errors.push({ field: "accountType", message: "must not be empty" });
                }
 instance.accountType = __raw_accountType; }{const __raw_subtype = obj["subtype" ]as string; 
                if (__raw_subtype.length === 0) {
                    errors.push({ field: "subtype", message: "must not be empty" });
                }
 instance.subtype = __raw_subtype; }{const __raw_isTaxExempt = obj["isTaxExempt" ]as boolean; instance.isTaxExempt = __raw_isTaxExempt; }{const __raw_paymentTerms = obj["paymentTerms" ]as string; 
                if (__raw_paymentTerms.length === 0) {
                    errors.push({ field: "paymentTerms", message: "must not be empty" });
                }
 instance.paymentTerms = __raw_paymentTerms; }{const __raw_tags = obj["tags" ]as string[]; if(Array.isArray(__raw_tags)){instance.tags = __raw_tags as string[];}}{const __raw_customFields = obj["customFields" ]as [string, string][]; if(Array.isArray(__raw_customFields)){instance.customFields = __raw_customFields as [string, string][];}}if(errors.length>0){throw new __mf_DeserializeError(errors);}return instance as Lead;}export function leadValidateField<K extends keyof Lead>(_field: K, _value: Lead[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(_field){case "status" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "status", message: "must not be empty" });
                }
 break;}case "memo" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "memo", message: "must not be empty" });
                }
 break;}case "accountType" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "accountType", message: "must not be empty" });
                }
 break;}case "subtype" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "subtype", message: "must not be empty" });
                }
 break;}case "paymentTerms" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "paymentTerms", message: "must not be empty" });
                }
 break;}}return errors; }export function leadValidateFields(_partial: Partial<Lead>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("status" in _partial && _partial.status!== undefined){const __val = _partial.status as string; 
                if (__val.length === 0) {
                    errors.push({ field: "status", message: "must not be empty" });
                }
}if("memo" in _partial && _partial.memo!== undefined){const __val = _partial.memo as string; 
                if (__val.length === 0) {
                    errors.push({ field: "memo", message: "must not be empty" });
                }
}if("accountType" in _partial && _partial.accountType!== undefined){const __val = _partial.accountType as string; 
                if (__val.length === 0) {
                    errors.push({ field: "accountType", message: "must not be empty" });
                }
}if("subtype" in _partial && _partial.subtype!== undefined){const __val = _partial.subtype as string; 
                if (__val.length === 0) {
                    errors.push({ field: "subtype", message: "must not be empty" });
                }
}if("paymentTerms" in _partial && _partial.paymentTerms!== undefined){const __val = _partial.paymentTerms as string; 
                if (__val.length === 0) {
                    errors.push({ field: "paymentTerms", message: "must not be empty" });
                }
}return errors; }export function leadHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "id" in o && "number" in o && "accepted" in o && "probability" in o && "priority" in o && "dueDate" in o && "closeDate" in o && "value" in o && "stage" in o && "status" in o && "description" in o && "nextStep" in o && "favorite" in o && "dateAdded" in o && "taxRate" in o && "sector" in o && "leadName" in o && "phones" in o && "email" in o && "leadSource" in o && "site" in o && "memo" in o && "needsReview" in o && "hasAlert" in o && "salesRep" in o && "color" in o && "accountType" in o && "subtype" in o && "isTaxExempt" in o && "paymentTerms" in o && "tags" in o && "customFields" in o;}export function leadIs(obj: unknown): obj is Lead {if(!leadHasShape(obj)){return false;}const result = leadDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type LeadErrors = {_errors: __gf_Option<Array<string>>; id: __gf_Option<Array<string>>; number: __gf_Option<Array<string>>; accepted: __gf_Option<Array<string>>; probability: __gf_Option<Array<string>>; priority: __gf_Option<Array<string>>; dueDate: __gf_Option<Array<string>>; closeDate: __gf_Option<Array<string>>; value: __gf_Option<Array<string>>; stage: __gf_Option<Array<string>>; status: __gf_Option<Array<string>>; description: __gf_Option<Array<string>>; nextStep: __gf_Option<Array<string>>; favorite: __gf_Option<Array<string>>; dateAdded: __gf_Option<Array<string>>; taxRate: __gf_Option<Array<string>>; sector: __gf_Option<Array<string>>; leadName: __gf_Option<Array<string>>; phones: __gf_Option<Array<string>>; email: __gf_Option<Array<string>>; leadSource: __gf_Option<Array<string>>; site: __gf_Option<Array<string>>; memo: __gf_Option<Array<string>>; needsReview: __gf_Option<Array<string>>; hasAlert: __gf_Option<Array<string>>; salesRep: __gf_Option<Array<string>>; color: __gf_Option<Array<string>>; accountType: __gf_Option<Array<string>>; subtype: __gf_Option<Array<string>>; isTaxExempt: __gf_Option<Array<string>>; paymentTerms: __gf_Option<Array<string>>; tags: __gf_Option<Array<string>>; customFields: __gf_Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type LeadTainted = {id: __gf_Option<boolean>; number: __gf_Option<boolean>; accepted: __gf_Option<boolean>; probability: __gf_Option<boolean>; priority: __gf_Option<boolean>; dueDate: __gf_Option<boolean>; closeDate: __gf_Option<boolean>; value: __gf_Option<boolean>; stage: __gf_Option<boolean>; status: __gf_Option<boolean>; description: __gf_Option<boolean>; nextStep: __gf_Option<boolean>; favorite: __gf_Option<boolean>; dateAdded: __gf_Option<boolean>; taxRate: __gf_Option<boolean>; sector: __gf_Option<boolean>; leadName: __gf_Option<boolean>; phones: __gf_Option<boolean>; email: __gf_Option<boolean>; leadSource: __gf_Option<boolean>; site: __gf_Option<boolean>; memo: __gf_Option<boolean>; needsReview: __gf_Option<boolean>; hasAlert: __gf_Option<boolean>; salesRep: __gf_Option<boolean>; color: __gf_Option<boolean>; accountType: __gf_Option<boolean>; subtype: __gf_Option<boolean>; isTaxExempt: __gf_Option<boolean>; paymentTerms: __gf_Option<boolean>; tags: __gf_Option<boolean>; customFields: __gf_Option<boolean>; }; /** Type-safe field controllers for this form */export interface LeadFieldControllers {readonly id: FieldController<string>; readonly number: FieldController<number | null>; readonly accepted: FieldController<boolean>; readonly probability: FieldController<number>; readonly priority: FieldController<Priority>; readonly dueDate: FieldController<string | null>; readonly closeDate: FieldController<string | null>; readonly value: FieldController<number>; readonly stage: FieldController<LeadStage>; readonly status: FieldController<string>; readonly description: FieldController<string | null>; readonly nextStep: FieldController<NextStep>; readonly favorite: FieldController<boolean>; readonly dateAdded: FieldController<string | null>; readonly taxRate: FieldController<(string | TaxRate) | null>; readonly sector: FieldController<Sector>; readonly leadName: FieldController<AccountName>; readonly phones: ArrayFieldController<PhoneNumber>; readonly email: FieldController<Email>; readonly leadSource: FieldController<string | null>; readonly site: FieldController<string | Site>; readonly memo: FieldController<string>; readonly needsReview: FieldController<boolean>; readonly hasAlert: FieldController<boolean>; readonly salesRep: FieldController<Represents[] | null>; readonly color: FieldController<string | null>; readonly accountType: FieldController<string>; readonly subtype: FieldController<string>; readonly isTaxExempt: FieldController<boolean>; readonly paymentTerms: FieldController<string>; readonly tags: ArrayFieldController<string>; readonly customFields: ArrayFieldController<[string, string]>; }/** Gigaform instance containing reactive state and field controllers */export interface LeadGigaform {readonly data: Lead; readonly errors: LeadErrors; readonly tainted: LeadTainted; readonly fields: LeadFieldControllers; validate(): Exit<Lead, Array<{field: string; message: string}>>; reset(overrides?: Partial<Lead>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function leadCreateForm(overrides?: Partial<Lead>): LeadGigaform {let data = $state({...leadDefaultValue(),...overrides}); let errors = $state<LeadErrors>({_errors: optionNone(), id: optionNone(), number: optionNone(), accepted: optionNone(), probability: optionNone(), priority: optionNone(), dueDate: optionNone(), closeDate: optionNone(), value: optionNone(), stage: optionNone(), status: optionNone(), description: optionNone(), nextStep: optionNone(), favorite: optionNone(), dateAdded: optionNone(), taxRate: optionNone(), sector: optionNone(), leadName: optionNone(), phones: optionNone(), email: optionNone(), leadSource: optionNone(), site: optionNone(), memo: optionNone(), needsReview: optionNone(), hasAlert: optionNone(), salesRep: optionNone(), color: optionNone(), accountType: optionNone(), subtype: optionNone(), isTaxExempt: optionNone(), paymentTerms: optionNone(), tags: optionNone(), customFields: optionNone(), }); let tainted = $state<LeadTainted>({id: optionNone(), number: optionNone(), accepted: optionNone(), probability: optionNone(), priority: optionNone(), dueDate: optionNone(), closeDate: optionNone(), value: optionNone(), stage: optionNone(), status: optionNone(), description: optionNone(), nextStep: optionNone(), favorite: optionNone(), dateAdded: optionNone(), taxRate: optionNone(), sector: optionNone(), leadName: optionNone(), phones: optionNone(), email: optionNone(), leadSource: optionNone(), site: optionNone(), memo: optionNone(), needsReview: optionNone(), hasAlert: optionNone(), salesRep: optionNone(), color: optionNone(), accountType: optionNone(), subtype: optionNone(), isTaxExempt: optionNone(), paymentTerms: optionNone(), tags: optionNone(), customFields: optionNone(), }); const fields: LeadFieldControllers = {id: {path: ["id" ]as const, name: "id" , constraints: { required: true }, get: ()=>data.id, set: (value: string)=>{data.id = value;}, transform: (value: string): string =>value,getError: ()=>errors.id, setError: (value: __gf_Option<Array<string>>)=>{errors.id = value;}, getTainted: ()=>tainted.id, setTainted: (value: __gf_Option<boolean>)=>{tainted.id = value;}, validate: (): Array<string>=>{const fieldErrors = leadValidateField("id", data.id); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},number: {path: ["number" ]as const, name: "number" , constraints: { required: true }, get: ()=>data.number, set: (value: number | null)=>{data.number = value;}, transform: (value: number | null): number | null =>value,getError: ()=>errors.number, setError: (value: __gf_Option<Array<string>>)=>{errors.number = value;}, getTainted: ()=>tainted.number, setTainted: (value: __gf_Option<boolean>)=>{tainted.number = value;}, validate: (): Array<string>=>{const fieldErrors = leadValidateField("number", data.number); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},accepted: {path: ["accepted" ]as const, name: "accepted" , constraints: { required: true }, get: ()=>data.accepted, set: (value: boolean)=>{data.accepted = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.accepted, setError: (value: __gf_Option<Array<string>>)=>{errors.accepted = value;}, getTainted: ()=>tainted.accepted, setTainted: (value: __gf_Option<boolean>)=>{tainted.accepted = value;}, validate: (): Array<string>=>{const fieldErrors = leadValidateField("accepted", data.accepted); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},probability: {path: ["probability" ]as const, name: "probability" , constraints: { required: true }, label: "Probability" , get: ()=>data.probability, set: (value: number)=>{data.probability = value;}, transform: (value: number): number =>value,getError: ()=>errors.probability, setError: (value: __gf_Option<Array<string>>)=>{errors.probability = value;}, getTainted: ()=>tainted.probability, setTainted: (value: __gf_Option<boolean>)=>{tainted.probability = value;}, validate: (): Array<string>=>{const fieldErrors = leadValidateField("probability", data.probability); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},priority: {path: ["priority" ]as const, name: "priority" , constraints: { required: true }, label: "Priority" , get: ()=>data.priority, set: (value: Priority)=>{data.priority = value;}, transform: (value: Priority): Priority =>value,getError: ()=>errors.priority, setError: (value: __gf_Option<Array<string>>)=>{errors.priority = value;}, getTainted: ()=>tainted.priority, setTainted: (value: __gf_Option<boolean>)=>{tainted.priority = value;}, validate: (): Array<string>=>{const fieldErrors = leadValidateField("priority", data.priority); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},dueDate: {path: ["dueDate" ]as const, name: "dueDate" , constraints: { required: true }, label: "Due Date" , get: ()=>data.dueDate, set: (value: string | null)=>{data.dueDate = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.dueDate, setError: (value: __gf_Option<Array<string>>)=>{errors.dueDate = value;}, getTainted: ()=>tainted.dueDate, setTainted: (value: __gf_Option<boolean>)=>{tainted.dueDate = value;}, validate: (): Array<string>=>{const fieldErrors = leadValidateField("dueDate", data.dueDate); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},closeDate: {path: ["closeDate" ]as const, name: "closeDate" , constraints: { required: true }, label: "Close Date" , get: ()=>data.closeDate, set: (value: string | null)=>{data.closeDate = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.closeDate, setError: (value: __gf_Option<Array<string>>)=>{errors.closeDate = value;}, getTainted: ()=>tainted.closeDate, setTainted: (value: __gf_Option<boolean>)=>{tainted.closeDate = value;}, validate: (): Array<string>=>{const fieldErrors = leadValidateField("closeDate", data.closeDate); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},value: {path: ["value" ]as const, name: "value" , constraints: { required: true }, label: "Value" , get: ()=>data.value, set: (value: number)=>{data.value = value;}, transform: (value: number): number =>value,getError: ()=>errors.value, setError: (value: __gf_Option<Array<string>>)=>{errors.value = value;}, getTainted: ()=>tainted.value, setTainted: (value: __gf_Option<boolean>)=>{tainted.value = value;}, validate: (): Array<string>=>{const fieldErrors = leadValidateField("value", data.value); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},stage: {path: ["stage" ]as const, name: "stage" , constraints: { required: true }, label: "Stage" , get: ()=>data.stage, set: (value: LeadStage)=>{data.stage = value;}, transform: (value: LeadStage): LeadStage =>value,getError: ()=>errors.stage, setError: (value: __gf_Option<Array<string>>)=>{errors.stage = value;}, getTainted: ()=>tainted.stage, setTainted: (value: __gf_Option<boolean>)=>{tainted.stage = value;}, validate: (): Array<string>=>{const fieldErrors = leadValidateField("stage", data.stage); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},status: {path: ["status" ]as const, name: "status" , constraints: { required: true }, label: "Status" , get: ()=>data.status, set: (value: string)=>{data.status = value;}, transform: (value: string): string =>value,getError: ()=>errors.status, setError: (value: __gf_Option<Array<string>>)=>{errors.status = value;}, getTainted: ()=>tainted.status, setTainted: (value: __gf_Option<boolean>)=>{tainted.status = value;}, validate: (): Array<string>=>{const fieldErrors = leadValidateField("status", data.status); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},description: {path: ["description" ]as const, name: "description" , constraints: { required: true }, label: "Description" , get: ()=>data.description, set: (value: string | null)=>{data.description = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.description, setError: (value: __gf_Option<Array<string>>)=>{errors.description = value;}, getTainted: ()=>tainted.description, setTainted: (value: __gf_Option<boolean>)=>{tainted.description = value;}, validate: (): Array<string>=>{const fieldErrors = leadValidateField("description", data.description); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},nextStep: {path: ["nextStep" ]as const, name: "nextStep" , constraints: { required: true }, get: ()=>data.nextStep, set: (value: NextStep)=>{data.nextStep = value;}, transform: (value: NextStep): NextStep =>value,getError: ()=>errors.nextStep, setError: (value: __gf_Option<Array<string>>)=>{errors.nextStep = value;}, getTainted: ()=>tainted.nextStep, setTainted: (value: __gf_Option<boolean>)=>{tainted.nextStep = value;}, validate: (): Array<string>=>{const fieldErrors = leadValidateField("nextStep", data.nextStep); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},favorite: {path: ["favorite" ]as const, name: "favorite" , constraints: { required: true }, label: "Favorite" , get: ()=>data.favorite, set: (value: boolean)=>{data.favorite = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.favorite, setError: (value: __gf_Option<Array<string>>)=>{errors.favorite = value;}, getTainted: ()=>tainted.favorite, setTainted: (value: __gf_Option<boolean>)=>{tainted.favorite = value;}, validate: (): Array<string>=>{const fieldErrors = leadValidateField("favorite", data.favorite); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},dateAdded: {path: ["dateAdded" ]as const, name: "dateAdded" , constraints: { required: true }, get: ()=>data.dateAdded, set: (value: string | null)=>{data.dateAdded = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.dateAdded, setError: (value: __gf_Option<Array<string>>)=>{errors.dateAdded = value;}, getTainted: ()=>tainted.dateAdded, setTainted: (value: __gf_Option<boolean>)=>{tainted.dateAdded = value;}, validate: (): Array<string>=>{const fieldErrors = leadValidateField("dateAdded", data.dateAdded); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},taxRate: {path: ["taxRate" ]as const, name: "taxRate" , constraints: { required: true }, label: "Tax Rate" , get: ()=>data.taxRate, set: (value: (string | TaxRate) | null)=>{data.taxRate = value;}, transform: (value: (string | TaxRate) | null): (string | TaxRate) | null =>value,getError: ()=>errors.taxRate, setError: (value: __gf_Option<Array<string>>)=>{errors.taxRate = value;}, getTainted: ()=>tainted.taxRate, setTainted: (value: __gf_Option<boolean>)=>{tainted.taxRate = value;}, validate: (): Array<string>=>{const fieldErrors = leadValidateField("taxRate", data.taxRate); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},sector: {path: ["sector" ]as const, name: "sector" , constraints: { required: true }, label: "Sector" , get: ()=>data.sector, set: (value: Sector)=>{data.sector = value;}, transform: (value: Sector): Sector =>value,getError: ()=>errors.sector, setError: (value: __gf_Option<Array<string>>)=>{errors.sector = value;}, getTainted: ()=>tainted.sector, setTainted: (value: __gf_Option<boolean>)=>{tainted.sector = value;}, validate: (): Array<string>=>{const fieldErrors = leadValidateField("sector", data.sector); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},leadName: {path: ["leadName" ]as const, name: "leadName" , constraints: { required: true }, get: ()=>data.leadName, set: (value: AccountName)=>{data.leadName = value;}, transform: (value: AccountName): AccountName =>value,getError: ()=>errors.leadName, setError: (value: __gf_Option<Array<string>>)=>{errors.leadName = value;}, getTainted: ()=>tainted.leadName, setTainted: (value: __gf_Option<boolean>)=>{tainted.leadName = value;}, validate: (): Array<string>=>{const fieldErrors = leadValidateField("leadName", data.leadName); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},phones: {path: ["phones" ]as const, name: "phones" , constraints: { required: true }, get: ()=>data.phones, set: (value: PhoneNumber[])=>{data.phones = value;}, transform: (value: PhoneNumber[]): PhoneNumber[] =>value,getError: ()=>errors.phones, setError: (value: __gf_Option<Array<string>>)=>{errors.phones = value;}, getTainted: ()=>tainted.phones, setTainted: (value: __gf_Option<boolean>)=>{tainted.phones = value;}, validate: (): Array<string>=>{const fieldErrors = leadValidateField("phones", data.phones); return fieldErrors.map((e: {field: string; message: string})=>e.message);},at: (index: number)=>({path: ["phones" , index]as const, name: `phones.${index}` , constraints: {required: true}, get: ()=>data.phones[index]!, set: (value: PhoneNumber)=>{data.phones[index]= value;}, transform: (value: PhoneNumber): PhoneNumber =>value, getError: ()=>errors.phones, setError: (value: __gf_Option<Array<string>>)=>{errors.phones = value;}, getTainted: ()=>tainted.phones, setTainted: (value: __gf_Option<boolean>)=>{tainted.phones = value;}, validate: (): Array<string>=>[],}), push: (item: PhoneNumber)=>{data.phones.push(item);}, remove: (index: number)=>{data.phones.splice(index, 1);}, swap: (a: number, b: number)=>{const tmp = data.phones[a]!; data.phones[a]= data.phones[b]!; data.phones[b]= tmp;},},email: {path: ["email" ]as const, name: "email" , constraints: { required: true }, label: "Email" , get: ()=>data.email, set: (value: Email)=>{data.email = value;}, transform: (value: Email): Email =>value,getError: ()=>errors.email, setError: (value: __gf_Option<Array<string>>)=>{errors.email = value;}, getTainted: ()=>tainted.email, setTainted: (value: __gf_Option<boolean>)=>{tainted.email = value;}, validate: (): Array<string>=>{const fieldErrors = leadValidateField("email", data.email); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},leadSource: {path: ["leadSource" ]as const, name: "leadSource" , constraints: { required: true }, label: "Lead Source" , get: ()=>data.leadSource, set: (value: string | null)=>{data.leadSource = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.leadSource, setError: (value: __gf_Option<Array<string>>)=>{errors.leadSource = value;}, getTainted: ()=>tainted.leadSource, setTainted: (value: __gf_Option<boolean>)=>{tainted.leadSource = value;}, validate: (): Array<string>=>{const fieldErrors = leadValidateField("leadSource", data.leadSource); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},site: {path: ["site" ]as const, name: "site" , constraints: { required: true }, label: "Site" , get: ()=>data.site, set: (value: string | Site)=>{data.site = value;}, transform: (value: string | Site): string | Site =>value,getError: ()=>errors.site, setError: (value: __gf_Option<Array<string>>)=>{errors.site = value;}, getTainted: ()=>tainted.site, setTainted: (value: __gf_Option<boolean>)=>{tainted.site = value;}, validate: (): Array<string>=>{const fieldErrors = leadValidateField("site", data.site); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},memo: {path: ["memo" ]as const, name: "memo" , constraints: { required: true }, label: "Memo" , get: ()=>data.memo, set: (value: string)=>{data.memo = value;}, transform: (value: string): string =>value,getError: ()=>errors.memo, setError: (value: __gf_Option<Array<string>>)=>{errors.memo = value;}, getTainted: ()=>tainted.memo, setTainted: (value: __gf_Option<boolean>)=>{tainted.memo = value;}, validate: (): Array<string>=>{const fieldErrors = leadValidateField("memo", data.memo); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},needsReview: {path: ["needsReview" ]as const, name: "needsReview" , constraints: { required: true }, label: "Needs Review" , get: ()=>data.needsReview, set: (value: boolean)=>{data.needsReview = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.needsReview, setError: (value: __gf_Option<Array<string>>)=>{errors.needsReview = value;}, getTainted: ()=>tainted.needsReview, setTainted: (value: __gf_Option<boolean>)=>{tainted.needsReview = value;}, validate: (): Array<string>=>{const fieldErrors = leadValidateField("needsReview", data.needsReview); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},hasAlert: {path: ["hasAlert" ]as const, name: "hasAlert" , constraints: { required: true }, label: "Has Alert" , get: ()=>data.hasAlert, set: (value: boolean)=>{data.hasAlert = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.hasAlert, setError: (value: __gf_Option<Array<string>>)=>{errors.hasAlert = value;}, getTainted: ()=>tainted.hasAlert, setTainted: (value: __gf_Option<boolean>)=>{tainted.hasAlert = value;}, validate: (): Array<string>=>{const fieldErrors = leadValidateField("hasAlert", data.hasAlert); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},salesRep: {path: ["salesRep" ]as const, name: "salesRep" , constraints: { required: true }, label: "Sales Rep" , get: ()=>data.salesRep, set: (value: Represents[] | null)=>{data.salesRep = value;}, transform: (value: Represents[] | null): Represents[] | null =>value,getError: ()=>errors.salesRep, setError: (value: __gf_Option<Array<string>>)=>{errors.salesRep = value;}, getTainted: ()=>tainted.salesRep, setTainted: (value: __gf_Option<boolean>)=>{tainted.salesRep = value;}, validate: (): Array<string>=>{const fieldErrors = leadValidateField("salesRep", data.salesRep); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},color: {path: ["color" ]as const, name: "color" , constraints: { required: true }, get: ()=>data.color, set: (value: string | null)=>{data.color = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.color, setError: (value: __gf_Option<Array<string>>)=>{errors.color = value;}, getTainted: ()=>tainted.color, setTainted: (value: __gf_Option<boolean>)=>{tainted.color = value;}, validate: (): Array<string>=>{const fieldErrors = leadValidateField("color", data.color); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},accountType: {path: ["accountType" ]as const, name: "accountType" , constraints: { required: true }, label: "Account Type" , get: ()=>data.accountType, set: (value: string)=>{data.accountType = value;}, transform: (value: string): string =>value,getError: ()=>errors.accountType, setError: (value: __gf_Option<Array<string>>)=>{errors.accountType = value;}, getTainted: ()=>tainted.accountType, setTainted: (value: __gf_Option<boolean>)=>{tainted.accountType = value;}, validate: (): Array<string>=>{const fieldErrors = leadValidateField("accountType", data.accountType); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},subtype: {path: ["subtype" ]as const, name: "subtype" , constraints: { required: true }, label: "Subtype" , get: ()=>data.subtype, set: (value: string)=>{data.subtype = value;}, transform: (value: string): string =>value,getError: ()=>errors.subtype, setError: (value: __gf_Option<Array<string>>)=>{errors.subtype = value;}, getTainted: ()=>tainted.subtype, setTainted: (value: __gf_Option<boolean>)=>{tainted.subtype = value;}, validate: (): Array<string>=>{const fieldErrors = leadValidateField("subtype", data.subtype); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},isTaxExempt: {path: ["isTaxExempt" ]as const, name: "isTaxExempt" , constraints: { required: true }, label: "Tax Exempt" , get: ()=>data.isTaxExempt, set: (value: boolean)=>{data.isTaxExempt = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.isTaxExempt, setError: (value: __gf_Option<Array<string>>)=>{errors.isTaxExempt = value;}, getTainted: ()=>tainted.isTaxExempt, setTainted: (value: __gf_Option<boolean>)=>{tainted.isTaxExempt = value;}, validate: (): Array<string>=>{const fieldErrors = leadValidateField("isTaxExempt", data.isTaxExempt); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},paymentTerms: {path: ["paymentTerms" ]as const, name: "paymentTerms" , constraints: { required: true }, label: "Payment Terms" , get: ()=>data.paymentTerms, set: (value: string)=>{data.paymentTerms = value;}, transform: (value: string): string =>value,getError: ()=>errors.paymentTerms, setError: (value: __gf_Option<Array<string>>)=>{errors.paymentTerms = value;}, getTainted: ()=>tainted.paymentTerms, setTainted: (value: __gf_Option<boolean>)=>{tainted.paymentTerms = value;}, validate: (): Array<string>=>{const fieldErrors = leadValidateField("paymentTerms", data.paymentTerms); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},tags: {path: ["tags" ]as const, name: "tags" , constraints: { required: true }, label: "Tags" , get: ()=>data.tags, set: (value: string[])=>{data.tags = value;}, transform: (value: string[]): string[] =>value,getError: ()=>errors.tags, setError: (value: __gf_Option<Array<string>>)=>{errors.tags = value;}, getTainted: ()=>tainted.tags, setTainted: (value: __gf_Option<boolean>)=>{tainted.tags = value;}, validate: (): Array<string>=>{const fieldErrors = leadValidateField("tags", data.tags); return fieldErrors.map((e: {field: string; message: string})=>e.message);},at: (index: number)=>({path: ["tags" , index]as const, name: `tags.${index}` , constraints: {required: true}, get: ()=>data.tags[index]!, set: (value: string)=>{data.tags[index]= value;}, transform: (value: string): string =>value, getError: ()=>errors.tags, setError: (value: __gf_Option<Array<string>>)=>{errors.tags = value;}, getTainted: ()=>tainted.tags, setTainted: (value: __gf_Option<boolean>)=>{tainted.tags = value;}, validate: (): Array<string>=>[],}), push: (item: string)=>{data.tags.push(item);}, remove: (index: number)=>{data.tags.splice(index, 1);}, swap: (a: number, b: number)=>{const tmp = data.tags[a]!; data.tags[a]= data.tags[b]!; data.tags[b]= tmp;},},customFields: {path: ["customFields" ]as const, name: "customFields" , constraints: { required: true }, get: ()=>data.customFields, set: (value: [string, string][])=>{data.customFields = value;}, transform: (value: [string, string][]): [string, string][] =>value,getError: ()=>errors.customFields, setError: (value: __gf_Option<Array<string>>)=>{errors.customFields = value;}, getTainted: ()=>tainted.customFields, setTainted: (value: __gf_Option<boolean>)=>{tainted.customFields = value;}, validate: (): Array<string>=>{const fieldErrors = leadValidateField("customFields", data.customFields); return fieldErrors.map((e: {field: string; message: string})=>e.message);},at: (index: number)=>({path: ["customFields" , index]as const, name: `customFields.${index}` , constraints: {required: true}, get: ()=>data.customFields[index]!, set: (value: [string, string])=>{data.customFields[index]= value;}, transform: (value: [string, string]): [string, string] =>value, getError: ()=>errors.customFields, setError: (value: __gf_Option<Array<string>>)=>{errors.customFields = value;}, getTainted: ()=>tainted.customFields, setTainted: (value: __gf_Option<boolean>)=>{tainted.customFields = value;}, validate: (): Array<string>=>[],}), push: (item: [string, string])=>{data.customFields.push(item);}, remove: (index: number)=>{data.customFields.splice(index, 1);}, swap: (a: number, b: number)=>{const tmp = data.customFields[a]!; data.customFields[a]= data.customFields[b]!; data.customFields[b]= tmp;},},}; function validate(): Exit<Lead, Array<{field: string; message: string}>>{return toExit(leadDeserialize(data));}function reset(newOverrides?: Partial<Lead>): void {data = {...leadDefaultValue(),...newOverrides}; errors = {_errors: optionNone(), id: optionNone(), number: optionNone(), accepted: optionNone(), probability: optionNone(), priority: optionNone(), dueDate: optionNone(), closeDate: optionNone(), value: optionNone(), stage: optionNone(), status: optionNone(), description: optionNone(), nextStep: optionNone(), favorite: optionNone(), dateAdded: optionNone(), taxRate: optionNone(), sector: optionNone(), leadName: optionNone(), phones: optionNone(), email: optionNone(), leadSource: optionNone(), site: optionNone(), memo: optionNone(), needsReview: optionNone(), hasAlert: optionNone(), salesRep: optionNone(), color: optionNone(), accountType: optionNone(), subtype: optionNone(), isTaxExempt: optionNone(), paymentTerms: optionNone(), tags: optionNone(), customFields: optionNone(), }; tainted = {id: optionNone(), number: optionNone(), accepted: optionNone(), probability: optionNone(), priority: optionNone(), dueDate: optionNone(), closeDate: optionNone(), value: optionNone(), stage: optionNone(), status: optionNone(), description: optionNone(), nextStep: optionNone(), favorite: optionNone(), dateAdded: optionNone(), taxRate: optionNone(), sector: optionNone(), leadName: optionNone(), phones: optionNone(), email: optionNone(), leadSource: optionNone(), site: optionNone(), memo: optionNone(), needsReview: optionNone(), hasAlert: optionNone(), salesRep: optionNone(), color: optionNone(), accountType: optionNone(), subtype: optionNone(), isTaxExempt: optionNone(), paymentTerms: optionNone(), tags: optionNone(), customFields: optionNone(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function leadFromFormData(formData: FormData): Exit<Lead, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.id = formData.get("id" )?? "" ;{const numberStr = formData.get("number" ); obj.number = numberStr? parseFloat(numberStr as string): 0; if(obj.number!== undefined && isNaN(obj.number as number))obj.number = 0;}{const acceptedVal = formData.get("accepted" ); obj.accepted = acceptedVal === "true" || acceptedVal === "on" || acceptedVal === "1" ;}{const probabilityStr = formData.get("probability" ); obj.probability = probabilityStr? parseFloat(probabilityStr as string): 0; if(obj.probability!== undefined && isNaN(obj.probability as number))obj.probability = 0;}{const priorityObj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("priority." )){const fieldName = key.slice("priority." .length); const parts = fieldName.split("." ); let current = priorityObj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.priority = priorityObj;}obj.dueDate = formData.get("dueDate" )?? "" ;obj.closeDate = formData.get("closeDate" )?? "" ;{const valueStr = formData.get("value" ); obj.value = valueStr? parseFloat(valueStr as string): 0; if(obj.value!== undefined && isNaN(obj.value as number))obj.value = 0;}{const stageObj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("stage." )){const fieldName = key.slice("stage." .length); const parts = fieldName.split("." ); let current = stageObj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.stage = stageObj;}obj.status = formData.get("status" )?? "" ;obj.description = formData.get("description" )?? "" ;{const nextStepObj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("nextStep." )){const fieldName = key.slice("nextStep." .length); const parts = fieldName.split("." ); let current = nextStepObj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.nextStep = nextStepObj;}{const favoriteVal = formData.get("favorite" ); obj.favorite = favoriteVal === "true" || favoriteVal === "on" || favoriteVal === "1" ;}obj.dateAdded = formData.get("dateAdded" )?? "" ;obj.taxRate = formData.get("taxRate" )?? "" ;{const sectorObj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("sector." )){const fieldName = key.slice("sector." .length); const parts = fieldName.split("." ); let current = sectorObj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.sector = sectorObj;}{const leadNameObj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("leadName." )){const fieldName = key.slice("leadName." .length); const parts = fieldName.split("." ); let current = leadNameObj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.leadName = leadNameObj;}{const phonesItems: Array<Record<string, unknown>>= []; let idx = 0; while(formData.has("phones." + idx + "." )|| idx === 0){const hasAny = Array.from(formData.keys()).some(k =>k.startsWith("phones." + idx + "." )); if(!hasAny && idx>0)break; if(hasAny){const item: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("phones." + idx + "." )){const fieldName = key.slice("phones." .length + String(idx).length + 1); item[fieldName]= value;}}phonesItems.push(item);}idx ++; if(idx>1000)break;}obj.phones = phonesItems;}{const emailObj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("email." )){const fieldName = key.slice("email." .length); const parts = fieldName.split("." ); let current = emailObj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.email = emailObj;}obj.leadSource = formData.get("leadSource" )?? "" ;obj.site = formData.get("site" )?? "" ;obj.memo = formData.get("memo" )?? "" ;{const needsReviewVal = formData.get("needsReview" ); obj.needsReview = needsReviewVal === "true" || needsReviewVal === "on" || needsReviewVal === "1" ;}{const hasAlertVal = formData.get("hasAlert" ); obj.hasAlert = hasAlertVal === "true" || hasAlertVal === "on" || hasAlertVal === "1" ;}obj.salesRep = formData.get("salesRep" )?? "" ;obj.color = formData.get("color" )?? "" ;obj.accountType = formData.get("accountType" )?? "" ;obj.subtype = formData.get("subtype" )?? "" ;{const isTaxExemptVal = formData.get("isTaxExempt" ); obj.isTaxExempt = isTaxExemptVal === "true" || isTaxExemptVal === "on" || isTaxExemptVal === "1" ;}obj.paymentTerms = formData.get("paymentTerms" )?? "" ;obj.tags = formData.getAll("tags" )as Array<string>;{const customFieldsItems: Array<Record<string, unknown>>= []; let idx = 0; while(formData.has("customFields." + idx + "." )|| idx === 0){const hasAny = Array.from(formData.keys()).some(k =>k.startsWith("customFields." + idx + "." )); if(!hasAny && idx>0)break; if(hasAny){const item: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("customFields." + idx + "." )){const fieldName = key.slice("customFields." .length + String(idx).length + 1); item[fieldName]= value;}}customFieldsItems.push(item);}idx ++; if(idx>1000)break;}obj.customFields = customFieldsItems;}return toExit(leadDeserialize(obj));}

export const Lead = {
  defaultValue: leadDefaultValue,
  serialize: leadSerialize,
  serializeWithContext: leadSerializeWithContext,
  deserialize: leadDeserialize,
  deserializeWithContext: leadDeserializeWithContext,
  validateFields: leadValidateFields,
  hasShape: leadHasShape,
  is: leadIs,
  createForm: leadCreateForm,
  fromFormData: leadFromFormData
} as const;


export interface AppPermissions {
    applications: Applications[];
    pages: Page[];
    data: Table[];
}

export function appPermissionsDefaultValue(): AppPermissions {return {applications: [],
                            pages: [],
                            data: [], }as AppPermissions;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function appPermissionsSerialize(value: AppPermissions): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(appPermissionsSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function appPermissionsSerializeWithContext(value: AppPermissions, ctx: __mf_SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "AppPermissions" , __id,}; result["applications" ]= value.applications.map((item)=>applicationsSerializeWithContext(item, ctx)); result["pages" ]= value.pages.map((item)=>pageSerializeWithContext(item, ctx)); result["data" ]= value.data.map((item)=>tableSerializeWithContext(item, ctx)); return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function appPermissionsDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: AppPermissions } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = appPermissionsDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "AppPermissions.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function appPermissionsDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): AppPermissions | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new __mf_DeserializeError([{field: "_root" , message: "AppPermissions.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("applications" in obj)){errors.push({field: "applications" , message: "missing required field" });}if(!("pages" in obj)){errors.push({field: "pages" , message: "missing required field" });}if(!("data" in obj)){errors.push({field: "data" , message: "missing required field" });}if(errors.length>0){throw new __mf_DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_applications = obj["applications" ]as Applications[]; if(Array.isArray(__raw_applications)){instance.applications = __raw_applications as Applications[];}}{const __raw_pages = obj["pages" ]as Page[]; if(Array.isArray(__raw_pages)){instance.pages = __raw_pages as Page[];}}{const __raw_data = obj["data" ]as Table[]; if(Array.isArray(__raw_data)){instance.data = __raw_data as Table[];}}if(errors.length>0){throw new __mf_DeserializeError(errors);}return instance as AppPermissions;}export function appPermissionsValidateField<K extends keyof AppPermissions>(_field: K, _value: AppPermissions[K]): Array<{field: string; message: string}>{return[]; }export function appPermissionsValidateFields(_partial: Partial<AppPermissions>): Array<{field: string; message: string}>{return[]; }export function appPermissionsHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "applications" in o && "pages" in o && "data" in o;}export function appPermissionsIs(obj: unknown): obj is AppPermissions {if(!appPermissionsHasShape(obj)){return false;}const result = appPermissionsDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type AppPermissionsErrors = {_errors: __gf_Option<Array<string>>; applications: __gf_Option<Array<string>>; pages: __gf_Option<Array<string>>; data: __gf_Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type AppPermissionsTainted = {applications: __gf_Option<boolean>; pages: __gf_Option<boolean>; data: __gf_Option<boolean>; }; /** Type-safe field controllers for this form */export interface AppPermissionsFieldControllers {readonly applications: ArrayFieldController<Applications>; readonly pages: ArrayFieldController<Page>; readonly data: ArrayFieldController<Table>; }/** Gigaform instance containing reactive state and field controllers */export interface AppPermissionsGigaform {readonly data: AppPermissions; readonly errors: AppPermissionsErrors; readonly tainted: AppPermissionsTainted; readonly fields: AppPermissionsFieldControllers; validate(): Exit<AppPermissions, Array<{field: string; message: string}>>; reset(overrides?: Partial<AppPermissions>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function appPermissionsCreateForm(overrides?: Partial<AppPermissions>): AppPermissionsGigaform {let data = $state({...appPermissionsDefaultValue(),...overrides}); let errors = $state<AppPermissionsErrors>({_errors: optionNone(), applications: optionNone(), pages: optionNone(), data: optionNone(), }); let tainted = $state<AppPermissionsTainted>({applications: optionNone(), pages: optionNone(), data: optionNone(), }); const fields: AppPermissionsFieldControllers = {applications: {path: ["applications" ]as const, name: "applications" , constraints: { required: true }, get: ()=>data.applications, set: (value: Applications[])=>{data.applications = value;}, transform: (value: Applications[]): Applications[] =>value,getError: ()=>errors.applications, setError: (value: __gf_Option<Array<string>>)=>{errors.applications = value;}, getTainted: ()=>tainted.applications, setTainted: (value: __gf_Option<boolean>)=>{tainted.applications = value;}, validate: (): Array<string>=>{const fieldErrors = appPermissionsValidateField("applications", data.applications); return fieldErrors.map((e: {field: string; message: string})=>e.message);},at: (index: number)=>({path: ["applications" , index]as const, name: `applications.${index}` , constraints: {required: true}, get: ()=>data.applications[index]!, set: (value: Applications)=>{data.applications[index]= value;}, transform: (value: Applications): Applications =>value, getError: ()=>errors.applications, setError: (value: __gf_Option<Array<string>>)=>{errors.applications = value;}, getTainted: ()=>tainted.applications, setTainted: (value: __gf_Option<boolean>)=>{tainted.applications = value;}, validate: (): Array<string>=>[],}), push: (item: Applications)=>{data.applications.push(item);}, remove: (index: number)=>{data.applications.splice(index, 1);}, swap: (a: number, b: number)=>{const tmp = data.applications[a]!; data.applications[a]= data.applications[b]!; data.applications[b]= tmp;},},pages: {path: ["pages" ]as const, name: "pages" , constraints: { required: true }, get: ()=>data.pages, set: (value: Page[])=>{data.pages = value;}, transform: (value: Page[]): Page[] =>value,getError: ()=>errors.pages, setError: (value: __gf_Option<Array<string>>)=>{errors.pages = value;}, getTainted: ()=>tainted.pages, setTainted: (value: __gf_Option<boolean>)=>{tainted.pages = value;}, validate: (): Array<string>=>{const fieldErrors = appPermissionsValidateField("pages", data.pages); return fieldErrors.map((e: {field: string; message: string})=>e.message);},at: (index: number)=>({path: ["pages" , index]as const, name: `pages.${index}` , constraints: {required: true}, get: ()=>data.pages[index]!, set: (value: Page)=>{data.pages[index]= value;}, transform: (value: Page): Page =>value, getError: ()=>errors.pages, setError: (value: __gf_Option<Array<string>>)=>{errors.pages = value;}, getTainted: ()=>tainted.pages, setTainted: (value: __gf_Option<boolean>)=>{tainted.pages = value;}, validate: (): Array<string>=>[],}), push: (item: Page)=>{data.pages.push(item);}, remove: (index: number)=>{data.pages.splice(index, 1);}, swap: (a: number, b: number)=>{const tmp = data.pages[a]!; data.pages[a]= data.pages[b]!; data.pages[b]= tmp;},},data: {path: ["data" ]as const, name: "data" , constraints: { required: true }, get: ()=>data.data, set: (value: Table[])=>{data.data = value;}, transform: (value: Table[]): Table[] =>value,getError: ()=>errors.data, setError: (value: __gf_Option<Array<string>>)=>{errors.data = value;}, getTainted: ()=>tainted.data, setTainted: (value: __gf_Option<boolean>)=>{tainted.data = value;}, validate: (): Array<string>=>{const fieldErrors = appPermissionsValidateField("data", data.data); return fieldErrors.map((e: {field: string; message: string})=>e.message);},at: (index: number)=>({path: ["data" , index]as const, name: `data.${index}` , constraints: {required: true}, get: ()=>data.data[index]!, set: (value: Table)=>{data.data[index]= value;}, transform: (value: Table): Table =>value, getError: ()=>errors.data, setError: (value: __gf_Option<Array<string>>)=>{errors.data = value;}, getTainted: ()=>tainted.data, setTainted: (value: __gf_Option<boolean>)=>{tainted.data = value;}, validate: (): Array<string>=>[],}), push: (item: Table)=>{data.data.push(item);}, remove: (index: number)=>{data.data.splice(index, 1);}, swap: (a: number, b: number)=>{const tmp = data.data[a]!; data.data[a]= data.data[b]!; data.data[b]= tmp;},},}; function validate(): Exit<AppPermissions, Array<{field: string; message: string}>>{return toExit(appPermissionsDeserialize(data));}function reset(newOverrides?: Partial<AppPermissions>): void {data = {...appPermissionsDefaultValue(),...newOverrides}; errors = {_errors: optionNone(), applications: optionNone(), pages: optionNone(), data: optionNone(), }; tainted = {applications: optionNone(), pages: optionNone(), data: optionNone(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function appPermissionsFromFormData(formData: FormData): Exit<AppPermissions, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; {const applicationsItems: Array<Record<string, unknown>>= []; let idx = 0; while(formData.has("applications." + idx + "." )|| idx === 0){const hasAny = Array.from(formData.keys()).some(k =>k.startsWith("applications." + idx + "." )); if(!hasAny && idx>0)break; if(hasAny){const item: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("applications." + idx + "." )){const fieldName = key.slice("applications." .length + String(idx).length + 1); item[fieldName]= value;}}applicationsItems.push(item);}idx ++; if(idx>1000)break;}obj.applications = applicationsItems;}{const pagesItems: Array<Record<string, unknown>>= []; let idx = 0; while(formData.has("pages." + idx + "." )|| idx === 0){const hasAny = Array.from(formData.keys()).some(k =>k.startsWith("pages." + idx + "." )); if(!hasAny && idx>0)break; if(hasAny){const item: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("pages." + idx + "." )){const fieldName = key.slice("pages." .length + String(idx).length + 1); item[fieldName]= value;}}pagesItems.push(item);}idx ++; if(idx>1000)break;}obj.pages = pagesItems;}{const dataItems: Array<Record<string, unknown>>= []; let idx = 0; while(formData.has("data." + idx + "." )|| idx === 0){const hasAny = Array.from(formData.keys()).some(k =>k.startsWith("data." + idx + "." )); if(!hasAny && idx>0)break; if(hasAny){const item: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("data." + idx + "." )){const fieldName = key.slice("data." .length + String(idx).length + 1); item[fieldName]= value;}}dataItems.push(item);}idx ++; if(idx>1000)break;}obj.data = dataItems;}return toExit(appPermissionsDeserialize(obj));}

export const AppPermissions = {
  defaultValue: appPermissionsDefaultValue,
  serialize: appPermissionsSerialize,
  serializeWithContext: appPermissionsSerializeWithContext,
  deserialize: appPermissionsDeserialize,
  deserializeWithContext: appPermissionsDeserializeWithContext,
  validateFields: appPermissionsValidateFields,
  hasShape: appPermissionsHasShape,
  is: appPermissionsIs,
  createForm: appPermissionsCreateForm,
  fromFormData: appPermissionsFromFormData
} as const;


export interface Company {
    id: string;
    
    legalName: string;
    
    headquarters: string | Site;
    phones: PhoneNumber[];
    
    fax: string;
    
    email: string;
    
    website: string;
    
    taxId: string;
    referenceNumber: number;
    
    postalCodeLookup: string;
    timeZone: string;
    
    defaultTax: string | TaxRate;
    
    defaultTaxLocation: string;
    defaultAreaCode: number;
    
    defaultAccountType: string;
    
    lookupFormatting: string;
    
    accountNameFormat: string;
    merchantServiceProvider: string | null;
    
    dateDisplayStyle: string;
    hasAutoCommission: boolean;
    hasAutoDaylightSavings: boolean;
    hasAutoFmsTracking: boolean;
    hasNotifications: boolean;
    hasRequiredLeadSource: boolean;
    hasRequiredEmail: boolean;
    hasSortServiceItemsAlphabetically: boolean;
    hasAttachOrderToAppointmentEmails: boolean;
    scheduleInterval: number;
    colorsConfig: ColorsConfig;
}

export function companyDefaultValue(): Company {return {id: "",
                            legalName: "",
                            headquarters: "",
                            phones: [],
                            fax: "",
                            email: "",
                            website: "",
                            taxId: "",
                            referenceNumber: 0,
                            postalCodeLookup: "",
                            timeZone: "",
                            defaultTax: "",
                            defaultTaxLocation: "",
                            defaultAreaCode: 0,
                            defaultAccountType: "",
                            lookupFormatting: "",
                            accountNameFormat: "",
                            merchantServiceProvider: null,
                            dateDisplayStyle: "",
                            hasAutoCommission: false,
                            hasAutoDaylightSavings: false,
                            hasAutoFmsTracking: false,
                            hasNotifications: false,
                            hasRequiredLeadSource: false,
                            hasRequiredEmail: false,
                            hasSortServiceItemsAlphabetically: false,
                            hasAttachOrderToAppointmentEmails: false,
                            scheduleInterval: 0,
                            colorsConfig: colorsConfigDefaultValue(), }as Company;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function companySerialize(value: Company): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(companySerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function companySerializeWithContext(value: Company, ctx: __mf_SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Company" , __id,}; result["id" ]= value.id; result["legalName" ]= value.legalName; result["headquarters" ]= value.headquarters; result["phones" ]= value.phones.map((item)=>phoneNumberSerializeWithContext(item, ctx)); result["fax" ]= value.fax; result["email" ]= value.email; result["website" ]= value.website; result["taxId" ]= value.taxId; result["referenceNumber" ]= value.referenceNumber; result["postalCodeLookup" ]= value.postalCodeLookup; result["timeZone" ]= value.timeZone; result["defaultTax" ]= value.defaultTax; result["defaultTaxLocation" ]= value.defaultTaxLocation; result["defaultAreaCode" ]= value.defaultAreaCode; result["defaultAccountType" ]= value.defaultAccountType; result["lookupFormatting" ]= value.lookupFormatting; result["accountNameFormat" ]= value.accountNameFormat; result["merchantServiceProvider" ]= value.merchantServiceProvider; result["dateDisplayStyle" ]= value.dateDisplayStyle; result["hasAutoCommission" ]= value.hasAutoCommission; result["hasAutoDaylightSavings" ]= value.hasAutoDaylightSavings; result["hasAutoFmsTracking" ]= value.hasAutoFmsTracking; result["hasNotifications" ]= value.hasNotifications; result["hasRequiredLeadSource" ]= value.hasRequiredLeadSource; result["hasRequiredEmail" ]= value.hasRequiredEmail; result["hasSortServiceItemsAlphabetically" ]= value.hasSortServiceItemsAlphabetically; result["hasAttachOrderToAppointmentEmails" ]= value.hasAttachOrderToAppointmentEmails; result["scheduleInterval" ]= value.scheduleInterval; result["colorsConfig" ]= colorsConfigSerializeWithContext(value.colorsConfig, ctx); return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function companyDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: Company } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = companyDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Company.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function companyDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Company | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new __mf_DeserializeError([{field: "_root" , message: "Company.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("id" in obj)){errors.push({field: "id" , message: "missing required field" });}if(!("legalName" in obj)){errors.push({field: "legalName" , message: "missing required field" });}if(!("headquarters" in obj)){errors.push({field: "headquarters" , message: "missing required field" });}if(!("phones" in obj)){errors.push({field: "phones" , message: "missing required field" });}if(!("fax" in obj)){errors.push({field: "fax" , message: "missing required field" });}if(!("email" in obj)){errors.push({field: "email" , message: "missing required field" });}if(!("website" in obj)){errors.push({field: "website" , message: "missing required field" });}if(!("taxId" in obj)){errors.push({field: "taxId" , message: "missing required field" });}if(!("referenceNumber" in obj)){errors.push({field: "referenceNumber" , message: "missing required field" });}if(!("postalCodeLookup" in obj)){errors.push({field: "postalCodeLookup" , message: "missing required field" });}if(!("timeZone" in obj)){errors.push({field: "timeZone" , message: "missing required field" });}if(!("defaultTax" in obj)){errors.push({field: "defaultTax" , message: "missing required field" });}if(!("defaultTaxLocation" in obj)){errors.push({field: "defaultTaxLocation" , message: "missing required field" });}if(!("defaultAreaCode" in obj)){errors.push({field: "defaultAreaCode" , message: "missing required field" });}if(!("defaultAccountType" in obj)){errors.push({field: "defaultAccountType" , message: "missing required field" });}if(!("lookupFormatting" in obj)){errors.push({field: "lookupFormatting" , message: "missing required field" });}if(!("accountNameFormat" in obj)){errors.push({field: "accountNameFormat" , message: "missing required field" });}if(!("merchantServiceProvider" in obj)){errors.push({field: "merchantServiceProvider" , message: "missing required field" });}if(!("dateDisplayStyle" in obj)){errors.push({field: "dateDisplayStyle" , message: "missing required field" });}if(!("hasAutoCommission" in obj)){errors.push({field: "hasAutoCommission" , message: "missing required field" });}if(!("hasAutoDaylightSavings" in obj)){errors.push({field: "hasAutoDaylightSavings" , message: "missing required field" });}if(!("hasAutoFmsTracking" in obj)){errors.push({field: "hasAutoFmsTracking" , message: "missing required field" });}if(!("hasNotifications" in obj)){errors.push({field: "hasNotifications" , message: "missing required field" });}if(!("hasRequiredLeadSource" in obj)){errors.push({field: "hasRequiredLeadSource" , message: "missing required field" });}if(!("hasRequiredEmail" in obj)){errors.push({field: "hasRequiredEmail" , message: "missing required field" });}if(!("hasSortServiceItemsAlphabetically" in obj)){errors.push({field: "hasSortServiceItemsAlphabetically" , message: "missing required field" });}if(!("hasAttachOrderToAppointmentEmails" in obj)){errors.push({field: "hasAttachOrderToAppointmentEmails" , message: "missing required field" });}if(!("scheduleInterval" in obj)){errors.push({field: "scheduleInterval" , message: "missing required field" });}if(!("colorsConfig" in obj)){errors.push({field: "colorsConfig" , message: "missing required field" });}if(errors.length>0){throw new __mf_DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_id = obj["id" ]as string; instance.id = __raw_id; }{const __raw_legalName = obj["legalName" ]as string; 
                if (__raw_legalName.length === 0) {
                    errors.push({ field: "legalName", message: "must not be empty" });
                }
 instance.legalName = __raw_legalName; }{const __raw_headquarters = obj["headquarters" ]as string | Site; instance.headquarters = __raw_headquarters; }{const __raw_phones = obj["phones" ]as PhoneNumber[]; if(Array.isArray(__raw_phones)){instance.phones = __raw_phones as PhoneNumber[];}}{const __raw_fax = obj["fax" ]as string; 
                if (__raw_fax.length === 0) {
                    errors.push({ field: "fax", message: "must not be empty" });
                }
 instance.fax = __raw_fax; }{const __raw_email = obj["email" ]as string; 
                if (__raw_email.length === 0) {
                    errors.push({ field: "email", message: "must not be empty" });
                }
 instance.email = __raw_email; }{const __raw_website = obj["website" ]as string; 
                if (__raw_website.length === 0) {
                    errors.push({ field: "website", message: "must not be empty" });
                }
 instance.website = __raw_website; }{const __raw_taxId = obj["taxId" ]as string; 
                if (__raw_taxId.length === 0) {
                    errors.push({ field: "taxId", message: "must not be empty" });
                }
 instance.taxId = __raw_taxId; }{const __raw_referenceNumber = obj["referenceNumber" ]as number; instance.referenceNumber = __raw_referenceNumber; }{const __raw_postalCodeLookup = obj["postalCodeLookup" ]as string; 
                if (__raw_postalCodeLookup.length === 0) {
                    errors.push({ field: "postalCodeLookup", message: "must not be empty" });
                }
 instance.postalCodeLookup = __raw_postalCodeLookup; }{const __raw_timeZone = obj["timeZone" ]as string; instance.timeZone = __raw_timeZone; }{const __raw_defaultTax = obj["defaultTax" ]as string | TaxRate; instance.defaultTax = __raw_defaultTax; }{const __raw_defaultTaxLocation = obj["defaultTaxLocation" ]as string; 
                if (__raw_defaultTaxLocation.length === 0) {
                    errors.push({ field: "defaultTaxLocation", message: "must not be empty" });
                }
 instance.defaultTaxLocation = __raw_defaultTaxLocation; }{const __raw_defaultAreaCode = obj["defaultAreaCode" ]as number; instance.defaultAreaCode = __raw_defaultAreaCode; }{const __raw_defaultAccountType = obj["defaultAccountType" ]as string; 
                if (__raw_defaultAccountType.length === 0) {
                    errors.push({ field: "defaultAccountType", message: "must not be empty" });
                }
 instance.defaultAccountType = __raw_defaultAccountType; }{const __raw_lookupFormatting = obj["lookupFormatting" ]as string; 
                if (__raw_lookupFormatting.length === 0) {
                    errors.push({ field: "lookupFormatting", message: "must not be empty" });
                }
 instance.lookupFormatting = __raw_lookupFormatting; }{const __raw_accountNameFormat = obj["accountNameFormat" ]as string; 
                if (__raw_accountNameFormat.length === 0) {
                    errors.push({ field: "accountNameFormat", message: "must not be empty" });
                }
 instance.accountNameFormat = __raw_accountNameFormat; }{const __raw_merchantServiceProvider = obj["merchantServiceProvider" ]as string | null; instance.merchantServiceProvider = __raw_merchantServiceProvider; }{const __raw_dateDisplayStyle = obj["dateDisplayStyle" ]as string; 
                if (__raw_dateDisplayStyle.length === 0) {
                    errors.push({ field: "dateDisplayStyle", message: "must not be empty" });
                }
 instance.dateDisplayStyle = __raw_dateDisplayStyle; }{const __raw_hasAutoCommission = obj["hasAutoCommission" ]as boolean; instance.hasAutoCommission = __raw_hasAutoCommission; }{const __raw_hasAutoDaylightSavings = obj["hasAutoDaylightSavings" ]as boolean; instance.hasAutoDaylightSavings = __raw_hasAutoDaylightSavings; }{const __raw_hasAutoFmsTracking = obj["hasAutoFmsTracking" ]as boolean; instance.hasAutoFmsTracking = __raw_hasAutoFmsTracking; }{const __raw_hasNotifications = obj["hasNotifications" ]as boolean; instance.hasNotifications = __raw_hasNotifications; }{const __raw_hasRequiredLeadSource = obj["hasRequiredLeadSource" ]as boolean; instance.hasRequiredLeadSource = __raw_hasRequiredLeadSource; }{const __raw_hasRequiredEmail = obj["hasRequiredEmail" ]as boolean; instance.hasRequiredEmail = __raw_hasRequiredEmail; }{const __raw_hasSortServiceItemsAlphabetically = obj["hasSortServiceItemsAlphabetically" ]as boolean; instance.hasSortServiceItemsAlphabetically = __raw_hasSortServiceItemsAlphabetically; }{const __raw_hasAttachOrderToAppointmentEmails = obj["hasAttachOrderToAppointmentEmails" ]as boolean; instance.hasAttachOrderToAppointmentEmails = __raw_hasAttachOrderToAppointmentEmails; }{const __raw_scheduleInterval = obj["scheduleInterval" ]as number; instance.scheduleInterval = __raw_scheduleInterval; }{const __raw_colorsConfig = obj["colorsConfig" ]as ColorsConfig; {const __result = colorsConfigDeserializeWithContext(__raw_colorsConfig, ctx); ctx.assignOrDefer(instance, "colorsConfig" , __result);}}if(errors.length>0){throw new __mf_DeserializeError(errors);}return instance as Company;}export function companyValidateField<K extends keyof Company>(_field: K, _value: Company[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(_field){case "legalName" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "legalName", message: "must not be empty" });
                }
 break;}case "fax" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "fax", message: "must not be empty" });
                }
 break;}case "email" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "email", message: "must not be empty" });
                }
 break;}case "website" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "website", message: "must not be empty" });
                }
 break;}case "taxId" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "taxId", message: "must not be empty" });
                }
 break;}case "postalCodeLookup" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "postalCodeLookup", message: "must not be empty" });
                }
 break;}case "defaultTaxLocation" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "defaultTaxLocation", message: "must not be empty" });
                }
 break;}case "defaultAccountType" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "defaultAccountType", message: "must not be empty" });
                }
 break;}case "lookupFormatting" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "lookupFormatting", message: "must not be empty" });
                }
 break;}case "accountNameFormat" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "accountNameFormat", message: "must not be empty" });
                }
 break;}case "dateDisplayStyle" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "dateDisplayStyle", message: "must not be empty" });
                }
 break;}}return errors; }export function companyValidateFields(_partial: Partial<Company>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("legalName" in _partial && _partial.legalName!== undefined){const __val = _partial.legalName as string; 
                if (__val.length === 0) {
                    errors.push({ field: "legalName", message: "must not be empty" });
                }
}if("fax" in _partial && _partial.fax!== undefined){const __val = _partial.fax as string; 
                if (__val.length === 0) {
                    errors.push({ field: "fax", message: "must not be empty" });
                }
}if("email" in _partial && _partial.email!== undefined){const __val = _partial.email as string; 
                if (__val.length === 0) {
                    errors.push({ field: "email", message: "must not be empty" });
                }
}if("website" in _partial && _partial.website!== undefined){const __val = _partial.website as string; 
                if (__val.length === 0) {
                    errors.push({ field: "website", message: "must not be empty" });
                }
}if("taxId" in _partial && _partial.taxId!== undefined){const __val = _partial.taxId as string; 
                if (__val.length === 0) {
                    errors.push({ field: "taxId", message: "must not be empty" });
                }
}if("postalCodeLookup" in _partial && _partial.postalCodeLookup!== undefined){const __val = _partial.postalCodeLookup as string; 
                if (__val.length === 0) {
                    errors.push({ field: "postalCodeLookup", message: "must not be empty" });
                }
}if("defaultTaxLocation" in _partial && _partial.defaultTaxLocation!== undefined){const __val = _partial.defaultTaxLocation as string; 
                if (__val.length === 0) {
                    errors.push({ field: "defaultTaxLocation", message: "must not be empty" });
                }
}if("defaultAccountType" in _partial && _partial.defaultAccountType!== undefined){const __val = _partial.defaultAccountType as string; 
                if (__val.length === 0) {
                    errors.push({ field: "defaultAccountType", message: "must not be empty" });
                }
}if("lookupFormatting" in _partial && _partial.lookupFormatting!== undefined){const __val = _partial.lookupFormatting as string; 
                if (__val.length === 0) {
                    errors.push({ field: "lookupFormatting", message: "must not be empty" });
                }
}if("accountNameFormat" in _partial && _partial.accountNameFormat!== undefined){const __val = _partial.accountNameFormat as string; 
                if (__val.length === 0) {
                    errors.push({ field: "accountNameFormat", message: "must not be empty" });
                }
}if("dateDisplayStyle" in _partial && _partial.dateDisplayStyle!== undefined){const __val = _partial.dateDisplayStyle as string; 
                if (__val.length === 0) {
                    errors.push({ field: "dateDisplayStyle", message: "must not be empty" });
                }
}return errors; }export function companyHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "id" in o && "legalName" in o && "headquarters" in o && "phones" in o && "fax" in o && "email" in o && "website" in o && "taxId" in o && "referenceNumber" in o && "postalCodeLookup" in o && "timeZone" in o && "defaultTax" in o && "defaultTaxLocation" in o && "defaultAreaCode" in o && "defaultAccountType" in o && "lookupFormatting" in o && "accountNameFormat" in o && "merchantServiceProvider" in o && "dateDisplayStyle" in o && "hasAutoCommission" in o && "hasAutoDaylightSavings" in o && "hasAutoFmsTracking" in o && "hasNotifications" in o && "hasRequiredLeadSource" in o && "hasRequiredEmail" in o && "hasSortServiceItemsAlphabetically" in o && "hasAttachOrderToAppointmentEmails" in o && "scheduleInterval" in o && "colorsConfig" in o;}export function companyIs(obj: unknown): obj is Company {if(!companyHasShape(obj)){return false;}const result = companyDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type CompanyErrors = {_errors: __gf_Option<Array<string>>; id: __gf_Option<Array<string>>; legalName: __gf_Option<Array<string>>; headquarters: __gf_Option<Array<string>>; phones: __gf_Option<Array<string>>; fax: __gf_Option<Array<string>>; email: __gf_Option<Array<string>>; website: __gf_Option<Array<string>>; taxId: __gf_Option<Array<string>>; referenceNumber: __gf_Option<Array<string>>; postalCodeLookup: __gf_Option<Array<string>>; timeZone: __gf_Option<Array<string>>; defaultTax: __gf_Option<Array<string>>; defaultTaxLocation: __gf_Option<Array<string>>; defaultAreaCode: __gf_Option<Array<string>>; defaultAccountType: __gf_Option<Array<string>>; lookupFormatting: __gf_Option<Array<string>>; accountNameFormat: __gf_Option<Array<string>>; merchantServiceProvider: __gf_Option<Array<string>>; dateDisplayStyle: __gf_Option<Array<string>>; hasAutoCommission: __gf_Option<Array<string>>; hasAutoDaylightSavings: __gf_Option<Array<string>>; hasAutoFmsTracking: __gf_Option<Array<string>>; hasNotifications: __gf_Option<Array<string>>; hasRequiredLeadSource: __gf_Option<Array<string>>; hasRequiredEmail: __gf_Option<Array<string>>; hasSortServiceItemsAlphabetically: __gf_Option<Array<string>>; hasAttachOrderToAppointmentEmails: __gf_Option<Array<string>>; scheduleInterval: __gf_Option<Array<string>>; colorsConfig: __gf_Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type CompanyTainted = {id: __gf_Option<boolean>; legalName: __gf_Option<boolean>; headquarters: __gf_Option<boolean>; phones: __gf_Option<boolean>; fax: __gf_Option<boolean>; email: __gf_Option<boolean>; website: __gf_Option<boolean>; taxId: __gf_Option<boolean>; referenceNumber: __gf_Option<boolean>; postalCodeLookup: __gf_Option<boolean>; timeZone: __gf_Option<boolean>; defaultTax: __gf_Option<boolean>; defaultTaxLocation: __gf_Option<boolean>; defaultAreaCode: __gf_Option<boolean>; defaultAccountType: __gf_Option<boolean>; lookupFormatting: __gf_Option<boolean>; accountNameFormat: __gf_Option<boolean>; merchantServiceProvider: __gf_Option<boolean>; dateDisplayStyle: __gf_Option<boolean>; hasAutoCommission: __gf_Option<boolean>; hasAutoDaylightSavings: __gf_Option<boolean>; hasAutoFmsTracking: __gf_Option<boolean>; hasNotifications: __gf_Option<boolean>; hasRequiredLeadSource: __gf_Option<boolean>; hasRequiredEmail: __gf_Option<boolean>; hasSortServiceItemsAlphabetically: __gf_Option<boolean>; hasAttachOrderToAppointmentEmails: __gf_Option<boolean>; scheduleInterval: __gf_Option<boolean>; colorsConfig: __gf_Option<boolean>; }; /** Type-safe field controllers for this form */export interface CompanyFieldControllers {readonly id: FieldController<string>; readonly legalName: FieldController<string>; readonly headquarters: FieldController<string | Site>; readonly phones: ArrayFieldController<PhoneNumber>; readonly fax: FieldController<string>; readonly email: FieldController<string>; readonly website: FieldController<string>; readonly taxId: FieldController<string>; readonly referenceNumber: FieldController<number>; readonly postalCodeLookup: FieldController<string>; readonly timeZone: FieldController<string>; readonly defaultTax: FieldController<string | TaxRate>; readonly defaultTaxLocation: FieldController<string>; readonly defaultAreaCode: FieldController<number>; readonly defaultAccountType: FieldController<string>; readonly lookupFormatting: FieldController<string>; readonly accountNameFormat: FieldController<string>; readonly merchantServiceProvider: FieldController<string | null>; readonly dateDisplayStyle: FieldController<string>; readonly hasAutoCommission: FieldController<boolean>; readonly hasAutoDaylightSavings: FieldController<boolean>; readonly hasAutoFmsTracking: FieldController<boolean>; readonly hasNotifications: FieldController<boolean>; readonly hasRequiredLeadSource: FieldController<boolean>; readonly hasRequiredEmail: FieldController<boolean>; readonly hasSortServiceItemsAlphabetically: FieldController<boolean>; readonly hasAttachOrderToAppointmentEmails: FieldController<boolean>; readonly scheduleInterval: FieldController<number>; readonly colorsConfig: FieldController<ColorsConfig>; }/** Gigaform instance containing reactive state and field controllers */export interface CompanyGigaform {readonly data: Company; readonly errors: CompanyErrors; readonly tainted: CompanyTainted; readonly fields: CompanyFieldControllers; validate(): Exit<Company, Array<{field: string; message: string}>>; reset(overrides?: Partial<Company>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function companyCreateForm(overrides?: Partial<Company>): CompanyGigaform {let data = $state({...companyDefaultValue(),...overrides}); let errors = $state<CompanyErrors>({_errors: optionNone(), id: optionNone(), legalName: optionNone(), headquarters: optionNone(), phones: optionNone(), fax: optionNone(), email: optionNone(), website: optionNone(), taxId: optionNone(), referenceNumber: optionNone(), postalCodeLookup: optionNone(), timeZone: optionNone(), defaultTax: optionNone(), defaultTaxLocation: optionNone(), defaultAreaCode: optionNone(), defaultAccountType: optionNone(), lookupFormatting: optionNone(), accountNameFormat: optionNone(), merchantServiceProvider: optionNone(), dateDisplayStyle: optionNone(), hasAutoCommission: optionNone(), hasAutoDaylightSavings: optionNone(), hasAutoFmsTracking: optionNone(), hasNotifications: optionNone(), hasRequiredLeadSource: optionNone(), hasRequiredEmail: optionNone(), hasSortServiceItemsAlphabetically: optionNone(), hasAttachOrderToAppointmentEmails: optionNone(), scheduleInterval: optionNone(), colorsConfig: optionNone(), }); let tainted = $state<CompanyTainted>({id: optionNone(), legalName: optionNone(), headquarters: optionNone(), phones: optionNone(), fax: optionNone(), email: optionNone(), website: optionNone(), taxId: optionNone(), referenceNumber: optionNone(), postalCodeLookup: optionNone(), timeZone: optionNone(), defaultTax: optionNone(), defaultTaxLocation: optionNone(), defaultAreaCode: optionNone(), defaultAccountType: optionNone(), lookupFormatting: optionNone(), accountNameFormat: optionNone(), merchantServiceProvider: optionNone(), dateDisplayStyle: optionNone(), hasAutoCommission: optionNone(), hasAutoDaylightSavings: optionNone(), hasAutoFmsTracking: optionNone(), hasNotifications: optionNone(), hasRequiredLeadSource: optionNone(), hasRequiredEmail: optionNone(), hasSortServiceItemsAlphabetically: optionNone(), hasAttachOrderToAppointmentEmails: optionNone(), scheduleInterval: optionNone(), colorsConfig: optionNone(), }); const fields: CompanyFieldControllers = {id: {path: ["id" ]as const, name: "id" , constraints: { required: true }, get: ()=>data.id, set: (value: string)=>{data.id = value;}, transform: (value: string): string =>value,getError: ()=>errors.id, setError: (value: __gf_Option<Array<string>>)=>{errors.id = value;}, getTainted: ()=>tainted.id, setTainted: (value: __gf_Option<boolean>)=>{tainted.id = value;}, validate: (): Array<string>=>{const fieldErrors = companyValidateField("id", data.id); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},legalName: {path: ["legalName" ]as const, name: "legalName" , constraints: { required: true }, get: ()=>data.legalName, set: (value: string)=>{data.legalName = value;}, transform: (value: string): string =>value,getError: ()=>errors.legalName, setError: (value: __gf_Option<Array<string>>)=>{errors.legalName = value;}, getTainted: ()=>tainted.legalName, setTainted: (value: __gf_Option<boolean>)=>{tainted.legalName = value;}, validate: (): Array<string>=>{const fieldErrors = companyValidateField("legalName", data.legalName); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},headquarters: {path: ["headquarters" ]as const, name: "headquarters" , constraints: { required: true }, get: ()=>data.headquarters, set: (value: string | Site)=>{data.headquarters = value;}, transform: (value: string | Site): string | Site =>value,getError: ()=>errors.headquarters, setError: (value: __gf_Option<Array<string>>)=>{errors.headquarters = value;}, getTainted: ()=>tainted.headquarters, setTainted: (value: __gf_Option<boolean>)=>{tainted.headquarters = value;}, validate: (): Array<string>=>{const fieldErrors = companyValidateField("headquarters", data.headquarters); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},phones: {path: ["phones" ]as const, name: "phones" , constraints: { required: true }, get: ()=>data.phones, set: (value: PhoneNumber[])=>{data.phones = value;}, transform: (value: PhoneNumber[]): PhoneNumber[] =>value,getError: ()=>errors.phones, setError: (value: __gf_Option<Array<string>>)=>{errors.phones = value;}, getTainted: ()=>tainted.phones, setTainted: (value: __gf_Option<boolean>)=>{tainted.phones = value;}, validate: (): Array<string>=>{const fieldErrors = companyValidateField("phones", data.phones); return fieldErrors.map((e: {field: string; message: string})=>e.message);},at: (index: number)=>({path: ["phones" , index]as const, name: `phones.${index}` , constraints: {required: true}, get: ()=>data.phones[index]!, set: (value: PhoneNumber)=>{data.phones[index]= value;}, transform: (value: PhoneNumber): PhoneNumber =>value, getError: ()=>errors.phones, setError: (value: __gf_Option<Array<string>>)=>{errors.phones = value;}, getTainted: ()=>tainted.phones, setTainted: (value: __gf_Option<boolean>)=>{tainted.phones = value;}, validate: (): Array<string>=>[],}), push: (item: PhoneNumber)=>{data.phones.push(item);}, remove: (index: number)=>{data.phones.splice(index, 1);}, swap: (a: number, b: number)=>{const tmp = data.phones[a]!; data.phones[a]= data.phones[b]!; data.phones[b]= tmp;},},fax: {path: ["fax" ]as const, name: "fax" , constraints: { required: true }, get: ()=>data.fax, set: (value: string)=>{data.fax = value;}, transform: (value: string): string =>value,getError: ()=>errors.fax, setError: (value: __gf_Option<Array<string>>)=>{errors.fax = value;}, getTainted: ()=>tainted.fax, setTainted: (value: __gf_Option<boolean>)=>{tainted.fax = value;}, validate: (): Array<string>=>{const fieldErrors = companyValidateField("fax", data.fax); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},email: {path: ["email" ]as const, name: "email" , constraints: { required: true }, get: ()=>data.email, set: (value: string)=>{data.email = value;}, transform: (value: string): string =>value,getError: ()=>errors.email, setError: (value: __gf_Option<Array<string>>)=>{errors.email = value;}, getTainted: ()=>tainted.email, setTainted: (value: __gf_Option<boolean>)=>{tainted.email = value;}, validate: (): Array<string>=>{const fieldErrors = companyValidateField("email", data.email); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},website: {path: ["website" ]as const, name: "website" , constraints: { required: true }, get: ()=>data.website, set: (value: string)=>{data.website = value;}, transform: (value: string): string =>value,getError: ()=>errors.website, setError: (value: __gf_Option<Array<string>>)=>{errors.website = value;}, getTainted: ()=>tainted.website, setTainted: (value: __gf_Option<boolean>)=>{tainted.website = value;}, validate: (): Array<string>=>{const fieldErrors = companyValidateField("website", data.website); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},taxId: {path: ["taxId" ]as const, name: "taxId" , constraints: { required: true }, get: ()=>data.taxId, set: (value: string)=>{data.taxId = value;}, transform: (value: string): string =>value,getError: ()=>errors.taxId, setError: (value: __gf_Option<Array<string>>)=>{errors.taxId = value;}, getTainted: ()=>tainted.taxId, setTainted: (value: __gf_Option<boolean>)=>{tainted.taxId = value;}, validate: (): Array<string>=>{const fieldErrors = companyValidateField("taxId", data.taxId); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},referenceNumber: {path: ["referenceNumber" ]as const, name: "referenceNumber" , constraints: { required: true }, get: ()=>data.referenceNumber, set: (value: number)=>{data.referenceNumber = value;}, transform: (value: number): number =>value,getError: ()=>errors.referenceNumber, setError: (value: __gf_Option<Array<string>>)=>{errors.referenceNumber = value;}, getTainted: ()=>tainted.referenceNumber, setTainted: (value: __gf_Option<boolean>)=>{tainted.referenceNumber = value;}, validate: (): Array<string>=>{const fieldErrors = companyValidateField("referenceNumber", data.referenceNumber); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},postalCodeLookup: {path: ["postalCodeLookup" ]as const, name: "postalCodeLookup" , constraints: { required: true }, get: ()=>data.postalCodeLookup, set: (value: string)=>{data.postalCodeLookup = value;}, transform: (value: string): string =>value,getError: ()=>errors.postalCodeLookup, setError: (value: __gf_Option<Array<string>>)=>{errors.postalCodeLookup = value;}, getTainted: ()=>tainted.postalCodeLookup, setTainted: (value: __gf_Option<boolean>)=>{tainted.postalCodeLookup = value;}, validate: (): Array<string>=>{const fieldErrors = companyValidateField("postalCodeLookup", data.postalCodeLookup); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},timeZone: {path: ["timeZone" ]as const, name: "timeZone" , constraints: { required: true }, get: ()=>data.timeZone, set: (value: string)=>{data.timeZone = value;}, transform: (value: string): string =>value,getError: ()=>errors.timeZone, setError: (value: __gf_Option<Array<string>>)=>{errors.timeZone = value;}, getTainted: ()=>tainted.timeZone, setTainted: (value: __gf_Option<boolean>)=>{tainted.timeZone = value;}, validate: (): Array<string>=>{const fieldErrors = companyValidateField("timeZone", data.timeZone); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},defaultTax: {path: ["defaultTax" ]as const, name: "defaultTax" , constraints: { required: true }, get: ()=>data.defaultTax, set: (value: string | TaxRate)=>{data.defaultTax = value;}, transform: (value: string | TaxRate): string | TaxRate =>value,getError: ()=>errors.defaultTax, setError: (value: __gf_Option<Array<string>>)=>{errors.defaultTax = value;}, getTainted: ()=>tainted.defaultTax, setTainted: (value: __gf_Option<boolean>)=>{tainted.defaultTax = value;}, validate: (): Array<string>=>{const fieldErrors = companyValidateField("defaultTax", data.defaultTax); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},defaultTaxLocation: {path: ["defaultTaxLocation" ]as const, name: "defaultTaxLocation" , constraints: { required: true }, get: ()=>data.defaultTaxLocation, set: (value: string)=>{data.defaultTaxLocation = value;}, transform: (value: string): string =>value,getError: ()=>errors.defaultTaxLocation, setError: (value: __gf_Option<Array<string>>)=>{errors.defaultTaxLocation = value;}, getTainted: ()=>tainted.defaultTaxLocation, setTainted: (value: __gf_Option<boolean>)=>{tainted.defaultTaxLocation = value;}, validate: (): Array<string>=>{const fieldErrors = companyValidateField("defaultTaxLocation", data.defaultTaxLocation); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},defaultAreaCode: {path: ["defaultAreaCode" ]as const, name: "defaultAreaCode" , constraints: { required: true }, get: ()=>data.defaultAreaCode, set: (value: number)=>{data.defaultAreaCode = value;}, transform: (value: number): number =>value,getError: ()=>errors.defaultAreaCode, setError: (value: __gf_Option<Array<string>>)=>{errors.defaultAreaCode = value;}, getTainted: ()=>tainted.defaultAreaCode, setTainted: (value: __gf_Option<boolean>)=>{tainted.defaultAreaCode = value;}, validate: (): Array<string>=>{const fieldErrors = companyValidateField("defaultAreaCode", data.defaultAreaCode); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},defaultAccountType: {path: ["defaultAccountType" ]as const, name: "defaultAccountType" , constraints: { required: true }, get: ()=>data.defaultAccountType, set: (value: string)=>{data.defaultAccountType = value;}, transform: (value: string): string =>value,getError: ()=>errors.defaultAccountType, setError: (value: __gf_Option<Array<string>>)=>{errors.defaultAccountType = value;}, getTainted: ()=>tainted.defaultAccountType, setTainted: (value: __gf_Option<boolean>)=>{tainted.defaultAccountType = value;}, validate: (): Array<string>=>{const fieldErrors = companyValidateField("defaultAccountType", data.defaultAccountType); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},lookupFormatting: {path: ["lookupFormatting" ]as const, name: "lookupFormatting" , constraints: { required: true }, get: ()=>data.lookupFormatting, set: (value: string)=>{data.lookupFormatting = value;}, transform: (value: string): string =>value,getError: ()=>errors.lookupFormatting, setError: (value: __gf_Option<Array<string>>)=>{errors.lookupFormatting = value;}, getTainted: ()=>tainted.lookupFormatting, setTainted: (value: __gf_Option<boolean>)=>{tainted.lookupFormatting = value;}, validate: (): Array<string>=>{const fieldErrors = companyValidateField("lookupFormatting", data.lookupFormatting); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},accountNameFormat: {path: ["accountNameFormat" ]as const, name: "accountNameFormat" , constraints: { required: true }, get: ()=>data.accountNameFormat, set: (value: string)=>{data.accountNameFormat = value;}, transform: (value: string): string =>value,getError: ()=>errors.accountNameFormat, setError: (value: __gf_Option<Array<string>>)=>{errors.accountNameFormat = value;}, getTainted: ()=>tainted.accountNameFormat, setTainted: (value: __gf_Option<boolean>)=>{tainted.accountNameFormat = value;}, validate: (): Array<string>=>{const fieldErrors = companyValidateField("accountNameFormat", data.accountNameFormat); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},merchantServiceProvider: {path: ["merchantServiceProvider" ]as const, name: "merchantServiceProvider" , constraints: { required: true }, get: ()=>data.merchantServiceProvider, set: (value: string | null)=>{data.merchantServiceProvider = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.merchantServiceProvider, setError: (value: __gf_Option<Array<string>>)=>{errors.merchantServiceProvider = value;}, getTainted: ()=>tainted.merchantServiceProvider, setTainted: (value: __gf_Option<boolean>)=>{tainted.merchantServiceProvider = value;}, validate: (): Array<string>=>{const fieldErrors = companyValidateField("merchantServiceProvider", data.merchantServiceProvider); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},dateDisplayStyle: {path: ["dateDisplayStyle" ]as const, name: "dateDisplayStyle" , constraints: { required: true }, get: ()=>data.dateDisplayStyle, set: (value: string)=>{data.dateDisplayStyle = value;}, transform: (value: string): string =>value,getError: ()=>errors.dateDisplayStyle, setError: (value: __gf_Option<Array<string>>)=>{errors.dateDisplayStyle = value;}, getTainted: ()=>tainted.dateDisplayStyle, setTainted: (value: __gf_Option<boolean>)=>{tainted.dateDisplayStyle = value;}, validate: (): Array<string>=>{const fieldErrors = companyValidateField("dateDisplayStyle", data.dateDisplayStyle); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},hasAutoCommission: {path: ["hasAutoCommission" ]as const, name: "hasAutoCommission" , constraints: { required: true }, get: ()=>data.hasAutoCommission, set: (value: boolean)=>{data.hasAutoCommission = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.hasAutoCommission, setError: (value: __gf_Option<Array<string>>)=>{errors.hasAutoCommission = value;}, getTainted: ()=>tainted.hasAutoCommission, setTainted: (value: __gf_Option<boolean>)=>{tainted.hasAutoCommission = value;}, validate: (): Array<string>=>{const fieldErrors = companyValidateField("hasAutoCommission", data.hasAutoCommission); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},hasAutoDaylightSavings: {path: ["hasAutoDaylightSavings" ]as const, name: "hasAutoDaylightSavings" , constraints: { required: true }, get: ()=>data.hasAutoDaylightSavings, set: (value: boolean)=>{data.hasAutoDaylightSavings = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.hasAutoDaylightSavings, setError: (value: __gf_Option<Array<string>>)=>{errors.hasAutoDaylightSavings = value;}, getTainted: ()=>tainted.hasAutoDaylightSavings, setTainted: (value: __gf_Option<boolean>)=>{tainted.hasAutoDaylightSavings = value;}, validate: (): Array<string>=>{const fieldErrors = companyValidateField("hasAutoDaylightSavings", data.hasAutoDaylightSavings); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},hasAutoFmsTracking: {path: ["hasAutoFmsTracking" ]as const, name: "hasAutoFmsTracking" , constraints: { required: true }, get: ()=>data.hasAutoFmsTracking, set: (value: boolean)=>{data.hasAutoFmsTracking = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.hasAutoFmsTracking, setError: (value: __gf_Option<Array<string>>)=>{errors.hasAutoFmsTracking = value;}, getTainted: ()=>tainted.hasAutoFmsTracking, setTainted: (value: __gf_Option<boolean>)=>{tainted.hasAutoFmsTracking = value;}, validate: (): Array<string>=>{const fieldErrors = companyValidateField("hasAutoFmsTracking", data.hasAutoFmsTracking); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},hasNotifications: {path: ["hasNotifications" ]as const, name: "hasNotifications" , constraints: { required: true }, get: ()=>data.hasNotifications, set: (value: boolean)=>{data.hasNotifications = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.hasNotifications, setError: (value: __gf_Option<Array<string>>)=>{errors.hasNotifications = value;}, getTainted: ()=>tainted.hasNotifications, setTainted: (value: __gf_Option<boolean>)=>{tainted.hasNotifications = value;}, validate: (): Array<string>=>{const fieldErrors = companyValidateField("hasNotifications", data.hasNotifications); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},hasRequiredLeadSource: {path: ["hasRequiredLeadSource" ]as const, name: "hasRequiredLeadSource" , constraints: { required: true }, get: ()=>data.hasRequiredLeadSource, set: (value: boolean)=>{data.hasRequiredLeadSource = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.hasRequiredLeadSource, setError: (value: __gf_Option<Array<string>>)=>{errors.hasRequiredLeadSource = value;}, getTainted: ()=>tainted.hasRequiredLeadSource, setTainted: (value: __gf_Option<boolean>)=>{tainted.hasRequiredLeadSource = value;}, validate: (): Array<string>=>{const fieldErrors = companyValidateField("hasRequiredLeadSource", data.hasRequiredLeadSource); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},hasRequiredEmail: {path: ["hasRequiredEmail" ]as const, name: "hasRequiredEmail" , constraints: { required: true }, get: ()=>data.hasRequiredEmail, set: (value: boolean)=>{data.hasRequiredEmail = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.hasRequiredEmail, setError: (value: __gf_Option<Array<string>>)=>{errors.hasRequiredEmail = value;}, getTainted: ()=>tainted.hasRequiredEmail, setTainted: (value: __gf_Option<boolean>)=>{tainted.hasRequiredEmail = value;}, validate: (): Array<string>=>{const fieldErrors = companyValidateField("hasRequiredEmail", data.hasRequiredEmail); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},hasSortServiceItemsAlphabetically: {path: ["hasSortServiceItemsAlphabetically" ]as const, name: "hasSortServiceItemsAlphabetically" , constraints: { required: true }, get: ()=>data.hasSortServiceItemsAlphabetically, set: (value: boolean)=>{data.hasSortServiceItemsAlphabetically = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.hasSortServiceItemsAlphabetically, setError: (value: __gf_Option<Array<string>>)=>{errors.hasSortServiceItemsAlphabetically = value;}, getTainted: ()=>tainted.hasSortServiceItemsAlphabetically, setTainted: (value: __gf_Option<boolean>)=>{tainted.hasSortServiceItemsAlphabetically = value;}, validate: (): Array<string>=>{const fieldErrors = companyValidateField("hasSortServiceItemsAlphabetically", data.hasSortServiceItemsAlphabetically); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},hasAttachOrderToAppointmentEmails: {path: ["hasAttachOrderToAppointmentEmails" ]as const, name: "hasAttachOrderToAppointmentEmails" , constraints: { required: true }, get: ()=>data.hasAttachOrderToAppointmentEmails, set: (value: boolean)=>{data.hasAttachOrderToAppointmentEmails = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.hasAttachOrderToAppointmentEmails, setError: (value: __gf_Option<Array<string>>)=>{errors.hasAttachOrderToAppointmentEmails = value;}, getTainted: ()=>tainted.hasAttachOrderToAppointmentEmails, setTainted: (value: __gf_Option<boolean>)=>{tainted.hasAttachOrderToAppointmentEmails = value;}, validate: (): Array<string>=>{const fieldErrors = companyValidateField("hasAttachOrderToAppointmentEmails", data.hasAttachOrderToAppointmentEmails); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},scheduleInterval: {path: ["scheduleInterval" ]as const, name: "scheduleInterval" , constraints: { required: true }, get: ()=>data.scheduleInterval, set: (value: number)=>{data.scheduleInterval = value;}, transform: (value: number): number =>value,getError: ()=>errors.scheduleInterval, setError: (value: __gf_Option<Array<string>>)=>{errors.scheduleInterval = value;}, getTainted: ()=>tainted.scheduleInterval, setTainted: (value: __gf_Option<boolean>)=>{tainted.scheduleInterval = value;}, validate: (): Array<string>=>{const fieldErrors = companyValidateField("scheduleInterval", data.scheduleInterval); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},colorsConfig: {path: ["colorsConfig" ]as const, name: "colorsConfig" , constraints: { required: true }, get: ()=>data.colorsConfig, set: (value: ColorsConfig)=>{data.colorsConfig = value;}, transform: (value: ColorsConfig): ColorsConfig =>value,getError: ()=>errors.colorsConfig, setError: (value: __gf_Option<Array<string>>)=>{errors.colorsConfig = value;}, getTainted: ()=>tainted.colorsConfig, setTainted: (value: __gf_Option<boolean>)=>{tainted.colorsConfig = value;}, validate: (): Array<string>=>{const fieldErrors = companyValidateField("colorsConfig", data.colorsConfig); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Exit<Company, Array<{field: string; message: string}>>{return toExit(companyDeserialize(data));}function reset(newOverrides?: Partial<Company>): void {data = {...companyDefaultValue(),...newOverrides}; errors = {_errors: optionNone(), id: optionNone(), legalName: optionNone(), headquarters: optionNone(), phones: optionNone(), fax: optionNone(), email: optionNone(), website: optionNone(), taxId: optionNone(), referenceNumber: optionNone(), postalCodeLookup: optionNone(), timeZone: optionNone(), defaultTax: optionNone(), defaultTaxLocation: optionNone(), defaultAreaCode: optionNone(), defaultAccountType: optionNone(), lookupFormatting: optionNone(), accountNameFormat: optionNone(), merchantServiceProvider: optionNone(), dateDisplayStyle: optionNone(), hasAutoCommission: optionNone(), hasAutoDaylightSavings: optionNone(), hasAutoFmsTracking: optionNone(), hasNotifications: optionNone(), hasRequiredLeadSource: optionNone(), hasRequiredEmail: optionNone(), hasSortServiceItemsAlphabetically: optionNone(), hasAttachOrderToAppointmentEmails: optionNone(), scheduleInterval: optionNone(), colorsConfig: optionNone(), }; tainted = {id: optionNone(), legalName: optionNone(), headquarters: optionNone(), phones: optionNone(), fax: optionNone(), email: optionNone(), website: optionNone(), taxId: optionNone(), referenceNumber: optionNone(), postalCodeLookup: optionNone(), timeZone: optionNone(), defaultTax: optionNone(), defaultTaxLocation: optionNone(), defaultAreaCode: optionNone(), defaultAccountType: optionNone(), lookupFormatting: optionNone(), accountNameFormat: optionNone(), merchantServiceProvider: optionNone(), dateDisplayStyle: optionNone(), hasAutoCommission: optionNone(), hasAutoDaylightSavings: optionNone(), hasAutoFmsTracking: optionNone(), hasNotifications: optionNone(), hasRequiredLeadSource: optionNone(), hasRequiredEmail: optionNone(), hasSortServiceItemsAlphabetically: optionNone(), hasAttachOrderToAppointmentEmails: optionNone(), scheduleInterval: optionNone(), colorsConfig: optionNone(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function companyFromFormData(formData: FormData): Exit<Company, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.id = formData.get("id" )?? "" ;obj.legalName = formData.get("legalName" )?? "" ;obj.headquarters = formData.get("headquarters" )?? "" ;{const phonesItems: Array<Record<string, unknown>>= []; let idx = 0; while(formData.has("phones." + idx + "." )|| idx === 0){const hasAny = Array.from(formData.keys()).some(k =>k.startsWith("phones." + idx + "." )); if(!hasAny && idx>0)break; if(hasAny){const item: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("phones." + idx + "." )){const fieldName = key.slice("phones." .length + String(idx).length + 1); item[fieldName]= value;}}phonesItems.push(item);}idx ++; if(idx>1000)break;}obj.phones = phonesItems;}obj.fax = formData.get("fax" )?? "" ;obj.email = formData.get("email" )?? "" ;obj.website = formData.get("website" )?? "" ;obj.taxId = formData.get("taxId" )?? "" ;{const referenceNumberStr = formData.get("referenceNumber" ); obj.referenceNumber = referenceNumberStr? parseFloat(referenceNumberStr as string): 0; if(obj.referenceNumber!== undefined && isNaN(obj.referenceNumber as number))obj.referenceNumber = 0;}obj.postalCodeLookup = formData.get("postalCodeLookup" )?? "" ;obj.timeZone = formData.get("timeZone" )?? "" ;obj.defaultTax = formData.get("defaultTax" )?? "" ;obj.defaultTaxLocation = formData.get("defaultTaxLocation" )?? "" ;{const defaultAreaCodeStr = formData.get("defaultAreaCode" ); obj.defaultAreaCode = defaultAreaCodeStr? parseFloat(defaultAreaCodeStr as string): 0; if(obj.defaultAreaCode!== undefined && isNaN(obj.defaultAreaCode as number))obj.defaultAreaCode = 0;}obj.defaultAccountType = formData.get("defaultAccountType" )?? "" ;obj.lookupFormatting = formData.get("lookupFormatting" )?? "" ;obj.accountNameFormat = formData.get("accountNameFormat" )?? "" ;obj.merchantServiceProvider = formData.get("merchantServiceProvider" )?? "" ;obj.dateDisplayStyle = formData.get("dateDisplayStyle" )?? "" ;{const hasAutoCommissionVal = formData.get("hasAutoCommission" ); obj.hasAutoCommission = hasAutoCommissionVal === "true" || hasAutoCommissionVal === "on" || hasAutoCommissionVal === "1" ;}{const hasAutoDaylightSavingsVal = formData.get("hasAutoDaylightSavings" ); obj.hasAutoDaylightSavings = hasAutoDaylightSavingsVal === "true" || hasAutoDaylightSavingsVal === "on" || hasAutoDaylightSavingsVal === "1" ;}{const hasAutoFmsTrackingVal = formData.get("hasAutoFmsTracking" ); obj.hasAutoFmsTracking = hasAutoFmsTrackingVal === "true" || hasAutoFmsTrackingVal === "on" || hasAutoFmsTrackingVal === "1" ;}{const hasNotificationsVal = formData.get("hasNotifications" ); obj.hasNotifications = hasNotificationsVal === "true" || hasNotificationsVal === "on" || hasNotificationsVal === "1" ;}{const hasRequiredLeadSourceVal = formData.get("hasRequiredLeadSource" ); obj.hasRequiredLeadSource = hasRequiredLeadSourceVal === "true" || hasRequiredLeadSourceVal === "on" || hasRequiredLeadSourceVal === "1" ;}{const hasRequiredEmailVal = formData.get("hasRequiredEmail" ); obj.hasRequiredEmail = hasRequiredEmailVal === "true" || hasRequiredEmailVal === "on" || hasRequiredEmailVal === "1" ;}{const hasSortServiceItemsAlphabeticallyVal = formData.get("hasSortServiceItemsAlphabetically" ); obj.hasSortServiceItemsAlphabetically = hasSortServiceItemsAlphabeticallyVal === "true" || hasSortServiceItemsAlphabeticallyVal === "on" || hasSortServiceItemsAlphabeticallyVal === "1" ;}{const hasAttachOrderToAppointmentEmailsVal = formData.get("hasAttachOrderToAppointmentEmails" ); obj.hasAttachOrderToAppointmentEmails = hasAttachOrderToAppointmentEmailsVal === "true" || hasAttachOrderToAppointmentEmailsVal === "on" || hasAttachOrderToAppointmentEmailsVal === "1" ;}{const scheduleIntervalStr = formData.get("scheduleInterval" ); obj.scheduleInterval = scheduleIntervalStr? parseFloat(scheduleIntervalStr as string): 0; if(obj.scheduleInterval!== undefined && isNaN(obj.scheduleInterval as number))obj.scheduleInterval = 0;}{const colorsConfigObj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("colorsConfig." )){const fieldName = key.slice("colorsConfig." .length); const parts = fieldName.split("." ); let current = colorsConfigObj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.colorsConfig = colorsConfigObj;}return toExit(companyDeserialize(obj));}

export const Company = {
  defaultValue: companyDefaultValue,
  serialize: companySerialize,
  serializeWithContext: companySerializeWithContext,
  deserialize: companyDeserialize,
  deserializeWithContext: companyDeserializeWithContext,
  validateFields: companyValidateFields,
  hasShape: companyHasShape,
  is: companyIs,
  createForm: companyCreateForm,
  fromFormData: companyFromFormData
} as const;


export interface Ordinal {
    north: number;
    northeast: number;
    east: number;
    southeast: number;
    south: number;
    southwest: number;
    west: number;
    northwest: number;
}

export function ordinalDefaultValue(): Ordinal {return {north: 0,
                            northeast: 0,
                            east: 0,
                            southeast: 0,
                            south: 0,
                            southwest: 0,
                            west: 0,
                            northwest: 0, }as Ordinal;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function ordinalSerialize(value: Ordinal): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(ordinalSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function ordinalSerializeWithContext(value: Ordinal, ctx: __mf_SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Ordinal" , __id,}; result["north" ]= value.north; result["northeast" ]= value.northeast; result["east" ]= value.east; result["southeast" ]= value.southeast; result["south" ]= value.south; result["southwest" ]= value.southwest; result["west" ]= value.west; result["northwest" ]= value.northwest; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function ordinalDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: Ordinal } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = ordinalDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Ordinal.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function ordinalDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Ordinal | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new __mf_DeserializeError([{field: "_root" , message: "Ordinal.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("north" in obj)){errors.push({field: "north" , message: "missing required field" });}if(!("northeast" in obj)){errors.push({field: "northeast" , message: "missing required field" });}if(!("east" in obj)){errors.push({field: "east" , message: "missing required field" });}if(!("southeast" in obj)){errors.push({field: "southeast" , message: "missing required field" });}if(!("south" in obj)){errors.push({field: "south" , message: "missing required field" });}if(!("southwest" in obj)){errors.push({field: "southwest" , message: "missing required field" });}if(!("west" in obj)){errors.push({field: "west" , message: "missing required field" });}if(!("northwest" in obj)){errors.push({field: "northwest" , message: "missing required field" });}if(errors.length>0){throw new __mf_DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_north = obj["north" ]as number; instance.north = __raw_north; }{const __raw_northeast = obj["northeast" ]as number; instance.northeast = __raw_northeast; }{const __raw_east = obj["east" ]as number; instance.east = __raw_east; }{const __raw_southeast = obj["southeast" ]as number; instance.southeast = __raw_southeast; }{const __raw_south = obj["south" ]as number; instance.south = __raw_south; }{const __raw_southwest = obj["southwest" ]as number; instance.southwest = __raw_southwest; }{const __raw_west = obj["west" ]as number; instance.west = __raw_west; }{const __raw_northwest = obj["northwest" ]as number; instance.northwest = __raw_northwest; }if(errors.length>0){throw new __mf_DeserializeError(errors);}return instance as Ordinal;}export function ordinalValidateField<K extends keyof Ordinal>(_field: K, _value: Ordinal[K]): Array<{field: string; message: string}>{return[]; }export function ordinalValidateFields(_partial: Partial<Ordinal>): Array<{field: string; message: string}>{return[]; }export function ordinalHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "north" in o && "northeast" in o && "east" in o && "southeast" in o && "south" in o && "southwest" in o && "west" in o && "northwest" in o;}export function ordinalIs(obj: unknown): obj is Ordinal {if(!ordinalHasShape(obj)){return false;}const result = ordinalDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type OrdinalErrors = {_errors: __gf_Option<Array<string>>; north: __gf_Option<Array<string>>; northeast: __gf_Option<Array<string>>; east: __gf_Option<Array<string>>; southeast: __gf_Option<Array<string>>; south: __gf_Option<Array<string>>; southwest: __gf_Option<Array<string>>; west: __gf_Option<Array<string>>; northwest: __gf_Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type OrdinalTainted = {north: __gf_Option<boolean>; northeast: __gf_Option<boolean>; east: __gf_Option<boolean>; southeast: __gf_Option<boolean>; south: __gf_Option<boolean>; southwest: __gf_Option<boolean>; west: __gf_Option<boolean>; northwest: __gf_Option<boolean>; }; /** Type-safe field controllers for this form */export interface OrdinalFieldControllers {readonly north: FieldController<number>; readonly northeast: FieldController<number>; readonly east: FieldController<number>; readonly southeast: FieldController<number>; readonly south: FieldController<number>; readonly southwest: FieldController<number>; readonly west: FieldController<number>; readonly northwest: FieldController<number>; }/** Gigaform instance containing reactive state and field controllers */export interface OrdinalGigaform {readonly data: Ordinal; readonly errors: OrdinalErrors; readonly tainted: OrdinalTainted; readonly fields: OrdinalFieldControllers; validate(): Exit<Ordinal, Array<{field: string; message: string}>>; reset(overrides?: Partial<Ordinal>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function ordinalCreateForm(overrides?: Partial<Ordinal>): OrdinalGigaform {let data = $state({...ordinalDefaultValue(),...overrides}); let errors = $state<OrdinalErrors>({_errors: optionNone(), north: optionNone(), northeast: optionNone(), east: optionNone(), southeast: optionNone(), south: optionNone(), southwest: optionNone(), west: optionNone(), northwest: optionNone(), }); let tainted = $state<OrdinalTainted>({north: optionNone(), northeast: optionNone(), east: optionNone(), southeast: optionNone(), south: optionNone(), southwest: optionNone(), west: optionNone(), northwest: optionNone(), }); const fields: OrdinalFieldControllers = {north: {path: ["north" ]as const, name: "north" , constraints: { required: true }, get: ()=>data.north, set: (value: number)=>{data.north = value;}, transform: (value: number): number =>value,getError: ()=>errors.north, setError: (value: __gf_Option<Array<string>>)=>{errors.north = value;}, getTainted: ()=>tainted.north, setTainted: (value: __gf_Option<boolean>)=>{tainted.north = value;}, validate: (): Array<string>=>{const fieldErrors = ordinalValidateField("north", data.north); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},northeast: {path: ["northeast" ]as const, name: "northeast" , constraints: { required: true }, get: ()=>data.northeast, set: (value: number)=>{data.northeast = value;}, transform: (value: number): number =>value,getError: ()=>errors.northeast, setError: (value: __gf_Option<Array<string>>)=>{errors.northeast = value;}, getTainted: ()=>tainted.northeast, setTainted: (value: __gf_Option<boolean>)=>{tainted.northeast = value;}, validate: (): Array<string>=>{const fieldErrors = ordinalValidateField("northeast", data.northeast); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},east: {path: ["east" ]as const, name: "east" , constraints: { required: true }, get: ()=>data.east, set: (value: number)=>{data.east = value;}, transform: (value: number): number =>value,getError: ()=>errors.east, setError: (value: __gf_Option<Array<string>>)=>{errors.east = value;}, getTainted: ()=>tainted.east, setTainted: (value: __gf_Option<boolean>)=>{tainted.east = value;}, validate: (): Array<string>=>{const fieldErrors = ordinalValidateField("east", data.east); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},southeast: {path: ["southeast" ]as const, name: "southeast" , constraints: { required: true }, get: ()=>data.southeast, set: (value: number)=>{data.southeast = value;}, transform: (value: number): number =>value,getError: ()=>errors.southeast, setError: (value: __gf_Option<Array<string>>)=>{errors.southeast = value;}, getTainted: ()=>tainted.southeast, setTainted: (value: __gf_Option<boolean>)=>{tainted.southeast = value;}, validate: (): Array<string>=>{const fieldErrors = ordinalValidateField("southeast", data.southeast); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},south: {path: ["south" ]as const, name: "south" , constraints: { required: true }, get: ()=>data.south, set: (value: number)=>{data.south = value;}, transform: (value: number): number =>value,getError: ()=>errors.south, setError: (value: __gf_Option<Array<string>>)=>{errors.south = value;}, getTainted: ()=>tainted.south, setTainted: (value: __gf_Option<boolean>)=>{tainted.south = value;}, validate: (): Array<string>=>{const fieldErrors = ordinalValidateField("south", data.south); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},southwest: {path: ["southwest" ]as const, name: "southwest" , constraints: { required: true }, get: ()=>data.southwest, set: (value: number)=>{data.southwest = value;}, transform: (value: number): number =>value,getError: ()=>errors.southwest, setError: (value: __gf_Option<Array<string>>)=>{errors.southwest = value;}, getTainted: ()=>tainted.southwest, setTainted: (value: __gf_Option<boolean>)=>{tainted.southwest = value;}, validate: (): Array<string>=>{const fieldErrors = ordinalValidateField("southwest", data.southwest); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},west: {path: ["west" ]as const, name: "west" , constraints: { required: true }, get: ()=>data.west, set: (value: number)=>{data.west = value;}, transform: (value: number): number =>value,getError: ()=>errors.west, setError: (value: __gf_Option<Array<string>>)=>{errors.west = value;}, getTainted: ()=>tainted.west, setTainted: (value: __gf_Option<boolean>)=>{tainted.west = value;}, validate: (): Array<string>=>{const fieldErrors = ordinalValidateField("west", data.west); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},northwest: {path: ["northwest" ]as const, name: "northwest" , constraints: { required: true }, get: ()=>data.northwest, set: (value: number)=>{data.northwest = value;}, transform: (value: number): number =>value,getError: ()=>errors.northwest, setError: (value: __gf_Option<Array<string>>)=>{errors.northwest = value;}, getTainted: ()=>tainted.northwest, setTainted: (value: __gf_Option<boolean>)=>{tainted.northwest = value;}, validate: (): Array<string>=>{const fieldErrors = ordinalValidateField("northwest", data.northwest); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Exit<Ordinal, Array<{field: string; message: string}>>{return toExit(ordinalDeserialize(data));}function reset(newOverrides?: Partial<Ordinal>): void {data = {...ordinalDefaultValue(),...newOverrides}; errors = {_errors: optionNone(), north: optionNone(), northeast: optionNone(), east: optionNone(), southeast: optionNone(), south: optionNone(), southwest: optionNone(), west: optionNone(), northwest: optionNone(), }; tainted = {north: optionNone(), northeast: optionNone(), east: optionNone(), southeast: optionNone(), south: optionNone(), southwest: optionNone(), west: optionNone(), northwest: optionNone(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function ordinalFromFormData(formData: FormData): Exit<Ordinal, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; {const northStr = formData.get("north" ); obj.north = northStr? parseFloat(northStr as string): 0; if(obj.north!== undefined && isNaN(obj.north as number))obj.north = 0;}{const northeastStr = formData.get("northeast" ); obj.northeast = northeastStr? parseFloat(northeastStr as string): 0; if(obj.northeast!== undefined && isNaN(obj.northeast as number))obj.northeast = 0;}{const eastStr = formData.get("east" ); obj.east = eastStr? parseFloat(eastStr as string): 0; if(obj.east!== undefined && isNaN(obj.east as number))obj.east = 0;}{const southeastStr = formData.get("southeast" ); obj.southeast = southeastStr? parseFloat(southeastStr as string): 0; if(obj.southeast!== undefined && isNaN(obj.southeast as number))obj.southeast = 0;}{const southStr = formData.get("south" ); obj.south = southStr? parseFloat(southStr as string): 0; if(obj.south!== undefined && isNaN(obj.south as number))obj.south = 0;}{const southwestStr = formData.get("southwest" ); obj.southwest = southwestStr? parseFloat(southwestStr as string): 0; if(obj.southwest!== undefined && isNaN(obj.southwest as number))obj.southwest = 0;}{const westStr = formData.get("west" ); obj.west = westStr? parseFloat(westStr as string): 0; if(obj.west!== undefined && isNaN(obj.west as number))obj.west = 0;}{const northwestStr = formData.get("northwest" ); obj.northwest = northwestStr? parseFloat(northwestStr as string): 0; if(obj.northwest!== undefined && isNaN(obj.northwest as number))obj.northwest = 0;}return toExit(ordinalDeserialize(obj));}

export const Ordinal = {
  defaultValue: ordinalDefaultValue,
  serialize: ordinalSerialize,
  serializeWithContext: ordinalSerializeWithContext,
  deserialize: ordinalDeserialize,
  deserializeWithContext: ordinalDeserializeWithContext,
  validateFields: ordinalValidateFields,
  hasShape: ordinalHasShape,
  is: ordinalIs,
  createForm: ordinalCreateForm,
  fromFormData: ordinalFromFormData
} as const;


export interface Password {
    
    password: string;
}

export function passwordDefaultValue(): Password {return {password: "", }as Password;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function passwordSerialize(value: Password): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(passwordSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function passwordSerializeWithContext(value: Password, ctx: __mf_SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Password" , __id,}; result["password" ]= value.password; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function passwordDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: Password } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = passwordDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Password.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function passwordDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Password | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new __mf_DeserializeError([{field: "_root" , message: "Password.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("password" in obj)){errors.push({field: "password" , message: "missing required field" });}if(errors.length>0){throw new __mf_DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_password = obj["password" ]as string; 
                if (__raw_password.length === 0) {
                    errors.push({ field: "password", message: "must not be empty" });
                }
 instance.password = __raw_password; }if(errors.length>0){throw new __mf_DeserializeError(errors);}return instance as Password;}export function passwordValidateField<K extends keyof Password>(_field: K, _value: Password[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(_field){case "password" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "password", message: "must not be empty" });
                }
 break;}}return errors; }export function passwordValidateFields(_partial: Partial<Password>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("password" in _partial && _partial.password!== undefined){const __val = _partial.password as string; 
                if (__val.length === 0) {
                    errors.push({ field: "password", message: "must not be empty" });
                }
}return errors; }export function passwordHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "password" in o;}export function passwordIs(obj: unknown): obj is Password {if(!passwordHasShape(obj)){return false;}const result = passwordDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type PasswordErrors = {_errors: __gf_Option<Array<string>>; password: __gf_Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type PasswordTainted = {password: __gf_Option<boolean>; }; /** Type-safe field controllers for this form */export interface PasswordFieldControllers {readonly password: FieldController<string>; }/** Gigaform instance containing reactive state and field controllers */export interface PasswordGigaform {readonly data: Password; readonly errors: PasswordErrors; readonly tainted: PasswordTainted; readonly fields: PasswordFieldControllers; validate(): Exit<Password, Array<{field: string; message: string}>>; reset(overrides?: Partial<Password>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function passwordCreateForm(overrides?: Partial<Password>): PasswordGigaform {let data = $state({...passwordDefaultValue(),...overrides}); let errors = $state<PasswordErrors>({_errors: optionNone(), password: optionNone(), }); let tainted = $state<PasswordTainted>({password: optionNone(), }); const fields: PasswordFieldControllers = {password: {path: ["password" ]as const, name: "password" , constraints: { required: true }, get: ()=>data.password, set: (value: string)=>{data.password = value;}, transform: (value: string): string =>value,getError: ()=>errors.password, setError: (value: __gf_Option<Array<string>>)=>{errors.password = value;}, getTainted: ()=>tainted.password, setTainted: (value: __gf_Option<boolean>)=>{tainted.password = value;}, validate: (): Array<string>=>{const fieldErrors = passwordValidateField("password", data.password); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Exit<Password, Array<{field: string; message: string}>>{return toExit(passwordDeserialize(data));}function reset(newOverrides?: Partial<Password>): void {data = {...passwordDefaultValue(),...newOverrides}; errors = {_errors: optionNone(), password: optionNone(), }; tainted = {password: optionNone(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function passwordFromFormData(formData: FormData): Exit<Password, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.password = formData.get("password" )?? "" ;return toExit(passwordDeserialize(obj));}

export const Password = {
  defaultValue: passwordDefaultValue,
  serialize: passwordSerialize,
  serializeWithContext: passwordSerializeWithContext,
  deserialize: passwordDeserialize,
  deserializeWithContext: passwordDeserializeWithContext,
  validateFields: passwordValidateFields,
  hasShape: passwordHasShape,
  is: passwordIs,
  createForm: passwordCreateForm,
  fromFormData: passwordFromFormData
} as const;


export interface Created {
    initialData: string | null;
}

export function createdDefaultValue(): Created {return {initialData: null, }as Created;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function createdSerialize(value: Created): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(createdSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function createdSerializeWithContext(value: Created, ctx: __mf_SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Created" , __id,}; result["initialData" ]= value.initialData; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function createdDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: Created } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = createdDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Created.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function createdDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Created | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new __mf_DeserializeError([{field: "_root" , message: "Created.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("initialData" in obj)){errors.push({field: "initialData" , message: "missing required field" });}if(errors.length>0){throw new __mf_DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_initialData = obj["initialData" ]as string | null; instance.initialData = __raw_initialData; }if(errors.length>0){throw new __mf_DeserializeError(errors);}return instance as Created;}export function createdValidateField<K extends keyof Created>(_field: K, _value: Created[K]): Array<{field: string; message: string}>{return[]; }export function createdValidateFields(_partial: Partial<Created>): Array<{field: string; message: string}>{return[]; }export function createdHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "initialData" in o;}export function createdIs(obj: unknown): obj is Created {if(!createdHasShape(obj)){return false;}const result = createdDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type CreatedErrors = {_errors: __gf_Option<Array<string>>; initialData: __gf_Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type CreatedTainted = {initialData: __gf_Option<boolean>; }; /** Type-safe field controllers for this form */export interface CreatedFieldControllers {readonly initialData: FieldController<string | null>; }/** Gigaform instance containing reactive state and field controllers */export interface CreatedGigaform {readonly data: Created; readonly errors: CreatedErrors; readonly tainted: CreatedTainted; readonly fields: CreatedFieldControllers; validate(): Exit<Created, Array<{field: string; message: string}>>; reset(overrides?: Partial<Created>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function createdCreateForm(overrides?: Partial<Created>): CreatedGigaform {let data = $state({...createdDefaultValue(),...overrides}); let errors = $state<CreatedErrors>({_errors: optionNone(), initialData: optionNone(), }); let tainted = $state<CreatedTainted>({initialData: optionNone(), }); const fields: CreatedFieldControllers = {initialData: {path: ["initialData" ]as const, name: "initialData" , constraints: { required: true }, get: ()=>data.initialData, set: (value: string | null)=>{data.initialData = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.initialData, setError: (value: __gf_Option<Array<string>>)=>{errors.initialData = value;}, getTainted: ()=>tainted.initialData, setTainted: (value: __gf_Option<boolean>)=>{tainted.initialData = value;}, validate: (): Array<string>=>{const fieldErrors = createdValidateField("initialData", data.initialData); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Exit<Created, Array<{field: string; message: string}>>{return toExit(createdDeserialize(data));}function reset(newOverrides?: Partial<Created>): void {data = {...createdDefaultValue(),...newOverrides}; errors = {_errors: optionNone(), initialData: optionNone(), }; tainted = {initialData: optionNone(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function createdFromFormData(formData: FormData): Exit<Created, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.initialData = formData.get("initialData" )?? "" ;return toExit(createdDeserialize(obj));}

export const Created = {
  defaultValue: createdDefaultValue,
  serialize: createdSerialize,
  serializeWithContext: createdSerializeWithContext,
  deserialize: createdDeserialize,
  deserializeWithContext: createdDeserializeWithContext,
  validateFields: createdValidateFields,
  hasShape: createdHasShape,
  is: createdIs,
  createForm: createdCreateForm,
  fromFormData: createdFromFormData
} as const;


export interface Employee {
    id: string;
    imageUrl: string | null;
    
    name: string;
    phones: PhoneNumber[];
    
    role: string;
    
    title: JobTitle;
    email: Email;
    
    address: string;
    
    username: string;
    
    route: string | Route;
    ratePerHour: number;
    active: boolean;
    isTechnician: boolean;
    isSalesRep: boolean;
    description: string | null;
    linkedinUrl: string | null;
    attendance: string[];
    settings: Settings;
}

export function employeeDefaultValue(): Employee {return {id: "",
                            imageUrl: null,
                            name: "",
                            phones: [],
                            role: "",
                            title: "Technician",
                            email: emailDefaultValue(),
                            address: "",
                            username: "",
                            route: "",
                            ratePerHour: 0,
                            active: false,
                            isTechnician: false,
                            isSalesRep: false,
                            description: null,
                            linkedinUrl: null,
                            attendance: [],
                            settings: settingsDefaultValue(), }as Employee;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function employeeSerialize(value: Employee): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(employeeSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function employeeSerializeWithContext(value: Employee, ctx: __mf_SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Employee" , __id,}; result["id" ]= value.id; result["imageUrl" ]= value.imageUrl; result["name" ]= value.name; result["phones" ]= value.phones.map((item)=>phoneNumberSerializeWithContext(item, ctx)); result["role" ]= value.role; result["title" ]= jobTitleSerializeWithContext(value.title, ctx); result["email" ]= emailSerializeWithContext(value.email, ctx); result["address" ]= value.address; result["username" ]= value.username; result["route" ]= value.route; result["ratePerHour" ]= value.ratePerHour; result["active" ]= value.active; result["isTechnician" ]= value.isTechnician; result["isSalesRep" ]= value.isSalesRep; result["description" ]= value.description; result["linkedinUrl" ]= value.linkedinUrl; result["attendance" ]= value.attendance; result["settings" ]= settingsSerializeWithContext(value.settings, ctx); return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function employeeDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: Employee } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = employeeDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Employee.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function employeeDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Employee | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new __mf_DeserializeError([{field: "_root" , message: "Employee.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("id" in obj)){errors.push({field: "id" , message: "missing required field" });}if(!("imageUrl" in obj)){errors.push({field: "imageUrl" , message: "missing required field" });}if(!("name" in obj)){errors.push({field: "name" , message: "missing required field" });}if(!("phones" in obj)){errors.push({field: "phones" , message: "missing required field" });}if(!("role" in obj)){errors.push({field: "role" , message: "missing required field" });}if(!("title" in obj)){errors.push({field: "title" , message: "missing required field" });}if(!("email" in obj)){errors.push({field: "email" , message: "missing required field" });}if(!("address" in obj)){errors.push({field: "address" , message: "missing required field" });}if(!("username" in obj)){errors.push({field: "username" , message: "missing required field" });}if(!("route" in obj)){errors.push({field: "route" , message: "missing required field" });}if(!("ratePerHour" in obj)){errors.push({field: "ratePerHour" , message: "missing required field" });}if(!("active" in obj)){errors.push({field: "active" , message: "missing required field" });}if(!("isTechnician" in obj)){errors.push({field: "isTechnician" , message: "missing required field" });}if(!("isSalesRep" in obj)){errors.push({field: "isSalesRep" , message: "missing required field" });}if(!("description" in obj)){errors.push({field: "description" , message: "missing required field" });}if(!("linkedinUrl" in obj)){errors.push({field: "linkedinUrl" , message: "missing required field" });}if(!("attendance" in obj)){errors.push({field: "attendance" , message: "missing required field" });}if(!("settings" in obj)){errors.push({field: "settings" , message: "missing required field" });}if(errors.length>0){throw new __mf_DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_id = obj["id" ]as string; instance.id = __raw_id; }{const __raw_imageUrl = obj["imageUrl" ]as string | null; instance.imageUrl = __raw_imageUrl; }{const __raw_name = obj["name" ]as string; 
                if (__raw_name.length === 0) {
                    errors.push({ field: "name", message: "must not be empty" });
                }
 instance.name = __raw_name; }{const __raw_phones = obj["phones" ]as PhoneNumber[]; if(Array.isArray(__raw_phones)){instance.phones = __raw_phones as PhoneNumber[];}}{const __raw_role = obj["role" ]as string; 
                if (__raw_role.length === 0) {
                    errors.push({ field: "role", message: "must not be empty" });
                }
 instance.role = __raw_role; }{const __raw_title = obj["title" ]as JobTitle; {const __result = jobTitleDeserializeWithContext(__raw_title, ctx); ctx.assignOrDefer(instance, "title" , __result);}}{const __raw_email = obj["email" ]as Email; {const __result = emailDeserializeWithContext(__raw_email, ctx); ctx.assignOrDefer(instance, "email" , __result);}}{const __raw_address = obj["address" ]as string; 
                if (__raw_address.length === 0) {
                    errors.push({ field: "address", message: "must not be empty" });
                }
 instance.address = __raw_address; }{const __raw_username = obj["username" ]as string; 
                if (__raw_username.length === 0) {
                    errors.push({ field: "username", message: "must not be empty" });
                }
 instance.username = __raw_username; }{const __raw_route = obj["route" ]as string | Route; instance.route = __raw_route; }{const __raw_ratePerHour = obj["ratePerHour" ]as number; instance.ratePerHour = __raw_ratePerHour; }{const __raw_active = obj["active" ]as boolean; instance.active = __raw_active; }{const __raw_isTechnician = obj["isTechnician" ]as boolean; instance.isTechnician = __raw_isTechnician; }{const __raw_isSalesRep = obj["isSalesRep" ]as boolean; instance.isSalesRep = __raw_isSalesRep; }{const __raw_description = obj["description" ]as string | null; instance.description = __raw_description; }{const __raw_linkedinUrl = obj["linkedinUrl" ]as string | null; instance.linkedinUrl = __raw_linkedinUrl; }{const __raw_attendance = obj["attendance" ]as string[]; if(Array.isArray(__raw_attendance)){instance.attendance = __raw_attendance as string[];}}{const __raw_settings = obj["settings" ]as Settings; {const __result = settingsDeserializeWithContext(__raw_settings, ctx); ctx.assignOrDefer(instance, "settings" , __result);}}if(errors.length>0){throw new __mf_DeserializeError(errors);}return instance as Employee;}export function employeeValidateField<K extends keyof Employee>(_field: K, _value: Employee[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(_field){case "name" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "name", message: "must not be empty" });
                }
 break;}case "role" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "role", message: "must not be empty" });
                }
 break;}case "address" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "address", message: "must not be empty" });
                }
 break;}case "username" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "username", message: "must not be empty" });
                }
 break;}}return errors; }export function employeeValidateFields(_partial: Partial<Employee>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("name" in _partial && _partial.name!== undefined){const __val = _partial.name as string; 
                if (__val.length === 0) {
                    errors.push({ field: "name", message: "must not be empty" });
                }
}if("role" in _partial && _partial.role!== undefined){const __val = _partial.role as string; 
                if (__val.length === 0) {
                    errors.push({ field: "role", message: "must not be empty" });
                }
}if("address" in _partial && _partial.address!== undefined){const __val = _partial.address as string; 
                if (__val.length === 0) {
                    errors.push({ field: "address", message: "must not be empty" });
                }
}if("username" in _partial && _partial.username!== undefined){const __val = _partial.username as string; 
                if (__val.length === 0) {
                    errors.push({ field: "username", message: "must not be empty" });
                }
}return errors; }export function employeeHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "id" in o && "imageUrl" in o && "name" in o && "phones" in o && "role" in o && "title" in o && "email" in o && "address" in o && "username" in o && "route" in o && "ratePerHour" in o && "active" in o && "isTechnician" in o && "isSalesRep" in o && "description" in o && "linkedinUrl" in o && "attendance" in o && "settings" in o;}export function employeeIs(obj: unknown): obj is Employee {if(!employeeHasShape(obj)){return false;}const result = employeeDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type EmployeeErrors = {_errors: __gf_Option<Array<string>>; id: __gf_Option<Array<string>>; imageUrl: __gf_Option<Array<string>>; name: __gf_Option<Array<string>>; phones: __gf_Option<Array<string>>; role: __gf_Option<Array<string>>; title: __gf_Option<Array<string>>; email: __gf_Option<Array<string>>; address: __gf_Option<Array<string>>; username: __gf_Option<Array<string>>; route: __gf_Option<Array<string>>; ratePerHour: __gf_Option<Array<string>>; active: __gf_Option<Array<string>>; isTechnician: __gf_Option<Array<string>>; isSalesRep: __gf_Option<Array<string>>; description: __gf_Option<Array<string>>; linkedinUrl: __gf_Option<Array<string>>; attendance: __gf_Option<Array<string>>; settings: __gf_Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type EmployeeTainted = {id: __gf_Option<boolean>; imageUrl: __gf_Option<boolean>; name: __gf_Option<boolean>; phones: __gf_Option<boolean>; role: __gf_Option<boolean>; title: __gf_Option<boolean>; email: __gf_Option<boolean>; address: __gf_Option<boolean>; username: __gf_Option<boolean>; route: __gf_Option<boolean>; ratePerHour: __gf_Option<boolean>; active: __gf_Option<boolean>; isTechnician: __gf_Option<boolean>; isSalesRep: __gf_Option<boolean>; description: __gf_Option<boolean>; linkedinUrl: __gf_Option<boolean>; attendance: __gf_Option<boolean>; settings: __gf_Option<boolean>; }; /** Type-safe field controllers for this form */export interface EmployeeFieldControllers {readonly id: FieldController<string>; readonly imageUrl: FieldController<string | null>; readonly name: FieldController<string>; readonly phones: ArrayFieldController<PhoneNumber>; readonly role: FieldController<string>; readonly title: FieldController<JobTitle>; readonly email: FieldController<Email>; readonly address: FieldController<string>; readonly username: FieldController<string>; readonly route: FieldController<string | Route>; readonly ratePerHour: FieldController<number>; readonly active: FieldController<boolean>; readonly isTechnician: FieldController<boolean>; readonly isSalesRep: FieldController<boolean>; readonly description: FieldController<string | null>; readonly linkedinUrl: FieldController<string | null>; readonly attendance: ArrayFieldController<string>; readonly settings: FieldController<Settings>; }/** Gigaform instance containing reactive state and field controllers */export interface EmployeeGigaform {readonly data: Employee; readonly errors: EmployeeErrors; readonly tainted: EmployeeTainted; readonly fields: EmployeeFieldControllers; validate(): Exit<Employee, Array<{field: string; message: string}>>; reset(overrides?: Partial<Employee>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function employeeCreateForm(overrides?: Partial<Employee>): EmployeeGigaform {let data = $state({...employeeDefaultValue(),...overrides}); let errors = $state<EmployeeErrors>({_errors: optionNone(), id: optionNone(), imageUrl: optionNone(), name: optionNone(), phones: optionNone(), role: optionNone(), title: optionNone(), email: optionNone(), address: optionNone(), username: optionNone(), route: optionNone(), ratePerHour: optionNone(), active: optionNone(), isTechnician: optionNone(), isSalesRep: optionNone(), description: optionNone(), linkedinUrl: optionNone(), attendance: optionNone(), settings: optionNone(), }); let tainted = $state<EmployeeTainted>({id: optionNone(), imageUrl: optionNone(), name: optionNone(), phones: optionNone(), role: optionNone(), title: optionNone(), email: optionNone(), address: optionNone(), username: optionNone(), route: optionNone(), ratePerHour: optionNone(), active: optionNone(), isTechnician: optionNone(), isSalesRep: optionNone(), description: optionNone(), linkedinUrl: optionNone(), attendance: optionNone(), settings: optionNone(), }); const fields: EmployeeFieldControllers = {id: {path: ["id" ]as const, name: "id" , constraints: { required: true }, get: ()=>data.id, set: (value: string)=>{data.id = value;}, transform: (value: string): string =>value,getError: ()=>errors.id, setError: (value: __gf_Option<Array<string>>)=>{errors.id = value;}, getTainted: ()=>tainted.id, setTainted: (value: __gf_Option<boolean>)=>{tainted.id = value;}, validate: (): Array<string>=>{const fieldErrors = employeeValidateField("id", data.id); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},imageUrl: {path: ["imageUrl" ]as const, name: "imageUrl" , constraints: { required: true }, get: ()=>data.imageUrl, set: (value: string | null)=>{data.imageUrl = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.imageUrl, setError: (value: __gf_Option<Array<string>>)=>{errors.imageUrl = value;}, getTainted: ()=>tainted.imageUrl, setTainted: (value: __gf_Option<boolean>)=>{tainted.imageUrl = value;}, validate: (): Array<string>=>{const fieldErrors = employeeValidateField("imageUrl", data.imageUrl); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},name: {path: ["name" ]as const, name: "name" , constraints: { required: true }, get: ()=>data.name, set: (value: string)=>{data.name = value;}, transform: (value: string): string =>value,getError: ()=>errors.name, setError: (value: __gf_Option<Array<string>>)=>{errors.name = value;}, getTainted: ()=>tainted.name, setTainted: (value: __gf_Option<boolean>)=>{tainted.name = value;}, validate: (): Array<string>=>{const fieldErrors = employeeValidateField("name", data.name); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},phones: {path: ["phones" ]as const, name: "phones" , constraints: { required: true }, get: ()=>data.phones, set: (value: PhoneNumber[])=>{data.phones = value;}, transform: (value: PhoneNumber[]): PhoneNumber[] =>value,getError: ()=>errors.phones, setError: (value: __gf_Option<Array<string>>)=>{errors.phones = value;}, getTainted: ()=>tainted.phones, setTainted: (value: __gf_Option<boolean>)=>{tainted.phones = value;}, validate: (): Array<string>=>{const fieldErrors = employeeValidateField("phones", data.phones); return fieldErrors.map((e: {field: string; message: string})=>e.message);},at: (index: number)=>({path: ["phones" , index]as const, name: `phones.${index}` , constraints: {required: true}, get: ()=>data.phones[index]!, set: (value: PhoneNumber)=>{data.phones[index]= value;}, transform: (value: PhoneNumber): PhoneNumber =>value, getError: ()=>errors.phones, setError: (value: __gf_Option<Array<string>>)=>{errors.phones = value;}, getTainted: ()=>tainted.phones, setTainted: (value: __gf_Option<boolean>)=>{tainted.phones = value;}, validate: (): Array<string>=>[],}), push: (item: PhoneNumber)=>{data.phones.push(item);}, remove: (index: number)=>{data.phones.splice(index, 1);}, swap: (a: number, b: number)=>{const tmp = data.phones[a]!; data.phones[a]= data.phones[b]!; data.phones[b]= tmp;},},role: {path: ["role" ]as const, name: "role" , constraints: { required: true }, get: ()=>data.role, set: (value: string)=>{data.role = value;}, transform: (value: string): string =>value,getError: ()=>errors.role, setError: (value: __gf_Option<Array<string>>)=>{errors.role = value;}, getTainted: ()=>tainted.role, setTainted: (value: __gf_Option<boolean>)=>{tainted.role = value;}, validate: (): Array<string>=>{const fieldErrors = employeeValidateField("role", data.role); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},title: {path: ["title" ]as const, name: "title" , constraints: { required: true }, get: ()=>data.title, set: (value: JobTitle)=>{data.title = value;}, transform: (value: JobTitle): JobTitle =>value,getError: ()=>errors.title, setError: (value: __gf_Option<Array<string>>)=>{errors.title = value;}, getTainted: ()=>tainted.title, setTainted: (value: __gf_Option<boolean>)=>{tainted.title = value;}, validate: (): Array<string>=>{const fieldErrors = employeeValidateField("title", data.title); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},email: {path: ["email" ]as const, name: "email" , constraints: { required: true }, get: ()=>data.email, set: (value: Email)=>{data.email = value;}, transform: (value: Email): Email =>value,getError: ()=>errors.email, setError: (value: __gf_Option<Array<string>>)=>{errors.email = value;}, getTainted: ()=>tainted.email, setTainted: (value: __gf_Option<boolean>)=>{tainted.email = value;}, validate: (): Array<string>=>{const fieldErrors = employeeValidateField("email", data.email); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},address: {path: ["address" ]as const, name: "address" , constraints: { required: true }, get: ()=>data.address, set: (value: string)=>{data.address = value;}, transform: (value: string): string =>value,getError: ()=>errors.address, setError: (value: __gf_Option<Array<string>>)=>{errors.address = value;}, getTainted: ()=>tainted.address, setTainted: (value: __gf_Option<boolean>)=>{tainted.address = value;}, validate: (): Array<string>=>{const fieldErrors = employeeValidateField("address", data.address); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},username: {path: ["username" ]as const, name: "username" , constraints: { required: true }, get: ()=>data.username, set: (value: string)=>{data.username = value;}, transform: (value: string): string =>value,getError: ()=>errors.username, setError: (value: __gf_Option<Array<string>>)=>{errors.username = value;}, getTainted: ()=>tainted.username, setTainted: (value: __gf_Option<boolean>)=>{tainted.username = value;}, validate: (): Array<string>=>{const fieldErrors = employeeValidateField("username", data.username); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},route: {path: ["route" ]as const, name: "route" , constraints: { required: true }, get: ()=>data.route, set: (value: string | Route)=>{data.route = value;}, transform: (value: string | Route): string | Route =>value,getError: ()=>errors.route, setError: (value: __gf_Option<Array<string>>)=>{errors.route = value;}, getTainted: ()=>tainted.route, setTainted: (value: __gf_Option<boolean>)=>{tainted.route = value;}, validate: (): Array<string>=>{const fieldErrors = employeeValidateField("route", data.route); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},ratePerHour: {path: ["ratePerHour" ]as const, name: "ratePerHour" , constraints: { required: true }, get: ()=>data.ratePerHour, set: (value: number)=>{data.ratePerHour = value;}, transform: (value: number): number =>value,getError: ()=>errors.ratePerHour, setError: (value: __gf_Option<Array<string>>)=>{errors.ratePerHour = value;}, getTainted: ()=>tainted.ratePerHour, setTainted: (value: __gf_Option<boolean>)=>{tainted.ratePerHour = value;}, validate: (): Array<string>=>{const fieldErrors = employeeValidateField("ratePerHour", data.ratePerHour); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},active: {path: ["active" ]as const, name: "active" , constraints: { required: true }, get: ()=>data.active, set: (value: boolean)=>{data.active = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.active, setError: (value: __gf_Option<Array<string>>)=>{errors.active = value;}, getTainted: ()=>tainted.active, setTainted: (value: __gf_Option<boolean>)=>{tainted.active = value;}, validate: (): Array<string>=>{const fieldErrors = employeeValidateField("active", data.active); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},isTechnician: {path: ["isTechnician" ]as const, name: "isTechnician" , constraints: { required: true }, get: ()=>data.isTechnician, set: (value: boolean)=>{data.isTechnician = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.isTechnician, setError: (value: __gf_Option<Array<string>>)=>{errors.isTechnician = value;}, getTainted: ()=>tainted.isTechnician, setTainted: (value: __gf_Option<boolean>)=>{tainted.isTechnician = value;}, validate: (): Array<string>=>{const fieldErrors = employeeValidateField("isTechnician", data.isTechnician); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},isSalesRep: {path: ["isSalesRep" ]as const, name: "isSalesRep" , constraints: { required: true }, get: ()=>data.isSalesRep, set: (value: boolean)=>{data.isSalesRep = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.isSalesRep, setError: (value: __gf_Option<Array<string>>)=>{errors.isSalesRep = value;}, getTainted: ()=>tainted.isSalesRep, setTainted: (value: __gf_Option<boolean>)=>{tainted.isSalesRep = value;}, validate: (): Array<string>=>{const fieldErrors = employeeValidateField("isSalesRep", data.isSalesRep); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},description: {path: ["description" ]as const, name: "description" , constraints: { required: true }, get: ()=>data.description, set: (value: string | null)=>{data.description = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.description, setError: (value: __gf_Option<Array<string>>)=>{errors.description = value;}, getTainted: ()=>tainted.description, setTainted: (value: __gf_Option<boolean>)=>{tainted.description = value;}, validate: (): Array<string>=>{const fieldErrors = employeeValidateField("description", data.description); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},linkedinUrl: {path: ["linkedinUrl" ]as const, name: "linkedinUrl" , constraints: { required: true }, get: ()=>data.linkedinUrl, set: (value: string | null)=>{data.linkedinUrl = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.linkedinUrl, setError: (value: __gf_Option<Array<string>>)=>{errors.linkedinUrl = value;}, getTainted: ()=>tainted.linkedinUrl, setTainted: (value: __gf_Option<boolean>)=>{tainted.linkedinUrl = value;}, validate: (): Array<string>=>{const fieldErrors = employeeValidateField("linkedinUrl", data.linkedinUrl); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},attendance: {path: ["attendance" ]as const, name: "attendance" , constraints: { required: true }, get: ()=>data.attendance, set: (value: string[])=>{data.attendance = value;}, transform: (value: string[]): string[] =>value,getError: ()=>errors.attendance, setError: (value: __gf_Option<Array<string>>)=>{errors.attendance = value;}, getTainted: ()=>tainted.attendance, setTainted: (value: __gf_Option<boolean>)=>{tainted.attendance = value;}, validate: (): Array<string>=>{const fieldErrors = employeeValidateField("attendance", data.attendance); return fieldErrors.map((e: {field: string; message: string})=>e.message);},at: (index: number)=>({path: ["attendance" , index]as const, name: `attendance.${index}` , constraints: {required: true}, get: ()=>data.attendance[index]!, set: (value: string)=>{data.attendance[index]= value;}, transform: (value: string): string =>value, getError: ()=>errors.attendance, setError: (value: __gf_Option<Array<string>>)=>{errors.attendance = value;}, getTainted: ()=>tainted.attendance, setTainted: (value: __gf_Option<boolean>)=>{tainted.attendance = value;}, validate: (): Array<string>=>[],}), push: (item: string)=>{data.attendance.push(item);}, remove: (index: number)=>{data.attendance.splice(index, 1);}, swap: (a: number, b: number)=>{const tmp = data.attendance[a]!; data.attendance[a]= data.attendance[b]!; data.attendance[b]= tmp;},},settings: {path: ["settings" ]as const, name: "settings" , constraints: { required: true }, get: ()=>data.settings, set: (value: Settings)=>{data.settings = value;}, transform: (value: Settings): Settings =>value,getError: ()=>errors.settings, setError: (value: __gf_Option<Array<string>>)=>{errors.settings = value;}, getTainted: ()=>tainted.settings, setTainted: (value: __gf_Option<boolean>)=>{tainted.settings = value;}, validate: (): Array<string>=>{const fieldErrors = employeeValidateField("settings", data.settings); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Exit<Employee, Array<{field: string; message: string}>>{return toExit(employeeDeserialize(data));}function reset(newOverrides?: Partial<Employee>): void {data = {...employeeDefaultValue(),...newOverrides}; errors = {_errors: optionNone(), id: optionNone(), imageUrl: optionNone(), name: optionNone(), phones: optionNone(), role: optionNone(), title: optionNone(), email: optionNone(), address: optionNone(), username: optionNone(), route: optionNone(), ratePerHour: optionNone(), active: optionNone(), isTechnician: optionNone(), isSalesRep: optionNone(), description: optionNone(), linkedinUrl: optionNone(), attendance: optionNone(), settings: optionNone(), }; tainted = {id: optionNone(), imageUrl: optionNone(), name: optionNone(), phones: optionNone(), role: optionNone(), title: optionNone(), email: optionNone(), address: optionNone(), username: optionNone(), route: optionNone(), ratePerHour: optionNone(), active: optionNone(), isTechnician: optionNone(), isSalesRep: optionNone(), description: optionNone(), linkedinUrl: optionNone(), attendance: optionNone(), settings: optionNone(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function employeeFromFormData(formData: FormData): Exit<Employee, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.id = formData.get("id" )?? "" ;obj.imageUrl = formData.get("imageUrl" )?? "" ;obj.name = formData.get("name" )?? "" ;{const phonesItems: Array<Record<string, unknown>>= []; let idx = 0; while(formData.has("phones." + idx + "." )|| idx === 0){const hasAny = Array.from(formData.keys()).some(k =>k.startsWith("phones." + idx + "." )); if(!hasAny && idx>0)break; if(hasAny){const item: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("phones." + idx + "." )){const fieldName = key.slice("phones." .length + String(idx).length + 1); item[fieldName]= value;}}phonesItems.push(item);}idx ++; if(idx>1000)break;}obj.phones = phonesItems;}obj.role = formData.get("role" )?? "" ;{const titleObj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("title." )){const fieldName = key.slice("title." .length); const parts = fieldName.split("." ); let current = titleObj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.title = titleObj;}{const emailObj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("email." )){const fieldName = key.slice("email." .length); const parts = fieldName.split("." ); let current = emailObj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.email = emailObj;}obj.address = formData.get("address" )?? "" ;obj.username = formData.get("username" )?? "" ;obj.route = formData.get("route" )?? "" ;{const ratePerHourStr = formData.get("ratePerHour" ); obj.ratePerHour = ratePerHourStr? parseFloat(ratePerHourStr as string): 0; if(obj.ratePerHour!== undefined && isNaN(obj.ratePerHour as number))obj.ratePerHour = 0;}{const activeVal = formData.get("active" ); obj.active = activeVal === "true" || activeVal === "on" || activeVal === "1" ;}{const isTechnicianVal = formData.get("isTechnician" ); obj.isTechnician = isTechnicianVal === "true" || isTechnicianVal === "on" || isTechnicianVal === "1" ;}{const isSalesRepVal = formData.get("isSalesRep" ); obj.isSalesRep = isSalesRepVal === "true" || isSalesRepVal === "on" || isSalesRepVal === "1" ;}obj.description = formData.get("description" )?? "" ;obj.linkedinUrl = formData.get("linkedinUrl" )?? "" ;obj.attendance = formData.getAll("attendance" )as Array<string>;{const settingsObj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("settings." )){const fieldName = key.slice("settings." .length); const parts = fieldName.split("." ); let current = settingsObj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.settings = settingsObj;}return toExit(employeeDeserialize(obj));}

export const Employee = {
  defaultValue: employeeDefaultValue,
  serialize: employeeSerialize,
  serializeWithContext: employeeSerializeWithContext,
  deserialize: employeeDeserialize,
  deserializeWithContext: employeeDeserializeWithContext,
  validateFields: employeeValidateFields,
  hasShape: employeeHasShape,
  is: employeeIs,
  createForm: employeeCreateForm,
  fromFormData: employeeFromFormData
} as const;


export interface Commissions {
    
    technician: string;
    
    salesRep: string;
}

export function commissionsDefaultValue(): Commissions {return {technician: "",
                            salesRep: "", }as Commissions;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function commissionsSerialize(value: Commissions): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(commissionsSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function commissionsSerializeWithContext(value: Commissions, ctx: __mf_SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Commissions" , __id,}; result["technician" ]= value.technician; result["salesRep" ]= value.salesRep; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function commissionsDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: Commissions } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = commissionsDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Commissions.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function commissionsDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Commissions | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new __mf_DeserializeError([{field: "_root" , message: "Commissions.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("technician" in obj)){errors.push({field: "technician" , message: "missing required field" });}if(!("salesRep" in obj)){errors.push({field: "salesRep" , message: "missing required field" });}if(errors.length>0){throw new __mf_DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_technician = obj["technician" ]as string; 
                if (__raw_technician.length === 0) {
                    errors.push({ field: "technician", message: "must not be empty" });
                }
 instance.technician = __raw_technician; }{const __raw_salesRep = obj["salesRep" ]as string; 
                if (__raw_salesRep.length === 0) {
                    errors.push({ field: "salesRep", message: "must not be empty" });
                }
 instance.salesRep = __raw_salesRep; }if(errors.length>0){throw new __mf_DeserializeError(errors);}return instance as Commissions;}export function commissionsValidateField<K extends keyof Commissions>(_field: K, _value: Commissions[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(_field){case "technician" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "technician", message: "must not be empty" });
                }
 break;}case "salesRep" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "salesRep", message: "must not be empty" });
                }
 break;}}return errors; }export function commissionsValidateFields(_partial: Partial<Commissions>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("technician" in _partial && _partial.technician!== undefined){const __val = _partial.technician as string; 
                if (__val.length === 0) {
                    errors.push({ field: "technician", message: "must not be empty" });
                }
}if("salesRep" in _partial && _partial.salesRep!== undefined){const __val = _partial.salesRep as string; 
                if (__val.length === 0) {
                    errors.push({ field: "salesRep", message: "must not be empty" });
                }
}return errors; }export function commissionsHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "technician" in o && "salesRep" in o;}export function commissionsIs(obj: unknown): obj is Commissions {if(!commissionsHasShape(obj)){return false;}const result = commissionsDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type CommissionsErrors = {_errors: __gf_Option<Array<string>>; technician: __gf_Option<Array<string>>; salesRep: __gf_Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type CommissionsTainted = {technician: __gf_Option<boolean>; salesRep: __gf_Option<boolean>; }; /** Type-safe field controllers for this form */export interface CommissionsFieldControllers {readonly technician: FieldController<string>; readonly salesRep: FieldController<string>; }/** Gigaform instance containing reactive state and field controllers */export interface CommissionsGigaform {readonly data: Commissions; readonly errors: CommissionsErrors; readonly tainted: CommissionsTainted; readonly fields: CommissionsFieldControllers; validate(): Exit<Commissions, Array<{field: string; message: string}>>; reset(overrides?: Partial<Commissions>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function commissionsCreateForm(overrides?: Partial<Commissions>): CommissionsGigaform {let data = $state({...commissionsDefaultValue(),...overrides}); let errors = $state<CommissionsErrors>({_errors: optionNone(), technician: optionNone(), salesRep: optionNone(), }); let tainted = $state<CommissionsTainted>({technician: optionNone(), salesRep: optionNone(), }); const fields: CommissionsFieldControllers = {technician: {path: ["technician" ]as const, name: "technician" , constraints: { required: true }, get: ()=>data.technician, set: (value: string)=>{data.technician = value;}, transform: (value: string): string =>value,getError: ()=>errors.technician, setError: (value: __gf_Option<Array<string>>)=>{errors.technician = value;}, getTainted: ()=>tainted.technician, setTainted: (value: __gf_Option<boolean>)=>{tainted.technician = value;}, validate: (): Array<string>=>{const fieldErrors = commissionsValidateField("technician", data.technician); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},salesRep: {path: ["salesRep" ]as const, name: "salesRep" , constraints: { required: true }, get: ()=>data.salesRep, set: (value: string)=>{data.salesRep = value;}, transform: (value: string): string =>value,getError: ()=>errors.salesRep, setError: (value: __gf_Option<Array<string>>)=>{errors.salesRep = value;}, getTainted: ()=>tainted.salesRep, setTainted: (value: __gf_Option<boolean>)=>{tainted.salesRep = value;}, validate: (): Array<string>=>{const fieldErrors = commissionsValidateField("salesRep", data.salesRep); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Exit<Commissions, Array<{field: string; message: string}>>{return toExit(commissionsDeserialize(data));}function reset(newOverrides?: Partial<Commissions>): void {data = {...commissionsDefaultValue(),...newOverrides}; errors = {_errors: optionNone(), technician: optionNone(), salesRep: optionNone(), }; tainted = {technician: optionNone(), salesRep: optionNone(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function commissionsFromFormData(formData: FormData): Exit<Commissions, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.technician = formData.get("technician" )?? "" ;obj.salesRep = formData.get("salesRep" )?? "" ;return toExit(commissionsDeserialize(obj));}

export const Commissions = {
  defaultValue: commissionsDefaultValue,
  serialize: commissionsSerialize,
  serializeWithContext: commissionsSerializeWithContext,
  deserialize: commissionsDeserialize,
  deserializeWithContext: commissionsDeserializeWithContext,
  validateFields: commissionsValidateFields,
  hasShape: commissionsHasShape,
  is: commissionsIs,
  createForm: commissionsCreateForm,
  fromFormData: commissionsFromFormData
} as const;


export interface Number {
    
    countryCode: string;
    
    areaCode: string;
    
    localNumber: string;
}

export function numberDefaultValue(): Number {return {countryCode: "",
                            areaCode: "",
                            localNumber: "", }as Number;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function numberSerialize(value: Number): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(numberSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function numberSerializeWithContext(value: Number, ctx: __mf_SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Number" , __id,}; result["countryCode" ]= value.countryCode; result["areaCode" ]= value.areaCode; result["localNumber" ]= value.localNumber; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function numberDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: Number } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = numberDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Number.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function numberDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Number | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new __mf_DeserializeError([{field: "_root" , message: "Number.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("countryCode" in obj)){errors.push({field: "countryCode" , message: "missing required field" });}if(!("areaCode" in obj)){errors.push({field: "areaCode" , message: "missing required field" });}if(!("localNumber" in obj)){errors.push({field: "localNumber" , message: "missing required field" });}if(errors.length>0){throw new __mf_DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_countryCode = obj["countryCode" ]as string; 
                if (__raw_countryCode.length === 0) {
                    errors.push({ field: "countryCode", message: "must not be empty" });
                }
 instance.countryCode = __raw_countryCode; }{const __raw_areaCode = obj["areaCode" ]as string; 
                if (__raw_areaCode.length === 0) {
                    errors.push({ field: "areaCode", message: "must not be empty" });
                }
 instance.areaCode = __raw_areaCode; }{const __raw_localNumber = obj["localNumber" ]as string; 
                if (__raw_localNumber.length === 0) {
                    errors.push({ field: "localNumber", message: "must not be empty" });
                }
 instance.localNumber = __raw_localNumber; }if(errors.length>0){throw new __mf_DeserializeError(errors);}return instance as Number;}export function numberValidateField<K extends keyof Number>(_field: K, _value: Number[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(_field){case "countryCode" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "countryCode", message: "must not be empty" });
                }
 break;}case "areaCode" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "areaCode", message: "must not be empty" });
                }
 break;}case "localNumber" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "localNumber", message: "must not be empty" });
                }
 break;}}return errors; }export function numberValidateFields(_partial: Partial<Number>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("countryCode" in _partial && _partial.countryCode!== undefined){const __val = _partial.countryCode as string; 
                if (__val.length === 0) {
                    errors.push({ field: "countryCode", message: "must not be empty" });
                }
}if("areaCode" in _partial && _partial.areaCode!== undefined){const __val = _partial.areaCode as string; 
                if (__val.length === 0) {
                    errors.push({ field: "areaCode", message: "must not be empty" });
                }
}if("localNumber" in _partial && _partial.localNumber!== undefined){const __val = _partial.localNumber as string; 
                if (__val.length === 0) {
                    errors.push({ field: "localNumber", message: "must not be empty" });
                }
}return errors; }export function numberHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "countryCode" in o && "areaCode" in o && "localNumber" in o;}export function numberIs(obj: unknown): obj is Number {if(!numberHasShape(obj)){return false;}const result = numberDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type NumberErrors = {_errors: __gf_Option<Array<string>>; countryCode: __gf_Option<Array<string>>; areaCode: __gf_Option<Array<string>>; localNumber: __gf_Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type NumberTainted = {countryCode: __gf_Option<boolean>; areaCode: __gf_Option<boolean>; localNumber: __gf_Option<boolean>; }; /** Type-safe field controllers for this form */export interface NumberFieldControllers {readonly countryCode: FieldController<string>; readonly areaCode: FieldController<string>; readonly localNumber: FieldController<string>; }/** Gigaform instance containing reactive state and field controllers */export interface NumberGigaform {readonly data: Number; readonly errors: NumberErrors; readonly tainted: NumberTainted; readonly fields: NumberFieldControllers; validate(): Exit<Number, Array<{field: string; message: string}>>; reset(overrides?: Partial<Number>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function numberCreateForm(overrides?: Partial<Number>): NumberGigaform {let data = $state({...numberDefaultValue(),...overrides}); let errors = $state<NumberErrors>({_errors: optionNone(), countryCode: optionNone(), areaCode: optionNone(), localNumber: optionNone(), }); let tainted = $state<NumberTainted>({countryCode: optionNone(), areaCode: optionNone(), localNumber: optionNone(), }); const fields: NumberFieldControllers = {countryCode: {path: ["countryCode" ]as const, name: "countryCode" , constraints: { required: true }, get: ()=>data.countryCode, set: (value: string)=>{data.countryCode = value;}, transform: (value: string): string =>value,getError: ()=>errors.countryCode, setError: (value: __gf_Option<Array<string>>)=>{errors.countryCode = value;}, getTainted: ()=>tainted.countryCode, setTainted: (value: __gf_Option<boolean>)=>{tainted.countryCode = value;}, validate: (): Array<string>=>{const fieldErrors = numberValidateField("countryCode", data.countryCode); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},areaCode: {path: ["areaCode" ]as const, name: "areaCode" , constraints: { required: true }, get: ()=>data.areaCode, set: (value: string)=>{data.areaCode = value;}, transform: (value: string): string =>value,getError: ()=>errors.areaCode, setError: (value: __gf_Option<Array<string>>)=>{errors.areaCode = value;}, getTainted: ()=>tainted.areaCode, setTainted: (value: __gf_Option<boolean>)=>{tainted.areaCode = value;}, validate: (): Array<string>=>{const fieldErrors = numberValidateField("areaCode", data.areaCode); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},localNumber: {path: ["localNumber" ]as const, name: "localNumber" , constraints: { required: true }, get: ()=>data.localNumber, set: (value: string)=>{data.localNumber = value;}, transform: (value: string): string =>value,getError: ()=>errors.localNumber, setError: (value: __gf_Option<Array<string>>)=>{errors.localNumber = value;}, getTainted: ()=>tainted.localNumber, setTainted: (value: __gf_Option<boolean>)=>{tainted.localNumber = value;}, validate: (): Array<string>=>{const fieldErrors = numberValidateField("localNumber", data.localNumber); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Exit<Number, Array<{field: string; message: string}>>{return toExit(numberDeserialize(data));}function reset(newOverrides?: Partial<Number>): void {data = {...numberDefaultValue(),...newOverrides}; errors = {_errors: optionNone(), countryCode: optionNone(), areaCode: optionNone(), localNumber: optionNone(), }; tainted = {countryCode: optionNone(), areaCode: optionNone(), localNumber: optionNone(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function numberFromFormData(formData: FormData): Exit<Number, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.countryCode = formData.get("countryCode" )?? "" ;obj.areaCode = formData.get("areaCode" )?? "" ;obj.localNumber = formData.get("localNumber" )?? "" ;return toExit(numberDeserialize(obj));}

export const Number = {
  defaultValue: numberDefaultValue,
  serialize: numberSerialize,
  serializeWithContext: numberSerializeWithContext,
  deserialize: numberDeserialize,
  deserializeWithContext: numberDeserializeWithContext,
  validateFields: numberValidateFields,
  hasShape: numberHasShape,
  is: numberIs,
  createForm: numberCreateForm,
  fromFormData: numberFromFormData
} as const;


export interface DataPath {
    path: string[];
    formatter: string | null;
}

export function dataPathDefaultValue(): DataPath {return {path: [],
                            formatter: null, }as DataPath;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function dataPathSerialize(value: DataPath): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(dataPathSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function dataPathSerializeWithContext(value: DataPath, ctx: __mf_SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "DataPath" , __id,}; result["path" ]= value.path; result["formatter" ]= value.formatter; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function dataPathDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: DataPath } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = dataPathDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "DataPath.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function dataPathDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): DataPath | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new __mf_DeserializeError([{field: "_root" , message: "DataPath.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("path" in obj)){errors.push({field: "path" , message: "missing required field" });}if(!("formatter" in obj)){errors.push({field: "formatter" , message: "missing required field" });}if(errors.length>0){throw new __mf_DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_path = obj["path" ]as string[]; if(Array.isArray(__raw_path)){instance.path = __raw_path as string[];}}{const __raw_formatter = obj["formatter" ]as string | null; instance.formatter = __raw_formatter; }if(errors.length>0){throw new __mf_DeserializeError(errors);}return instance as DataPath;}export function dataPathValidateField<K extends keyof DataPath>(_field: K, _value: DataPath[K]): Array<{field: string; message: string}>{return[]; }export function dataPathValidateFields(_partial: Partial<DataPath>): Array<{field: string; message: string}>{return[]; }export function dataPathHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "path" in o && "formatter" in o;}export function dataPathIs(obj: unknown): obj is DataPath {if(!dataPathHasShape(obj)){return false;}const result = dataPathDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type DataPathErrors = {_errors: __gf_Option<Array<string>>; path: __gf_Option<Array<string>>; formatter: __gf_Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type DataPathTainted = {path: __gf_Option<boolean>; formatter: __gf_Option<boolean>; }; /** Type-safe field controllers for this form */export interface DataPathFieldControllers {readonly path: ArrayFieldController<string>; readonly formatter: FieldController<string | null>; }/** Gigaform instance containing reactive state and field controllers */export interface DataPathGigaform {readonly data: DataPath; readonly errors: DataPathErrors; readonly tainted: DataPathTainted; readonly fields: DataPathFieldControllers; validate(): Exit<DataPath, Array<{field: string; message: string}>>; reset(overrides?: Partial<DataPath>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function dataPathCreateForm(overrides?: Partial<DataPath>): DataPathGigaform {let data = $state({...dataPathDefaultValue(),...overrides}); let errors = $state<DataPathErrors>({_errors: optionNone(), path: optionNone(), formatter: optionNone(), }); let tainted = $state<DataPathTainted>({path: optionNone(), formatter: optionNone(), }); const fields: DataPathFieldControllers = {path: {path: ["path" ]as const, name: "path" , constraints: { required: true }, get: ()=>data.path, set: (value: string[])=>{data.path = value;}, transform: (value: string[]): string[] =>value,getError: ()=>errors.path, setError: (value: __gf_Option<Array<string>>)=>{errors.path = value;}, getTainted: ()=>tainted.path, setTainted: (value: __gf_Option<boolean>)=>{tainted.path = value;}, validate: (): Array<string>=>{const fieldErrors = dataPathValidateField("path", data.path); return fieldErrors.map((e: {field: string; message: string})=>e.message);},at: (index: number)=>({path: ["path" , index]as const, name: `path.${index}` , constraints: {required: true}, get: ()=>data.path[index]!, set: (value: string)=>{data.path[index]= value;}, transform: (value: string): string =>value, getError: ()=>errors.path, setError: (value: __gf_Option<Array<string>>)=>{errors.path = value;}, getTainted: ()=>tainted.path, setTainted: (value: __gf_Option<boolean>)=>{tainted.path = value;}, validate: (): Array<string>=>[],}), push: (item: string)=>{data.path.push(item);}, remove: (index: number)=>{data.path.splice(index, 1);}, swap: (a: number, b: number)=>{const tmp = data.path[a]!; data.path[a]= data.path[b]!; data.path[b]= tmp;},},formatter: {path: ["formatter" ]as const, name: "formatter" , constraints: { required: true }, get: ()=>data.formatter, set: (value: string | null)=>{data.formatter = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.formatter, setError: (value: __gf_Option<Array<string>>)=>{errors.formatter = value;}, getTainted: ()=>tainted.formatter, setTainted: (value: __gf_Option<boolean>)=>{tainted.formatter = value;}, validate: (): Array<string>=>{const fieldErrors = dataPathValidateField("formatter", data.formatter); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Exit<DataPath, Array<{field: string; message: string}>>{return toExit(dataPathDeserialize(data));}function reset(newOverrides?: Partial<DataPath>): void {data = {...dataPathDefaultValue(),...newOverrides}; errors = {_errors: optionNone(), path: optionNone(), formatter: optionNone(), }; tainted = {path: optionNone(), formatter: optionNone(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function dataPathFromFormData(formData: FormData): Exit<DataPath, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.path = formData.getAll("path" )as Array<string>;obj.formatter = formData.get("formatter" )?? "" ;return toExit(dataPathDeserialize(obj));}

export const DataPath = {
  defaultValue: dataPathDefaultValue,
  serialize: dataPathSerialize,
  serializeWithContext: dataPathSerializeWithContext,
  deserialize: dataPathDeserialize,
  deserializeWithContext: dataPathDeserializeWithContext,
  validateFields: dataPathValidateFields,
  hasShape: dataPathHasShape,
  is: dataPathIs,
  createForm: dataPathCreateForm,
  fromFormData: dataPathFromFormData
} as const;


export interface Route {
    id: string;
    techs: (string | Employee)[] | null;
    active: boolean;
    
    name: string;
    
    phone: string;
    
    position: string;
    serviceRoute: boolean;
    defaultDurationHours: number;
    tags: string[];
    icon: string | null;
    color: string | null;
}

export function routeDefaultValue(): Route {return {id: "",
                            techs: null,
                            active: false,
                            name: "",
                            phone: "",
                            position: "",
                            serviceRoute: false,
                            defaultDurationHours: 0,
                            tags: [],
                            icon: null,
                            color: null, }as Route;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function routeSerialize(value: Route): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(routeSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function routeSerializeWithContext(value: Route, ctx: __mf_SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Route" , __id,}; result["id" ]= value.id; if(value.techs!== null){result["techs" ]= value.techs; }else {result["techs" ]= null;}result["active" ]= value.active; result["name" ]= value.name; result["phone" ]= value.phone; result["position" ]= value.position; result["serviceRoute" ]= value.serviceRoute; result["defaultDurationHours" ]= value.defaultDurationHours; result["tags" ]= value.tags; result["icon" ]= value.icon; result["color" ]= value.color; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function routeDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: Route } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = routeDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Route.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function routeDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Route | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new __mf_DeserializeError([{field: "_root" , message: "Route.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("id" in obj)){errors.push({field: "id" , message: "missing required field" });}if(!("techs" in obj)){errors.push({field: "techs" , message: "missing required field" });}if(!("active" in obj)){errors.push({field: "active" , message: "missing required field" });}if(!("name" in obj)){errors.push({field: "name" , message: "missing required field" });}if(!("phone" in obj)){errors.push({field: "phone" , message: "missing required field" });}if(!("position" in obj)){errors.push({field: "position" , message: "missing required field" });}if(!("serviceRoute" in obj)){errors.push({field: "serviceRoute" , message: "missing required field" });}if(!("defaultDurationHours" in obj)){errors.push({field: "defaultDurationHours" , message: "missing required field" });}if(!("tags" in obj)){errors.push({field: "tags" , message: "missing required field" });}if(!("icon" in obj)){errors.push({field: "icon" , message: "missing required field" });}if(!("color" in obj)){errors.push({field: "color" , message: "missing required field" });}if(errors.length>0){throw new __mf_DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_id = obj["id" ]as string; instance.id = __raw_id; }{const __raw_techs = obj["techs" ]as (string | Employee)[] | null; if(__raw_techs === null){instance.techs = null;}else {instance.techs = __raw_techs; }}{const __raw_active = obj["active" ]as boolean; instance.active = __raw_active; }{const __raw_name = obj["name" ]as string; 
                if (__raw_name.length === 0) {
                    errors.push({ field: "name", message: "must not be empty" });
                }
 instance.name = __raw_name; }{const __raw_phone = obj["phone" ]as string; 
                if (__raw_phone.length === 0) {
                    errors.push({ field: "phone", message: "must not be empty" });
                }
 instance.phone = __raw_phone; }{const __raw_position = obj["position" ]as string; 
                if (__raw_position.length === 0) {
                    errors.push({ field: "position", message: "must not be empty" });
                }
 instance.position = __raw_position; }{const __raw_serviceRoute = obj["serviceRoute" ]as boolean; instance.serviceRoute = __raw_serviceRoute; }{const __raw_defaultDurationHours = obj["defaultDurationHours" ]as number; instance.defaultDurationHours = __raw_defaultDurationHours; }{const __raw_tags = obj["tags" ]as string[]; if(Array.isArray(__raw_tags)){instance.tags = __raw_tags as string[];}}{const __raw_icon = obj["icon" ]as string | null; instance.icon = __raw_icon; }{const __raw_color = obj["color" ]as string | null; instance.color = __raw_color; }if(errors.length>0){throw new __mf_DeserializeError(errors);}return instance as Route;}export function routeValidateField<K extends keyof Route>(_field: K, _value: Route[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(_field){case "name" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "name", message: "must not be empty" });
                }
 break;}case "phone" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "phone", message: "must not be empty" });
                }
 break;}case "position" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "position", message: "must not be empty" });
                }
 break;}}return errors; }export function routeValidateFields(_partial: Partial<Route>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("name" in _partial && _partial.name!== undefined){const __val = _partial.name as string; 
                if (__val.length === 0) {
                    errors.push({ field: "name", message: "must not be empty" });
                }
}if("phone" in _partial && _partial.phone!== undefined){const __val = _partial.phone as string; 
                if (__val.length === 0) {
                    errors.push({ field: "phone", message: "must not be empty" });
                }
}if("position" in _partial && _partial.position!== undefined){const __val = _partial.position as string; 
                if (__val.length === 0) {
                    errors.push({ field: "position", message: "must not be empty" });
                }
}return errors; }export function routeHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "id" in o && "techs" in o && "active" in o && "name" in o && "phone" in o && "position" in o && "serviceRoute" in o && "defaultDurationHours" in o && "tags" in o && "icon" in o && "color" in o;}export function routeIs(obj: unknown): obj is Route {if(!routeHasShape(obj)){return false;}const result = routeDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type RouteErrors = {_errors: __gf_Option<Array<string>>; id: __gf_Option<Array<string>>; techs: __gf_Option<Array<string>>; active: __gf_Option<Array<string>>; name: __gf_Option<Array<string>>; phone: __gf_Option<Array<string>>; position: __gf_Option<Array<string>>; serviceRoute: __gf_Option<Array<string>>; defaultDurationHours: __gf_Option<Array<string>>; tags: __gf_Option<Array<string>>; icon: __gf_Option<Array<string>>; color: __gf_Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type RouteTainted = {id: __gf_Option<boolean>; techs: __gf_Option<boolean>; active: __gf_Option<boolean>; name: __gf_Option<boolean>; phone: __gf_Option<boolean>; position: __gf_Option<boolean>; serviceRoute: __gf_Option<boolean>; defaultDurationHours: __gf_Option<boolean>; tags: __gf_Option<boolean>; icon: __gf_Option<boolean>; color: __gf_Option<boolean>; }; /** Type-safe field controllers for this form */export interface RouteFieldControllers {readonly id: FieldController<string>; readonly techs: FieldController<(string | Employee)[] | null>; readonly active: FieldController<boolean>; readonly name: FieldController<string>; readonly phone: FieldController<string>; readonly position: FieldController<string>; readonly serviceRoute: FieldController<boolean>; readonly defaultDurationHours: FieldController<number>; readonly tags: ArrayFieldController<string>; readonly icon: FieldController<string | null>; readonly color: FieldController<string | null>; }/** Gigaform instance containing reactive state and field controllers */export interface RouteGigaform {readonly data: Route; readonly errors: RouteErrors; readonly tainted: RouteTainted; readonly fields: RouteFieldControllers; validate(): Exit<Route, Array<{field: string; message: string}>>; reset(overrides?: Partial<Route>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function routeCreateForm(overrides?: Partial<Route>): RouteGigaform {let data = $state({...routeDefaultValue(),...overrides}); let errors = $state<RouteErrors>({_errors: optionNone(), id: optionNone(), techs: optionNone(), active: optionNone(), name: optionNone(), phone: optionNone(), position: optionNone(), serviceRoute: optionNone(), defaultDurationHours: optionNone(), tags: optionNone(), icon: optionNone(), color: optionNone(), }); let tainted = $state<RouteTainted>({id: optionNone(), techs: optionNone(), active: optionNone(), name: optionNone(), phone: optionNone(), position: optionNone(), serviceRoute: optionNone(), defaultDurationHours: optionNone(), tags: optionNone(), icon: optionNone(), color: optionNone(), }); const fields: RouteFieldControllers = {id: {path: ["id" ]as const, name: "id" , constraints: { required: true }, get: ()=>data.id, set: (value: string)=>{data.id = value;}, transform: (value: string): string =>value,getError: ()=>errors.id, setError: (value: __gf_Option<Array<string>>)=>{errors.id = value;}, getTainted: ()=>tainted.id, setTainted: (value: __gf_Option<boolean>)=>{tainted.id = value;}, validate: (): Array<string>=>{const fieldErrors = routeValidateField("id", data.id); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},techs: {path: ["techs" ]as const, name: "techs" , constraints: { required: true }, get: ()=>data.techs, set: (value: (string | Employee)[] | null)=>{data.techs = value;}, transform: (value: (string | Employee)[] | null): (string | Employee)[] | null =>value,getError: ()=>errors.techs, setError: (value: __gf_Option<Array<string>>)=>{errors.techs = value;}, getTainted: ()=>tainted.techs, setTainted: (value: __gf_Option<boolean>)=>{tainted.techs = value;}, validate: (): Array<string>=>{const fieldErrors = routeValidateField("techs", data.techs); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},active: {path: ["active" ]as const, name: "active" , constraints: { required: true }, get: ()=>data.active, set: (value: boolean)=>{data.active = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.active, setError: (value: __gf_Option<Array<string>>)=>{errors.active = value;}, getTainted: ()=>tainted.active, setTainted: (value: __gf_Option<boolean>)=>{tainted.active = value;}, validate: (): Array<string>=>{const fieldErrors = routeValidateField("active", data.active); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},name: {path: ["name" ]as const, name: "name" , constraints: { required: true }, get: ()=>data.name, set: (value: string)=>{data.name = value;}, transform: (value: string): string =>value,getError: ()=>errors.name, setError: (value: __gf_Option<Array<string>>)=>{errors.name = value;}, getTainted: ()=>tainted.name, setTainted: (value: __gf_Option<boolean>)=>{tainted.name = value;}, validate: (): Array<string>=>{const fieldErrors = routeValidateField("name", data.name); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},phone: {path: ["phone" ]as const, name: "phone" , constraints: { required: true }, get: ()=>data.phone, set: (value: string)=>{data.phone = value;}, transform: (value: string): string =>value,getError: ()=>errors.phone, setError: (value: __gf_Option<Array<string>>)=>{errors.phone = value;}, getTainted: ()=>tainted.phone, setTainted: (value: __gf_Option<boolean>)=>{tainted.phone = value;}, validate: (): Array<string>=>{const fieldErrors = routeValidateField("phone", data.phone); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},position: {path: ["position" ]as const, name: "position" , constraints: { required: true }, get: ()=>data.position, set: (value: string)=>{data.position = value;}, transform: (value: string): string =>value,getError: ()=>errors.position, setError: (value: __gf_Option<Array<string>>)=>{errors.position = value;}, getTainted: ()=>tainted.position, setTainted: (value: __gf_Option<boolean>)=>{tainted.position = value;}, validate: (): Array<string>=>{const fieldErrors = routeValidateField("position", data.position); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},serviceRoute: {path: ["serviceRoute" ]as const, name: "serviceRoute" , constraints: { required: true }, get: ()=>data.serviceRoute, set: (value: boolean)=>{data.serviceRoute = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.serviceRoute, setError: (value: __gf_Option<Array<string>>)=>{errors.serviceRoute = value;}, getTainted: ()=>tainted.serviceRoute, setTainted: (value: __gf_Option<boolean>)=>{tainted.serviceRoute = value;}, validate: (): Array<string>=>{const fieldErrors = routeValidateField("serviceRoute", data.serviceRoute); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},defaultDurationHours: {path: ["defaultDurationHours" ]as const, name: "defaultDurationHours" , constraints: { required: true }, get: ()=>data.defaultDurationHours, set: (value: number)=>{data.defaultDurationHours = value;}, transform: (value: number): number =>value,getError: ()=>errors.defaultDurationHours, setError: (value: __gf_Option<Array<string>>)=>{errors.defaultDurationHours = value;}, getTainted: ()=>tainted.defaultDurationHours, setTainted: (value: __gf_Option<boolean>)=>{tainted.defaultDurationHours = value;}, validate: (): Array<string>=>{const fieldErrors = routeValidateField("defaultDurationHours", data.defaultDurationHours); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},tags: {path: ["tags" ]as const, name: "tags" , constraints: { required: true }, get: ()=>data.tags, set: (value: string[])=>{data.tags = value;}, transform: (value: string[]): string[] =>value,getError: ()=>errors.tags, setError: (value: __gf_Option<Array<string>>)=>{errors.tags = value;}, getTainted: ()=>tainted.tags, setTainted: (value: __gf_Option<boolean>)=>{tainted.tags = value;}, validate: (): Array<string>=>{const fieldErrors = routeValidateField("tags", data.tags); return fieldErrors.map((e: {field: string; message: string})=>e.message);},at: (index: number)=>({path: ["tags" , index]as const, name: `tags.${index}` , constraints: {required: true}, get: ()=>data.tags[index]!, set: (value: string)=>{data.tags[index]= value;}, transform: (value: string): string =>value, getError: ()=>errors.tags, setError: (value: __gf_Option<Array<string>>)=>{errors.tags = value;}, getTainted: ()=>tainted.tags, setTainted: (value: __gf_Option<boolean>)=>{tainted.tags = value;}, validate: (): Array<string>=>[],}), push: (item: string)=>{data.tags.push(item);}, remove: (index: number)=>{data.tags.splice(index, 1);}, swap: (a: number, b: number)=>{const tmp = data.tags[a]!; data.tags[a]= data.tags[b]!; data.tags[b]= tmp;},},icon: {path: ["icon" ]as const, name: "icon" , constraints: { required: true }, get: ()=>data.icon, set: (value: string | null)=>{data.icon = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.icon, setError: (value: __gf_Option<Array<string>>)=>{errors.icon = value;}, getTainted: ()=>tainted.icon, setTainted: (value: __gf_Option<boolean>)=>{tainted.icon = value;}, validate: (): Array<string>=>{const fieldErrors = routeValidateField("icon", data.icon); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},color: {path: ["color" ]as const, name: "color" , constraints: { required: true }, get: ()=>data.color, set: (value: string | null)=>{data.color = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.color, setError: (value: __gf_Option<Array<string>>)=>{errors.color = value;}, getTainted: ()=>tainted.color, setTainted: (value: __gf_Option<boolean>)=>{tainted.color = value;}, validate: (): Array<string>=>{const fieldErrors = routeValidateField("color", data.color); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Exit<Route, Array<{field: string; message: string}>>{return toExit(routeDeserialize(data));}function reset(newOverrides?: Partial<Route>): void {data = {...routeDefaultValue(),...newOverrides}; errors = {_errors: optionNone(), id: optionNone(), techs: optionNone(), active: optionNone(), name: optionNone(), phone: optionNone(), position: optionNone(), serviceRoute: optionNone(), defaultDurationHours: optionNone(), tags: optionNone(), icon: optionNone(), color: optionNone(), }; tainted = {id: optionNone(), techs: optionNone(), active: optionNone(), name: optionNone(), phone: optionNone(), position: optionNone(), serviceRoute: optionNone(), defaultDurationHours: optionNone(), tags: optionNone(), icon: optionNone(), color: optionNone(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function routeFromFormData(formData: FormData): Exit<Route, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.id = formData.get("id" )?? "" ;obj.techs = formData.get("techs" )?? "" ;{const activeVal = formData.get("active" ); obj.active = activeVal === "true" || activeVal === "on" || activeVal === "1" ;}obj.name = formData.get("name" )?? "" ;obj.phone = formData.get("phone" )?? "" ;obj.position = formData.get("position" )?? "" ;{const serviceRouteVal = formData.get("serviceRoute" ); obj.serviceRoute = serviceRouteVal === "true" || serviceRouteVal === "on" || serviceRouteVal === "1" ;}{const defaultDurationHoursStr = formData.get("defaultDurationHours" ); obj.defaultDurationHours = defaultDurationHoursStr? parseFloat(defaultDurationHoursStr as string): 0; if(obj.defaultDurationHours!== undefined && isNaN(obj.defaultDurationHours as number))obj.defaultDurationHours = 0;}obj.tags = formData.getAll("tags" )as Array<string>;obj.icon = formData.get("icon" )?? "" ;obj.color = formData.get("color" )?? "" ;return toExit(routeDeserialize(obj));}

export const Route = {
  defaultValue: routeDefaultValue,
  serialize: routeSerialize,
  serializeWithContext: routeSerializeWithContext,
  deserialize: routeDeserialize,
  deserializeWithContext: routeDeserializeWithContext,
  validateFields: routeValidateFields,
  hasShape: routeHasShape,
  is: routeIs,
  createForm: routeCreateForm,
  fromFormData: routeFromFormData
} as const;


export interface EmailParts {
    
    local: string;
    
    domainName: string;
    
    topLevelDomain: string;
}

export function emailPartsDefaultValue(): EmailParts {return {local: "",
                            domainName: "",
                            topLevelDomain: "", }as EmailParts;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function emailPartsSerialize(value: EmailParts): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(emailPartsSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function emailPartsSerializeWithContext(value: EmailParts, ctx: __mf_SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "EmailParts" , __id,}; result["local" ]= value.local; result["domainName" ]= value.domainName; result["topLevelDomain" ]= value.topLevelDomain; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function emailPartsDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: EmailParts } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = emailPartsDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "EmailParts.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function emailPartsDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): EmailParts | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new __mf_DeserializeError([{field: "_root" , message: "EmailParts.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("local" in obj)){errors.push({field: "local" , message: "missing required field" });}if(!("domainName" in obj)){errors.push({field: "domainName" , message: "missing required field" });}if(!("topLevelDomain" in obj)){errors.push({field: "topLevelDomain" , message: "missing required field" });}if(errors.length>0){throw new __mf_DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_local = obj["local" ]as string; 
                if (__raw_local.length === 0) {
                    errors.push({ field: "local", message: "must not be empty" });
                }
 instance.local = __raw_local; }{const __raw_domainName = obj["domainName" ]as string; 
                if (__raw_domainName.length === 0) {
                    errors.push({ field: "domainName", message: "must not be empty" });
                }
 instance.domainName = __raw_domainName; }{const __raw_topLevelDomain = obj["topLevelDomain" ]as string; 
                if (__raw_topLevelDomain.length === 0) {
                    errors.push({ field: "topLevelDomain", message: "must not be empty" });
                }
 instance.topLevelDomain = __raw_topLevelDomain; }if(errors.length>0){throw new __mf_DeserializeError(errors);}return instance as EmailParts;}export function emailPartsValidateField<K extends keyof EmailParts>(_field: K, _value: EmailParts[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(_field){case "local" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "local", message: "must not be empty" });
                }
 break;}case "domainName" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "domainName", message: "must not be empty" });
                }
 break;}case "topLevelDomain" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "topLevelDomain", message: "must not be empty" });
                }
 break;}}return errors; }export function emailPartsValidateFields(_partial: Partial<EmailParts>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("local" in _partial && _partial.local!== undefined){const __val = _partial.local as string; 
                if (__val.length === 0) {
                    errors.push({ field: "local", message: "must not be empty" });
                }
}if("domainName" in _partial && _partial.domainName!== undefined){const __val = _partial.domainName as string; 
                if (__val.length === 0) {
                    errors.push({ field: "domainName", message: "must not be empty" });
                }
}if("topLevelDomain" in _partial && _partial.topLevelDomain!== undefined){const __val = _partial.topLevelDomain as string; 
                if (__val.length === 0) {
                    errors.push({ field: "topLevelDomain", message: "must not be empty" });
                }
}return errors; }export function emailPartsHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "local" in o && "domainName" in o && "topLevelDomain" in o;}export function emailPartsIs(obj: unknown): obj is EmailParts {if(!emailPartsHasShape(obj)){return false;}const result = emailPartsDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type EmailPartsErrors = {_errors: __gf_Option<Array<string>>; local: __gf_Option<Array<string>>; domainName: __gf_Option<Array<string>>; topLevelDomain: __gf_Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type EmailPartsTainted = {local: __gf_Option<boolean>; domainName: __gf_Option<boolean>; topLevelDomain: __gf_Option<boolean>; }; /** Type-safe field controllers for this form */export interface EmailPartsFieldControllers {readonly local: FieldController<string>; readonly domainName: FieldController<string>; readonly topLevelDomain: FieldController<string>; }/** Gigaform instance containing reactive state and field controllers */export interface EmailPartsGigaform {readonly data: EmailParts; readonly errors: EmailPartsErrors; readonly tainted: EmailPartsTainted; readonly fields: EmailPartsFieldControllers; validate(): Exit<EmailParts, Array<{field: string; message: string}>>; reset(overrides?: Partial<EmailParts>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function emailPartsCreateForm(overrides?: Partial<EmailParts>): EmailPartsGigaform {let data = $state({...emailPartsDefaultValue(),...overrides}); let errors = $state<EmailPartsErrors>({_errors: optionNone(), local: optionNone(), domainName: optionNone(), topLevelDomain: optionNone(), }); let tainted = $state<EmailPartsTainted>({local: optionNone(), domainName: optionNone(), topLevelDomain: optionNone(), }); const fields: EmailPartsFieldControllers = {local: {path: ["local" ]as const, name: "local" , constraints: { required: true }, get: ()=>data.local, set: (value: string)=>{data.local = value;}, transform: (value: string): string =>value,getError: ()=>errors.local, setError: (value: __gf_Option<Array<string>>)=>{errors.local = value;}, getTainted: ()=>tainted.local, setTainted: (value: __gf_Option<boolean>)=>{tainted.local = value;}, validate: (): Array<string>=>{const fieldErrors = emailPartsValidateField("local", data.local); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},domainName: {path: ["domainName" ]as const, name: "domainName" , constraints: { required: true }, get: ()=>data.domainName, set: (value: string)=>{data.domainName = value;}, transform: (value: string): string =>value,getError: ()=>errors.domainName, setError: (value: __gf_Option<Array<string>>)=>{errors.domainName = value;}, getTainted: ()=>tainted.domainName, setTainted: (value: __gf_Option<boolean>)=>{tainted.domainName = value;}, validate: (): Array<string>=>{const fieldErrors = emailPartsValidateField("domainName", data.domainName); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},topLevelDomain: {path: ["topLevelDomain" ]as const, name: "topLevelDomain" , constraints: { required: true }, get: ()=>data.topLevelDomain, set: (value: string)=>{data.topLevelDomain = value;}, transform: (value: string): string =>value,getError: ()=>errors.topLevelDomain, setError: (value: __gf_Option<Array<string>>)=>{errors.topLevelDomain = value;}, getTainted: ()=>tainted.topLevelDomain, setTainted: (value: __gf_Option<boolean>)=>{tainted.topLevelDomain = value;}, validate: (): Array<string>=>{const fieldErrors = emailPartsValidateField("topLevelDomain", data.topLevelDomain); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Exit<EmailParts, Array<{field: string; message: string}>>{return toExit(emailPartsDeserialize(data));}function reset(newOverrides?: Partial<EmailParts>): void {data = {...emailPartsDefaultValue(),...newOverrides}; errors = {_errors: optionNone(), local: optionNone(), domainName: optionNone(), topLevelDomain: optionNone(), }; tainted = {local: optionNone(), domainName: optionNone(), topLevelDomain: optionNone(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function emailPartsFromFormData(formData: FormData): Exit<EmailParts, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.local = formData.get("local" )?? "" ;obj.domainName = formData.get("domainName" )?? "" ;obj.topLevelDomain = formData.get("topLevelDomain" )?? "" ;return toExit(emailPartsDeserialize(obj));}

export const EmailParts = {
  defaultValue: emailPartsDefaultValue,
  serialize: emailPartsSerialize,
  serializeWithContext: emailPartsSerializeWithContext,
  deserialize: emailPartsDeserialize,
  deserializeWithContext: emailPartsDeserializeWithContext,
  validateFields: emailPartsValidateFields,
  hasShape: emailPartsHasShape,
  is: emailPartsIs,
  createForm: emailPartsCreateForm,
  fromFormData: emailPartsFromFormData
} as const;


export interface Sent {
    recipient: string | null;
    method: string | null;
}

export function sentDefaultValue(): Sent {return {recipient: null,
                            method: null, }as Sent;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function sentSerialize(value: Sent): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(sentSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function sentSerializeWithContext(value: Sent, ctx: __mf_SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Sent" , __id,}; result["recipient" ]= value.recipient; result["method" ]= value.method; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function sentDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: Sent } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = sentDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Sent.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function sentDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Sent | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new __mf_DeserializeError([{field: "_root" , message: "Sent.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("recipient" in obj)){errors.push({field: "recipient" , message: "missing required field" });}if(!("method" in obj)){errors.push({field: "method" , message: "missing required field" });}if(errors.length>0){throw new __mf_DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_recipient = obj["recipient" ]as string | null; instance.recipient = __raw_recipient; }{const __raw_method = obj["method" ]as string | null; instance.method = __raw_method; }if(errors.length>0){throw new __mf_DeserializeError(errors);}return instance as Sent;}export function sentValidateField<K extends keyof Sent>(_field: K, _value: Sent[K]): Array<{field: string; message: string}>{return[]; }export function sentValidateFields(_partial: Partial<Sent>): Array<{field: string; message: string}>{return[]; }export function sentHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "recipient" in o && "method" in o;}export function sentIs(obj: unknown): obj is Sent {if(!sentHasShape(obj)){return false;}const result = sentDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type SentErrors = {_errors: __gf_Option<Array<string>>; recipient: __gf_Option<Array<string>>; method: __gf_Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type SentTainted = {recipient: __gf_Option<boolean>; method: __gf_Option<boolean>; }; /** Type-safe field controllers for this form */export interface SentFieldControllers {readonly recipient: FieldController<string | null>; readonly method: FieldController<string | null>; }/** Gigaform instance containing reactive state and field controllers */export interface SentGigaform {readonly data: Sent; readonly errors: SentErrors; readonly tainted: SentTainted; readonly fields: SentFieldControllers; validate(): Exit<Sent, Array<{field: string; message: string}>>; reset(overrides?: Partial<Sent>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function sentCreateForm(overrides?: Partial<Sent>): SentGigaform {let data = $state({...sentDefaultValue(),...overrides}); let errors = $state<SentErrors>({_errors: optionNone(), recipient: optionNone(), method: optionNone(), }); let tainted = $state<SentTainted>({recipient: optionNone(), method: optionNone(), }); const fields: SentFieldControllers = {recipient: {path: ["recipient" ]as const, name: "recipient" , constraints: { required: true }, get: ()=>data.recipient, set: (value: string | null)=>{data.recipient = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.recipient, setError: (value: __gf_Option<Array<string>>)=>{errors.recipient = value;}, getTainted: ()=>tainted.recipient, setTainted: (value: __gf_Option<boolean>)=>{tainted.recipient = value;}, validate: (): Array<string>=>{const fieldErrors = sentValidateField("recipient", data.recipient); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},method: {path: ["method" ]as const, name: "method" , constraints: { required: true }, get: ()=>data.method, set: (value: string | null)=>{data.method = value;}, transform: (value: string | null): string | null =>value,getError: ()=>errors.method, setError: (value: __gf_Option<Array<string>>)=>{errors.method = value;}, getTainted: ()=>tainted.method, setTainted: (value: __gf_Option<boolean>)=>{tainted.method = value;}, validate: (): Array<string>=>{const fieldErrors = sentValidateField("method", data.method); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Exit<Sent, Array<{field: string; message: string}>>{return toExit(sentDeserialize(data));}function reset(newOverrides?: Partial<Sent>): void {data = {...sentDefaultValue(),...newOverrides}; errors = {_errors: optionNone(), recipient: optionNone(), method: optionNone(), }; tainted = {recipient: optionNone(), method: optionNone(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function sentFromFormData(formData: FormData): Exit<Sent, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.recipient = formData.get("recipient" )?? "" ;obj.method = formData.get("method" )?? "" ;return toExit(sentDeserialize(obj));}

export const Sent = {
  defaultValue: sentDefaultValue,
  serialize: sentSerialize,
  serializeWithContext: sentSerializeWithContext,
  deserialize: sentDeserialize,
  deserializeWithContext: sentDeserializeWithContext,
  validateFields: sentValidateFields,
  hasShape: sentHasShape,
  is: sentIs,
  createForm: sentCreateForm,
  fromFormData: sentFromFormData
} as const;


export interface BilledItem {
    
    
    item: Item;
    
    quantity: number;
    
    taxed: boolean;
    
    upsale: boolean;
}

export function billedItemDefaultValue(): BilledItem {return {item: "",
                            quantity: 0,
                            taxed: false,
                            upsale: false, }as BilledItem;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function billedItemSerialize(value: BilledItem): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(billedItemSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function billedItemSerializeWithContext(value: BilledItem, ctx: __mf_SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "BilledItem" , __id,}; result["item" ]= itemSerializeWithContext(value.item, ctx); result["quantity" ]= value.quantity; result["taxed" ]= value.taxed; result["upsale" ]= value.upsale; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function billedItemDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: BilledItem } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = billedItemDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "BilledItem.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function billedItemDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): BilledItem | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new __mf_DeserializeError([{field: "_root" , message: "BilledItem.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("item" in obj)){errors.push({field: "item" , message: "missing required field" });}if(!("quantity" in obj)){errors.push({field: "quantity" , message: "missing required field" });}if(!("taxed" in obj)){errors.push({field: "taxed" , message: "missing required field" });}if(!("upsale" in obj)){errors.push({field: "upsale" , message: "missing required field" });}if(errors.length>0){throw new __mf_DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_item = obj["item" ]as Item; {const __result = itemDeserializeWithContext(__raw_item, ctx); ctx.assignOrDefer(instance, "item" , __result);}}{const __raw_quantity = obj["quantity" ]as number; instance.quantity = __raw_quantity; }{const __raw_taxed = obj["taxed" ]as boolean; instance.taxed = __raw_taxed; }{const __raw_upsale = obj["upsale" ]as boolean; instance.upsale = __raw_upsale; }if(errors.length>0){throw new __mf_DeserializeError(errors);}return instance as BilledItem;}export function billedItemValidateField<K extends keyof BilledItem>(_field: K, _value: BilledItem[K]): Array<{field: string; message: string}>{return[]; }export function billedItemValidateFields(_partial: Partial<BilledItem>): Array<{field: string; message: string}>{return[]; }export function billedItemHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "item" in o && "quantity" in o && "taxed" in o && "upsale" in o;}export function billedItemIs(obj: unknown): obj is BilledItem {if(!billedItemHasShape(obj)){return false;}const result = billedItemDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type BilledItemErrors = {_errors: __gf_Option<Array<string>>; item: __gf_Option<Array<string>>; quantity: __gf_Option<Array<string>>; taxed: __gf_Option<Array<string>>; upsale: __gf_Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type BilledItemTainted = {item: __gf_Option<boolean>; quantity: __gf_Option<boolean>; taxed: __gf_Option<boolean>; upsale: __gf_Option<boolean>; }; /** Type-safe field controllers for this form */export interface BilledItemFieldControllers {readonly item: FieldController<Item>; readonly quantity: FieldController<number>; readonly taxed: FieldController<boolean>; readonly upsale: FieldController<boolean>; }/** Gigaform instance containing reactive state and field controllers */export interface BilledItemGigaform {readonly data: BilledItem; readonly errors: BilledItemErrors; readonly tainted: BilledItemTainted; readonly fields: BilledItemFieldControllers; validate(): Exit<BilledItem, Array<{field: string; message: string}>>; reset(overrides?: Partial<BilledItem>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function billedItemCreateForm(overrides?: Partial<BilledItem>): BilledItemGigaform {let data = $state({...billedItemDefaultValue(),...overrides}); let errors = $state<BilledItemErrors>({_errors: optionNone(), item: optionNone(), quantity: optionNone(), taxed: optionNone(), upsale: optionNone(), }); let tainted = $state<BilledItemTainted>({item: optionNone(), quantity: optionNone(), taxed: optionNone(), upsale: optionNone(), }); const fields: BilledItemFieldControllers = {item: {path: ["item" ]as const, name: "item" , constraints: { required: true }, label: "Item" , get: ()=>data.item, set: (value: Item)=>{data.item = value;}, transform: (value: Item): Item =>value,getError: ()=>errors.item, setError: (value: __gf_Option<Array<string>>)=>{errors.item = value;}, getTainted: ()=>tainted.item, setTainted: (value: __gf_Option<boolean>)=>{tainted.item = value;}, validate: (): Array<string>=>{const fieldErrors = billedItemValidateField("item", data.item); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},quantity: {path: ["quantity" ]as const, name: "quantity" , constraints: { required: true }, label: "Quantity" , get: ()=>data.quantity, set: (value: number)=>{data.quantity = value;}, transform: (value: number): number =>value,getError: ()=>errors.quantity, setError: (value: __gf_Option<Array<string>>)=>{errors.quantity = value;}, getTainted: ()=>tainted.quantity, setTainted: (value: __gf_Option<boolean>)=>{tainted.quantity = value;}, validate: (): Array<string>=>{const fieldErrors = billedItemValidateField("quantity", data.quantity); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},taxed: {path: ["taxed" ]as const, name: "taxed" , constraints: { required: true }, label: "Taxed" , get: ()=>data.taxed, set: (value: boolean)=>{data.taxed = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.taxed, setError: (value: __gf_Option<Array<string>>)=>{errors.taxed = value;}, getTainted: ()=>tainted.taxed, setTainted: (value: __gf_Option<boolean>)=>{tainted.taxed = value;}, validate: (): Array<string>=>{const fieldErrors = billedItemValidateField("taxed", data.taxed); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},upsale: {path: ["upsale" ]as const, name: "upsale" , constraints: { required: true }, label: "Upsale" , get: ()=>data.upsale, set: (value: boolean)=>{data.upsale = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.upsale, setError: (value: __gf_Option<Array<string>>)=>{errors.upsale = value;}, getTainted: ()=>tainted.upsale, setTainted: (value: __gf_Option<boolean>)=>{tainted.upsale = value;}, validate: (): Array<string>=>{const fieldErrors = billedItemValidateField("upsale", data.upsale); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Exit<BilledItem, Array<{field: string; message: string}>>{return toExit(billedItemDeserialize(data));}function reset(newOverrides?: Partial<BilledItem>): void {data = {...billedItemDefaultValue(),...newOverrides}; errors = {_errors: optionNone(), item: optionNone(), quantity: optionNone(), taxed: optionNone(), upsale: optionNone(), }; tainted = {item: optionNone(), quantity: optionNone(), taxed: optionNone(), upsale: optionNone(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function billedItemFromFormData(formData: FormData): Exit<BilledItem, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; {const itemObj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("item." )){const fieldName = key.slice("item." .length); const parts = fieldName.split("." ); let current = itemObj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.item = itemObj;}{const quantityStr = formData.get("quantity" ); obj.quantity = quantityStr? parseFloat(quantityStr as string): 0; if(obj.quantity!== undefined && isNaN(obj.quantity as number))obj.quantity = 0;}{const taxedVal = formData.get("taxed" ); obj.taxed = taxedVal === "true" || taxedVal === "on" || taxedVal === "1" ;}{const upsaleVal = formData.get("upsale" ); obj.upsale = upsaleVal === "true" || upsaleVal === "on" || upsaleVal === "1" ;}return toExit(billedItemDeserialize(obj));}

export const BilledItem = {
  defaultValue: billedItemDefaultValue,
  serialize: billedItemSerialize,
  serializeWithContext: billedItemSerializeWithContext,
  deserialize: billedItemDeserialize,
  deserializeWithContext: billedItemDeserializeWithContext,
  validateFields: billedItemValidateFields,
  hasShape: billedItemHasShape,
  is: billedItemIs,
  createForm: billedItemCreateForm,
  fromFormData: billedItemFromFormData
} as const;


export interface Coordinates {
    lat: number;
    lng: number;
}

export function coordinatesDefaultValue(): Coordinates {return {lat: 0,
                            lng: 0, }as Coordinates;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function coordinatesSerialize(value: Coordinates): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(coordinatesSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function coordinatesSerializeWithContext(value: Coordinates, ctx: __mf_SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Coordinates" , __id,}; result["lat" ]= value.lat; result["lng" ]= value.lng; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function coordinatesDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: Coordinates } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = coordinatesDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Coordinates.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function coordinatesDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Coordinates | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new __mf_DeserializeError([{field: "_root" , message: "Coordinates.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("lat" in obj)){errors.push({field: "lat" , message: "missing required field" });}if(!("lng" in obj)){errors.push({field: "lng" , message: "missing required field" });}if(errors.length>0){throw new __mf_DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_lat = obj["lat" ]as number; instance.lat = __raw_lat; }{const __raw_lng = obj["lng" ]as number; instance.lng = __raw_lng; }if(errors.length>0){throw new __mf_DeserializeError(errors);}return instance as Coordinates;}export function coordinatesValidateField<K extends keyof Coordinates>(_field: K, _value: Coordinates[K]): Array<{field: string; message: string}>{return[]; }export function coordinatesValidateFields(_partial: Partial<Coordinates>): Array<{field: string; message: string}>{return[]; }export function coordinatesHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "lat" in o && "lng" in o;}export function coordinatesIs(obj: unknown): obj is Coordinates {if(!coordinatesHasShape(obj)){return false;}const result = coordinatesDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type CoordinatesErrors = {_errors: __gf_Option<Array<string>>; lat: __gf_Option<Array<string>>; lng: __gf_Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type CoordinatesTainted = {lat: __gf_Option<boolean>; lng: __gf_Option<boolean>; }; /** Type-safe field controllers for this form */export interface CoordinatesFieldControllers {readonly lat: FieldController<number>; readonly lng: FieldController<number>; }/** Gigaform instance containing reactive state and field controllers */export interface CoordinatesGigaform {readonly data: Coordinates; readonly errors: CoordinatesErrors; readonly tainted: CoordinatesTainted; readonly fields: CoordinatesFieldControllers; validate(): Exit<Coordinates, Array<{field: string; message: string}>>; reset(overrides?: Partial<Coordinates>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function coordinatesCreateForm(overrides?: Partial<Coordinates>): CoordinatesGigaform {let data = $state({...coordinatesDefaultValue(),...overrides}); let errors = $state<CoordinatesErrors>({_errors: optionNone(), lat: optionNone(), lng: optionNone(), }); let tainted = $state<CoordinatesTainted>({lat: optionNone(), lng: optionNone(), }); const fields: CoordinatesFieldControllers = {lat: {path: ["lat" ]as const, name: "lat" , constraints: { required: true }, get: ()=>data.lat, set: (value: number)=>{data.lat = value;}, transform: (value: number): number =>value,getError: ()=>errors.lat, setError: (value: __gf_Option<Array<string>>)=>{errors.lat = value;}, getTainted: ()=>tainted.lat, setTainted: (value: __gf_Option<boolean>)=>{tainted.lat = value;}, validate: (): Array<string>=>{const fieldErrors = coordinatesValidateField("lat", data.lat); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},lng: {path: ["lng" ]as const, name: "lng" , constraints: { required: true }, get: ()=>data.lng, set: (value: number)=>{data.lng = value;}, transform: (value: number): number =>value,getError: ()=>errors.lng, setError: (value: __gf_Option<Array<string>>)=>{errors.lng = value;}, getTainted: ()=>tainted.lng, setTainted: (value: __gf_Option<boolean>)=>{tainted.lng = value;}, validate: (): Array<string>=>{const fieldErrors = coordinatesValidateField("lng", data.lng); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Exit<Coordinates, Array<{field: string; message: string}>>{return toExit(coordinatesDeserialize(data));}function reset(newOverrides?: Partial<Coordinates>): void {data = {...coordinatesDefaultValue(),...newOverrides}; errors = {_errors: optionNone(), lat: optionNone(), lng: optionNone(), }; tainted = {lat: optionNone(), lng: optionNone(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function coordinatesFromFormData(formData: FormData): Exit<Coordinates, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; {const latStr = formData.get("lat" ); obj.lat = latStr? parseFloat(latStr as string): 0; if(obj.lat!== undefined && isNaN(obj.lat as number))obj.lat = 0;}{const lngStr = formData.get("lng" ); obj.lng = lngStr? parseFloat(lngStr as string): 0; if(obj.lng!== undefined && isNaN(obj.lng as number))obj.lng = 0;}return toExit(coordinatesDeserialize(obj));}

export const Coordinates = {
  defaultValue: coordinatesDefaultValue,
  serialize: coordinatesSerialize,
  serializeWithContext: coordinatesSerializeWithContext,
  deserialize: coordinatesDeserialize,
  deserializeWithContext: coordinatesDeserializeWithContext,
  validateFields: coordinatesValidateFields,
  hasShape: coordinatesHasShape,
  is: coordinatesIs,
  createForm: coordinatesCreateForm,
  fromFormData: coordinatesFromFormData
} as const;


export interface Ordered {
    id: string;
    
    in: string | Account;
    
    out: string | Order;
    date: string;
}

export function orderedDefaultValue(): Ordered {return {id: "",
                            in: "",
                            out: "",
                            date: "", }as Ordered;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function orderedSerialize(value: Ordered): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(orderedSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function orderedSerializeWithContext(value: Ordered, ctx: __mf_SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Ordered" , __id,}; result["id" ]= value.id; result["in" ]= value.in; result["out" ]= value.out; result["date" ]= value.date; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function orderedDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: Ordered } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = orderedDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Ordered.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function orderedDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Ordered | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new __mf_DeserializeError([{field: "_root" , message: "Ordered.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("id" in obj)){errors.push({field: "id" , message: "missing required field" });}if(!("in" in obj)){errors.push({field: "in" , message: "missing required field" });}if(!("out" in obj)){errors.push({field: "out" , message: "missing required field" });}if(!("date" in obj)){errors.push({field: "date" , message: "missing required field" });}if(errors.length>0){throw new __mf_DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_id = obj["id" ]as string; instance.id = __raw_id; }{const __raw_in = obj["in" ]as string | Account; instance.in = __raw_in; }{const __raw_out = obj["out" ]as string | Order; instance.out = __raw_out; }{const __raw_date = obj["date" ]as string; instance.date = __raw_date; }if(errors.length>0){throw new __mf_DeserializeError(errors);}return instance as Ordered;}export function orderedValidateField<K extends keyof Ordered>(_field: K, _value: Ordered[K]): Array<{field: string; message: string}>{return[]; }export function orderedValidateFields(_partial: Partial<Ordered>): Array<{field: string; message: string}>{return[]; }export function orderedHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "id" in o && "in" in o && "out" in o && "date" in o;}export function orderedIs(obj: unknown): obj is Ordered {if(!orderedHasShape(obj)){return false;}const result = orderedDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type OrderedErrors = {_errors: __gf_Option<Array<string>>; id: __gf_Option<Array<string>>; in: __gf_Option<Array<string>>; out: __gf_Option<Array<string>>; date: __gf_Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type OrderedTainted = {id: __gf_Option<boolean>; in: __gf_Option<boolean>; out: __gf_Option<boolean>; date: __gf_Option<boolean>; }; /** Type-safe field controllers for this form */export interface OrderedFieldControllers {readonly id: FieldController<string>; readonly in: FieldController<string | Account>; readonly out: FieldController<string | Order>; readonly date: FieldController<string>; }/** Gigaform instance containing reactive state and field controllers */export interface OrderedGigaform {readonly data: Ordered; readonly errors: OrderedErrors; readonly tainted: OrderedTainted; readonly fields: OrderedFieldControllers; validate(): Exit<Ordered, Array<{field: string; message: string}>>; reset(overrides?: Partial<Ordered>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function orderedCreateForm(overrides?: Partial<Ordered>): OrderedGigaform {let data = $state({...orderedDefaultValue(),...overrides}); let errors = $state<OrderedErrors>({_errors: optionNone(), id: optionNone(), in: optionNone(), out: optionNone(), date: optionNone(), }); let tainted = $state<OrderedTainted>({id: optionNone(), in: optionNone(), out: optionNone(), date: optionNone(), }); const fields: OrderedFieldControllers = {id: {path: ["id" ]as const, name: "id" , constraints: { required: true }, get: ()=>data.id, set: (value: string)=>{data.id = value;}, transform: (value: string): string =>value,getError: ()=>errors.id, setError: (value: __gf_Option<Array<string>>)=>{errors.id = value;}, getTainted: ()=>tainted.id, setTainted: (value: __gf_Option<boolean>)=>{tainted.id = value;}, validate: (): Array<string>=>{const fieldErrors = orderedValidateField("id", data.id); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},in: {path: ["in" ]as const, name: "in" , constraints: { required: true }, get: ()=>data.in, set: (value: string | Account)=>{data.in = value;}, transform: (value: string | Account): string | Account =>value,getError: ()=>errors.in, setError: (value: __gf_Option<Array<string>>)=>{errors.in = value;}, getTainted: ()=>tainted.in, setTainted: (value: __gf_Option<boolean>)=>{tainted.in = value;}, validate: (): Array<string>=>{const fieldErrors = orderedValidateField("in", data.in); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},out: {path: ["out" ]as const, name: "out" , constraints: { required: true }, get: ()=>data.out, set: (value: string | Order)=>{data.out = value;}, transform: (value: string | Order): string | Order =>value,getError: ()=>errors.out, setError: (value: __gf_Option<Array<string>>)=>{errors.out = value;}, getTainted: ()=>tainted.out, setTainted: (value: __gf_Option<boolean>)=>{tainted.out = value;}, validate: (): Array<string>=>{const fieldErrors = orderedValidateField("out", data.out); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},date: {path: ["date" ]as const, name: "date" , constraints: { required: true }, get: ()=>data.date, set: (value: string)=>{data.date = value;}, transform: (value: string): string =>value,getError: ()=>errors.date, setError: (value: __gf_Option<Array<string>>)=>{errors.date = value;}, getTainted: ()=>tainted.date, setTainted: (value: __gf_Option<boolean>)=>{tainted.date = value;}, validate: (): Array<string>=>{const fieldErrors = orderedValidateField("date", data.date); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Exit<Ordered, Array<{field: string; message: string}>>{return toExit(orderedDeserialize(data));}function reset(newOverrides?: Partial<Ordered>): void {data = {...orderedDefaultValue(),...newOverrides}; errors = {_errors: optionNone(), id: optionNone(), in: optionNone(), out: optionNone(), date: optionNone(), }; tainted = {id: optionNone(), in: optionNone(), out: optionNone(), date: optionNone(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function orderedFromFormData(formData: FormData): Exit<Ordered, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.id = formData.get("id" )?? "" ;obj.in = formData.get("in" )?? "" ;obj.out = formData.get("out" )?? "" ;obj.date = formData.get("date" )?? "" ;return toExit(orderedDeserialize(obj));}

export const Ordered = {
  defaultValue: orderedDefaultValue,
  serialize: orderedSerialize,
  serializeWithContext: orderedSerializeWithContext,
  deserialize: orderedDeserialize,
  deserializeWithContext: orderedDeserializeWithContext,
  validateFields: orderedValidateFields,
  hasShape: orderedHasShape,
  is: orderedIs,
  createForm: orderedCreateForm,
  fromFormData: orderedFromFormData
} as const;


export interface Email {
    
    canEmail: boolean;
    
    
    emailString: string;
}

export function emailDefaultValue(): Email {return {canEmail: false,
                            emailString: "", }as Email;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function emailSerialize(value: Email): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(emailSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function emailSerializeWithContext(value: Email, ctx: __mf_SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Email" , __id,}; result["canEmail" ]= value.canEmail; result["emailString" ]= value.emailString; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function emailDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: Email } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = emailDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Email.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function emailDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Email | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new __mf_DeserializeError([{field: "_root" , message: "Email.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("canEmail" in obj)){errors.push({field: "canEmail" , message: "missing required field" });}if(!("emailString" in obj)){errors.push({field: "emailString" , message: "missing required field" });}if(errors.length>0){throw new __mf_DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_canEmail = obj["canEmail" ]as boolean; instance.canEmail = __raw_canEmail; }{const __raw_emailString = obj["emailString" ]as string; 
                if (__raw_emailString.length === 0) {
                    errors.push({ field: "emailString", message: "must not be empty" });
                }

                if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(__raw_emailString)) {
                    errors.push({ field: "emailString", message: "must be a valid email" });
                }
 instance.emailString = __raw_emailString; }if(errors.length>0){throw new __mf_DeserializeError(errors);}return instance as Email;}export function emailValidateField<K extends keyof Email>(_field: K, _value: Email[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(_field){case "emailString" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "emailString", message: "must not be empty" });
                }

                if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(__val)) {
                    errors.push({ field: "emailString", message: "must be a valid email" });
                }
 break;}}return errors; }export function emailValidateFields(_partial: Partial<Email>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("emailString" in _partial && _partial.emailString!== undefined){const __val = _partial.emailString as string; 
                if (__val.length === 0) {
                    errors.push({ field: "emailString", message: "must not be empty" });
                }

                if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(__val)) {
                    errors.push({ field: "emailString", message: "must be a valid email" });
                }
}return errors; }export function emailHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "canEmail" in o && "emailString" in o;}export function emailIs(obj: unknown): obj is Email {if(!emailHasShape(obj)){return false;}const result = emailDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type EmailErrors = {_errors: __gf_Option<Array<string>>; canEmail: __gf_Option<Array<string>>; emailString: __gf_Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type EmailTainted = {canEmail: __gf_Option<boolean>; emailString: __gf_Option<boolean>; }; /** Type-safe field controllers for this form */export interface EmailFieldControllers {readonly canEmail: FieldController<boolean>; readonly emailString: FieldController<string>; }/** Gigaform instance containing reactive state and field controllers */export interface EmailGigaform {readonly data: Email; readonly errors: EmailErrors; readonly tainted: EmailTainted; readonly fields: EmailFieldControllers; validate(): Exit<Email, Array<{field: string; message: string}>>; reset(overrides?: Partial<Email>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function emailCreateForm(overrides?: Partial<Email>): EmailGigaform {let data = $state({...emailDefaultValue(),...overrides}); let errors = $state<EmailErrors>({_errors: optionNone(), canEmail: optionNone(), emailString: optionNone(), }); let tainted = $state<EmailTainted>({canEmail: optionNone(), emailString: optionNone(), }); const fields: EmailFieldControllers = {canEmail: {path: ["canEmail" ]as const, name: "canEmail" , constraints: { required: true }, label: "Can Email" , get: ()=>data.canEmail, set: (value: boolean)=>{data.canEmail = value;}, transform: (value: boolean): boolean =>value,getError: ()=>errors.canEmail, setError: (value: __gf_Option<Array<string>>)=>{errors.canEmail = value;}, getTainted: ()=>tainted.canEmail, setTainted: (value: __gf_Option<boolean>)=>{tainted.canEmail = value;}, validate: (): Array<string>=>{const fieldErrors = emailValidateField("canEmail", data.canEmail); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},emailString: {path: ["emailString" ]as const, name: "emailString" , constraints: { required: true, type: "email" }, label: "Email" , get: ()=>data.emailString, set: (value: string)=>{data.emailString = value;}, transform: (value: string): string =>value,getError: ()=>errors.emailString, setError: (value: __gf_Option<Array<string>>)=>{errors.emailString = value;}, getTainted: ()=>tainted.emailString, setTainted: (value: __gf_Option<boolean>)=>{tainted.emailString = value;}, validate: (): Array<string>=>{const fieldErrors = emailValidateField("emailString", data.emailString); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Exit<Email, Array<{field: string; message: string}>>{return toExit(emailDeserialize(data));}function reset(newOverrides?: Partial<Email>): void {data = {...emailDefaultValue(),...newOverrides}; errors = {_errors: optionNone(), canEmail: optionNone(), emailString: optionNone(), }; tainted = {canEmail: optionNone(), emailString: optionNone(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function emailFromFormData(formData: FormData): Exit<Email, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; {const canEmailVal = formData.get("canEmail" ); obj.canEmail = canEmailVal === "true" || canEmailVal === "on" || canEmailVal === "1" ;}obj.emailString = formData.get("emailString" )?? "" ;return toExit(emailDeserialize(obj));}

export const Email = {
  defaultValue: emailDefaultValue,
  serialize: emailSerialize,
  serializeWithContext: emailSerializeWithContext,
  deserialize: emailDeserialize,
  deserializeWithContext: emailDeserializeWithContext,
  validateFields: emailValidateFields,
  hasShape: emailHasShape,
  is: emailIs,
  createForm: emailCreateForm,
  fromFormData: emailFromFormData
} as const;


export interface RecurrenceRule {
    interval: Interval;
    recurrenceBegins: string;
    recurrenceEnds: RecurrenceEnd | null;
    cancelledInstances: string[] | null;
    additionalInstances: string[] | null;
}

export function recurrenceRuleDefaultValue(): RecurrenceRule {return {interval: intervalDefaultValue(),
                            recurrenceBegins: "",
                            recurrenceEnds: null,
                            cancelledInstances: null,
                            additionalInstances: null, }as RecurrenceRule;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function recurrenceRuleSerialize(value: RecurrenceRule): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(recurrenceRuleSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function recurrenceRuleSerializeWithContext(value: RecurrenceRule, ctx: __mf_SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "RecurrenceRule" , __id,}; result["interval" ]= intervalSerializeWithContext(value.interval, ctx); result["recurrenceBegins" ]= value.recurrenceBegins; if(value.recurrenceEnds!== null){result["recurrenceEnds" ]= recurrenceEndSerializeWithContext(value.recurrenceEnds, ctx); }else {result["recurrenceEnds" ]= null;}if(value.cancelledInstances!== null){result["cancelledInstances" ]= value.cancelledInstances; }else {result["cancelledInstances" ]= null;}if(value.additionalInstances!== null){result["additionalInstances" ]= value.additionalInstances; }else {result["additionalInstances" ]= null;}return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function recurrenceRuleDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: RecurrenceRule } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = recurrenceRuleDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "RecurrenceRule.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function recurrenceRuleDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): RecurrenceRule | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new __mf_DeserializeError([{field: "_root" , message: "RecurrenceRule.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("interval" in obj)){errors.push({field: "interval" , message: "missing required field" });}if(!("recurrenceBegins" in obj)){errors.push({field: "recurrenceBegins" , message: "missing required field" });}if(!("recurrenceEnds" in obj)){errors.push({field: "recurrenceEnds" , message: "missing required field" });}if(!("cancelledInstances" in obj)){errors.push({field: "cancelledInstances" , message: "missing required field" });}if(!("additionalInstances" in obj)){errors.push({field: "additionalInstances" , message: "missing required field" });}if(errors.length>0){throw new __mf_DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_interval = obj["interval" ]as Interval; {const __result = intervalDeserializeWithContext(__raw_interval, ctx); ctx.assignOrDefer(instance, "interval" , __result);}}{const __raw_recurrenceBegins = obj["recurrenceBegins" ]as string; instance.recurrenceBegins = __raw_recurrenceBegins; }{const __raw_recurrenceEnds = obj["recurrenceEnds" ]as RecurrenceEnd | null; if(__raw_recurrenceEnds === null){instance.recurrenceEnds = null;}else {const __result = recurrenceEndDeserializeWithContext(__raw_recurrenceEnds, ctx); ctx.assignOrDefer(instance, "recurrenceEnds" , __result); }}{const __raw_cancelledInstances = obj["cancelledInstances" ]as string[] | null; if(__raw_cancelledInstances === null){instance.cancelledInstances = null;}else {instance.cancelledInstances = __raw_cancelledInstances; }}{const __raw_additionalInstances = obj["additionalInstances" ]as string[] | null; if(__raw_additionalInstances === null){instance.additionalInstances = null;}else {instance.additionalInstances = __raw_additionalInstances; }}if(errors.length>0){throw new __mf_DeserializeError(errors);}return instance as RecurrenceRule;}export function recurrenceRuleValidateField<K extends keyof RecurrenceRule>(_field: K, _value: RecurrenceRule[K]): Array<{field: string; message: string}>{return[]; }export function recurrenceRuleValidateFields(_partial: Partial<RecurrenceRule>): Array<{field: string; message: string}>{return[]; }export function recurrenceRuleHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "interval" in o && "recurrenceBegins" in o && "recurrenceEnds" in o && "cancelledInstances" in o && "additionalInstances" in o;}export function recurrenceRuleIs(obj: unknown): obj is RecurrenceRule {if(!recurrenceRuleHasShape(obj)){return false;}const result = recurrenceRuleDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type RecurrenceRuleErrors = {_errors: __gf_Option<Array<string>>; interval: __gf_Option<Array<string>>; recurrenceBegins: __gf_Option<Array<string>>; recurrenceEnds: __gf_Option<Array<string>>; cancelledInstances: __gf_Option<Array<string>>; additionalInstances: __gf_Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type RecurrenceRuleTainted = {interval: __gf_Option<boolean>; recurrenceBegins: __gf_Option<boolean>; recurrenceEnds: __gf_Option<boolean>; cancelledInstances: __gf_Option<boolean>; additionalInstances: __gf_Option<boolean>; }; /** Type-safe field controllers for this form */export interface RecurrenceRuleFieldControllers {readonly interval: FieldController<Interval>; readonly recurrenceBegins: FieldController<string>; readonly recurrenceEnds: FieldController<RecurrenceEnd | null>; readonly cancelledInstances: FieldController<string[] | null>; readonly additionalInstances: FieldController<string[] | null>; }/** Gigaform instance containing reactive state and field controllers */export interface RecurrenceRuleGigaform {readonly data: RecurrenceRule; readonly errors: RecurrenceRuleErrors; readonly tainted: RecurrenceRuleTainted; readonly fields: RecurrenceRuleFieldControllers; validate(): Exit<RecurrenceRule, Array<{field: string; message: string}>>; reset(overrides?: Partial<RecurrenceRule>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function recurrenceRuleCreateForm(overrides?: Partial<RecurrenceRule>): RecurrenceRuleGigaform {let data = $state({...recurrenceRuleDefaultValue(),...overrides}); let errors = $state<RecurrenceRuleErrors>({_errors: optionNone(), interval: optionNone(), recurrenceBegins: optionNone(), recurrenceEnds: optionNone(), cancelledInstances: optionNone(), additionalInstances: optionNone(), }); let tainted = $state<RecurrenceRuleTainted>({interval: optionNone(), recurrenceBegins: optionNone(), recurrenceEnds: optionNone(), cancelledInstances: optionNone(), additionalInstances: optionNone(), }); const fields: RecurrenceRuleFieldControllers = {interval: {path: ["interval" ]as const, name: "interval" , constraints: { required: true }, get: ()=>data.interval, set: (value: Interval)=>{data.interval = value;}, transform: (value: Interval): Interval =>value,getError: ()=>errors.interval, setError: (value: __gf_Option<Array<string>>)=>{errors.interval = value;}, getTainted: ()=>tainted.interval, setTainted: (value: __gf_Option<boolean>)=>{tainted.interval = value;}, validate: (): Array<string>=>{const fieldErrors = recurrenceRuleValidateField("interval", data.interval); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},recurrenceBegins: {path: ["recurrenceBegins" ]as const, name: "recurrenceBegins" , constraints: { required: true }, get: ()=>data.recurrenceBegins, set: (value: string)=>{data.recurrenceBegins = value;}, transform: (value: string): string =>value,getError: ()=>errors.recurrenceBegins, setError: (value: __gf_Option<Array<string>>)=>{errors.recurrenceBegins = value;}, getTainted: ()=>tainted.recurrenceBegins, setTainted: (value: __gf_Option<boolean>)=>{tainted.recurrenceBegins = value;}, validate: (): Array<string>=>{const fieldErrors = recurrenceRuleValidateField("recurrenceBegins", data.recurrenceBegins); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},recurrenceEnds: {path: ["recurrenceEnds" ]as const, name: "recurrenceEnds" , constraints: { required: true }, get: ()=>data.recurrenceEnds, set: (value: RecurrenceEnd | null)=>{data.recurrenceEnds = value;}, transform: (value: RecurrenceEnd | null): RecurrenceEnd | null =>value,getError: ()=>errors.recurrenceEnds, setError: (value: __gf_Option<Array<string>>)=>{errors.recurrenceEnds = value;}, getTainted: ()=>tainted.recurrenceEnds, setTainted: (value: __gf_Option<boolean>)=>{tainted.recurrenceEnds = value;}, validate: (): Array<string>=>{const fieldErrors = recurrenceRuleValidateField("recurrenceEnds", data.recurrenceEnds); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},cancelledInstances: {path: ["cancelledInstances" ]as const, name: "cancelledInstances" , constraints: { required: true }, get: ()=>data.cancelledInstances, set: (value: string[] | null)=>{data.cancelledInstances = value;}, transform: (value: string[] | null): string[] | null =>value,getError: ()=>errors.cancelledInstances, setError: (value: __gf_Option<Array<string>>)=>{errors.cancelledInstances = value;}, getTainted: ()=>tainted.cancelledInstances, setTainted: (value: __gf_Option<boolean>)=>{tainted.cancelledInstances = value;}, validate: (): Array<string>=>{const fieldErrors = recurrenceRuleValidateField("cancelledInstances", data.cancelledInstances); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},additionalInstances: {path: ["additionalInstances" ]as const, name: "additionalInstances" , constraints: { required: true }, get: ()=>data.additionalInstances, set: (value: string[] | null)=>{data.additionalInstances = value;}, transform: (value: string[] | null): string[] | null =>value,getError: ()=>errors.additionalInstances, setError: (value: __gf_Option<Array<string>>)=>{errors.additionalInstances = value;}, getTainted: ()=>tainted.additionalInstances, setTainted: (value: __gf_Option<boolean>)=>{tainted.additionalInstances = value;}, validate: (): Array<string>=>{const fieldErrors = recurrenceRuleValidateField("additionalInstances", data.additionalInstances); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Exit<RecurrenceRule, Array<{field: string; message: string}>>{return toExit(recurrenceRuleDeserialize(data));}function reset(newOverrides?: Partial<RecurrenceRule>): void {data = {...recurrenceRuleDefaultValue(),...newOverrides}; errors = {_errors: optionNone(), interval: optionNone(), recurrenceBegins: optionNone(), recurrenceEnds: optionNone(), cancelledInstances: optionNone(), additionalInstances: optionNone(), }; tainted = {interval: optionNone(), recurrenceBegins: optionNone(), recurrenceEnds: optionNone(), cancelledInstances: optionNone(), additionalInstances: optionNone(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function recurrenceRuleFromFormData(formData: FormData): Exit<RecurrenceRule, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; {const intervalObj: Record<string, unknown>= {}; for(const[key, value]of Array.from(formData.entries())){if(key.startsWith("interval." )){const fieldName = key.slice("interval." .length); const parts = fieldName.split("." ); let current = intervalObj; for(let i = 0; i<parts.length - 1; i ++){const part = parts[i]!; if(!(part in current)){current[part]= {};}current = current[part]as Record<string, unknown>;}current[parts[parts.length - 1]!]= value;}}obj.interval = intervalObj;}obj.recurrenceBegins = formData.get("recurrenceBegins" )?? "" ;obj.recurrenceEnds = formData.get("recurrenceEnds" )?? "" ;obj.cancelledInstances = formData.get("cancelledInstances" )?? "" ;obj.additionalInstances = formData.get("additionalInstances" )?? "" ;return toExit(recurrenceRuleDeserialize(obj));}

export const RecurrenceRule = {
  defaultValue: recurrenceRuleDefaultValue,
  serialize: recurrenceRuleSerialize,
  serializeWithContext: recurrenceRuleSerializeWithContext,
  deserialize: recurrenceRuleDeserialize,
  deserializeWithContext: recurrenceRuleDeserializeWithContext,
  validateFields: recurrenceRuleValidateFields,
  hasShape: recurrenceRuleHasShape,
  is: recurrenceRuleIs,
  createForm: recurrenceRuleCreateForm,
  fromFormData: recurrenceRuleFromFormData
} as const;


export interface LastName {
    
    name: string;
}

export function lastNameDefaultValue(): LastName {return {name: "", }as LastName;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function lastNameSerialize(value: LastName): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(lastNameSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function lastNameSerializeWithContext(value: LastName, ctx: __mf_SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "LastName" , __id,}; result["name" ]= value.name; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function lastNameDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: LastName } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = lastNameDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "LastName.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function lastNameDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): LastName | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new __mf_DeserializeError([{field: "_root" , message: "LastName.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("name" in obj)){errors.push({field: "name" , message: "missing required field" });}if(errors.length>0){throw new __mf_DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_name = obj["name" ]as string; 
                if (__raw_name.length === 0) {
                    errors.push({ field: "name", message: "must not be empty" });
                }
 instance.name = __raw_name; }if(errors.length>0){throw new __mf_DeserializeError(errors);}return instance as LastName;}export function lastNameValidateField<K extends keyof LastName>(_field: K, _value: LastName[K]): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; switch(_field){case "name" : {const __val = _value as string; 
                if (__val.length === 0) {
                    errors.push({ field: "name", message: "must not be empty" });
                }
 break;}}return errors; }export function lastNameValidateFields(_partial: Partial<LastName>): Array<{field: string; message: string}>{const errors: Array<{field: string; message: string}>= []; if("name" in _partial && _partial.name!== undefined){const __val = _partial.name as string; 
                if (__val.length === 0) {
                    errors.push({ field: "name", message: "must not be empty" });
                }
}return errors; }export function lastNameHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "name" in o;}export function lastNameIs(obj: unknown): obj is LastName {if(!lastNameHasShape(obj)){return false;}const result = lastNameDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type LastNameErrors = {_errors: __gf_Option<Array<string>>; name: __gf_Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type LastNameTainted = {name: __gf_Option<boolean>; }; /** Type-safe field controllers for this form */export interface LastNameFieldControllers {readonly name: FieldController<string>; }/** Gigaform instance containing reactive state and field controllers */export interface LastNameGigaform {readonly data: LastName; readonly errors: LastNameErrors; readonly tainted: LastNameTainted; readonly fields: LastNameFieldControllers; validate(): Exit<LastName, Array<{field: string; message: string}>>; reset(overrides?: Partial<LastName>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function lastNameCreateForm(overrides?: Partial<LastName>): LastNameGigaform {let data = $state({...lastNameDefaultValue(),...overrides}); let errors = $state<LastNameErrors>({_errors: optionNone(), name: optionNone(), }); let tainted = $state<LastNameTainted>({name: optionNone(), }); const fields: LastNameFieldControllers = {name: {path: ["name" ]as const, name: "name" , constraints: { required: true }, get: ()=>data.name, set: (value: string)=>{data.name = value;}, transform: (value: string): string =>value,getError: ()=>errors.name, setError: (value: __gf_Option<Array<string>>)=>{errors.name = value;}, getTainted: ()=>tainted.name, setTainted: (value: __gf_Option<boolean>)=>{tainted.name = value;}, validate: (): Array<string>=>{const fieldErrors = lastNameValidateField("name", data.name); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Exit<LastName, Array<{field: string; message: string}>>{return toExit(lastNameDeserialize(data));}function reset(newOverrides?: Partial<LastName>): void {data = {...lastNameDefaultValue(),...newOverrides}; errors = {_errors: optionNone(), name: optionNone(), }; tainted = {name: optionNone(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function lastNameFromFormData(formData: FormData): Exit<LastName, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; obj.name = formData.get("name" )?? "" ;return toExit(lastNameDeserialize(obj));}

export const LastName = {
  defaultValue: lastNameDefaultValue,
  serialize: lastNameSerialize,
  serializeWithContext: lastNameSerializeWithContext,
  deserialize: lastNameDeserialize,
  deserializeWithContext: lastNameDeserializeWithContext,
  validateFields: lastNameValidateFields,
  hasShape: lastNameHasShape,
  is: lastNameIs,
  createForm: lastNameCreateForm,
  fromFormData: lastNameFromFormData
} as const;


export interface Cardinal {
    north: number;
    east: number;
    south: number;
    west: number;
}

export function cardinalDefaultValue(): Cardinal {return {north: 0,
                            east: 0,
                            south: 0,
                            west: 0, }as Cardinal;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function cardinalSerialize(value: Cardinal): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(cardinalSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function cardinalSerializeWithContext(value: Cardinal, ctx: __mf_SerializeContext): Record<string, unknown>{const existingId = ctx.getId(value); if(existingId!== undefined){return {__ref: existingId};}const __id = ctx.register(value); const result: Record<string, unknown>= {__type: "Cardinal" , __id,}; result["north" ]= value.north; result["east" ]= value.east; result["south" ]= value.south; result["west" ]= value.west; return result;}

/** Deserializes input to this interface type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function cardinalDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: Cardinal } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = cardinalDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Cardinal.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function cardinalDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Cardinal | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref);}if(typeof value!== "object" || value === null || Array.isArray(value)){throw new __mf_DeserializeError([{field: "_root" , message: "Cardinal.deserializeWithContext: expected an object" }]);}const obj = value as Record<string, unknown>; const errors: Array<{field: string; message: string}>= []; if(!("north" in obj)){errors.push({field: "north" , message: "missing required field" });}if(!("east" in obj)){errors.push({field: "east" , message: "missing required field" });}if(!("south" in obj)){errors.push({field: "south" , message: "missing required field" });}if(!("west" in obj)){errors.push({field: "west" , message: "missing required field" });}if(errors.length>0){throw new __mf_DeserializeError(errors);}const instance: any = {}; if(obj.__id!== undefined){ctx.register(obj.__id as number, instance);}ctx.trackForFreeze(instance); {const __raw_north = obj["north" ]as number; instance.north = __raw_north; }{const __raw_east = obj["east" ]as number; instance.east = __raw_east; }{const __raw_south = obj["south" ]as number; instance.south = __raw_south; }{const __raw_west = obj["west" ]as number; instance.west = __raw_west; }if(errors.length>0){throw new __mf_DeserializeError(errors);}return instance as Cardinal;}export function cardinalValidateField<K extends keyof Cardinal>(_field: K, _value: Cardinal[K]): Array<{field: string; message: string}>{return[]; }export function cardinalValidateFields(_partial: Partial<Cardinal>): Array<{field: string; message: string}>{return[]; }export function cardinalHasShape(obj: unknown): boolean {if(typeof obj!== "object" || obj === null || Array.isArray(obj)){return false;}const o = obj as Record<string, unknown>; return "north" in o && "east" in o && "south" in o && "west" in o;}export function cardinalIs(obj: unknown): obj is Cardinal {if(!cardinalHasShape(obj)){return false;}const result = cardinalDeserialize(obj); return result.success;}

/** Nested error structure matching the data shape */export type CardinalErrors = {_errors: __gf_Option<Array<string>>; north: __gf_Option<Array<string>>; east: __gf_Option<Array<string>>; south: __gf_Option<Array<string>>; west: __gf_Option<Array<string>>; }; /** Nested boolean structure for tracking touched/dirty fields */export type CardinalTainted = {north: __gf_Option<boolean>; east: __gf_Option<boolean>; south: __gf_Option<boolean>; west: __gf_Option<boolean>; }; /** Type-safe field controllers for this form */export interface CardinalFieldControllers {readonly north: FieldController<number>; readonly east: FieldController<number>; readonly south: FieldController<number>; readonly west: FieldController<number>; }/** Gigaform instance containing reactive state and field controllers */export interface CardinalGigaform {readonly data: Cardinal; readonly errors: CardinalErrors; readonly tainted: CardinalTainted; readonly fields: CardinalFieldControllers; validate(): Exit<Cardinal, Array<{field: string; message: string}>>; reset(overrides?: Partial<Cardinal>): void;}/** Creates a new Gigaform instance with reactive state and field controllers. */export function cardinalCreateForm(overrides?: Partial<Cardinal>): CardinalGigaform {let data = $state({...cardinalDefaultValue(),...overrides}); let errors = $state<CardinalErrors>({_errors: optionNone(), north: optionNone(), east: optionNone(), south: optionNone(), west: optionNone(), }); let tainted = $state<CardinalTainted>({north: optionNone(), east: optionNone(), south: optionNone(), west: optionNone(), }); const fields: CardinalFieldControllers = {north: {path: ["north" ]as const, name: "north" , constraints: { required: true }, get: ()=>data.north, set: (value: number)=>{data.north = value;}, transform: (value: number): number =>value,getError: ()=>errors.north, setError: (value: __gf_Option<Array<string>>)=>{errors.north = value;}, getTainted: ()=>tainted.north, setTainted: (value: __gf_Option<boolean>)=>{tainted.north = value;}, validate: (): Array<string>=>{const fieldErrors = cardinalValidateField("north", data.north); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},east: {path: ["east" ]as const, name: "east" , constraints: { required: true }, get: ()=>data.east, set: (value: number)=>{data.east = value;}, transform: (value: number): number =>value,getError: ()=>errors.east, setError: (value: __gf_Option<Array<string>>)=>{errors.east = value;}, getTainted: ()=>tainted.east, setTainted: (value: __gf_Option<boolean>)=>{tainted.east = value;}, validate: (): Array<string>=>{const fieldErrors = cardinalValidateField("east", data.east); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},south: {path: ["south" ]as const, name: "south" , constraints: { required: true }, get: ()=>data.south, set: (value: number)=>{data.south = value;}, transform: (value: number): number =>value,getError: ()=>errors.south, setError: (value: __gf_Option<Array<string>>)=>{errors.south = value;}, getTainted: ()=>tainted.south, setTainted: (value: __gf_Option<boolean>)=>{tainted.south = value;}, validate: (): Array<string>=>{const fieldErrors = cardinalValidateField("south", data.south); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},west: {path: ["west" ]as const, name: "west" , constraints: { required: true }, get: ()=>data.west, set: (value: number)=>{data.west = value;}, transform: (value: number): number =>value,getError: ()=>errors.west, setError: (value: __gf_Option<Array<string>>)=>{errors.west = value;}, getTainted: ()=>tainted.west, setTainted: (value: __gf_Option<boolean>)=>{tainted.west = value;}, validate: (): Array<string>=>{const fieldErrors = cardinalValidateField("west", data.west); return fieldErrors.map((e: {field: string; message: string})=>e.message);},},}; function validate(): Exit<Cardinal, Array<{field: string; message: string}>>{return toExit(cardinalDeserialize(data));}function reset(newOverrides?: Partial<Cardinal>): void {data = {...cardinalDefaultValue(),...newOverrides}; errors = {_errors: optionNone(), north: optionNone(), east: optionNone(), south: optionNone(), west: optionNone(), }; tainted = {north: optionNone(), east: optionNone(), south: optionNone(), west: optionNone(), };}return {get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, fields, validate, reset,};}/** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to deserialize() from @derive(Deserialize). */export function cardinalFromFormData(formData: FormData): Exit<Cardinal, Array<{field: string; message: string}>>{const obj: Record<string, unknown>= {}; {const northStr = formData.get("north" ); obj.north = northStr? parseFloat(northStr as string): 0; if(obj.north!== undefined && isNaN(obj.north as number))obj.north = 0;}{const eastStr = formData.get("east" ); obj.east = eastStr? parseFloat(eastStr as string): 0; if(obj.east!== undefined && isNaN(obj.east as number))obj.east = 0;}{const southStr = formData.get("south" ); obj.south = southStr? parseFloat(southStr as string): 0; if(obj.south!== undefined && isNaN(obj.south as number))obj.south = 0;}{const westStr = formData.get("west" ); obj.west = westStr? parseFloat(westStr as string): 0; if(obj.west!== undefined && isNaN(obj.west as number))obj.west = 0;}return toExit(cardinalDeserialize(obj));}

export const Cardinal = {
  defaultValue: cardinalDefaultValue,
  serialize: cardinalSerialize,
  serializeWithContext: cardinalSerializeWithContext,
  deserialize: cardinalDeserialize,
  deserializeWithContext: cardinalDeserializeWithContext,
  validateFields: cardinalValidateFields,
  hasShape: cardinalHasShape,
  is: cardinalIs,
  createForm: cardinalCreateForm,
  fromFormData: cardinalFromFormData
} as const;


export type Interval =
    | /** @default */ DailyRecurrenceRule
    | WeeklyRecurrenceRule
    | MonthlyRecurrenceRule
    | YearlyRecurrenceRule;

export function intervalDefaultValue(): Interval {return dailyRecurrenceRuleDefaultValue();}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function intervalSerialize(value: Interval): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(intervalSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function intervalSerializeWithContext(value: Interval, ctx: __mf_SerializeContext): unknown {if(typeof(value as any)?.serializeWithContext === "function" ){return(value as any).serializeWithContext(ctx);}return value;}

/** Deserializes input to this type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function intervalDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: Interval } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = intervalDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Interval.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function intervalDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Interval | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref)as Interval | __mf_PendingRef;}if(typeof value!== "object" || value === null){throw new __mf_DeserializeError([{field: "_root" , message: "Interval.deserializeWithContext: expected an object" }]);}const __typeName = (value as any).__type; if(typeof __typeName!== "string" ){throw new __mf_DeserializeError([{field: "_root" , message: "Interval.deserializeWithContext: missing __type field for union dispatch" }]);}if(__typeName === "DailyRecurrenceRule" ){return dailyRecurrenceRuleDeserializeWithContext(value, ctx)as Interval;}if(__typeName === "WeeklyRecurrenceRule" ){return weeklyRecurrenceRuleDeserializeWithContext(value, ctx)as Interval;}if(__typeName === "MonthlyRecurrenceRule" ){return monthlyRecurrenceRuleDeserializeWithContext(value, ctx)as Interval;}if(__typeName === "YearlyRecurrenceRule" ){return yearlyRecurrenceRuleDeserializeWithContext(value, ctx)as Interval;}throw new __mf_DeserializeError([{field: "_root" , message: "Interval.deserializeWithContext: unknown type \"" + __typeName + "\". Expected one of: DailyRecurrenceRule, WeeklyRecurrenceRule, MonthlyRecurrenceRule, YearlyRecurrenceRule" }]); }export function intervalIs(value: unknown): value is Interval {if(typeof value!== "object" || value === null){return false;}const __typeName = (value as any).__type; return __typeName === "DailyRecurrenceRule" || __typeName === "WeeklyRecurrenceRule" || __typeName === "MonthlyRecurrenceRule" || __typeName === "YearlyRecurrenceRule" ; }

/** Per-variant error types */export type IntervalDailyRecurrenceRuleErrors = {_errors: __gf_Option<Array<string>>; }; export type IntervalWeeklyRecurrenceRuleErrors = {_errors: __gf_Option<Array<string>>; }; export type IntervalMonthlyRecurrenceRuleErrors = {_errors: __gf_Option<Array<string>>; }; export type IntervalYearlyRecurrenceRuleErrors = {_errors: __gf_Option<Array<string>>; }; /** Per-variant tainted types */export type IntervalDailyRecurrenceRuleTainted = {}; export type IntervalWeeklyRecurrenceRuleTainted = {}; export type IntervalMonthlyRecurrenceRuleTainted = {}; export type IntervalYearlyRecurrenceRuleTainted = {}; /** Union error type */export type IntervalErrors = ({ _type: "DailyRecurrenceRule" } & IntervalDailyRecurrenceRuleErrors) | ({ _type: "WeeklyRecurrenceRule" } & IntervalWeeklyRecurrenceRuleErrors) | ({ _type: "MonthlyRecurrenceRule" } & IntervalMonthlyRecurrenceRuleErrors) | ({ _type: "YearlyRecurrenceRule" } & IntervalYearlyRecurrenceRuleErrors); /** Union tainted type */export type IntervalTainted = ({ _type: "DailyRecurrenceRule" } & IntervalDailyRecurrenceRuleTainted) | ({ _type: "WeeklyRecurrenceRule" } & IntervalWeeklyRecurrenceRuleTainted) | ({ _type: "MonthlyRecurrenceRule" } & IntervalMonthlyRecurrenceRuleTainted) | ({ _type: "YearlyRecurrenceRule" } & IntervalYearlyRecurrenceRuleTainted); /** Per-variant field controller types */export interface IntervalDailyRecurrenceRuleFieldControllers {}export interface IntervalWeeklyRecurrenceRuleFieldControllers {}export interface IntervalMonthlyRecurrenceRuleFieldControllers {}export interface IntervalYearlyRecurrenceRuleFieldControllers {}/** Union Gigaform interface with variant switching */export interface IntervalGigaform {readonly currentVariant: "DailyRecurrenceRule" | "WeeklyRecurrenceRule" | "MonthlyRecurrenceRule" | "YearlyRecurrenceRule"; readonly data: Interval; readonly errors: IntervalErrors; readonly tainted: IntervalTainted; readonly variants: IntervalVariantFields; switchVariant(variant: "DailyRecurrenceRule" | "WeeklyRecurrenceRule" | "MonthlyRecurrenceRule" | "YearlyRecurrenceRule"): void; validate(): Exit<Interval, Array<{field: string; message: string}>>; reset(overrides?: Partial<Interval>): void;}/** Variant fields container */export interface IntervalVariantFields {readonly DailyRecurrenceRule: {readonly fields: IntervalDailyRecurrenceRuleFieldControllers}; readonly WeeklyRecurrenceRule: {readonly fields: IntervalWeeklyRecurrenceRuleFieldControllers}; readonly MonthlyRecurrenceRule: {readonly fields: IntervalMonthlyRecurrenceRuleFieldControllers}; readonly YearlyRecurrenceRule: {readonly fields: IntervalYearlyRecurrenceRuleFieldControllers}; }/** Gets default value for a specific variant */function intervalGetDefaultForVariant(variant: string): Interval {switch(variant){case "DailyRecurrenceRule" : return dailyRecurrenceRuleDefaultValue() as Interval; case "WeeklyRecurrenceRule" : return weeklyRecurrenceRuleDefaultValue() as Interval; case "MonthlyRecurrenceRule" : return monthlyRecurrenceRuleDefaultValue() as Interval; case "YearlyRecurrenceRule" : return yearlyRecurrenceRuleDefaultValue() as Interval; default: return dailyRecurrenceRuleDefaultValue() as Interval;}}/** Creates a new discriminated union Gigaform with variant switching */export function intervalCreateForm(initial?: Interval): IntervalGigaform {const initialVariant: "DailyRecurrenceRule" | "WeeklyRecurrenceRule" | "MonthlyRecurrenceRule" | "YearlyRecurrenceRule" = "DailyRecurrenceRule"; let currentVariant = $state<"DailyRecurrenceRule" | "WeeklyRecurrenceRule" | "MonthlyRecurrenceRule" | "YearlyRecurrenceRule">(initialVariant); let data = $state<Interval>(initial?? intervalGetDefaultForVariant(initialVariant)); let errors = $state<IntervalErrors>({}as IntervalErrors); let tainted = $state<IntervalTainted>({}as IntervalTainted); const variants: IntervalVariantFields = {DailyRecurrenceRule: {fields: {}as IntervalDailyRecurrenceRuleFieldControllers}, WeeklyRecurrenceRule: {fields: {}as IntervalWeeklyRecurrenceRuleFieldControllers}, MonthlyRecurrenceRule: {fields: {}as IntervalMonthlyRecurrenceRuleFieldControllers}, YearlyRecurrenceRule: {fields: {}as IntervalYearlyRecurrenceRuleFieldControllers}, }; function switchVariant(variant: "DailyRecurrenceRule" | "WeeklyRecurrenceRule" | "MonthlyRecurrenceRule" | "YearlyRecurrenceRule"): void {currentVariant = variant; data = intervalGetDefaultForVariant(variant); errors = {}as IntervalErrors; tainted = {}as IntervalTainted;}function validate(): Exit<Interval, Array<{field: string; message: string}>>{return toExit(intervalDeserialize(data));}function reset(overrides?: Partial<Interval>): void {data = overrides ? overrides as typeof data : intervalGetDefaultForVariant(currentVariant); errors = {}as IntervalErrors; tainted = {}as IntervalTainted;}return {get currentVariant(){return currentVariant;}, get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, variants, switchVariant, validate, reset,};}/** Parses FormData for union type, determining variant from discriminant field */export function intervalFromFormData(formData: FormData): Exit<Interval, Array<{field: string; message: string}>>{const discriminant = formData.get("_type" )as "DailyRecurrenceRule" | "WeeklyRecurrenceRule" | "MonthlyRecurrenceRule" | "YearlyRecurrenceRule" | null; if(!discriminant){return toExit({success: false, errors: [{field: "_type" , message: "Missing discriminant field" }]});}const obj: Record<string, unknown>= {}; obj._type = discriminant; if(discriminant === "DailyRecurrenceRule" ){}else if(discriminant === "WeeklyRecurrenceRule" ){}else if(discriminant === "MonthlyRecurrenceRule" ){}else if(discriminant === "YearlyRecurrenceRule" ){}return toExit(intervalDeserialize(obj));}

export const Interval = {
  defaultValue: intervalDefaultValue,
  serialize: intervalSerialize,
  serializeWithContext: intervalSerializeWithContext,
  deserialize: intervalDeserialize,
  deserializeWithContext: intervalDeserializeWithContext,
  is: intervalIs,
  createForm: intervalCreateForm,
  fromFormData: intervalFromFormData
} as const;


export type Page =
    | /** @default */ 'SalesHomeDashboard'
    | 'SalesHomeProducts'
    | 'SalesHomeServices'
    | 'SalesHomePackages'
    | 'SalesHomeTaxRates'
    | 'SalesLeadsOverview'
    | 'SalesLeadsActivities'
    | 'SalesLeadsCampaigns'
    | 'SalesLeadsDripCampaigns'
    | 'SalesLeadsOpportunities'
    | 'SalesLeadsPromotions'
    | 'SalesAccountsOverview'
    | 'SalesAccountsActivities'
    | 'SalesAccountsBilling'
    | 'SalesAccountsContracts'
    | 'SalesOrdersOverview'
    | 'SalesOrdersActivities'
    | 'SalesOrdersPayments'
    | 'SalesOrdersCommissions'
    | 'SalesSchedulingSchedule'
    | 'SalesSchedulingAppointments'
    | 'SalesSchedulingRecurring'
    | 'SalesSchedulingRoutes'
    | 'SalesSchedulingReminders'
    | 'UserHome';

export function pageDefaultValue(): Page {return 'SalesHomeDashboard';}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function pageSerialize(value: Page): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(pageSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function pageSerializeWithContext(value: Page, ctx: __mf_SerializeContext): unknown {if(typeof(value as any)?.serializeWithContext === "function" ){return(value as any).serializeWithContext(ctx);}return value;}

/** Deserializes input to this type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function pageDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: Page } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = pageDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Page.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function pageDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Page | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref)as Page | __mf_PendingRef;}const allowedValues = ['SalesHomeDashboard', 'SalesHomeProducts', 'SalesHomeServices', 'SalesHomePackages', 'SalesHomeTaxRates', 'SalesLeadsOverview', 'SalesLeadsActivities', 'SalesLeadsCampaigns', 'SalesLeadsDripCampaigns', 'SalesLeadsOpportunities', 'SalesLeadsPromotions', 'SalesAccountsOverview', 'SalesAccountsActivities', 'SalesAccountsBilling', 'SalesAccountsContracts', 'SalesOrdersOverview', 'SalesOrdersActivities', 'SalesOrdersPayments', 'SalesOrdersCommissions', 'SalesSchedulingSchedule', 'SalesSchedulingAppointments', 'SalesSchedulingRecurring', 'SalesSchedulingRoutes', 'SalesSchedulingReminders', 'UserHome', ]as const; if(!allowedValues.includes(value)){throw new __mf_DeserializeError([{field: "_root" , message: "Invalid value for Page: expected one of " + allowedValues.map(v =>JSON.stringify(v)).join(", " )+ ", got " + JSON.stringify(value)}]);}return value as Page; }export function pageIs(value: unknown): value is Page {const allowedValues = ['SalesHomeDashboard', 'SalesHomeProducts', 'SalesHomeServices', 'SalesHomePackages', 'SalesHomeTaxRates', 'SalesLeadsOverview', 'SalesLeadsActivities', 'SalesLeadsCampaigns', 'SalesLeadsDripCampaigns', 'SalesLeadsOpportunities', 'SalesLeadsPromotions', 'SalesAccountsOverview', 'SalesAccountsActivities', 'SalesAccountsBilling', 'SalesAccountsContracts', 'SalesOrdersOverview', 'SalesOrdersActivities', 'SalesOrdersPayments', 'SalesOrdersCommissions', 'SalesSchedulingSchedule', 'SalesSchedulingAppointments', 'SalesSchedulingRecurring', 'SalesSchedulingRoutes', 'SalesSchedulingReminders', 'UserHome', ]as const; return allowedValues.includes(value as any); }

/** Per-variant error types */export type PageSalesHomeDashboardErrors = {_errors: __gf_Option<Array<string>>; }; export type PageSalesHomeProductsErrors = {_errors: __gf_Option<Array<string>>; }; export type PageSalesHomeServicesErrors = {_errors: __gf_Option<Array<string>>; }; export type PageSalesHomePackagesErrors = {_errors: __gf_Option<Array<string>>; }; export type PageSalesHomeTaxRatesErrors = {_errors: __gf_Option<Array<string>>; }; export type PageSalesLeadsOverviewErrors = {_errors: __gf_Option<Array<string>>; }; export type PageSalesLeadsActivitiesErrors = {_errors: __gf_Option<Array<string>>; }; export type PageSalesLeadsCampaignsErrors = {_errors: __gf_Option<Array<string>>; }; export type PageSalesLeadsDripCampaignsErrors = {_errors: __gf_Option<Array<string>>; }; export type PageSalesLeadsOpportunitiesErrors = {_errors: __gf_Option<Array<string>>; }; export type PageSalesLeadsPromotionsErrors = {_errors: __gf_Option<Array<string>>; }; export type PageSalesAccountsOverviewErrors = {_errors: __gf_Option<Array<string>>; }; export type PageSalesAccountsActivitiesErrors = {_errors: __gf_Option<Array<string>>; }; export type PageSalesAccountsBillingErrors = {_errors: __gf_Option<Array<string>>; }; export type PageSalesAccountsContractsErrors = {_errors: __gf_Option<Array<string>>; }; export type PageSalesOrdersOverviewErrors = {_errors: __gf_Option<Array<string>>; }; export type PageSalesOrdersActivitiesErrors = {_errors: __gf_Option<Array<string>>; }; export type PageSalesOrdersPaymentsErrors = {_errors: __gf_Option<Array<string>>; }; export type PageSalesOrdersCommissionsErrors = {_errors: __gf_Option<Array<string>>; }; export type PageSalesSchedulingScheduleErrors = {_errors: __gf_Option<Array<string>>; }; export type PageSalesSchedulingAppointmentsErrors = {_errors: __gf_Option<Array<string>>; }; export type PageSalesSchedulingRecurringErrors = {_errors: __gf_Option<Array<string>>; }; export type PageSalesSchedulingRoutesErrors = {_errors: __gf_Option<Array<string>>; }; export type PageSalesSchedulingRemindersErrors = {_errors: __gf_Option<Array<string>>; }; export type PageUserHomeErrors = {_errors: __gf_Option<Array<string>>; }; /** Per-variant tainted types */export type PageSalesHomeDashboardTainted = {}; export type PageSalesHomeProductsTainted = {}; export type PageSalesHomeServicesTainted = {}; export type PageSalesHomePackagesTainted = {}; export type PageSalesHomeTaxRatesTainted = {}; export type PageSalesLeadsOverviewTainted = {}; export type PageSalesLeadsActivitiesTainted = {}; export type PageSalesLeadsCampaignsTainted = {}; export type PageSalesLeadsDripCampaignsTainted = {}; export type PageSalesLeadsOpportunitiesTainted = {}; export type PageSalesLeadsPromotionsTainted = {}; export type PageSalesAccountsOverviewTainted = {}; export type PageSalesAccountsActivitiesTainted = {}; export type PageSalesAccountsBillingTainted = {}; export type PageSalesAccountsContractsTainted = {}; export type PageSalesOrdersOverviewTainted = {}; export type PageSalesOrdersActivitiesTainted = {}; export type PageSalesOrdersPaymentsTainted = {}; export type PageSalesOrdersCommissionsTainted = {}; export type PageSalesSchedulingScheduleTainted = {}; export type PageSalesSchedulingAppointmentsTainted = {}; export type PageSalesSchedulingRecurringTainted = {}; export type PageSalesSchedulingRoutesTainted = {}; export type PageSalesSchedulingRemindersTainted = {}; export type PageUserHomeTainted = {}; /** Union error type */export type PageErrors = ({ _value: "SalesHomeDashboard" } & PageSalesHomeDashboardErrors) | ({ _value: "SalesHomeProducts" } & PageSalesHomeProductsErrors) | ({ _value: "SalesHomeServices" } & PageSalesHomeServicesErrors) | ({ _value: "SalesHomePackages" } & PageSalesHomePackagesErrors) | ({ _value: "SalesHomeTaxRates" } & PageSalesHomeTaxRatesErrors) | ({ _value: "SalesLeadsOverview" } & PageSalesLeadsOverviewErrors) | ({ _value: "SalesLeadsActivities" } & PageSalesLeadsActivitiesErrors) | ({ _value: "SalesLeadsCampaigns" } & PageSalesLeadsCampaignsErrors) | ({ _value: "SalesLeadsDripCampaigns" } & PageSalesLeadsDripCampaignsErrors) | ({ _value: "SalesLeadsOpportunities" } & PageSalesLeadsOpportunitiesErrors) | ({ _value: "SalesLeadsPromotions" } & PageSalesLeadsPromotionsErrors) | ({ _value: "SalesAccountsOverview" } & PageSalesAccountsOverviewErrors) | ({ _value: "SalesAccountsActivities" } & PageSalesAccountsActivitiesErrors) | ({ _value: "SalesAccountsBilling" } & PageSalesAccountsBillingErrors) | ({ _value: "SalesAccountsContracts" } & PageSalesAccountsContractsErrors) | ({ _value: "SalesOrdersOverview" } & PageSalesOrdersOverviewErrors) | ({ _value: "SalesOrdersActivities" } & PageSalesOrdersActivitiesErrors) | ({ _value: "SalesOrdersPayments" } & PageSalesOrdersPaymentsErrors) | ({ _value: "SalesOrdersCommissions" } & PageSalesOrdersCommissionsErrors) | ({ _value: "SalesSchedulingSchedule" } & PageSalesSchedulingScheduleErrors) | ({ _value: "SalesSchedulingAppointments" } & PageSalesSchedulingAppointmentsErrors) | ({ _value: "SalesSchedulingRecurring" } & PageSalesSchedulingRecurringErrors) | ({ _value: "SalesSchedulingRoutes" } & PageSalesSchedulingRoutesErrors) | ({ _value: "SalesSchedulingReminders" } & PageSalesSchedulingRemindersErrors) | ({ _value: "UserHome" } & PageUserHomeErrors); /** Union tainted type */export type PageTainted = ({ _value: "SalesHomeDashboard" } & PageSalesHomeDashboardTainted) | ({ _value: "SalesHomeProducts" } & PageSalesHomeProductsTainted) | ({ _value: "SalesHomeServices" } & PageSalesHomeServicesTainted) | ({ _value: "SalesHomePackages" } & PageSalesHomePackagesTainted) | ({ _value: "SalesHomeTaxRates" } & PageSalesHomeTaxRatesTainted) | ({ _value: "SalesLeadsOverview" } & PageSalesLeadsOverviewTainted) | ({ _value: "SalesLeadsActivities" } & PageSalesLeadsActivitiesTainted) | ({ _value: "SalesLeadsCampaigns" } & PageSalesLeadsCampaignsTainted) | ({ _value: "SalesLeadsDripCampaigns" } & PageSalesLeadsDripCampaignsTainted) | ({ _value: "SalesLeadsOpportunities" } & PageSalesLeadsOpportunitiesTainted) | ({ _value: "SalesLeadsPromotions" } & PageSalesLeadsPromotionsTainted) | ({ _value: "SalesAccountsOverview" } & PageSalesAccountsOverviewTainted) | ({ _value: "SalesAccountsActivities" } & PageSalesAccountsActivitiesTainted) | ({ _value: "SalesAccountsBilling" } & PageSalesAccountsBillingTainted) | ({ _value: "SalesAccountsContracts" } & PageSalesAccountsContractsTainted) | ({ _value: "SalesOrdersOverview" } & PageSalesOrdersOverviewTainted) | ({ _value: "SalesOrdersActivities" } & PageSalesOrdersActivitiesTainted) | ({ _value: "SalesOrdersPayments" } & PageSalesOrdersPaymentsTainted) | ({ _value: "SalesOrdersCommissions" } & PageSalesOrdersCommissionsTainted) | ({ _value: "SalesSchedulingSchedule" } & PageSalesSchedulingScheduleTainted) | ({ _value: "SalesSchedulingAppointments" } & PageSalesSchedulingAppointmentsTainted) | ({ _value: "SalesSchedulingRecurring" } & PageSalesSchedulingRecurringTainted) | ({ _value: "SalesSchedulingRoutes" } & PageSalesSchedulingRoutesTainted) | ({ _value: "SalesSchedulingReminders" } & PageSalesSchedulingRemindersTainted) | ({ _value: "UserHome" } & PageUserHomeTainted); /** Per-variant field controller types */export interface PageSalesHomeDashboardFieldControllers {}export interface PageSalesHomeProductsFieldControllers {}export interface PageSalesHomeServicesFieldControllers {}export interface PageSalesHomePackagesFieldControllers {}export interface PageSalesHomeTaxRatesFieldControllers {}export interface PageSalesLeadsOverviewFieldControllers {}export interface PageSalesLeadsActivitiesFieldControllers {}export interface PageSalesLeadsCampaignsFieldControllers {}export interface PageSalesLeadsDripCampaignsFieldControllers {}export interface PageSalesLeadsOpportunitiesFieldControllers {}export interface PageSalesLeadsPromotionsFieldControllers {}export interface PageSalesAccountsOverviewFieldControllers {}export interface PageSalesAccountsActivitiesFieldControllers {}export interface PageSalesAccountsBillingFieldControllers {}export interface PageSalesAccountsContractsFieldControllers {}export interface PageSalesOrdersOverviewFieldControllers {}export interface PageSalesOrdersActivitiesFieldControllers {}export interface PageSalesOrdersPaymentsFieldControllers {}export interface PageSalesOrdersCommissionsFieldControllers {}export interface PageSalesSchedulingScheduleFieldControllers {}export interface PageSalesSchedulingAppointmentsFieldControllers {}export interface PageSalesSchedulingRecurringFieldControllers {}export interface PageSalesSchedulingRoutesFieldControllers {}export interface PageSalesSchedulingRemindersFieldControllers {}export interface PageUserHomeFieldControllers {}/** Union Gigaform interface with variant switching */export interface PageGigaform {readonly currentVariant: "SalesHomeDashboard" | "SalesHomeProducts" | "SalesHomeServices" | "SalesHomePackages" | "SalesHomeTaxRates" | "SalesLeadsOverview" | "SalesLeadsActivities" | "SalesLeadsCampaigns" | "SalesLeadsDripCampaigns" | "SalesLeadsOpportunities" | "SalesLeadsPromotions" | "SalesAccountsOverview" | "SalesAccountsActivities" | "SalesAccountsBilling" | "SalesAccountsContracts" | "SalesOrdersOverview" | "SalesOrdersActivities" | "SalesOrdersPayments" | "SalesOrdersCommissions" | "SalesSchedulingSchedule" | "SalesSchedulingAppointments" | "SalesSchedulingRecurring" | "SalesSchedulingRoutes" | "SalesSchedulingReminders" | "UserHome"; readonly data: Page; readonly errors: PageErrors; readonly tainted: PageTainted; readonly variants: PageVariantFields; switchVariant(variant: "SalesHomeDashboard" | "SalesHomeProducts" | "SalesHomeServices" | "SalesHomePackages" | "SalesHomeTaxRates" | "SalesLeadsOverview" | "SalesLeadsActivities" | "SalesLeadsCampaigns" | "SalesLeadsDripCampaigns" | "SalesLeadsOpportunities" | "SalesLeadsPromotions" | "SalesAccountsOverview" | "SalesAccountsActivities" | "SalesAccountsBilling" | "SalesAccountsContracts" | "SalesOrdersOverview" | "SalesOrdersActivities" | "SalesOrdersPayments" | "SalesOrdersCommissions" | "SalesSchedulingSchedule" | "SalesSchedulingAppointments" | "SalesSchedulingRecurring" | "SalesSchedulingRoutes" | "SalesSchedulingReminders" | "UserHome"): void; validate(): Exit<Page, Array<{field: string; message: string}>>; reset(overrides?: Partial<Page>): void;}/** Variant fields container */export interface PageVariantFields {readonly SalesHomeDashboard: {readonly fields: PageSalesHomeDashboardFieldControllers}; readonly SalesHomeProducts: {readonly fields: PageSalesHomeProductsFieldControllers}; readonly SalesHomeServices: {readonly fields: PageSalesHomeServicesFieldControllers}; readonly SalesHomePackages: {readonly fields: PageSalesHomePackagesFieldControllers}; readonly SalesHomeTaxRates: {readonly fields: PageSalesHomeTaxRatesFieldControllers}; readonly SalesLeadsOverview: {readonly fields: PageSalesLeadsOverviewFieldControllers}; readonly SalesLeadsActivities: {readonly fields: PageSalesLeadsActivitiesFieldControllers}; readonly SalesLeadsCampaigns: {readonly fields: PageSalesLeadsCampaignsFieldControllers}; readonly SalesLeadsDripCampaigns: {readonly fields: PageSalesLeadsDripCampaignsFieldControllers}; readonly SalesLeadsOpportunities: {readonly fields: PageSalesLeadsOpportunitiesFieldControllers}; readonly SalesLeadsPromotions: {readonly fields: PageSalesLeadsPromotionsFieldControllers}; readonly SalesAccountsOverview: {readonly fields: PageSalesAccountsOverviewFieldControllers}; readonly SalesAccountsActivities: {readonly fields: PageSalesAccountsActivitiesFieldControllers}; readonly SalesAccountsBilling: {readonly fields: PageSalesAccountsBillingFieldControllers}; readonly SalesAccountsContracts: {readonly fields: PageSalesAccountsContractsFieldControllers}; readonly SalesOrdersOverview: {readonly fields: PageSalesOrdersOverviewFieldControllers}; readonly SalesOrdersActivities: {readonly fields: PageSalesOrdersActivitiesFieldControllers}; readonly SalesOrdersPayments: {readonly fields: PageSalesOrdersPaymentsFieldControllers}; readonly SalesOrdersCommissions: {readonly fields: PageSalesOrdersCommissionsFieldControllers}; readonly SalesSchedulingSchedule: {readonly fields: PageSalesSchedulingScheduleFieldControllers}; readonly SalesSchedulingAppointments: {readonly fields: PageSalesSchedulingAppointmentsFieldControllers}; readonly SalesSchedulingRecurring: {readonly fields: PageSalesSchedulingRecurringFieldControllers}; readonly SalesSchedulingRoutes: {readonly fields: PageSalesSchedulingRoutesFieldControllers}; readonly SalesSchedulingReminders: {readonly fields: PageSalesSchedulingRemindersFieldControllers}; readonly UserHome: {readonly fields: PageUserHomeFieldControllers}; }/** Gets default value for a specific variant */function pageGetDefaultForVariant(variant: string): Page {switch(variant){case "SalesHomeDashboard" : return "SalesHomeDashboard" as Page; case "SalesHomeProducts" : return "SalesHomeProducts" as Page; case "SalesHomeServices" : return "SalesHomeServices" as Page; case "SalesHomePackages" : return "SalesHomePackages" as Page; case "SalesHomeTaxRates" : return "SalesHomeTaxRates" as Page; case "SalesLeadsOverview" : return "SalesLeadsOverview" as Page; case "SalesLeadsActivities" : return "SalesLeadsActivities" as Page; case "SalesLeadsCampaigns" : return "SalesLeadsCampaigns" as Page; case "SalesLeadsDripCampaigns" : return "SalesLeadsDripCampaigns" as Page; case "SalesLeadsOpportunities" : return "SalesLeadsOpportunities" as Page; case "SalesLeadsPromotions" : return "SalesLeadsPromotions" as Page; case "SalesAccountsOverview" : return "SalesAccountsOverview" as Page; case "SalesAccountsActivities" : return "SalesAccountsActivities" as Page; case "SalesAccountsBilling" : return "SalesAccountsBilling" as Page; case "SalesAccountsContracts" : return "SalesAccountsContracts" as Page; case "SalesOrdersOverview" : return "SalesOrdersOverview" as Page; case "SalesOrdersActivities" : return "SalesOrdersActivities" as Page; case "SalesOrdersPayments" : return "SalesOrdersPayments" as Page; case "SalesOrdersCommissions" : return "SalesOrdersCommissions" as Page; case "SalesSchedulingSchedule" : return "SalesSchedulingSchedule" as Page; case "SalesSchedulingAppointments" : return "SalesSchedulingAppointments" as Page; case "SalesSchedulingRecurring" : return "SalesSchedulingRecurring" as Page; case "SalesSchedulingRoutes" : return "SalesSchedulingRoutes" as Page; case "SalesSchedulingReminders" : return "SalesSchedulingReminders" as Page; case "UserHome" : return "UserHome" as Page; default: return "SalesHomeDashboard" as Page;}}/** Creates a new discriminated union Gigaform with variant switching */export function pageCreateForm(initial?: Page): PageGigaform {const initialVariant: "SalesHomeDashboard" | "SalesHomeProducts" | "SalesHomeServices" | "SalesHomePackages" | "SalesHomeTaxRates" | "SalesLeadsOverview" | "SalesLeadsActivities" | "SalesLeadsCampaigns" | "SalesLeadsDripCampaigns" | "SalesLeadsOpportunities" | "SalesLeadsPromotions" | "SalesAccountsOverview" | "SalesAccountsActivities" | "SalesAccountsBilling" | "SalesAccountsContracts" | "SalesOrdersOverview" | "SalesOrdersActivities" | "SalesOrdersPayments" | "SalesOrdersCommissions" | "SalesSchedulingSchedule" | "SalesSchedulingAppointments" | "SalesSchedulingRecurring" | "SalesSchedulingRoutes" | "SalesSchedulingReminders" | "UserHome" = (initial as "SalesHomeDashboard" | "SalesHomeProducts" | "SalesHomeServices" | "SalesHomePackages" | "SalesHomeTaxRates" | "SalesLeadsOverview" | "SalesLeadsActivities" | "SalesLeadsCampaigns" | "SalesLeadsDripCampaigns" | "SalesLeadsOpportunities" | "SalesLeadsPromotions" | "SalesAccountsOverview" | "SalesAccountsActivities" | "SalesAccountsBilling" | "SalesAccountsContracts" | "SalesOrdersOverview" | "SalesOrdersActivities" | "SalesOrdersPayments" | "SalesOrdersCommissions" | "SalesSchedulingSchedule" | "SalesSchedulingAppointments" | "SalesSchedulingRecurring" | "SalesSchedulingRoutes" | "SalesSchedulingReminders" | "UserHome") ?? "SalesHomeDashboard"; let currentVariant = $state<"SalesHomeDashboard" | "SalesHomeProducts" | "SalesHomeServices" | "SalesHomePackages" | "SalesHomeTaxRates" | "SalesLeadsOverview" | "SalesLeadsActivities" | "SalesLeadsCampaigns" | "SalesLeadsDripCampaigns" | "SalesLeadsOpportunities" | "SalesLeadsPromotions" | "SalesAccountsOverview" | "SalesAccountsActivities" | "SalesAccountsBilling" | "SalesAccountsContracts" | "SalesOrdersOverview" | "SalesOrdersActivities" | "SalesOrdersPayments" | "SalesOrdersCommissions" | "SalesSchedulingSchedule" | "SalesSchedulingAppointments" | "SalesSchedulingRecurring" | "SalesSchedulingRoutes" | "SalesSchedulingReminders" | "UserHome">(initialVariant); let data = $state<Page>(initial?? pageGetDefaultForVariant(initialVariant)); let errors = $state<PageErrors>({}as PageErrors); let tainted = $state<PageTainted>({}as PageTainted); const variants: PageVariantFields = {SalesHomeDashboard: {fields: {}as PageSalesHomeDashboardFieldControllers}, SalesHomeProducts: {fields: {}as PageSalesHomeProductsFieldControllers}, SalesHomeServices: {fields: {}as PageSalesHomeServicesFieldControllers}, SalesHomePackages: {fields: {}as PageSalesHomePackagesFieldControllers}, SalesHomeTaxRates: {fields: {}as PageSalesHomeTaxRatesFieldControllers}, SalesLeadsOverview: {fields: {}as PageSalesLeadsOverviewFieldControllers}, SalesLeadsActivities: {fields: {}as PageSalesLeadsActivitiesFieldControllers}, SalesLeadsCampaigns: {fields: {}as PageSalesLeadsCampaignsFieldControllers}, SalesLeadsDripCampaigns: {fields: {}as PageSalesLeadsDripCampaignsFieldControllers}, SalesLeadsOpportunities: {fields: {}as PageSalesLeadsOpportunitiesFieldControllers}, SalesLeadsPromotions: {fields: {}as PageSalesLeadsPromotionsFieldControllers}, SalesAccountsOverview: {fields: {}as PageSalesAccountsOverviewFieldControllers}, SalesAccountsActivities: {fields: {}as PageSalesAccountsActivitiesFieldControllers}, SalesAccountsBilling: {fields: {}as PageSalesAccountsBillingFieldControllers}, SalesAccountsContracts: {fields: {}as PageSalesAccountsContractsFieldControllers}, SalesOrdersOverview: {fields: {}as PageSalesOrdersOverviewFieldControllers}, SalesOrdersActivities: {fields: {}as PageSalesOrdersActivitiesFieldControllers}, SalesOrdersPayments: {fields: {}as PageSalesOrdersPaymentsFieldControllers}, SalesOrdersCommissions: {fields: {}as PageSalesOrdersCommissionsFieldControllers}, SalesSchedulingSchedule: {fields: {}as PageSalesSchedulingScheduleFieldControllers}, SalesSchedulingAppointments: {fields: {}as PageSalesSchedulingAppointmentsFieldControllers}, SalesSchedulingRecurring: {fields: {}as PageSalesSchedulingRecurringFieldControllers}, SalesSchedulingRoutes: {fields: {}as PageSalesSchedulingRoutesFieldControllers}, SalesSchedulingReminders: {fields: {}as PageSalesSchedulingRemindersFieldControllers}, UserHome: {fields: {}as PageUserHomeFieldControllers}, }; function switchVariant(variant: "SalesHomeDashboard" | "SalesHomeProducts" | "SalesHomeServices" | "SalesHomePackages" | "SalesHomeTaxRates" | "SalesLeadsOverview" | "SalesLeadsActivities" | "SalesLeadsCampaigns" | "SalesLeadsDripCampaigns" | "SalesLeadsOpportunities" | "SalesLeadsPromotions" | "SalesAccountsOverview" | "SalesAccountsActivities" | "SalesAccountsBilling" | "SalesAccountsContracts" | "SalesOrdersOverview" | "SalesOrdersActivities" | "SalesOrdersPayments" | "SalesOrdersCommissions" | "SalesSchedulingSchedule" | "SalesSchedulingAppointments" | "SalesSchedulingRecurring" | "SalesSchedulingRoutes" | "SalesSchedulingReminders" | "UserHome"): void {currentVariant = variant; data = pageGetDefaultForVariant(variant); errors = {}as PageErrors; tainted = {}as PageTainted;}function validate(): Exit<Page, Array<{field: string; message: string}>>{return toExit(pageDeserialize(data));}function reset(overrides?: Partial<Page>): void {data = overrides ? overrides as typeof data : pageGetDefaultForVariant(currentVariant); errors = {}as PageErrors; tainted = {}as PageTainted;}return {get currentVariant(){return currentVariant;}, get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, variants, switchVariant, validate, reset,};}/** Parses FormData for union type, determining variant from discriminant field */export function pageFromFormData(formData: FormData): Exit<Page, Array<{field: string; message: string}>>{const discriminant = formData.get("_value" )as "SalesHomeDashboard" | "SalesHomeProducts" | "SalesHomeServices" | "SalesHomePackages" | "SalesHomeTaxRates" | "SalesLeadsOverview" | "SalesLeadsActivities" | "SalesLeadsCampaigns" | "SalesLeadsDripCampaigns" | "SalesLeadsOpportunities" | "SalesLeadsPromotions" | "SalesAccountsOverview" | "SalesAccountsActivities" | "SalesAccountsBilling" | "SalesAccountsContracts" | "SalesOrdersOverview" | "SalesOrdersActivities" | "SalesOrdersPayments" | "SalesOrdersCommissions" | "SalesSchedulingSchedule" | "SalesSchedulingAppointments" | "SalesSchedulingRecurring" | "SalesSchedulingRoutes" | "SalesSchedulingReminders" | "UserHome" | null; if(!discriminant){return toExit({success: false, errors: [{field: "_value" , message: "Missing discriminant field" }]});}const obj: Record<string, unknown>= {}; obj._value = discriminant; if(discriminant === "SalesHomeDashboard" ){}else if(discriminant === "SalesHomeProducts" ){}else if(discriminant === "SalesHomeServices" ){}else if(discriminant === "SalesHomePackages" ){}else if(discriminant === "SalesHomeTaxRates" ){}else if(discriminant === "SalesLeadsOverview" ){}else if(discriminant === "SalesLeadsActivities" ){}else if(discriminant === "SalesLeadsCampaigns" ){}else if(discriminant === "SalesLeadsDripCampaigns" ){}else if(discriminant === "SalesLeadsOpportunities" ){}else if(discriminant === "SalesLeadsPromotions" ){}else if(discriminant === "SalesAccountsOverview" ){}else if(discriminant === "SalesAccountsActivities" ){}else if(discriminant === "SalesAccountsBilling" ){}else if(discriminant === "SalesAccountsContracts" ){}else if(discriminant === "SalesOrdersOverview" ){}else if(discriminant === "SalesOrdersActivities" ){}else if(discriminant === "SalesOrdersPayments" ){}else if(discriminant === "SalesOrdersCommissions" ){}else if(discriminant === "SalesSchedulingSchedule" ){}else if(discriminant === "SalesSchedulingAppointments" ){}else if(discriminant === "SalesSchedulingRecurring" ){}else if(discriminant === "SalesSchedulingRoutes" ){}else if(discriminant === "SalesSchedulingReminders" ){}else if(discriminant === "UserHome" ){}return toExit(pageDeserialize(obj));}

export const Page = {
  defaultValue: pageDefaultValue,
  serialize: pageSerialize,
  serializeWithContext: pageSerializeWithContext,
  deserialize: pageDeserialize,
  deserializeWithContext: pageDeserializeWithContext,
  is: pageIs,
  createForm: pageCreateForm,
  fromFormData: pageFromFormData
} as const;


export type UserRole =
    | /** @default */ 'Administrator'
    | 'SalesRepresentative'
    | 'Technician'
    | 'HumanResources'
    | 'InformationTechnology';

export function userRoleDefaultValue(): UserRole {return 'Administrator';}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function userRoleSerialize(value: UserRole): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(userRoleSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function userRoleSerializeWithContext(value: UserRole, ctx: __mf_SerializeContext): unknown {if(typeof(value as any)?.serializeWithContext === "function" ){return(value as any).serializeWithContext(ctx);}return value;}

/** Deserializes input to this type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function userRoleDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: UserRole } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = userRoleDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "UserRole.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function userRoleDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): UserRole | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref)as UserRole | __mf_PendingRef;}const allowedValues = ['Administrator', 'SalesRepresentative', 'Technician', 'HumanResources', 'InformationTechnology', ]as const; if(!allowedValues.includes(value)){throw new __mf_DeserializeError([{field: "_root" , message: "Invalid value for UserRole: expected one of " + allowedValues.map(v =>JSON.stringify(v)).join(", " )+ ", got " + JSON.stringify(value)}]);}return value as UserRole; }export function userRoleIs(value: unknown): value is UserRole {const allowedValues = ['Administrator', 'SalesRepresentative', 'Technician', 'HumanResources', 'InformationTechnology', ]as const; return allowedValues.includes(value as any); }

/** Per-variant error types */export type UserRoleAdministratorErrors = {_errors: __gf_Option<Array<string>>; }; export type UserRoleSalesRepresentativeErrors = {_errors: __gf_Option<Array<string>>; }; export type UserRoleTechnicianErrors = {_errors: __gf_Option<Array<string>>; }; export type UserRoleHumanResourcesErrors = {_errors: __gf_Option<Array<string>>; }; export type UserRoleInformationTechnologyErrors = {_errors: __gf_Option<Array<string>>; }; /** Per-variant tainted types */export type UserRoleAdministratorTainted = {}; export type UserRoleSalesRepresentativeTainted = {}; export type UserRoleTechnicianTainted = {}; export type UserRoleHumanResourcesTainted = {}; export type UserRoleInformationTechnologyTainted = {}; /** Union error type */export type UserRoleErrors = ({ _value: "Administrator" } & UserRoleAdministratorErrors) | ({ _value: "SalesRepresentative" } & UserRoleSalesRepresentativeErrors) | ({ _value: "Technician" } & UserRoleTechnicianErrors) | ({ _value: "HumanResources" } & UserRoleHumanResourcesErrors) | ({ _value: "InformationTechnology" } & UserRoleInformationTechnologyErrors); /** Union tainted type */export type UserRoleTainted = ({ _value: "Administrator" } & UserRoleAdministratorTainted) | ({ _value: "SalesRepresentative" } & UserRoleSalesRepresentativeTainted) | ({ _value: "Technician" } & UserRoleTechnicianTainted) | ({ _value: "HumanResources" } & UserRoleHumanResourcesTainted) | ({ _value: "InformationTechnology" } & UserRoleInformationTechnologyTainted); /** Per-variant field controller types */export interface UserRoleAdministratorFieldControllers {}export interface UserRoleSalesRepresentativeFieldControllers {}export interface UserRoleTechnicianFieldControllers {}export interface UserRoleHumanResourcesFieldControllers {}export interface UserRoleInformationTechnologyFieldControllers {}/** Union Gigaform interface with variant switching */export interface UserRoleGigaform {readonly currentVariant: "Administrator" | "SalesRepresentative" | "Technician" | "HumanResources" | "InformationTechnology"; readonly data: UserRole; readonly errors: UserRoleErrors; readonly tainted: UserRoleTainted; readonly variants: UserRoleVariantFields; switchVariant(variant: "Administrator" | "SalesRepresentative" | "Technician" | "HumanResources" | "InformationTechnology"): void; validate(): Exit<UserRole, Array<{field: string; message: string}>>; reset(overrides?: Partial<UserRole>): void;}/** Variant fields container */export interface UserRoleVariantFields {readonly Administrator: {readonly fields: UserRoleAdministratorFieldControllers}; readonly SalesRepresentative: {readonly fields: UserRoleSalesRepresentativeFieldControllers}; readonly Technician: {readonly fields: UserRoleTechnicianFieldControllers}; readonly HumanResources: {readonly fields: UserRoleHumanResourcesFieldControllers}; readonly InformationTechnology: {readonly fields: UserRoleInformationTechnologyFieldControllers}; }/** Gets default value for a specific variant */function userRoleGetDefaultForVariant(variant: string): UserRole {switch(variant){case "Administrator" : return "Administrator" as UserRole; case "SalesRepresentative" : return "SalesRepresentative" as UserRole; case "Technician" : return "Technician" as UserRole; case "HumanResources" : return "HumanResources" as UserRole; case "InformationTechnology" : return "InformationTechnology" as UserRole; default: return "Administrator" as UserRole;}}/** Creates a new discriminated union Gigaform with variant switching */export function userRoleCreateForm(initial?: UserRole): UserRoleGigaform {const initialVariant: "Administrator" | "SalesRepresentative" | "Technician" | "HumanResources" | "InformationTechnology" = (initial as "Administrator" | "SalesRepresentative" | "Technician" | "HumanResources" | "InformationTechnology") ?? "Administrator"; let currentVariant = $state<"Administrator" | "SalesRepresentative" | "Technician" | "HumanResources" | "InformationTechnology">(initialVariant); let data = $state<UserRole>(initial?? userRoleGetDefaultForVariant(initialVariant)); let errors = $state<UserRoleErrors>({}as UserRoleErrors); let tainted = $state<UserRoleTainted>({}as UserRoleTainted); const variants: UserRoleVariantFields = {Administrator: {fields: {}as UserRoleAdministratorFieldControllers}, SalesRepresentative: {fields: {}as UserRoleSalesRepresentativeFieldControllers}, Technician: {fields: {}as UserRoleTechnicianFieldControllers}, HumanResources: {fields: {}as UserRoleHumanResourcesFieldControllers}, InformationTechnology: {fields: {}as UserRoleInformationTechnologyFieldControllers}, }; function switchVariant(variant: "Administrator" | "SalesRepresentative" | "Technician" | "HumanResources" | "InformationTechnology"): void {currentVariant = variant; data = userRoleGetDefaultForVariant(variant); errors = {}as UserRoleErrors; tainted = {}as UserRoleTainted;}function validate(): Exit<UserRole, Array<{field: string; message: string}>>{return toExit(userRoleDeserialize(data));}function reset(overrides?: Partial<UserRole>): void {data = overrides ? overrides as typeof data : userRoleGetDefaultForVariant(currentVariant); errors = {}as UserRoleErrors; tainted = {}as UserRoleTainted;}return {get currentVariant(){return currentVariant;}, get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, variants, switchVariant, validate, reset,};}/** Parses FormData for union type, determining variant from discriminant field */export function userRoleFromFormData(formData: FormData): Exit<UserRole, Array<{field: string; message: string}>>{const discriminant = formData.get("_value" )as "Administrator" | "SalesRepresentative" | "Technician" | "HumanResources" | "InformationTechnology" | null; if(!discriminant){return toExit({success: false, errors: [{field: "_value" , message: "Missing discriminant field" }]});}const obj: Record<string, unknown>= {}; obj._value = discriminant; if(discriminant === "Administrator" ){}else if(discriminant === "SalesRepresentative" ){}else if(discriminant === "Technician" ){}else if(discriminant === "HumanResources" ){}else if(discriminant === "InformationTechnology" ){}return toExit(userRoleDeserialize(obj));}

export const UserRole = {
  defaultValue: userRoleDefaultValue,
  serialize: userRoleSerialize,
  serializeWithContext: userRoleSerializeWithContext,
  deserialize: userRoleDeserialize,
  deserializeWithContext: userRoleDeserializeWithContext,
  is: userRoleIs,
  createForm: userRoleCreateForm,
  fromFormData: userRoleFromFormData
} as const;


export type Target =
    | /** @default */ Account
    | User
    | Employee
    | Appointment
    | Lead
    | TaxRate
    | Site
    | Route
    | Company
    | Product
    | Service
    | Order
    | Payment
    | Package
    | Promotion
    | Represents
    | Ordered;

export function targetDefaultValue(): Target {return accountDefaultValue();}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function targetSerialize(value: Target): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(targetSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function targetSerializeWithContext(value: Target, ctx: __mf_SerializeContext): unknown {if(typeof(value as any)?.serializeWithContext === "function" ){return(value as any).serializeWithContext(ctx);}return value;}

/** Deserializes input to this type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function targetDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: Target } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = targetDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Target.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function targetDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Target | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref)as Target | __mf_PendingRef;}if(typeof value!== "object" || value === null){throw new __mf_DeserializeError([{field: "_root" , message: "Target.deserializeWithContext: expected an object" }]);}const __typeName = (value as any).__type; if(typeof __typeName!== "string" ){throw new __mf_DeserializeError([{field: "_root" , message: "Target.deserializeWithContext: missing __type field for union dispatch" }]);}if(__typeName === "Account" ){return accountDeserializeWithContext(value, ctx)as Target;}if(__typeName === "User" ){return userDeserializeWithContext(value, ctx)as Target;}if(__typeName === "Employee" ){return employeeDeserializeWithContext(value, ctx)as Target;}if(__typeName === "Appointment" ){return appointmentDeserializeWithContext(value, ctx)as Target;}if(__typeName === "Lead" ){return leadDeserializeWithContext(value, ctx)as Target;}if(__typeName === "TaxRate" ){return taxRateDeserializeWithContext(value, ctx)as Target;}if(__typeName === "Site" ){return siteDeserializeWithContext(value, ctx)as Target;}if(__typeName === "Route" ){return routeDeserializeWithContext(value, ctx)as Target;}if(__typeName === "Company" ){return companyDeserializeWithContext(value, ctx)as Target;}if(__typeName === "Product" ){return productDeserializeWithContext(value, ctx)as Target;}if(__typeName === "Service" ){return serviceDeserializeWithContext(value, ctx)as Target;}if(__typeName === "Order" ){return orderDeserializeWithContext(value, ctx)as Target;}if(__typeName === "Payment" ){return paymentDeserializeWithContext(value, ctx)as Target;}if(__typeName === "Package" ){return packageDeserializeWithContext(value, ctx)as Target;}if(__typeName === "Promotion" ){return promotionDeserializeWithContext(value, ctx)as Target;}if(__typeName === "Represents" ){return representsDeserializeWithContext(value, ctx)as Target;}if(__typeName === "Ordered" ){return orderedDeserializeWithContext(value, ctx)as Target;}throw new __mf_DeserializeError([{field: "_root" , message: "Target.deserializeWithContext: unknown type \"" + __typeName + "\". Expected one of: Account, User, Employee, Appointment, Lead, TaxRate, Site, Route, Company, Product, Service, Order, Payment, Package, Promotion, Represents, Ordered" }]); }export function targetIs(value: unknown): value is Target {if(typeof value!== "object" || value === null){return false;}const __typeName = (value as any).__type; return __typeName === "Account" || __typeName === "User" || __typeName === "Employee" || __typeName === "Appointment" || __typeName === "Lead" || __typeName === "TaxRate" || __typeName === "Site" || __typeName === "Route" || __typeName === "Company" || __typeName === "Product" || __typeName === "Service" || __typeName === "Order" || __typeName === "Payment" || __typeName === "Package" || __typeName === "Promotion" || __typeName === "Represents" || __typeName === "Ordered" ; }

/** Per-variant error types */export type TargetAccountErrors = {_errors: __gf_Option<Array<string>>; }; export type TargetUserErrors = {_errors: __gf_Option<Array<string>>; }; export type TargetEmployeeErrors = {_errors: __gf_Option<Array<string>>; }; export type TargetAppointmentErrors = {_errors: __gf_Option<Array<string>>; }; export type TargetLeadErrors = {_errors: __gf_Option<Array<string>>; }; export type TargetTaxRateErrors = {_errors: __gf_Option<Array<string>>; }; export type TargetSiteErrors = {_errors: __gf_Option<Array<string>>; }; export type TargetRouteErrors = {_errors: __gf_Option<Array<string>>; }; export type TargetCompanyErrors = {_errors: __gf_Option<Array<string>>; }; export type TargetProductErrors = {_errors: __gf_Option<Array<string>>; }; export type TargetServiceErrors = {_errors: __gf_Option<Array<string>>; }; export type TargetOrderErrors = {_errors: __gf_Option<Array<string>>; }; export type TargetPaymentErrors = {_errors: __gf_Option<Array<string>>; }; export type TargetPackageErrors = {_errors: __gf_Option<Array<string>>; }; export type TargetPromotionErrors = {_errors: __gf_Option<Array<string>>; }; export type TargetRepresentsErrors = {_errors: __gf_Option<Array<string>>; }; export type TargetOrderedErrors = {_errors: __gf_Option<Array<string>>; }; /** Per-variant tainted types */export type TargetAccountTainted = {}; export type TargetUserTainted = {}; export type TargetEmployeeTainted = {}; export type TargetAppointmentTainted = {}; export type TargetLeadTainted = {}; export type TargetTaxRateTainted = {}; export type TargetSiteTainted = {}; export type TargetRouteTainted = {}; export type TargetCompanyTainted = {}; export type TargetProductTainted = {}; export type TargetServiceTainted = {}; export type TargetOrderTainted = {}; export type TargetPaymentTainted = {}; export type TargetPackageTainted = {}; export type TargetPromotionTainted = {}; export type TargetRepresentsTainted = {}; export type TargetOrderedTainted = {}; /** Union error type */export type TargetErrors = ({ _type: "Account" } & TargetAccountErrors) | ({ _type: "User" } & TargetUserErrors) | ({ _type: "Employee" } & TargetEmployeeErrors) | ({ _type: "Appointment" } & TargetAppointmentErrors) | ({ _type: "Lead" } & TargetLeadErrors) | ({ _type: "TaxRate" } & TargetTaxRateErrors) | ({ _type: "Site" } & TargetSiteErrors) | ({ _type: "Route" } & TargetRouteErrors) | ({ _type: "Company" } & TargetCompanyErrors) | ({ _type: "Product" } & TargetProductErrors) | ({ _type: "Service" } & TargetServiceErrors) | ({ _type: "Order" } & TargetOrderErrors) | ({ _type: "Payment" } & TargetPaymentErrors) | ({ _type: "Package" } & TargetPackageErrors) | ({ _type: "Promotion" } & TargetPromotionErrors) | ({ _type: "Represents" } & TargetRepresentsErrors) | ({ _type: "Ordered" } & TargetOrderedErrors); /** Union tainted type */export type TargetTainted = ({ _type: "Account" } & TargetAccountTainted) | ({ _type: "User" } & TargetUserTainted) | ({ _type: "Employee" } & TargetEmployeeTainted) | ({ _type: "Appointment" } & TargetAppointmentTainted) | ({ _type: "Lead" } & TargetLeadTainted) | ({ _type: "TaxRate" } & TargetTaxRateTainted) | ({ _type: "Site" } & TargetSiteTainted) | ({ _type: "Route" } & TargetRouteTainted) | ({ _type: "Company" } & TargetCompanyTainted) | ({ _type: "Product" } & TargetProductTainted) | ({ _type: "Service" } & TargetServiceTainted) | ({ _type: "Order" } & TargetOrderTainted) | ({ _type: "Payment" } & TargetPaymentTainted) | ({ _type: "Package" } & TargetPackageTainted) | ({ _type: "Promotion" } & TargetPromotionTainted) | ({ _type: "Represents" } & TargetRepresentsTainted) | ({ _type: "Ordered" } & TargetOrderedTainted); /** Per-variant field controller types */export interface TargetAccountFieldControllers {}export interface TargetUserFieldControllers {}export interface TargetEmployeeFieldControllers {}export interface TargetAppointmentFieldControllers {}export interface TargetLeadFieldControllers {}export interface TargetTaxRateFieldControllers {}export interface TargetSiteFieldControllers {}export interface TargetRouteFieldControllers {}export interface TargetCompanyFieldControllers {}export interface TargetProductFieldControllers {}export interface TargetServiceFieldControllers {}export interface TargetOrderFieldControllers {}export interface TargetPaymentFieldControllers {}export interface TargetPackageFieldControllers {}export interface TargetPromotionFieldControllers {}export interface TargetRepresentsFieldControllers {}export interface TargetOrderedFieldControllers {}/** Union Gigaform interface with variant switching */export interface TargetGigaform {readonly currentVariant: "Account" | "User" | "Employee" | "Appointment" | "Lead" | "TaxRate" | "Site" | "Route" | "Company" | "Product" | "Service" | "Order" | "Payment" | "Package" | "Promotion" | "Represents" | "Ordered"; readonly data: Target; readonly errors: TargetErrors; readonly tainted: TargetTainted; readonly variants: TargetVariantFields; switchVariant(variant: "Account" | "User" | "Employee" | "Appointment" | "Lead" | "TaxRate" | "Site" | "Route" | "Company" | "Product" | "Service" | "Order" | "Payment" | "Package" | "Promotion" | "Represents" | "Ordered"): void; validate(): Exit<Target, Array<{field: string; message: string}>>; reset(overrides?: Partial<Target>): void;}/** Variant fields container */export interface TargetVariantFields {readonly Account: {readonly fields: TargetAccountFieldControllers}; readonly User: {readonly fields: TargetUserFieldControllers}; readonly Employee: {readonly fields: TargetEmployeeFieldControllers}; readonly Appointment: {readonly fields: TargetAppointmentFieldControllers}; readonly Lead: {readonly fields: TargetLeadFieldControllers}; readonly TaxRate: {readonly fields: TargetTaxRateFieldControllers}; readonly Site: {readonly fields: TargetSiteFieldControllers}; readonly Route: {readonly fields: TargetRouteFieldControllers}; readonly Company: {readonly fields: TargetCompanyFieldControllers}; readonly Product: {readonly fields: TargetProductFieldControllers}; readonly Service: {readonly fields: TargetServiceFieldControllers}; readonly Order: {readonly fields: TargetOrderFieldControllers}; readonly Payment: {readonly fields: TargetPaymentFieldControllers}; readonly Package: {readonly fields: TargetPackageFieldControllers}; readonly Promotion: {readonly fields: TargetPromotionFieldControllers}; readonly Represents: {readonly fields: TargetRepresentsFieldControllers}; readonly Ordered: {readonly fields: TargetOrderedFieldControllers}; }/** Gets default value for a specific variant */function targetGetDefaultForVariant(variant: string): Target {switch(variant){case "Account" : return accountDefaultValue() as Target; case "User" : return userDefaultValue() as Target; case "Employee" : return employeeDefaultValue() as Target; case "Appointment" : return appointmentDefaultValue() as Target; case "Lead" : return leadDefaultValue() as Target; case "TaxRate" : return taxRateDefaultValue() as Target; case "Site" : return siteDefaultValue() as Target; case "Route" : return routeDefaultValue() as Target; case "Company" : return companyDefaultValue() as Target; case "Product" : return productDefaultValue() as Target; case "Service" : return serviceDefaultValue() as Target; case "Order" : return orderDefaultValue() as Target; case "Payment" : return paymentDefaultValue() as Target; case "Package" : return packageDefaultValue() as Target; case "Promotion" : return promotionDefaultValue() as Target; case "Represents" : return representsDefaultValue() as Target; case "Ordered" : return orderedDefaultValue() as Target; default: return accountDefaultValue() as Target;}}/** Creates a new discriminated union Gigaform with variant switching */export function targetCreateForm(initial?: Target): TargetGigaform {const initialVariant: "Account" | "User" | "Employee" | "Appointment" | "Lead" | "TaxRate" | "Site" | "Route" | "Company" | "Product" | "Service" | "Order" | "Payment" | "Package" | "Promotion" | "Represents" | "Ordered" = "Account"; let currentVariant = $state<"Account" | "User" | "Employee" | "Appointment" | "Lead" | "TaxRate" | "Site" | "Route" | "Company" | "Product" | "Service" | "Order" | "Payment" | "Package" | "Promotion" | "Represents" | "Ordered">(initialVariant); let data = $state<Target>(initial?? targetGetDefaultForVariant(initialVariant)); let errors = $state<TargetErrors>({}as TargetErrors); let tainted = $state<TargetTainted>({}as TargetTainted); const variants: TargetVariantFields = {Account: {fields: {}as TargetAccountFieldControllers}, User: {fields: {}as TargetUserFieldControllers}, Employee: {fields: {}as TargetEmployeeFieldControllers}, Appointment: {fields: {}as TargetAppointmentFieldControllers}, Lead: {fields: {}as TargetLeadFieldControllers}, TaxRate: {fields: {}as TargetTaxRateFieldControllers}, Site: {fields: {}as TargetSiteFieldControllers}, Route: {fields: {}as TargetRouteFieldControllers}, Company: {fields: {}as TargetCompanyFieldControllers}, Product: {fields: {}as TargetProductFieldControllers}, Service: {fields: {}as TargetServiceFieldControllers}, Order: {fields: {}as TargetOrderFieldControllers}, Payment: {fields: {}as TargetPaymentFieldControllers}, Package: {fields: {}as TargetPackageFieldControllers}, Promotion: {fields: {}as TargetPromotionFieldControllers}, Represents: {fields: {}as TargetRepresentsFieldControllers}, Ordered: {fields: {}as TargetOrderedFieldControllers}, }; function switchVariant(variant: "Account" | "User" | "Employee" | "Appointment" | "Lead" | "TaxRate" | "Site" | "Route" | "Company" | "Product" | "Service" | "Order" | "Payment" | "Package" | "Promotion" | "Represents" | "Ordered"): void {currentVariant = variant; data = targetGetDefaultForVariant(variant); errors = {}as TargetErrors; tainted = {}as TargetTainted;}function validate(): Exit<Target, Array<{field: string; message: string}>>{return toExit(targetDeserialize(data));}function reset(overrides?: Partial<Target>): void {data = overrides ? overrides as typeof data : targetGetDefaultForVariant(currentVariant); errors = {}as TargetErrors; tainted = {}as TargetTainted;}return {get currentVariant(){return currentVariant;}, get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, variants, switchVariant, validate, reset,};}/** Parses FormData for union type, determining variant from discriminant field */export function targetFromFormData(formData: FormData): Exit<Target, Array<{field: string; message: string}>>{const discriminant = formData.get("_type" )as "Account" | "User" | "Employee" | "Appointment" | "Lead" | "TaxRate" | "Site" | "Route" | "Company" | "Product" | "Service" | "Order" | "Payment" | "Package" | "Promotion" | "Represents" | "Ordered" | null; if(!discriminant){return toExit({success: false, errors: [{field: "_type" , message: "Missing discriminant field" }]});}const obj: Record<string, unknown>= {}; obj._type = discriminant; if(discriminant === "Account" ){}else if(discriminant === "User" ){}else if(discriminant === "Employee" ){}else if(discriminant === "Appointment" ){}else if(discriminant === "Lead" ){}else if(discriminant === "TaxRate" ){}else if(discriminant === "Site" ){}else if(discriminant === "Route" ){}else if(discriminant === "Company" ){}else if(discriminant === "Product" ){}else if(discriminant === "Service" ){}else if(discriminant === "Order" ){}else if(discriminant === "Payment" ){}else if(discriminant === "Package" ){}else if(discriminant === "Promotion" ){}else if(discriminant === "Represents" ){}else if(discriminant === "Ordered" ){}return toExit(targetDeserialize(obj));}

export const Target = {
  defaultValue: targetDefaultValue,
  serialize: targetSerialize,
  serializeWithContext: targetSerializeWithContext,
  deserialize: targetDeserialize,
  deserializeWithContext: targetDeserializeWithContext,
  is: targetIs,
  createForm: targetCreateForm,
  fromFormData: targetFromFormData
} as const;


export type RecurrenceEnd = /** @default(0) */ number | string;

export function recurrenceEndDefaultValue(): RecurrenceEnd {return 0;}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function recurrenceEndSerialize(value: RecurrenceEnd): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(recurrenceEndSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function recurrenceEndSerializeWithContext(value: RecurrenceEnd, ctx: __mf_SerializeContext): unknown {if(typeof(value as any)?.serializeWithContext === "function" ){return(value as any).serializeWithContext(ctx);}return value;}

/** Deserializes input to this type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function recurrenceEndDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: RecurrenceEnd } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = recurrenceEndDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "RecurrenceEnd.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function recurrenceEndDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): RecurrenceEnd | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref)as RecurrenceEnd | __mf_PendingRef;}if(typeof value === "number" ){return value as RecurrenceEnd;}if(typeof value === "string" ){return value as RecurrenceEnd;}throw new __mf_DeserializeError([{field: "_root" , message: "RecurrenceEnd.deserializeWithContext: expected number, string, got " + typeof value}]); }export function recurrenceEndIs(value: unknown): value is RecurrenceEnd {return typeof value === "number" || typeof value === "string" ; }

/** Per-variant error types */export type RecurrenceEndNumberErrors = {_errors: __gf_Option<Array<string>>; }; export type RecurrenceEndStringErrors = {_errors: __gf_Option<Array<string>>; }; /** Per-variant tainted types */export type RecurrenceEndNumberTainted = {}; export type RecurrenceEndStringTainted = {}; /** Union error type */export type RecurrenceEndErrors = ({ _type: "number" } & RecurrenceEndNumberErrors) | ({ _type: "string" } & RecurrenceEndStringErrors); /** Union tainted type */export type RecurrenceEndTainted = ({ _type: "number" } & RecurrenceEndNumberTainted) | ({ _type: "string" } & RecurrenceEndStringTainted); /** Per-variant field controller types */export interface RecurrenceEndNumberFieldControllers {}export interface RecurrenceEndStringFieldControllers {}/** Union Gigaform interface with variant switching */export interface RecurrenceEndGigaform {readonly currentVariant: "number" | "string"; readonly data: RecurrenceEnd; readonly errors: RecurrenceEndErrors; readonly tainted: RecurrenceEndTainted; readonly variants: RecurrenceEndVariantFields; switchVariant(variant: "number" | "string"): void; validate(): Exit<RecurrenceEnd, Array<{field: string; message: string}>>; reset(overrides?: Partial<RecurrenceEnd>): void;}/** Variant fields container */export interface RecurrenceEndVariantFields {readonly number: {readonly fields: RecurrenceEndNumberFieldControllers}; readonly string: {readonly fields: RecurrenceEndStringFieldControllers}; }/** Gets default value for a specific variant */function recurrenceEndGetDefaultForVariant(variant: string): RecurrenceEnd {switch(variant){case "number" : return 0 as RecurrenceEnd; case "string" : return "" as RecurrenceEnd; default: return 0 as RecurrenceEnd;}}/** Creates a new discriminated union Gigaform with variant switching */export function recurrenceEndCreateForm(initial?: RecurrenceEnd): RecurrenceEndGigaform {const initialVariant: "number" | "string" = "number"; let currentVariant = $state<"number" | "string">(initialVariant); let data = $state<RecurrenceEnd>(initial?? recurrenceEndGetDefaultForVariant(initialVariant)); let errors = $state<RecurrenceEndErrors>({}as RecurrenceEndErrors); let tainted = $state<RecurrenceEndTainted>({}as RecurrenceEndTainted); const variants: RecurrenceEndVariantFields = {number: {fields: {}as RecurrenceEndNumberFieldControllers}, string: {fields: {}as RecurrenceEndStringFieldControllers}, }; function switchVariant(variant: "number" | "string"): void {currentVariant = variant; data = recurrenceEndGetDefaultForVariant(variant); errors = {}as RecurrenceEndErrors; tainted = {}as RecurrenceEndTainted;}function validate(): Exit<RecurrenceEnd, Array<{field: string; message: string}>>{return toExit(recurrenceEndDeserialize(data));}function reset(overrides?: Partial<RecurrenceEnd>): void {data = overrides ? overrides as typeof data : recurrenceEndGetDefaultForVariant(currentVariant); errors = {}as RecurrenceEndErrors; tainted = {}as RecurrenceEndTainted;}return {get currentVariant(){return currentVariant;}, get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, variants, switchVariant, validate, reset,};}/** Parses FormData for union type, determining variant from discriminant field */export function recurrenceEndFromFormData(formData: FormData): Exit<RecurrenceEnd, Array<{field: string; message: string}>>{const discriminant = formData.get("_type" )as "number" | "string" | null; if(!discriminant){return toExit({success: false, errors: [{field: "_type" , message: "Missing discriminant field" }]});}const obj: Record<string, unknown>= {}; obj._type = discriminant; if(discriminant === "number" ){}else if(discriminant === "string" ){}return toExit(recurrenceEndDeserialize(obj));}

export const RecurrenceEnd = {
  defaultValue: recurrenceEndDefaultValue,
  serialize: recurrenceEndSerialize,
  serializeWithContext: recurrenceEndSerializeWithContext,
  deserialize: recurrenceEndDeserialize,
  deserializeWithContext: recurrenceEndDeserializeWithContext,
  is: recurrenceEndIs,
  createForm: recurrenceEndCreateForm,
  fromFormData: recurrenceEndFromFormData
} as const;


export type OverviewDisplay = /** @default */ 'Card' | 'Table';

export function overviewDisplayDefaultValue(): OverviewDisplay {return 'Card';}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function overviewDisplaySerialize(value: OverviewDisplay): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(overviewDisplaySerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function overviewDisplaySerializeWithContext(value: OverviewDisplay, ctx: __mf_SerializeContext): unknown {if(typeof(value as any)?.serializeWithContext === "function" ){return(value as any).serializeWithContext(ctx);}return value;}

/** Deserializes input to this type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function overviewDisplayDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: OverviewDisplay } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = overviewDisplayDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "OverviewDisplay.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function overviewDisplayDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): OverviewDisplay | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref)as OverviewDisplay | __mf_PendingRef;}const allowedValues = ['Card', 'Table', ]as const; if(!allowedValues.includes(value)){throw new __mf_DeserializeError([{field: "_root" , message: "Invalid value for OverviewDisplay: expected one of " + allowedValues.map(v =>JSON.stringify(v)).join(", " )+ ", got " + JSON.stringify(value)}]);}return value as OverviewDisplay; }export function overviewDisplayIs(value: unknown): value is OverviewDisplay {const allowedValues = ['Card', 'Table', ]as const; return allowedValues.includes(value as any); }

/** Per-variant error types */export type OverviewDisplayCardErrors = {_errors: __gf_Option<Array<string>>; }; export type OverviewDisplayTableErrors = {_errors: __gf_Option<Array<string>>; }; /** Per-variant tainted types */export type OverviewDisplayCardTainted = {}; export type OverviewDisplayTableTainted = {}; /** Union error type */export type OverviewDisplayErrors = ({ _value: "Card" } & OverviewDisplayCardErrors) | ({ _value: "Table" } & OverviewDisplayTableErrors); /** Union tainted type */export type OverviewDisplayTainted = ({ _value: "Card" } & OverviewDisplayCardTainted) | ({ _value: "Table" } & OverviewDisplayTableTainted); /** Per-variant field controller types */export interface OverviewDisplayCardFieldControllers {}export interface OverviewDisplayTableFieldControllers {}/** Union Gigaform interface with variant switching */export interface OverviewDisplayGigaform {readonly currentVariant: "Card" | "Table"; readonly data: OverviewDisplay; readonly errors: OverviewDisplayErrors; readonly tainted: OverviewDisplayTainted; readonly variants: OverviewDisplayVariantFields; switchVariant(variant: "Card" | "Table"): void; validate(): Exit<OverviewDisplay, Array<{field: string; message: string}>>; reset(overrides?: Partial<OverviewDisplay>): void;}/** Variant fields container */export interface OverviewDisplayVariantFields {readonly Card: {readonly fields: OverviewDisplayCardFieldControllers}; readonly Table: {readonly fields: OverviewDisplayTableFieldControllers}; }/** Gets default value for a specific variant */function overviewDisplayGetDefaultForVariant(variant: string): OverviewDisplay {switch(variant){case "Card" : return "Card" as OverviewDisplay; case "Table" : return "Table" as OverviewDisplay; default: return "Card" as OverviewDisplay;}}/** Creates a new discriminated union Gigaform with variant switching */export function overviewDisplayCreateForm(initial?: OverviewDisplay): OverviewDisplayGigaform {const initialVariant: "Card" | "Table" = (initial as "Card" | "Table") ?? "Card"; let currentVariant = $state<"Card" | "Table">(initialVariant); let data = $state<OverviewDisplay>(initial?? overviewDisplayGetDefaultForVariant(initialVariant)); let errors = $state<OverviewDisplayErrors>({}as OverviewDisplayErrors); let tainted = $state<OverviewDisplayTainted>({}as OverviewDisplayTainted); const variants: OverviewDisplayVariantFields = {Card: {fields: {}as OverviewDisplayCardFieldControllers}, Table: {fields: {}as OverviewDisplayTableFieldControllers}, }; function switchVariant(variant: "Card" | "Table"): void {currentVariant = variant; data = overviewDisplayGetDefaultForVariant(variant); errors = {}as OverviewDisplayErrors; tainted = {}as OverviewDisplayTainted;}function validate(): Exit<OverviewDisplay, Array<{field: string; message: string}>>{return toExit(overviewDisplayDeserialize(data));}function reset(overrides?: Partial<OverviewDisplay>): void {data = overrides ? overrides as typeof data : overviewDisplayGetDefaultForVariant(currentVariant); errors = {}as OverviewDisplayErrors; tainted = {}as OverviewDisplayTainted;}return {get currentVariant(){return currentVariant;}, get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, variants, switchVariant, validate, reset,};}/** Parses FormData for union type, determining variant from discriminant field */export function overviewDisplayFromFormData(formData: FormData): Exit<OverviewDisplay, Array<{field: string; message: string}>>{const discriminant = formData.get("_value" )as "Card" | "Table" | null; if(!discriminant){return toExit({success: false, errors: [{field: "_value" , message: "Missing discriminant field" }]});}const obj: Record<string, unknown>= {}; obj._value = discriminant; if(discriminant === "Card" ){}else if(discriminant === "Table" ){}return toExit(overviewDisplayDeserialize(obj));}

export const OverviewDisplay = {
  defaultValue: overviewDisplayDefaultValue,
  serialize: overviewDisplaySerialize,
  serializeWithContext: overviewDisplaySerializeWithContext,
  deserialize: overviewDisplayDeserialize,
  deserializeWithContext: overviewDisplayDeserializeWithContext,
  is: overviewDisplayIs,
  createForm: overviewDisplayCreateForm,
  fromFormData: overviewDisplayFromFormData
} as const;


export type IntervalUnit = /** @default */ 'Day' | 'Week' | 'Month' | 'Year';

export function intervalUnitDefaultValue(): IntervalUnit {return 'Day';}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function intervalUnitSerialize(value: IntervalUnit): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(intervalUnitSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function intervalUnitSerializeWithContext(value: IntervalUnit, ctx: __mf_SerializeContext): unknown {if(typeof(value as any)?.serializeWithContext === "function" ){return(value as any).serializeWithContext(ctx);}return value;}

/** Deserializes input to this type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function intervalUnitDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: IntervalUnit } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = intervalUnitDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "IntervalUnit.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function intervalUnitDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): IntervalUnit | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref)as IntervalUnit | __mf_PendingRef;}const allowedValues = ['Day', 'Week', 'Month', 'Year', ]as const; if(!allowedValues.includes(value)){throw new __mf_DeserializeError([{field: "_root" , message: "Invalid value for IntervalUnit: expected one of " + allowedValues.map(v =>JSON.stringify(v)).join(", " )+ ", got " + JSON.stringify(value)}]);}return value as IntervalUnit; }export function intervalUnitIs(value: unknown): value is IntervalUnit {const allowedValues = ['Day', 'Week', 'Month', 'Year', ]as const; return allowedValues.includes(value as any); }

/** Per-variant error types */export type IntervalUnitDayErrors = {_errors: __gf_Option<Array<string>>; }; export type IntervalUnitWeekErrors = {_errors: __gf_Option<Array<string>>; }; export type IntervalUnitMonthErrors = {_errors: __gf_Option<Array<string>>; }; export type IntervalUnitYearErrors = {_errors: __gf_Option<Array<string>>; }; /** Per-variant tainted types */export type IntervalUnitDayTainted = {}; export type IntervalUnitWeekTainted = {}; export type IntervalUnitMonthTainted = {}; export type IntervalUnitYearTainted = {}; /** Union error type */export type IntervalUnitErrors = ({ _value: "Day" } & IntervalUnitDayErrors) | ({ _value: "Week" } & IntervalUnitWeekErrors) | ({ _value: "Month" } & IntervalUnitMonthErrors) | ({ _value: "Year" } & IntervalUnitYearErrors); /** Union tainted type */export type IntervalUnitTainted = ({ _value: "Day" } & IntervalUnitDayTainted) | ({ _value: "Week" } & IntervalUnitWeekTainted) | ({ _value: "Month" } & IntervalUnitMonthTainted) | ({ _value: "Year" } & IntervalUnitYearTainted); /** Per-variant field controller types */export interface IntervalUnitDayFieldControllers {}export interface IntervalUnitWeekFieldControllers {}export interface IntervalUnitMonthFieldControllers {}export interface IntervalUnitYearFieldControllers {}/** Union Gigaform interface with variant switching */export interface IntervalUnitGigaform {readonly currentVariant: "Day" | "Week" | "Month" | "Year"; readonly data: IntervalUnit; readonly errors: IntervalUnitErrors; readonly tainted: IntervalUnitTainted; readonly variants: IntervalUnitVariantFields; switchVariant(variant: "Day" | "Week" | "Month" | "Year"): void; validate(): Exit<IntervalUnit, Array<{field: string; message: string}>>; reset(overrides?: Partial<IntervalUnit>): void;}/** Variant fields container */export interface IntervalUnitVariantFields {readonly Day: {readonly fields: IntervalUnitDayFieldControllers}; readonly Week: {readonly fields: IntervalUnitWeekFieldControllers}; readonly Month: {readonly fields: IntervalUnitMonthFieldControllers}; readonly Year: {readonly fields: IntervalUnitYearFieldControllers}; }/** Gets default value for a specific variant */function intervalUnitGetDefaultForVariant(variant: string): IntervalUnit {switch(variant){case "Day" : return "Day" as IntervalUnit; case "Week" : return "Week" as IntervalUnit; case "Month" : return "Month" as IntervalUnit; case "Year" : return "Year" as IntervalUnit; default: return "Day" as IntervalUnit;}}/** Creates a new discriminated union Gigaform with variant switching */export function intervalUnitCreateForm(initial?: IntervalUnit): IntervalUnitGigaform {const initialVariant: "Day" | "Week" | "Month" | "Year" = (initial as "Day" | "Week" | "Month" | "Year") ?? "Day"; let currentVariant = $state<"Day" | "Week" | "Month" | "Year">(initialVariant); let data = $state<IntervalUnit>(initial?? intervalUnitGetDefaultForVariant(initialVariant)); let errors = $state<IntervalUnitErrors>({}as IntervalUnitErrors); let tainted = $state<IntervalUnitTainted>({}as IntervalUnitTainted); const variants: IntervalUnitVariantFields = {Day: {fields: {}as IntervalUnitDayFieldControllers}, Week: {fields: {}as IntervalUnitWeekFieldControllers}, Month: {fields: {}as IntervalUnitMonthFieldControllers}, Year: {fields: {}as IntervalUnitYearFieldControllers}, }; function switchVariant(variant: "Day" | "Week" | "Month" | "Year"): void {currentVariant = variant; data = intervalUnitGetDefaultForVariant(variant); errors = {}as IntervalUnitErrors; tainted = {}as IntervalUnitTainted;}function validate(): Exit<IntervalUnit, Array<{field: string; message: string}>>{return toExit(intervalUnitDeserialize(data));}function reset(overrides?: Partial<IntervalUnit>): void {data = overrides ? overrides as typeof data : intervalUnitGetDefaultForVariant(currentVariant); errors = {}as IntervalUnitErrors; tainted = {}as IntervalUnitTainted;}return {get currentVariant(){return currentVariant;}, get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, variants, switchVariant, validate, reset,};}/** Parses FormData for union type, determining variant from discriminant field */export function intervalUnitFromFormData(formData: FormData): Exit<IntervalUnit, Array<{field: string; message: string}>>{const discriminant = formData.get("_value" )as "Day" | "Week" | "Month" | "Year" | null; if(!discriminant){return toExit({success: false, errors: [{field: "_value" , message: "Missing discriminant field" }]});}const obj: Record<string, unknown>= {}; obj._value = discriminant; if(discriminant === "Day" ){}else if(discriminant === "Week" ){}else if(discriminant === "Month" ){}else if(discriminant === "Year" ){}return toExit(intervalUnitDeserialize(obj));}

export const IntervalUnit = {
  defaultValue: intervalUnitDefaultValue,
  serialize: intervalUnitSerialize,
  serializeWithContext: intervalUnitSerializeWithContext,
  deserialize: intervalUnitDeserialize,
  deserializeWithContext: intervalUnitDeserializeWithContext,
  is: intervalUnitIs,
  createForm: intervalUnitCreateForm,
  fromFormData: intervalUnitFromFormData
} as const;


export type Sector = /** @default */ 'Residential' | 'Commercial';

export function sectorDefaultValue(): Sector {return 'Residential';}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function sectorSerialize(value: Sector): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(sectorSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function sectorSerializeWithContext(value: Sector, ctx: __mf_SerializeContext): unknown {if(typeof(value as any)?.serializeWithContext === "function" ){return(value as any).serializeWithContext(ctx);}return value;}

/** Deserializes input to this type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function sectorDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: Sector } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = sectorDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Sector.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function sectorDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Sector | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref)as Sector | __mf_PendingRef;}const allowedValues = ['Residential', 'Commercial', ]as const; if(!allowedValues.includes(value)){throw new __mf_DeserializeError([{field: "_root" , message: "Invalid value for Sector: expected one of " + allowedValues.map(v =>JSON.stringify(v)).join(", " )+ ", got " + JSON.stringify(value)}]);}return value as Sector; }export function sectorIs(value: unknown): value is Sector {const allowedValues = ['Residential', 'Commercial', ]as const; return allowedValues.includes(value as any); }

/** Per-variant error types */export type SectorResidentialErrors = {_errors: __gf_Option<Array<string>>; }; export type SectorCommercialErrors = {_errors: __gf_Option<Array<string>>; }; /** Per-variant tainted types */export type SectorResidentialTainted = {}; export type SectorCommercialTainted = {}; /** Union error type */export type SectorErrors = ({ _value: "Residential" } & SectorResidentialErrors) | ({ _value: "Commercial" } & SectorCommercialErrors); /** Union tainted type */export type SectorTainted = ({ _value: "Residential" } & SectorResidentialTainted) | ({ _value: "Commercial" } & SectorCommercialTainted); /** Per-variant field controller types */export interface SectorResidentialFieldControllers {}export interface SectorCommercialFieldControllers {}/** Union Gigaform interface with variant switching */export interface SectorGigaform {readonly currentVariant: "Residential" | "Commercial"; readonly data: Sector; readonly errors: SectorErrors; readonly tainted: SectorTainted; readonly variants: SectorVariantFields; switchVariant(variant: "Residential" | "Commercial"): void; validate(): Exit<Sector, Array<{field: string; message: string}>>; reset(overrides?: Partial<Sector>): void;}/** Variant fields container */export interface SectorVariantFields {readonly Residential: {readonly fields: SectorResidentialFieldControllers}; readonly Commercial: {readonly fields: SectorCommercialFieldControllers}; }/** Gets default value for a specific variant */function sectorGetDefaultForVariant(variant: string): Sector {switch(variant){case "Residential" : return "Residential" as Sector; case "Commercial" : return "Commercial" as Sector; default: return "Residential" as Sector;}}/** Creates a new discriminated union Gigaform with variant switching */export function sectorCreateForm(initial?: Sector): SectorGigaform {const initialVariant: "Residential" | "Commercial" = (initial as "Residential" | "Commercial") ?? "Residential"; let currentVariant = $state<"Residential" | "Commercial">(initialVariant); let data = $state<Sector>(initial?? sectorGetDefaultForVariant(initialVariant)); let errors = $state<SectorErrors>({}as SectorErrors); let tainted = $state<SectorTainted>({}as SectorTainted); const variants: SectorVariantFields = {Residential: {fields: {}as SectorResidentialFieldControllers}, Commercial: {fields: {}as SectorCommercialFieldControllers}, }; function switchVariant(variant: "Residential" | "Commercial"): void {currentVariant = variant; data = sectorGetDefaultForVariant(variant); errors = {}as SectorErrors; tainted = {}as SectorTainted;}function validate(): Exit<Sector, Array<{field: string; message: string}>>{return toExit(sectorDeserialize(data));}function reset(overrides?: Partial<Sector>): void {data = overrides ? overrides as typeof data : sectorGetDefaultForVariant(currentVariant); errors = {}as SectorErrors; tainted = {}as SectorTainted;}return {get currentVariant(){return currentVariant;}, get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, variants, switchVariant, validate, reset,};}/** Parses FormData for union type, determining variant from discriminant field */export function sectorFromFormData(formData: FormData): Exit<Sector, Array<{field: string; message: string}>>{const discriminant = formData.get("_value" )as "Residential" | "Commercial" | null; if(!discriminant){return toExit({success: false, errors: [{field: "_value" , message: "Missing discriminant field" }]});}const obj: Record<string, unknown>= {}; obj._value = discriminant; if(discriminant === "Residential" ){}else if(discriminant === "Commercial" ){}return toExit(sectorDeserialize(obj));}

export const Sector = {
  defaultValue: sectorDefaultValue,
  serialize: sectorSerialize,
  serializeWithContext: sectorSerializeWithContext,
  deserialize: sectorDeserialize,
  deserializeWithContext: sectorDeserializeWithContext,
  is: sectorIs,
  createForm: sectorCreateForm,
  fromFormData: sectorFromFormData
} as const;


export type Weekday =
    | /** @default */ 'Monday'
    | 'Tuesday'
    | 'Wednesday'
    | 'Thursday'
    | 'Friday'
    | 'Saturday'
    | 'Sunday';

export function weekdayDefaultValue(): Weekday {return 'Monday';}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function weekdaySerialize(value: Weekday): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(weekdaySerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function weekdaySerializeWithContext(value: Weekday, ctx: __mf_SerializeContext): unknown {if(typeof(value as any)?.serializeWithContext === "function" ){return(value as any).serializeWithContext(ctx);}return value;}

/** Deserializes input to this type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function weekdayDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: Weekday } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = weekdayDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Weekday.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function weekdayDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Weekday | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref)as Weekday | __mf_PendingRef;}const allowedValues = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday', ]as const; if(!allowedValues.includes(value)){throw new __mf_DeserializeError([{field: "_root" , message: "Invalid value for Weekday: expected one of " + allowedValues.map(v =>JSON.stringify(v)).join(", " )+ ", got " + JSON.stringify(value)}]);}return value as Weekday; }export function weekdayIs(value: unknown): value is Weekday {const allowedValues = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday', ]as const; return allowedValues.includes(value as any); }

/** Per-variant error types */export type WeekdayMondayErrors = {_errors: __gf_Option<Array<string>>; }; export type WeekdayTuesdayErrors = {_errors: __gf_Option<Array<string>>; }; export type WeekdayWednesdayErrors = {_errors: __gf_Option<Array<string>>; }; export type WeekdayThursdayErrors = {_errors: __gf_Option<Array<string>>; }; export type WeekdayFridayErrors = {_errors: __gf_Option<Array<string>>; }; export type WeekdaySaturdayErrors = {_errors: __gf_Option<Array<string>>; }; export type WeekdaySundayErrors = {_errors: __gf_Option<Array<string>>; }; /** Per-variant tainted types */export type WeekdayMondayTainted = {}; export type WeekdayTuesdayTainted = {}; export type WeekdayWednesdayTainted = {}; export type WeekdayThursdayTainted = {}; export type WeekdayFridayTainted = {}; export type WeekdaySaturdayTainted = {}; export type WeekdaySundayTainted = {}; /** Union error type */export type WeekdayErrors = ({ _value: "Monday" } & WeekdayMondayErrors) | ({ _value: "Tuesday" } & WeekdayTuesdayErrors) | ({ _value: "Wednesday" } & WeekdayWednesdayErrors) | ({ _value: "Thursday" } & WeekdayThursdayErrors) | ({ _value: "Friday" } & WeekdayFridayErrors) | ({ _value: "Saturday" } & WeekdaySaturdayErrors) | ({ _value: "Sunday" } & WeekdaySundayErrors); /** Union tainted type */export type WeekdayTainted = ({ _value: "Monday" } & WeekdayMondayTainted) | ({ _value: "Tuesday" } & WeekdayTuesdayTainted) | ({ _value: "Wednesday" } & WeekdayWednesdayTainted) | ({ _value: "Thursday" } & WeekdayThursdayTainted) | ({ _value: "Friday" } & WeekdayFridayTainted) | ({ _value: "Saturday" } & WeekdaySaturdayTainted) | ({ _value: "Sunday" } & WeekdaySundayTainted); /** Per-variant field controller types */export interface WeekdayMondayFieldControllers {}export interface WeekdayTuesdayFieldControllers {}export interface WeekdayWednesdayFieldControllers {}export interface WeekdayThursdayFieldControllers {}export interface WeekdayFridayFieldControllers {}export interface WeekdaySaturdayFieldControllers {}export interface WeekdaySundayFieldControllers {}/** Union Gigaform interface with variant switching */export interface WeekdayGigaform {readonly currentVariant: "Monday" | "Tuesday" | "Wednesday" | "Thursday" | "Friday" | "Saturday" | "Sunday"; readonly data: Weekday; readonly errors: WeekdayErrors; readonly tainted: WeekdayTainted; readonly variants: WeekdayVariantFields; switchVariant(variant: "Monday" | "Tuesday" | "Wednesday" | "Thursday" | "Friday" | "Saturday" | "Sunday"): void; validate(): Exit<Weekday, Array<{field: string; message: string}>>; reset(overrides?: Partial<Weekday>): void;}/** Variant fields container */export interface WeekdayVariantFields {readonly Monday: {readonly fields: WeekdayMondayFieldControllers}; readonly Tuesday: {readonly fields: WeekdayTuesdayFieldControllers}; readonly Wednesday: {readonly fields: WeekdayWednesdayFieldControllers}; readonly Thursday: {readonly fields: WeekdayThursdayFieldControllers}; readonly Friday: {readonly fields: WeekdayFridayFieldControllers}; readonly Saturday: {readonly fields: WeekdaySaturdayFieldControllers}; readonly Sunday: {readonly fields: WeekdaySundayFieldControllers}; }/** Gets default value for a specific variant */function weekdayGetDefaultForVariant(variant: string): Weekday {switch(variant){case "Monday" : return "Monday" as Weekday; case "Tuesday" : return "Tuesday" as Weekday; case "Wednesday" : return "Wednesday" as Weekday; case "Thursday" : return "Thursday" as Weekday; case "Friday" : return "Friday" as Weekday; case "Saturday" : return "Saturday" as Weekday; case "Sunday" : return "Sunday" as Weekday; default: return "Monday" as Weekday;}}/** Creates a new discriminated union Gigaform with variant switching */export function weekdayCreateForm(initial?: Weekday): WeekdayGigaform {const initialVariant: "Monday" | "Tuesday" | "Wednesday" | "Thursday" | "Friday" | "Saturday" | "Sunday" = (initial as "Monday" | "Tuesday" | "Wednesday" | "Thursday" | "Friday" | "Saturday" | "Sunday") ?? "Monday"; let currentVariant = $state<"Monday" | "Tuesday" | "Wednesday" | "Thursday" | "Friday" | "Saturday" | "Sunday">(initialVariant); let data = $state<Weekday>(initial?? weekdayGetDefaultForVariant(initialVariant)); let errors = $state<WeekdayErrors>({}as WeekdayErrors); let tainted = $state<WeekdayTainted>({}as WeekdayTainted); const variants: WeekdayVariantFields = {Monday: {fields: {}as WeekdayMondayFieldControllers}, Tuesday: {fields: {}as WeekdayTuesdayFieldControllers}, Wednesday: {fields: {}as WeekdayWednesdayFieldControllers}, Thursday: {fields: {}as WeekdayThursdayFieldControllers}, Friday: {fields: {}as WeekdayFridayFieldControllers}, Saturday: {fields: {}as WeekdaySaturdayFieldControllers}, Sunday: {fields: {}as WeekdaySundayFieldControllers}, }; function switchVariant(variant: "Monday" | "Tuesday" | "Wednesday" | "Thursday" | "Friday" | "Saturday" | "Sunday"): void {currentVariant = variant; data = weekdayGetDefaultForVariant(variant); errors = {}as WeekdayErrors; tainted = {}as WeekdayTainted;}function validate(): Exit<Weekday, Array<{field: string; message: string}>>{return toExit(weekdayDeserialize(data));}function reset(overrides?: Partial<Weekday>): void {data = overrides ? overrides as typeof data : weekdayGetDefaultForVariant(currentVariant); errors = {}as WeekdayErrors; tainted = {}as WeekdayTainted;}return {get currentVariant(){return currentVariant;}, get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, variants, switchVariant, validate, reset,};}/** Parses FormData for union type, determining variant from discriminant field */export function weekdayFromFormData(formData: FormData): Exit<Weekday, Array<{field: string; message: string}>>{const discriminant = formData.get("_value" )as "Monday" | "Tuesday" | "Wednesday" | "Thursday" | "Friday" | "Saturday" | "Sunday" | null; if(!discriminant){return toExit({success: false, errors: [{field: "_value" , message: "Missing discriminant field" }]});}const obj: Record<string, unknown>= {}; obj._value = discriminant; if(discriminant === "Monday" ){}else if(discriminant === "Tuesday" ){}else if(discriminant === "Wednesday" ){}else if(discriminant === "Thursday" ){}else if(discriminant === "Friday" ){}else if(discriminant === "Saturday" ){}else if(discriminant === "Sunday" ){}return toExit(weekdayDeserialize(obj));}

export const Weekday = {
  defaultValue: weekdayDefaultValue,
  serialize: weekdaySerialize,
  serializeWithContext: weekdaySerializeWithContext,
  deserialize: weekdayDeserialize,
  deserializeWithContext: weekdayDeserializeWithContext,
  is: weekdayIs,
  createForm: weekdayCreateForm,
  fromFormData: weekdayFromFormData
} as const;


export type Status = /** @default */ 'Scheduled' | 'OnDeck' | 'Waiting';

export function statusDefaultValue(): Status {return 'Scheduled';}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function statusSerialize(value: Status): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(statusSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function statusSerializeWithContext(value: Status, ctx: __mf_SerializeContext): unknown {if(typeof(value as any)?.serializeWithContext === "function" ){return(value as any).serializeWithContext(ctx);}return value;}

/** Deserializes input to this type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function statusDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: Status } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = statusDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Status.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function statusDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Status | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref)as Status | __mf_PendingRef;}const allowedValues = ['Scheduled', 'OnDeck', 'Waiting', ]as const; if(!allowedValues.includes(value)){throw new __mf_DeserializeError([{field: "_root" , message: "Invalid value for Status: expected one of " + allowedValues.map(v =>JSON.stringify(v)).join(", " )+ ", got " + JSON.stringify(value)}]);}return value as Status; }export function statusIs(value: unknown): value is Status {const allowedValues = ['Scheduled', 'OnDeck', 'Waiting', ]as const; return allowedValues.includes(value as any); }

/** Per-variant error types */export type StatusScheduledErrors = {_errors: __gf_Option<Array<string>>; }; export type StatusOnDeckErrors = {_errors: __gf_Option<Array<string>>; }; export type StatusWaitingErrors = {_errors: __gf_Option<Array<string>>; }; /** Per-variant tainted types */export type StatusScheduledTainted = {}; export type StatusOnDeckTainted = {}; export type StatusWaitingTainted = {}; /** Union error type */export type StatusErrors = ({ _value: "Scheduled" } & StatusScheduledErrors) | ({ _value: "OnDeck" } & StatusOnDeckErrors) | ({ _value: "Waiting" } & StatusWaitingErrors); /** Union tainted type */export type StatusTainted = ({ _value: "Scheduled" } & StatusScheduledTainted) | ({ _value: "OnDeck" } & StatusOnDeckTainted) | ({ _value: "Waiting" } & StatusWaitingTainted); /** Per-variant field controller types */export interface StatusScheduledFieldControllers {}export interface StatusOnDeckFieldControllers {}export interface StatusWaitingFieldControllers {}/** Union Gigaform interface with variant switching */export interface StatusGigaform {readonly currentVariant: "Scheduled" | "OnDeck" | "Waiting"; readonly data: Status; readonly errors: StatusErrors; readonly tainted: StatusTainted; readonly variants: StatusVariantFields; switchVariant(variant: "Scheduled" | "OnDeck" | "Waiting"): void; validate(): Exit<Status, Array<{field: string; message: string}>>; reset(overrides?: Partial<Status>): void;}/** Variant fields container */export interface StatusVariantFields {readonly Scheduled: {readonly fields: StatusScheduledFieldControllers}; readonly OnDeck: {readonly fields: StatusOnDeckFieldControllers}; readonly Waiting: {readonly fields: StatusWaitingFieldControllers}; }/** Gets default value for a specific variant */function statusGetDefaultForVariant(variant: string): Status {switch(variant){case "Scheduled" : return "Scheduled" as Status; case "OnDeck" : return "OnDeck" as Status; case "Waiting" : return "Waiting" as Status; default: return "Scheduled" as Status;}}/** Creates a new discriminated union Gigaform with variant switching */export function statusCreateForm(initial?: Status): StatusGigaform {const initialVariant: "Scheduled" | "OnDeck" | "Waiting" = (initial as "Scheduled" | "OnDeck" | "Waiting") ?? "Scheduled"; let currentVariant = $state<"Scheduled" | "OnDeck" | "Waiting">(initialVariant); let data = $state<Status>(initial?? statusGetDefaultForVariant(initialVariant)); let errors = $state<StatusErrors>({}as StatusErrors); let tainted = $state<StatusTainted>({}as StatusTainted); const variants: StatusVariantFields = {Scheduled: {fields: {}as StatusScheduledFieldControllers}, OnDeck: {fields: {}as StatusOnDeckFieldControllers}, Waiting: {fields: {}as StatusWaitingFieldControllers}, }; function switchVariant(variant: "Scheduled" | "OnDeck" | "Waiting"): void {currentVariant = variant; data = statusGetDefaultForVariant(variant); errors = {}as StatusErrors; tainted = {}as StatusTainted;}function validate(): Exit<Status, Array<{field: string; message: string}>>{return toExit(statusDeserialize(data));}function reset(overrides?: Partial<Status>): void {data = overrides ? overrides as typeof data : statusGetDefaultForVariant(currentVariant); errors = {}as StatusErrors; tainted = {}as StatusTainted;}return {get currentVariant(){return currentVariant;}, get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, variants, switchVariant, validate, reset,};}/** Parses FormData for union type, determining variant from discriminant field */export function statusFromFormData(formData: FormData): Exit<Status, Array<{field: string; message: string}>>{const discriminant = formData.get("_value" )as "Scheduled" | "OnDeck" | "Waiting" | null; if(!discriminant){return toExit({success: false, errors: [{field: "_value" , message: "Missing discriminant field" }]});}const obj: Record<string, unknown>= {}; obj._value = discriminant; if(discriminant === "Scheduled" ){}else if(discriminant === "OnDeck" ){}else if(discriminant === "Waiting" ){}return toExit(statusDeserialize(obj));}

export const Status = {
  defaultValue: statusDefaultValue,
  serialize: statusSerialize,
  serializeWithContext: statusSerializeWithContext,
  deserialize: statusDeserialize,
  deserializeWithContext: statusDeserializeWithContext,
  is: statusIs,
  createForm: statusCreateForm,
  fromFormData: statusFromFormData
} as const;


export type NextStep = /** @default */ 'InitialContact' | 'Qualified' | 'Estimate' | 'Negotiation';

export function nextStepDefaultValue(): NextStep {return 'InitialContact';}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function nextStepSerialize(value: NextStep): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(nextStepSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function nextStepSerializeWithContext(value: NextStep, ctx: __mf_SerializeContext): unknown {if(typeof(value as any)?.serializeWithContext === "function" ){return(value as any).serializeWithContext(ctx);}return value;}

/** Deserializes input to this type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function nextStepDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: NextStep } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = nextStepDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "NextStep.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function nextStepDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): NextStep | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref)as NextStep | __mf_PendingRef;}const allowedValues = ['InitialContact', 'Qualified', 'Estimate', 'Negotiation', ]as const; if(!allowedValues.includes(value)){throw new __mf_DeserializeError([{field: "_root" , message: "Invalid value for NextStep: expected one of " + allowedValues.map(v =>JSON.stringify(v)).join(", " )+ ", got " + JSON.stringify(value)}]);}return value as NextStep; }export function nextStepIs(value: unknown): value is NextStep {const allowedValues = ['InitialContact', 'Qualified', 'Estimate', 'Negotiation', ]as const; return allowedValues.includes(value as any); }

/** Per-variant error types */export type NextStepInitialContactErrors = {_errors: __gf_Option<Array<string>>; }; export type NextStepQualifiedErrors = {_errors: __gf_Option<Array<string>>; }; export type NextStepEstimateErrors = {_errors: __gf_Option<Array<string>>; }; export type NextStepNegotiationErrors = {_errors: __gf_Option<Array<string>>; }; /** Per-variant tainted types */export type NextStepInitialContactTainted = {}; export type NextStepQualifiedTainted = {}; export type NextStepEstimateTainted = {}; export type NextStepNegotiationTainted = {}; /** Union error type */export type NextStepErrors = ({ _value: "InitialContact" } & NextStepInitialContactErrors) | ({ _value: "Qualified" } & NextStepQualifiedErrors) | ({ _value: "Estimate" } & NextStepEstimateErrors) | ({ _value: "Negotiation" } & NextStepNegotiationErrors); /** Union tainted type */export type NextStepTainted = ({ _value: "InitialContact" } & NextStepInitialContactTainted) | ({ _value: "Qualified" } & NextStepQualifiedTainted) | ({ _value: "Estimate" } & NextStepEstimateTainted) | ({ _value: "Negotiation" } & NextStepNegotiationTainted); /** Per-variant field controller types */export interface NextStepInitialContactFieldControllers {}export interface NextStepQualifiedFieldControllers {}export interface NextStepEstimateFieldControllers {}export interface NextStepNegotiationFieldControllers {}/** Union Gigaform interface with variant switching */export interface NextStepGigaform {readonly currentVariant: "InitialContact" | "Qualified" | "Estimate" | "Negotiation"; readonly data: NextStep; readonly errors: NextStepErrors; readonly tainted: NextStepTainted; readonly variants: NextStepVariantFields; switchVariant(variant: "InitialContact" | "Qualified" | "Estimate" | "Negotiation"): void; validate(): Exit<NextStep, Array<{field: string; message: string}>>; reset(overrides?: Partial<NextStep>): void;}/** Variant fields container */export interface NextStepVariantFields {readonly InitialContact: {readonly fields: NextStepInitialContactFieldControllers}; readonly Qualified: {readonly fields: NextStepQualifiedFieldControllers}; readonly Estimate: {readonly fields: NextStepEstimateFieldControllers}; readonly Negotiation: {readonly fields: NextStepNegotiationFieldControllers}; }/** Gets default value for a specific variant */function nextStepGetDefaultForVariant(variant: string): NextStep {switch(variant){case "InitialContact" : return "InitialContact" as NextStep; case "Qualified" : return "Qualified" as NextStep; case "Estimate" : return "Estimate" as NextStep; case "Negotiation" : return "Negotiation" as NextStep; default: return "InitialContact" as NextStep;}}/** Creates a new discriminated union Gigaform with variant switching */export function nextStepCreateForm(initial?: NextStep): NextStepGigaform {const initialVariant: "InitialContact" | "Qualified" | "Estimate" | "Negotiation" = (initial as "InitialContact" | "Qualified" | "Estimate" | "Negotiation") ?? "InitialContact"; let currentVariant = $state<"InitialContact" | "Qualified" | "Estimate" | "Negotiation">(initialVariant); let data = $state<NextStep>(initial?? nextStepGetDefaultForVariant(initialVariant)); let errors = $state<NextStepErrors>({}as NextStepErrors); let tainted = $state<NextStepTainted>({}as NextStepTainted); const variants: NextStepVariantFields = {InitialContact: {fields: {}as NextStepInitialContactFieldControllers}, Qualified: {fields: {}as NextStepQualifiedFieldControllers}, Estimate: {fields: {}as NextStepEstimateFieldControllers}, Negotiation: {fields: {}as NextStepNegotiationFieldControllers}, }; function switchVariant(variant: "InitialContact" | "Qualified" | "Estimate" | "Negotiation"): void {currentVariant = variant; data = nextStepGetDefaultForVariant(variant); errors = {}as NextStepErrors; tainted = {}as NextStepTainted;}function validate(): Exit<NextStep, Array<{field: string; message: string}>>{return toExit(nextStepDeserialize(data));}function reset(overrides?: Partial<NextStep>): void {data = overrides ? overrides as typeof data : nextStepGetDefaultForVariant(currentVariant); errors = {}as NextStepErrors; tainted = {}as NextStepTainted;}return {get currentVariant(){return currentVariant;}, get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, variants, switchVariant, validate, reset,};}/** Parses FormData for union type, determining variant from discriminant field */export function nextStepFromFormData(formData: FormData): Exit<NextStep, Array<{field: string; message: string}>>{const discriminant = formData.get("_value" )as "InitialContact" | "Qualified" | "Estimate" | "Negotiation" | null; if(!discriminant){return toExit({success: false, errors: [{field: "_value" , message: "Missing discriminant field" }]});}const obj: Record<string, unknown>= {}; obj._value = discriminant; if(discriminant === "InitialContact" ){}else if(discriminant === "Qualified" ){}else if(discriminant === "Estimate" ){}else if(discriminant === "Negotiation" ){}return toExit(nextStepDeserialize(obj));}

export const NextStep = {
  defaultValue: nextStepDefaultValue,
  serialize: nextStepSerialize,
  serializeWithContext: nextStepSerializeWithContext,
  deserialize: nextStepDeserialize,
  deserializeWithContext: nextStepDeserializeWithContext,
  is: nextStepIs,
  createForm: nextStepCreateForm,
  fromFormData: nextStepFromFormData
} as const;


export type LeadStage =
    | /** @default */ 'Open'
    | 'InitialContact'
    | 'Qualified'
    | 'Estimate'
    | 'Negotiation';

export function leadStageDefaultValue(): LeadStage {return 'Open';}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function leadStageSerialize(value: LeadStage): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(leadStageSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function leadStageSerializeWithContext(value: LeadStage, ctx: __mf_SerializeContext): unknown {if(typeof(value as any)?.serializeWithContext === "function" ){return(value as any).serializeWithContext(ctx);}return value;}

/** Deserializes input to this type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function leadStageDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: LeadStage } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = leadStageDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "LeadStage.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function leadStageDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): LeadStage | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref)as LeadStage | __mf_PendingRef;}const allowedValues = ['Open', 'InitialContact', 'Qualified', 'Estimate', 'Negotiation', ]as const; if(!allowedValues.includes(value)){throw new __mf_DeserializeError([{field: "_root" , message: "Invalid value for LeadStage: expected one of " + allowedValues.map(v =>JSON.stringify(v)).join(", " )+ ", got " + JSON.stringify(value)}]);}return value as LeadStage; }export function leadStageIs(value: unknown): value is LeadStage {const allowedValues = ['Open', 'InitialContact', 'Qualified', 'Estimate', 'Negotiation', ]as const; return allowedValues.includes(value as any); }

/** Per-variant error types */export type LeadStageOpenErrors = {_errors: __gf_Option<Array<string>>; }; export type LeadStageInitialContactErrors = {_errors: __gf_Option<Array<string>>; }; export type LeadStageQualifiedErrors = {_errors: __gf_Option<Array<string>>; }; export type LeadStageEstimateErrors = {_errors: __gf_Option<Array<string>>; }; export type LeadStageNegotiationErrors = {_errors: __gf_Option<Array<string>>; }; /** Per-variant tainted types */export type LeadStageOpenTainted = {}; export type LeadStageInitialContactTainted = {}; export type LeadStageQualifiedTainted = {}; export type LeadStageEstimateTainted = {}; export type LeadStageNegotiationTainted = {}; /** Union error type */export type LeadStageErrors = ({ _value: "Open" } & LeadStageOpenErrors) | ({ _value: "InitialContact" } & LeadStageInitialContactErrors) | ({ _value: "Qualified" } & LeadStageQualifiedErrors) | ({ _value: "Estimate" } & LeadStageEstimateErrors) | ({ _value: "Negotiation" } & LeadStageNegotiationErrors); /** Union tainted type */export type LeadStageTainted = ({ _value: "Open" } & LeadStageOpenTainted) | ({ _value: "InitialContact" } & LeadStageInitialContactTainted) | ({ _value: "Qualified" } & LeadStageQualifiedTainted) | ({ _value: "Estimate" } & LeadStageEstimateTainted) | ({ _value: "Negotiation" } & LeadStageNegotiationTainted); /** Per-variant field controller types */export interface LeadStageOpenFieldControllers {}export interface LeadStageInitialContactFieldControllers {}export interface LeadStageQualifiedFieldControllers {}export interface LeadStageEstimateFieldControllers {}export interface LeadStageNegotiationFieldControllers {}/** Union Gigaform interface with variant switching */export interface LeadStageGigaform {readonly currentVariant: "Open" | "InitialContact" | "Qualified" | "Estimate" | "Negotiation"; readonly data: LeadStage; readonly errors: LeadStageErrors; readonly tainted: LeadStageTainted; readonly variants: LeadStageVariantFields; switchVariant(variant: "Open" | "InitialContact" | "Qualified" | "Estimate" | "Negotiation"): void; validate(): Exit<LeadStage, Array<{field: string; message: string}>>; reset(overrides?: Partial<LeadStage>): void;}/** Variant fields container */export interface LeadStageVariantFields {readonly Open: {readonly fields: LeadStageOpenFieldControllers}; readonly InitialContact: {readonly fields: LeadStageInitialContactFieldControllers}; readonly Qualified: {readonly fields: LeadStageQualifiedFieldControllers}; readonly Estimate: {readonly fields: LeadStageEstimateFieldControllers}; readonly Negotiation: {readonly fields: LeadStageNegotiationFieldControllers}; }/** Gets default value for a specific variant */function leadStageGetDefaultForVariant(variant: string): LeadStage {switch(variant){case "Open" : return "Open" as LeadStage; case "InitialContact" : return "InitialContact" as LeadStage; case "Qualified" : return "Qualified" as LeadStage; case "Estimate" : return "Estimate" as LeadStage; case "Negotiation" : return "Negotiation" as LeadStage; default: return "Open" as LeadStage;}}/** Creates a new discriminated union Gigaform with variant switching */export function leadStageCreateForm(initial?: LeadStage): LeadStageGigaform {const initialVariant: "Open" | "InitialContact" | "Qualified" | "Estimate" | "Negotiation" = (initial as "Open" | "InitialContact" | "Qualified" | "Estimate" | "Negotiation") ?? "Open"; let currentVariant = $state<"Open" | "InitialContact" | "Qualified" | "Estimate" | "Negotiation">(initialVariant); let data = $state<LeadStage>(initial?? leadStageGetDefaultForVariant(initialVariant)); let errors = $state<LeadStageErrors>({}as LeadStageErrors); let tainted = $state<LeadStageTainted>({}as LeadStageTainted); const variants: LeadStageVariantFields = {Open: {fields: {}as LeadStageOpenFieldControllers}, InitialContact: {fields: {}as LeadStageInitialContactFieldControllers}, Qualified: {fields: {}as LeadStageQualifiedFieldControllers}, Estimate: {fields: {}as LeadStageEstimateFieldControllers}, Negotiation: {fields: {}as LeadStageNegotiationFieldControllers}, }; function switchVariant(variant: "Open" | "InitialContact" | "Qualified" | "Estimate" | "Negotiation"): void {currentVariant = variant; data = leadStageGetDefaultForVariant(variant); errors = {}as LeadStageErrors; tainted = {}as LeadStageTainted;}function validate(): Exit<LeadStage, Array<{field: string; message: string}>>{return toExit(leadStageDeserialize(data));}function reset(overrides?: Partial<LeadStage>): void {data = overrides ? overrides as typeof data : leadStageGetDefaultForVariant(currentVariant); errors = {}as LeadStageErrors; tainted = {}as LeadStageTainted;}return {get currentVariant(){return currentVariant;}, get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, variants, switchVariant, validate, reset,};}/** Parses FormData for union type, determining variant from discriminant field */export function leadStageFromFormData(formData: FormData): Exit<LeadStage, Array<{field: string; message: string}>>{const discriminant = formData.get("_value" )as "Open" | "InitialContact" | "Qualified" | "Estimate" | "Negotiation" | null; if(!discriminant){return toExit({success: false, errors: [{field: "_value" , message: "Missing discriminant field" }]});}const obj: Record<string, unknown>= {}; obj._value = discriminant; if(discriminant === "Open" ){}else if(discriminant === "InitialContact" ){}else if(discriminant === "Qualified" ){}else if(discriminant === "Estimate" ){}else if(discriminant === "Negotiation" ){}return toExit(leadStageDeserialize(obj));}

export const LeadStage = {
  defaultValue: leadStageDefaultValue,
  serialize: leadStageSerialize,
  serializeWithContext: leadStageSerializeWithContext,
  deserialize: leadStageDeserialize,
  deserializeWithContext: leadStageDeserializeWithContext,
  is: leadStageIs,
  createForm: leadStageCreateForm,
  fromFormData: leadStageFromFormData
} as const;


export type AccountName = /** @default */ CompanyName | PersonName;

export function accountNameDefaultValue(): AccountName {return companyNameDefaultValue();}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function accountNameSerialize(value: AccountName): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(accountNameSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function accountNameSerializeWithContext(value: AccountName, ctx: __mf_SerializeContext): unknown {if(typeof(value as any)?.serializeWithContext === "function" ){return(value as any).serializeWithContext(ctx);}return value;}

/** Deserializes input to this type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function accountNameDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: AccountName } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = accountNameDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "AccountName.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function accountNameDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): AccountName | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref)as AccountName | __mf_PendingRef;}if(typeof value!== "object" || value === null){throw new __mf_DeserializeError([{field: "_root" , message: "AccountName.deserializeWithContext: expected an object" }]);}const __typeName = (value as any).__type; if(typeof __typeName!== "string" ){throw new __mf_DeserializeError([{field: "_root" , message: "AccountName.deserializeWithContext: missing __type field for union dispatch" }]);}if(__typeName === "CompanyName" ){return companyNameDeserializeWithContext(value, ctx)as AccountName;}if(__typeName === "PersonName" ){return personNameDeserializeWithContext(value, ctx)as AccountName;}throw new __mf_DeserializeError([{field: "_root" , message: "AccountName.deserializeWithContext: unknown type \"" + __typeName + "\". Expected one of: CompanyName, PersonName" }]); }export function accountNameIs(value: unknown): value is AccountName {if(typeof value!== "object" || value === null){return false;}const __typeName = (value as any).__type; return __typeName === "CompanyName" || __typeName === "PersonName" ; }

/** Per-variant error types */export type AccountNameCompanyNameErrors = {_errors: __gf_Option<Array<string>>; }; export type AccountNamePersonNameErrors = {_errors: __gf_Option<Array<string>>; }; /** Per-variant tainted types */export type AccountNameCompanyNameTainted = {}; export type AccountNamePersonNameTainted = {}; /** Union error type */export type AccountNameErrors = ({ _type: "CompanyName" } & AccountNameCompanyNameErrors) | ({ _type: "PersonName" } & AccountNamePersonNameErrors); /** Union tainted type */export type AccountNameTainted = ({ _type: "CompanyName" } & AccountNameCompanyNameTainted) | ({ _type: "PersonName" } & AccountNamePersonNameTainted); /** Per-variant field controller types */export interface AccountNameCompanyNameFieldControllers {}export interface AccountNamePersonNameFieldControllers {}/** Union Gigaform interface with variant switching */export interface AccountNameGigaform {readonly currentVariant: "CompanyName" | "PersonName"; readonly data: AccountName; readonly errors: AccountNameErrors; readonly tainted: AccountNameTainted; readonly variants: AccountNameVariantFields; switchVariant(variant: "CompanyName" | "PersonName"): void; validate(): Exit<AccountName, Array<{field: string; message: string}>>; reset(overrides?: Partial<AccountName>): void;}/** Variant fields container */export interface AccountNameVariantFields {readonly CompanyName: {readonly fields: AccountNameCompanyNameFieldControllers}; readonly PersonName: {readonly fields: AccountNamePersonNameFieldControllers}; }/** Gets default value for a specific variant */function accountNameGetDefaultForVariant(variant: string): AccountName {switch(variant){case "CompanyName" : return companyNameDefaultValue() as AccountName; case "PersonName" : return personNameDefaultValue() as AccountName; default: return companyNameDefaultValue() as AccountName;}}/** Creates a new discriminated union Gigaform with variant switching */export function accountNameCreateForm(initial?: AccountName): AccountNameGigaform {const initialVariant: "CompanyName" | "PersonName" = "CompanyName"; let currentVariant = $state<"CompanyName" | "PersonName">(initialVariant); let data = $state<AccountName>(initial?? accountNameGetDefaultForVariant(initialVariant)); let errors = $state<AccountNameErrors>({}as AccountNameErrors); let tainted = $state<AccountNameTainted>({}as AccountNameTainted); const variants: AccountNameVariantFields = {CompanyName: {fields: {}as AccountNameCompanyNameFieldControllers}, PersonName: {fields: {}as AccountNamePersonNameFieldControllers}, }; function switchVariant(variant: "CompanyName" | "PersonName"): void {currentVariant = variant; data = accountNameGetDefaultForVariant(variant); errors = {}as AccountNameErrors; tainted = {}as AccountNameTainted;}function validate(): Exit<AccountName, Array<{field: string; message: string}>>{return toExit(accountNameDeserialize(data));}function reset(overrides?: Partial<AccountName>): void {data = overrides ? overrides as typeof data : accountNameGetDefaultForVariant(currentVariant); errors = {}as AccountNameErrors; tainted = {}as AccountNameTainted;}return {get currentVariant(){return currentVariant;}, get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, variants, switchVariant, validate, reset,};}/** Parses FormData for union type, determining variant from discriminant field */export function accountNameFromFormData(formData: FormData): Exit<AccountName, Array<{field: string; message: string}>>{const discriminant = formData.get("_type" )as "CompanyName" | "PersonName" | null; if(!discriminant){return toExit({success: false, errors: [{field: "_type" , message: "Missing discriminant field" }]});}const obj: Record<string, unknown>= {}; obj._type = discriminant; if(discriminant === "CompanyName" ){}else if(discriminant === "PersonName" ){}return toExit(accountNameDeserialize(obj));}

export const AccountName = {
  defaultValue: accountNameDefaultValue,
  serialize: accountNameSerialize,
  serializeWithContext: accountNameSerializeWithContext,
  deserialize: accountNameDeserialize,
  deserializeWithContext: accountNameDeserializeWithContext,
  is: accountNameIs,
  createForm: accountNameCreateForm,
  fromFormData: accountNameFromFormData
} as const;


export type Priority = /** @default */ 'Medium' | 'High' | 'Low';

export function priorityDefaultValue(): Priority {return 'Medium';}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function prioritySerialize(value: Priority): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(prioritySerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function prioritySerializeWithContext(value: Priority, ctx: __mf_SerializeContext): unknown {if(typeof(value as any)?.serializeWithContext === "function" ){return(value as any).serializeWithContext(ctx);}return value;}

/** Deserializes input to this type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function priorityDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: Priority } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = priorityDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Priority.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function priorityDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Priority | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref)as Priority | __mf_PendingRef;}const allowedValues = ['Medium', 'High', 'Low', ]as const; if(!allowedValues.includes(value)){throw new __mf_DeserializeError([{field: "_root" , message: "Invalid value for Priority: expected one of " + allowedValues.map(v =>JSON.stringify(v)).join(", " )+ ", got " + JSON.stringify(value)}]);}return value as Priority; }export function priorityIs(value: unknown): value is Priority {const allowedValues = ['Medium', 'High', 'Low', ]as const; return allowedValues.includes(value as any); }

/** Per-variant error types */export type PriorityMediumErrors = {_errors: __gf_Option<Array<string>>; }; export type PriorityHighErrors = {_errors: __gf_Option<Array<string>>; }; export type PriorityLowErrors = {_errors: __gf_Option<Array<string>>; }; /** Per-variant tainted types */export type PriorityMediumTainted = {}; export type PriorityHighTainted = {}; export type PriorityLowTainted = {}; /** Union error type */export type PriorityErrors = ({ _value: "Medium" } & PriorityMediumErrors) | ({ _value: "High" } & PriorityHighErrors) | ({ _value: "Low" } & PriorityLowErrors); /** Union tainted type */export type PriorityTainted = ({ _value: "Medium" } & PriorityMediumTainted) | ({ _value: "High" } & PriorityHighTainted) | ({ _value: "Low" } & PriorityLowTainted); /** Per-variant field controller types */export interface PriorityMediumFieldControllers {}export interface PriorityHighFieldControllers {}export interface PriorityLowFieldControllers {}/** Union Gigaform interface with variant switching */export interface PriorityGigaform {readonly currentVariant: "Medium" | "High" | "Low"; readonly data: Priority; readonly errors: PriorityErrors; readonly tainted: PriorityTainted; readonly variants: PriorityVariantFields; switchVariant(variant: "Medium" | "High" | "Low"): void; validate(): Exit<Priority, Array<{field: string; message: string}>>; reset(overrides?: Partial<Priority>): void;}/** Variant fields container */export interface PriorityVariantFields {readonly Medium: {readonly fields: PriorityMediumFieldControllers}; readonly High: {readonly fields: PriorityHighFieldControllers}; readonly Low: {readonly fields: PriorityLowFieldControllers}; }/** Gets default value for a specific variant */function priorityGetDefaultForVariant(variant: string): Priority {switch(variant){case "Medium" : return "Medium" as Priority; case "High" : return "High" as Priority; case "Low" : return "Low" as Priority; default: return "Medium" as Priority;}}/** Creates a new discriminated union Gigaform with variant switching */export function priorityCreateForm(initial?: Priority): PriorityGigaform {const initialVariant: "Medium" | "High" | "Low" = (initial as "Medium" | "High" | "Low") ?? "Medium"; let currentVariant = $state<"Medium" | "High" | "Low">(initialVariant); let data = $state<Priority>(initial?? priorityGetDefaultForVariant(initialVariant)); let errors = $state<PriorityErrors>({}as PriorityErrors); let tainted = $state<PriorityTainted>({}as PriorityTainted); const variants: PriorityVariantFields = {Medium: {fields: {}as PriorityMediumFieldControllers}, High: {fields: {}as PriorityHighFieldControllers}, Low: {fields: {}as PriorityLowFieldControllers}, }; function switchVariant(variant: "Medium" | "High" | "Low"): void {currentVariant = variant; data = priorityGetDefaultForVariant(variant); errors = {}as PriorityErrors; tainted = {}as PriorityTainted;}function validate(): Exit<Priority, Array<{field: string; message: string}>>{return toExit(priorityDeserialize(data));}function reset(overrides?: Partial<Priority>): void {data = overrides ? overrides as typeof data : priorityGetDefaultForVariant(currentVariant); errors = {}as PriorityErrors; tainted = {}as PriorityTainted;}return {get currentVariant(){return currentVariant;}, get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, variants, switchVariant, validate, reset,};}/** Parses FormData for union type, determining variant from discriminant field */export function priorityFromFormData(formData: FormData): Exit<Priority, Array<{field: string; message: string}>>{const discriminant = formData.get("_value" )as "Medium" | "High" | "Low" | null; if(!discriminant){return toExit({success: false, errors: [{field: "_value" , message: "Missing discriminant field" }]});}const obj: Record<string, unknown>= {}; obj._value = discriminant; if(discriminant === "Medium" ){}else if(discriminant === "High" ){}else if(discriminant === "Low" ){}return toExit(priorityDeserialize(obj));}

export const Priority = {
  defaultValue: priorityDefaultValue,
  serialize: prioritySerialize,
  serializeWithContext: prioritySerializeWithContext,
  deserialize: priorityDeserialize,
  deserializeWithContext: priorityDeserializeWithContext,
  is: priorityIs,
  createForm: priorityCreateForm,
  fromFormData: priorityFromFormData
} as const;


export type Applications =
    | /** @default */ 'Sales'
    | 'Accounting'
    | 'Errand'
    | 'HumanResources'
    | 'Logistics'
    | 'Marketing'
    | 'Website';

export function applicationsDefaultValue(): Applications {return 'Sales';}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function applicationsSerialize(value: Applications): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(applicationsSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function applicationsSerializeWithContext(value: Applications, ctx: __mf_SerializeContext): unknown {if(typeof(value as any)?.serializeWithContext === "function" ){return(value as any).serializeWithContext(ctx);}return value;}

/** Deserializes input to this type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function applicationsDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: Applications } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = applicationsDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Applications.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function applicationsDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Applications | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref)as Applications | __mf_PendingRef;}const allowedValues = ['Sales', 'Accounting', 'Errand', 'HumanResources', 'Logistics', 'Marketing', 'Website', ]as const; if(!allowedValues.includes(value)){throw new __mf_DeserializeError([{field: "_root" , message: "Invalid value for Applications: expected one of " + allowedValues.map(v =>JSON.stringify(v)).join(", " )+ ", got " + JSON.stringify(value)}]);}return value as Applications; }export function applicationsIs(value: unknown): value is Applications {const allowedValues = ['Sales', 'Accounting', 'Errand', 'HumanResources', 'Logistics', 'Marketing', 'Website', ]as const; return allowedValues.includes(value as any); }

/** Per-variant error types */export type ApplicationsSalesErrors = {_errors: __gf_Option<Array<string>>; }; export type ApplicationsAccountingErrors = {_errors: __gf_Option<Array<string>>; }; export type ApplicationsErrandErrors = {_errors: __gf_Option<Array<string>>; }; export type ApplicationsHumanResourcesErrors = {_errors: __gf_Option<Array<string>>; }; export type ApplicationsLogisticsErrors = {_errors: __gf_Option<Array<string>>; }; export type ApplicationsMarketingErrors = {_errors: __gf_Option<Array<string>>; }; export type ApplicationsWebsiteErrors = {_errors: __gf_Option<Array<string>>; }; /** Per-variant tainted types */export type ApplicationsSalesTainted = {}; export type ApplicationsAccountingTainted = {}; export type ApplicationsErrandTainted = {}; export type ApplicationsHumanResourcesTainted = {}; export type ApplicationsLogisticsTainted = {}; export type ApplicationsMarketingTainted = {}; export type ApplicationsWebsiteTainted = {}; /** Union error type */export type ApplicationsErrors = ({ _value: "Sales" } & ApplicationsSalesErrors) | ({ _value: "Accounting" } & ApplicationsAccountingErrors) | ({ _value: "Errand" } & ApplicationsErrandErrors) | ({ _value: "HumanResources" } & ApplicationsHumanResourcesErrors) | ({ _value: "Logistics" } & ApplicationsLogisticsErrors) | ({ _value: "Marketing" } & ApplicationsMarketingErrors) | ({ _value: "Website" } & ApplicationsWebsiteErrors); /** Union tainted type */export type ApplicationsTainted = ({ _value: "Sales" } & ApplicationsSalesTainted) | ({ _value: "Accounting" } & ApplicationsAccountingTainted) | ({ _value: "Errand" } & ApplicationsErrandTainted) | ({ _value: "HumanResources" } & ApplicationsHumanResourcesTainted) | ({ _value: "Logistics" } & ApplicationsLogisticsTainted) | ({ _value: "Marketing" } & ApplicationsMarketingTainted) | ({ _value: "Website" } & ApplicationsWebsiteTainted); /** Per-variant field controller types */export interface ApplicationsSalesFieldControllers {}export interface ApplicationsAccountingFieldControllers {}export interface ApplicationsErrandFieldControllers {}export interface ApplicationsHumanResourcesFieldControllers {}export interface ApplicationsLogisticsFieldControllers {}export interface ApplicationsMarketingFieldControllers {}export interface ApplicationsWebsiteFieldControllers {}/** Union Gigaform interface with variant switching */export interface ApplicationsGigaform {readonly currentVariant: "Sales" | "Accounting" | "Errand" | "HumanResources" | "Logistics" | "Marketing" | "Website"; readonly data: Applications; readonly errors: ApplicationsErrors; readonly tainted: ApplicationsTainted; readonly variants: ApplicationsVariantFields; switchVariant(variant: "Sales" | "Accounting" | "Errand" | "HumanResources" | "Logistics" | "Marketing" | "Website"): void; validate(): Exit<Applications, Array<{field: string; message: string}>>; reset(overrides?: Partial<Applications>): void;}/** Variant fields container */export interface ApplicationsVariantFields {readonly Sales: {readonly fields: ApplicationsSalesFieldControllers}; readonly Accounting: {readonly fields: ApplicationsAccountingFieldControllers}; readonly Errand: {readonly fields: ApplicationsErrandFieldControllers}; readonly HumanResources: {readonly fields: ApplicationsHumanResourcesFieldControllers}; readonly Logistics: {readonly fields: ApplicationsLogisticsFieldControllers}; readonly Marketing: {readonly fields: ApplicationsMarketingFieldControllers}; readonly Website: {readonly fields: ApplicationsWebsiteFieldControllers}; }/** Gets default value for a specific variant */function applicationsGetDefaultForVariant(variant: string): Applications {switch(variant){case "Sales" : return "Sales" as Applications; case "Accounting" : return "Accounting" as Applications; case "Errand" : return "Errand" as Applications; case "HumanResources" : return "HumanResources" as Applications; case "Logistics" : return "Logistics" as Applications; case "Marketing" : return "Marketing" as Applications; case "Website" : return "Website" as Applications; default: return "Sales" as Applications;}}/** Creates a new discriminated union Gigaform with variant switching */export function applicationsCreateForm(initial?: Applications): ApplicationsGigaform {const initialVariant: "Sales" | "Accounting" | "Errand" | "HumanResources" | "Logistics" | "Marketing" | "Website" = (initial as "Sales" | "Accounting" | "Errand" | "HumanResources" | "Logistics" | "Marketing" | "Website") ?? "Sales"; let currentVariant = $state<"Sales" | "Accounting" | "Errand" | "HumanResources" | "Logistics" | "Marketing" | "Website">(initialVariant); let data = $state<Applications>(initial?? applicationsGetDefaultForVariant(initialVariant)); let errors = $state<ApplicationsErrors>({}as ApplicationsErrors); let tainted = $state<ApplicationsTainted>({}as ApplicationsTainted); const variants: ApplicationsVariantFields = {Sales: {fields: {}as ApplicationsSalesFieldControllers}, Accounting: {fields: {}as ApplicationsAccountingFieldControllers}, Errand: {fields: {}as ApplicationsErrandFieldControllers}, HumanResources: {fields: {}as ApplicationsHumanResourcesFieldControllers}, Logistics: {fields: {}as ApplicationsLogisticsFieldControllers}, Marketing: {fields: {}as ApplicationsMarketingFieldControllers}, Website: {fields: {}as ApplicationsWebsiteFieldControllers}, }; function switchVariant(variant: "Sales" | "Accounting" | "Errand" | "HumanResources" | "Logistics" | "Marketing" | "Website"): void {currentVariant = variant; data = applicationsGetDefaultForVariant(variant); errors = {}as ApplicationsErrors; tainted = {}as ApplicationsTainted;}function validate(): Exit<Applications, Array<{field: string; message: string}>>{return toExit(applicationsDeserialize(data));}function reset(overrides?: Partial<Applications>): void {data = overrides ? overrides as typeof data : applicationsGetDefaultForVariant(currentVariant); errors = {}as ApplicationsErrors; tainted = {}as ApplicationsTainted;}return {get currentVariant(){return currentVariant;}, get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, variants, switchVariant, validate, reset,};}/** Parses FormData for union type, determining variant from discriminant field */export function applicationsFromFormData(formData: FormData): Exit<Applications, Array<{field: string; message: string}>>{const discriminant = formData.get("_value" )as "Sales" | "Accounting" | "Errand" | "HumanResources" | "Logistics" | "Marketing" | "Website" | null; if(!discriminant){return toExit({success: false, errors: [{field: "_value" , message: "Missing discriminant field" }]});}const obj: Record<string, unknown>= {}; obj._value = discriminant; if(discriminant === "Sales" ){}else if(discriminant === "Accounting" ){}else if(discriminant === "Errand" ){}else if(discriminant === "HumanResources" ){}else if(discriminant === "Logistics" ){}else if(discriminant === "Marketing" ){}else if(discriminant === "Website" ){}return toExit(applicationsDeserialize(obj));}

export const Applications = {
  defaultValue: applicationsDefaultValue,
  serialize: applicationsSerialize,
  serializeWithContext: applicationsSerializeWithContext,
  deserialize: applicationsDeserialize,
  deserializeWithContext: applicationsDeserializeWithContext,
  is: applicationsIs,
  createForm: applicationsCreateForm,
  fromFormData: applicationsFromFormData
} as const;


export type JobTitle =
    | /** @default */ 'Technician'
    | 'SalesRepresentative'
    | 'HumanResources'
    | 'InformationTechnology';

export function jobTitleDefaultValue(): JobTitle {return 'Technician';}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function jobTitleSerialize(value: JobTitle): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(jobTitleSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function jobTitleSerializeWithContext(value: JobTitle, ctx: __mf_SerializeContext): unknown {if(typeof(value as any)?.serializeWithContext === "function" ){return(value as any).serializeWithContext(ctx);}return value;}

/** Deserializes input to this type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function jobTitleDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: JobTitle } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = jobTitleDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "JobTitle.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function jobTitleDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): JobTitle | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref)as JobTitle | __mf_PendingRef;}const allowedValues = ['Technician', 'SalesRepresentative', 'HumanResources', 'InformationTechnology', ]as const; if(!allowedValues.includes(value)){throw new __mf_DeserializeError([{field: "_root" , message: "Invalid value for JobTitle: expected one of " + allowedValues.map(v =>JSON.stringify(v)).join(", " )+ ", got " + JSON.stringify(value)}]);}return value as JobTitle; }export function jobTitleIs(value: unknown): value is JobTitle {const allowedValues = ['Technician', 'SalesRepresentative', 'HumanResources', 'InformationTechnology', ]as const; return allowedValues.includes(value as any); }

/** Per-variant error types */export type JobTitleTechnicianErrors = {_errors: __gf_Option<Array<string>>; }; export type JobTitleSalesRepresentativeErrors = {_errors: __gf_Option<Array<string>>; }; export type JobTitleHumanResourcesErrors = {_errors: __gf_Option<Array<string>>; }; export type JobTitleInformationTechnologyErrors = {_errors: __gf_Option<Array<string>>; }; /** Per-variant tainted types */export type JobTitleTechnicianTainted = {}; export type JobTitleSalesRepresentativeTainted = {}; export type JobTitleHumanResourcesTainted = {}; export type JobTitleInformationTechnologyTainted = {}; /** Union error type */export type JobTitleErrors = ({ _value: "Technician" } & JobTitleTechnicianErrors) | ({ _value: "SalesRepresentative" } & JobTitleSalesRepresentativeErrors) | ({ _value: "HumanResources" } & JobTitleHumanResourcesErrors) | ({ _value: "InformationTechnology" } & JobTitleInformationTechnologyErrors); /** Union tainted type */export type JobTitleTainted = ({ _value: "Technician" } & JobTitleTechnicianTainted) | ({ _value: "SalesRepresentative" } & JobTitleSalesRepresentativeTainted) | ({ _value: "HumanResources" } & JobTitleHumanResourcesTainted) | ({ _value: "InformationTechnology" } & JobTitleInformationTechnologyTainted); /** Per-variant field controller types */export interface JobTitleTechnicianFieldControllers {}export interface JobTitleSalesRepresentativeFieldControllers {}export interface JobTitleHumanResourcesFieldControllers {}export interface JobTitleInformationTechnologyFieldControllers {}/** Union Gigaform interface with variant switching */export interface JobTitleGigaform {readonly currentVariant: "Technician" | "SalesRepresentative" | "HumanResources" | "InformationTechnology"; readonly data: JobTitle; readonly errors: JobTitleErrors; readonly tainted: JobTitleTainted; readonly variants: JobTitleVariantFields; switchVariant(variant: "Technician" | "SalesRepresentative" | "HumanResources" | "InformationTechnology"): void; validate(): Exit<JobTitle, Array<{field: string; message: string}>>; reset(overrides?: Partial<JobTitle>): void;}/** Variant fields container */export interface JobTitleVariantFields {readonly Technician: {readonly fields: JobTitleTechnicianFieldControllers}; readonly SalesRepresentative: {readonly fields: JobTitleSalesRepresentativeFieldControllers}; readonly HumanResources: {readonly fields: JobTitleHumanResourcesFieldControllers}; readonly InformationTechnology: {readonly fields: JobTitleInformationTechnologyFieldControllers}; }/** Gets default value for a specific variant */function jobTitleGetDefaultForVariant(variant: string): JobTitle {switch(variant){case "Technician" : return "Technician" as JobTitle; case "SalesRepresentative" : return "SalesRepresentative" as JobTitle; case "HumanResources" : return "HumanResources" as JobTitle; case "InformationTechnology" : return "InformationTechnology" as JobTitle; default: return "Technician" as JobTitle;}}/** Creates a new discriminated union Gigaform with variant switching */export function jobTitleCreateForm(initial?: JobTitle): JobTitleGigaform {const initialVariant: "Technician" | "SalesRepresentative" | "HumanResources" | "InformationTechnology" = (initial as "Technician" | "SalesRepresentative" | "HumanResources" | "InformationTechnology") ?? "Technician"; let currentVariant = $state<"Technician" | "SalesRepresentative" | "HumanResources" | "InformationTechnology">(initialVariant); let data = $state<JobTitle>(initial?? jobTitleGetDefaultForVariant(initialVariant)); let errors = $state<JobTitleErrors>({}as JobTitleErrors); let tainted = $state<JobTitleTainted>({}as JobTitleTainted); const variants: JobTitleVariantFields = {Technician: {fields: {}as JobTitleTechnicianFieldControllers}, SalesRepresentative: {fields: {}as JobTitleSalesRepresentativeFieldControllers}, HumanResources: {fields: {}as JobTitleHumanResourcesFieldControllers}, InformationTechnology: {fields: {}as JobTitleInformationTechnologyFieldControllers}, }; function switchVariant(variant: "Technician" | "SalesRepresentative" | "HumanResources" | "InformationTechnology"): void {currentVariant = variant; data = jobTitleGetDefaultForVariant(variant); errors = {}as JobTitleErrors; tainted = {}as JobTitleTainted;}function validate(): Exit<JobTitle, Array<{field: string; message: string}>>{return toExit(jobTitleDeserialize(data));}function reset(overrides?: Partial<JobTitle>): void {data = overrides ? overrides as typeof data : jobTitleGetDefaultForVariant(currentVariant); errors = {}as JobTitleErrors; tainted = {}as JobTitleTainted;}return {get currentVariant(){return currentVariant;}, get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, variants, switchVariant, validate, reset,};}/** Parses FormData for union type, determining variant from discriminant field */export function jobTitleFromFormData(formData: FormData): Exit<JobTitle, Array<{field: string; message: string}>>{const discriminant = formData.get("_value" )as "Technician" | "SalesRepresentative" | "HumanResources" | "InformationTechnology" | null; if(!discriminant){return toExit({success: false, errors: [{field: "_value" , message: "Missing discriminant field" }]});}const obj: Record<string, unknown>= {}; obj._value = discriminant; if(discriminant === "Technician" ){}else if(discriminant === "SalesRepresentative" ){}else if(discriminant === "HumanResources" ){}else if(discriminant === "InformationTechnology" ){}return toExit(jobTitleDeserialize(obj));}

export const JobTitle = {
  defaultValue: jobTitleDefaultValue,
  serialize: jobTitleSerialize,
  serializeWithContext: jobTitleSerializeWithContext,
  deserialize: jobTitleDeserialize,
  deserializeWithContext: jobTitleDeserializeWithContext,
  is: jobTitleIs,
  createForm: jobTitleCreateForm,
  fromFormData: jobTitleFromFormData
} as const;


export type ColorsConfig = Cardinal | Ordinal | Custom | /** @default */ Gradient;

export function colorsConfigDefaultValue(): ColorsConfig {return gradientDefaultValue();}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function colorsConfigSerialize(value: ColorsConfig): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(colorsConfigSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function colorsConfigSerializeWithContext(value: ColorsConfig, ctx: __mf_SerializeContext): unknown {if(typeof(value as any)?.serializeWithContext === "function" ){return(value as any).serializeWithContext(ctx);}return value;}

/** Deserializes input to this type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function colorsConfigDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: ColorsConfig } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = colorsConfigDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "ColorsConfig.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function colorsConfigDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): ColorsConfig | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref)as ColorsConfig | __mf_PendingRef;}if(typeof value!== "object" || value === null){throw new __mf_DeserializeError([{field: "_root" , message: "ColorsConfig.deserializeWithContext: expected an object" }]);}const __typeName = (value as any).__type; if(typeof __typeName!== "string" ){throw new __mf_DeserializeError([{field: "_root" , message: "ColorsConfig.deserializeWithContext: missing __type field for union dispatch" }]);}if(__typeName === "Cardinal" ){return cardinalDeserializeWithContext(value, ctx)as ColorsConfig;}if(__typeName === "Ordinal" ){return ordinalDeserializeWithContext(value, ctx)as ColorsConfig;}if(__typeName === "Custom" ){return customDeserializeWithContext(value, ctx)as ColorsConfig;}if(__typeName === "Gradient" ){return gradientDeserializeWithContext(value, ctx)as ColorsConfig;}throw new __mf_DeserializeError([{field: "_root" , message: "ColorsConfig.deserializeWithContext: unknown type \"" + __typeName + "\". Expected one of: Cardinal, Ordinal, Custom, Gradient" }]); }export function colorsConfigIs(value: unknown): value is ColorsConfig {if(typeof value!== "object" || value === null){return false;}const __typeName = (value as any).__type; return __typeName === "Cardinal" || __typeName === "Ordinal" || __typeName === "Custom" || __typeName === "Gradient" ; }

/** Per-variant error types */export type ColorsConfigCardinalErrors = {_errors: __gf_Option<Array<string>>; }; export type ColorsConfigOrdinalErrors = {_errors: __gf_Option<Array<string>>; }; export type ColorsConfigCustomErrors = {_errors: __gf_Option<Array<string>>; }; export type ColorsConfigGradientErrors = {_errors: __gf_Option<Array<string>>; }; /** Per-variant tainted types */export type ColorsConfigCardinalTainted = {}; export type ColorsConfigOrdinalTainted = {}; export type ColorsConfigCustomTainted = {}; export type ColorsConfigGradientTainted = {}; /** Union error type */export type ColorsConfigErrors = ({ _type: "Cardinal" } & ColorsConfigCardinalErrors) | ({ _type: "Ordinal" } & ColorsConfigOrdinalErrors) | ({ _type: "Custom" } & ColorsConfigCustomErrors) | ({ _type: "Gradient" } & ColorsConfigGradientErrors); /** Union tainted type */export type ColorsConfigTainted = ({ _type: "Cardinal" } & ColorsConfigCardinalTainted) | ({ _type: "Ordinal" } & ColorsConfigOrdinalTainted) | ({ _type: "Custom" } & ColorsConfigCustomTainted) | ({ _type: "Gradient" } & ColorsConfigGradientTainted); /** Per-variant field controller types */export interface ColorsConfigCardinalFieldControllers {}export interface ColorsConfigOrdinalFieldControllers {}export interface ColorsConfigCustomFieldControllers {}export interface ColorsConfigGradientFieldControllers {}/** Union Gigaform interface with variant switching */export interface ColorsConfigGigaform {readonly currentVariant: "Cardinal" | "Ordinal" | "Custom" | "Gradient"; readonly data: ColorsConfig; readonly errors: ColorsConfigErrors; readonly tainted: ColorsConfigTainted; readonly variants: ColorsConfigVariantFields; switchVariant(variant: "Cardinal" | "Ordinal" | "Custom" | "Gradient"): void; validate(): Exit<ColorsConfig, Array<{field: string; message: string}>>; reset(overrides?: Partial<ColorsConfig>): void;}/** Variant fields container */export interface ColorsConfigVariantFields {readonly Cardinal: {readonly fields: ColorsConfigCardinalFieldControllers}; readonly Ordinal: {readonly fields: ColorsConfigOrdinalFieldControllers}; readonly Custom: {readonly fields: ColorsConfigCustomFieldControllers}; readonly Gradient: {readonly fields: ColorsConfigGradientFieldControllers}; }/** Gets default value for a specific variant */function colorsConfigGetDefaultForVariant(variant: string): ColorsConfig {switch(variant){case "Cardinal" : return cardinalDefaultValue() as ColorsConfig; case "Ordinal" : return ordinalDefaultValue() as ColorsConfig; case "Custom" : return customDefaultValue() as ColorsConfig; case "Gradient" : return gradientDefaultValue() as ColorsConfig; default: return cardinalDefaultValue() as ColorsConfig;}}/** Creates a new discriminated union Gigaform with variant switching */export function colorsConfigCreateForm(initial?: ColorsConfig): ColorsConfigGigaform {const initialVariant: "Cardinal" | "Ordinal" | "Custom" | "Gradient" = "Cardinal"; let currentVariant = $state<"Cardinal" | "Ordinal" | "Custom" | "Gradient">(initialVariant); let data = $state<ColorsConfig>(initial?? colorsConfigGetDefaultForVariant(initialVariant)); let errors = $state<ColorsConfigErrors>({}as ColorsConfigErrors); let tainted = $state<ColorsConfigTainted>({}as ColorsConfigTainted); const variants: ColorsConfigVariantFields = {Cardinal: {fields: {}as ColorsConfigCardinalFieldControllers}, Ordinal: {fields: {}as ColorsConfigOrdinalFieldControllers}, Custom: {fields: {}as ColorsConfigCustomFieldControllers}, Gradient: {fields: {}as ColorsConfigGradientFieldControllers}, }; function switchVariant(variant: "Cardinal" | "Ordinal" | "Custom" | "Gradient"): void {currentVariant = variant; data = colorsConfigGetDefaultForVariant(variant); errors = {}as ColorsConfigErrors; tainted = {}as ColorsConfigTainted;}function validate(): Exit<ColorsConfig, Array<{field: string; message: string}>>{return toExit(colorsConfigDeserialize(data));}function reset(overrides?: Partial<ColorsConfig>): void {data = overrides ? overrides as typeof data : colorsConfigGetDefaultForVariant(currentVariant); errors = {}as ColorsConfigErrors; tainted = {}as ColorsConfigTainted;}return {get currentVariant(){return currentVariant;}, get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, variants, switchVariant, validate, reset,};}/** Parses FormData for union type, determining variant from discriminant field */export function colorsConfigFromFormData(formData: FormData): Exit<ColorsConfig, Array<{field: string; message: string}>>{const discriminant = formData.get("_type" )as "Cardinal" | "Ordinal" | "Custom" | "Gradient" | null; if(!discriminant){return toExit({success: false, errors: [{field: "_type" , message: "Missing discriminant field" }]});}const obj: Record<string, unknown>= {}; obj._type = discriminant; if(discriminant === "Cardinal" ){}else if(discriminant === "Ordinal" ){}else if(discriminant === "Custom" ){}else if(discriminant === "Gradient" ){}return toExit(colorsConfigDeserialize(obj));}

export const ColorsConfig = {
  defaultValue: colorsConfigDefaultValue,
  serialize: colorsConfigSerialize,
  serializeWithContext: colorsConfigSerializeWithContext,
  deserialize: colorsConfigDeserialize,
  deserializeWithContext: colorsConfigDeserializeWithContext,
  is: colorsConfigIs,
  createForm: colorsConfigCreateForm,
  fromFormData: colorsConfigFromFormData
} as const;


export type WeekOfMonth = /** @default */ 'First' | 'Second' | 'Third' | 'Fourth' | 'Last';

export function weekOfMonthDefaultValue(): WeekOfMonth {return 'First';}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function weekOfMonthSerialize(value: WeekOfMonth): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(weekOfMonthSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function weekOfMonthSerializeWithContext(value: WeekOfMonth, ctx: __mf_SerializeContext): unknown {if(typeof(value as any)?.serializeWithContext === "function" ){return(value as any).serializeWithContext(ctx);}return value;}

/** Deserializes input to this type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function weekOfMonthDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: WeekOfMonth } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = weekOfMonthDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "WeekOfMonth.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function weekOfMonthDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): WeekOfMonth | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref)as WeekOfMonth | __mf_PendingRef;}const allowedValues = ['First', 'Second', 'Third', 'Fourth', 'Last', ]as const; if(!allowedValues.includes(value)){throw new __mf_DeserializeError([{field: "_root" , message: "Invalid value for WeekOfMonth: expected one of " + allowedValues.map(v =>JSON.stringify(v)).join(", " )+ ", got " + JSON.stringify(value)}]);}return value as WeekOfMonth; }export function weekOfMonthIs(value: unknown): value is WeekOfMonth {const allowedValues = ['First', 'Second', 'Third', 'Fourth', 'Last', ]as const; return allowedValues.includes(value as any); }

/** Per-variant error types */export type WeekOfMonthFirstErrors = {_errors: __gf_Option<Array<string>>; }; export type WeekOfMonthSecondErrors = {_errors: __gf_Option<Array<string>>; }; export type WeekOfMonthThirdErrors = {_errors: __gf_Option<Array<string>>; }; export type WeekOfMonthFourthErrors = {_errors: __gf_Option<Array<string>>; }; export type WeekOfMonthLastErrors = {_errors: __gf_Option<Array<string>>; }; /** Per-variant tainted types */export type WeekOfMonthFirstTainted = {}; export type WeekOfMonthSecondTainted = {}; export type WeekOfMonthThirdTainted = {}; export type WeekOfMonthFourthTainted = {}; export type WeekOfMonthLastTainted = {}; /** Union error type */export type WeekOfMonthErrors = ({ _value: "First" } & WeekOfMonthFirstErrors) | ({ _value: "Second" } & WeekOfMonthSecondErrors) | ({ _value: "Third" } & WeekOfMonthThirdErrors) | ({ _value: "Fourth" } & WeekOfMonthFourthErrors) | ({ _value: "Last" } & WeekOfMonthLastErrors); /** Union tainted type */export type WeekOfMonthTainted = ({ _value: "First" } & WeekOfMonthFirstTainted) | ({ _value: "Second" } & WeekOfMonthSecondTainted) | ({ _value: "Third" } & WeekOfMonthThirdTainted) | ({ _value: "Fourth" } & WeekOfMonthFourthTainted) | ({ _value: "Last" } & WeekOfMonthLastTainted); /** Per-variant field controller types */export interface WeekOfMonthFirstFieldControllers {}export interface WeekOfMonthSecondFieldControllers {}export interface WeekOfMonthThirdFieldControllers {}export interface WeekOfMonthFourthFieldControllers {}export interface WeekOfMonthLastFieldControllers {}/** Union Gigaform interface with variant switching */export interface WeekOfMonthGigaform {readonly currentVariant: "First" | "Second" | "Third" | "Fourth" | "Last"; readonly data: WeekOfMonth; readonly errors: WeekOfMonthErrors; readonly tainted: WeekOfMonthTainted; readonly variants: WeekOfMonthVariantFields; switchVariant(variant: "First" | "Second" | "Third" | "Fourth" | "Last"): void; validate(): Exit<WeekOfMonth, Array<{field: string; message: string}>>; reset(overrides?: Partial<WeekOfMonth>): void;}/** Variant fields container */export interface WeekOfMonthVariantFields {readonly First: {readonly fields: WeekOfMonthFirstFieldControllers}; readonly Second: {readonly fields: WeekOfMonthSecondFieldControllers}; readonly Third: {readonly fields: WeekOfMonthThirdFieldControllers}; readonly Fourth: {readonly fields: WeekOfMonthFourthFieldControllers}; readonly Last: {readonly fields: WeekOfMonthLastFieldControllers}; }/** Gets default value for a specific variant */function weekOfMonthGetDefaultForVariant(variant: string): WeekOfMonth {switch(variant){case "First" : return "First" as WeekOfMonth; case "Second" : return "Second" as WeekOfMonth; case "Third" : return "Third" as WeekOfMonth; case "Fourth" : return "Fourth" as WeekOfMonth; case "Last" : return "Last" as WeekOfMonth; default: return "First" as WeekOfMonth;}}/** Creates a new discriminated union Gigaform with variant switching */export function weekOfMonthCreateForm(initial?: WeekOfMonth): WeekOfMonthGigaform {const initialVariant: "First" | "Second" | "Third" | "Fourth" | "Last" = (initial as "First" | "Second" | "Third" | "Fourth" | "Last") ?? "First"; let currentVariant = $state<"First" | "Second" | "Third" | "Fourth" | "Last">(initialVariant); let data = $state<WeekOfMonth>(initial?? weekOfMonthGetDefaultForVariant(initialVariant)); let errors = $state<WeekOfMonthErrors>({}as WeekOfMonthErrors); let tainted = $state<WeekOfMonthTainted>({}as WeekOfMonthTainted); const variants: WeekOfMonthVariantFields = {First: {fields: {}as WeekOfMonthFirstFieldControllers}, Second: {fields: {}as WeekOfMonthSecondFieldControllers}, Third: {fields: {}as WeekOfMonthThirdFieldControllers}, Fourth: {fields: {}as WeekOfMonthFourthFieldControllers}, Last: {fields: {}as WeekOfMonthLastFieldControllers}, }; function switchVariant(variant: "First" | "Second" | "Third" | "Fourth" | "Last"): void {currentVariant = variant; data = weekOfMonthGetDefaultForVariant(variant); errors = {}as WeekOfMonthErrors; tainted = {}as WeekOfMonthTainted;}function validate(): Exit<WeekOfMonth, Array<{field: string; message: string}>>{return toExit(weekOfMonthDeserialize(data));}function reset(overrides?: Partial<WeekOfMonth>): void {data = overrides ? overrides as typeof data : weekOfMonthGetDefaultForVariant(currentVariant); errors = {}as WeekOfMonthErrors; tainted = {}as WeekOfMonthTainted;}return {get currentVariant(){return currentVariant;}, get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, variants, switchVariant, validate, reset,};}/** Parses FormData for union type, determining variant from discriminant field */export function weekOfMonthFromFormData(formData: FormData): Exit<WeekOfMonth, Array<{field: string; message: string}>>{const discriminant = formData.get("_value" )as "First" | "Second" | "Third" | "Fourth" | "Last" | null; if(!discriminant){return toExit({success: false, errors: [{field: "_value" , message: "Missing discriminant field" }]});}const obj: Record<string, unknown>= {}; obj._value = discriminant; if(discriminant === "First" ){}else if(discriminant === "Second" ){}else if(discriminant === "Third" ){}else if(discriminant === "Fourth" ){}else if(discriminant === "Last" ){}return toExit(weekOfMonthDeserialize(obj));}

export const WeekOfMonth = {
  defaultValue: weekOfMonthDefaultValue,
  serialize: weekOfMonthSerialize,
  serializeWithContext: weekOfMonthSerializeWithContext,
  deserialize: weekOfMonthDeserialize,
  deserializeWithContext: weekOfMonthDeserializeWithContext,
  is: weekOfMonthIs,
  createForm: weekOfMonthCreateForm,
  fromFormData: weekOfMonthFromFormData
} as const;


export type ActivityType = /** @default */ Created | Edited | Sent | Viewed | Commented | Paid;

export function activityTypeDefaultValue(): ActivityType {return createdDefaultValue();}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function activityTypeSerialize(value: ActivityType): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(activityTypeSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function activityTypeSerializeWithContext(value: ActivityType, ctx: __mf_SerializeContext): unknown {if(typeof(value as any)?.serializeWithContext === "function" ){return(value as any).serializeWithContext(ctx);}return value;}

/** Deserializes input to this type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function activityTypeDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: ActivityType } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = activityTypeDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "ActivityType.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function activityTypeDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): ActivityType | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref)as ActivityType | __mf_PendingRef;}if(typeof value!== "object" || value === null){throw new __mf_DeserializeError([{field: "_root" , message: "ActivityType.deserializeWithContext: expected an object" }]);}const __typeName = (value as any).__type; if(typeof __typeName!== "string" ){throw new __mf_DeserializeError([{field: "_root" , message: "ActivityType.deserializeWithContext: missing __type field for union dispatch" }]);}if(__typeName === "Created" ){return createdDeserializeWithContext(value, ctx)as ActivityType;}if(__typeName === "Edited" ){return editedDeserializeWithContext(value, ctx)as ActivityType;}if(__typeName === "Sent" ){return sentDeserializeWithContext(value, ctx)as ActivityType;}if(__typeName === "Viewed" ){return viewedDeserializeWithContext(value, ctx)as ActivityType;}if(__typeName === "Commented" ){return commentedDeserializeWithContext(value, ctx)as ActivityType;}if(__typeName === "Paid" ){return paidDeserializeWithContext(value, ctx)as ActivityType;}throw new __mf_DeserializeError([{field: "_root" , message: "ActivityType.deserializeWithContext: unknown type \"" + __typeName + "\". Expected one of: Created, Edited, Sent, Viewed, Commented, Paid" }]); }export function activityTypeIs(value: unknown): value is ActivityType {if(typeof value!== "object" || value === null){return false;}const __typeName = (value as any).__type; return __typeName === "Created" || __typeName === "Edited" || __typeName === "Sent" || __typeName === "Viewed" || __typeName === "Commented" || __typeName === "Paid" ; }

/** Per-variant error types */export type ActivityTypeCreatedErrors = {_errors: __gf_Option<Array<string>>; }; export type ActivityTypeEditedErrors = {_errors: __gf_Option<Array<string>>; }; export type ActivityTypeSentErrors = {_errors: __gf_Option<Array<string>>; }; export type ActivityTypeViewedErrors = {_errors: __gf_Option<Array<string>>; }; export type ActivityTypeCommentedErrors = {_errors: __gf_Option<Array<string>>; }; export type ActivityTypePaidErrors = {_errors: __gf_Option<Array<string>>; }; /** Per-variant tainted types */export type ActivityTypeCreatedTainted = {}; export type ActivityTypeEditedTainted = {}; export type ActivityTypeSentTainted = {}; export type ActivityTypeViewedTainted = {}; export type ActivityTypeCommentedTainted = {}; export type ActivityTypePaidTainted = {}; /** Union error type */export type ActivityTypeErrors = ({ _type: "Created" } & ActivityTypeCreatedErrors) | ({ _type: "Edited" } & ActivityTypeEditedErrors) | ({ _type: "Sent" } & ActivityTypeSentErrors) | ({ _type: "Viewed" } & ActivityTypeViewedErrors) | ({ _type: "Commented" } & ActivityTypeCommentedErrors) | ({ _type: "Paid" } & ActivityTypePaidErrors); /** Union tainted type */export type ActivityTypeTainted = ({ _type: "Created" } & ActivityTypeCreatedTainted) | ({ _type: "Edited" } & ActivityTypeEditedTainted) | ({ _type: "Sent" } & ActivityTypeSentTainted) | ({ _type: "Viewed" } & ActivityTypeViewedTainted) | ({ _type: "Commented" } & ActivityTypeCommentedTainted) | ({ _type: "Paid" } & ActivityTypePaidTainted); /** Per-variant field controller types */export interface ActivityTypeCreatedFieldControllers {}export interface ActivityTypeEditedFieldControllers {}export interface ActivityTypeSentFieldControllers {}export interface ActivityTypeViewedFieldControllers {}export interface ActivityTypeCommentedFieldControllers {}export interface ActivityTypePaidFieldControllers {}/** Union Gigaform interface with variant switching */export interface ActivityTypeGigaform {readonly currentVariant: "Created" | "Edited" | "Sent" | "Viewed" | "Commented" | "Paid"; readonly data: ActivityType; readonly errors: ActivityTypeErrors; readonly tainted: ActivityTypeTainted; readonly variants: ActivityTypeVariantFields; switchVariant(variant: "Created" | "Edited" | "Sent" | "Viewed" | "Commented" | "Paid"): void; validate(): Exit<ActivityType, Array<{field: string; message: string}>>; reset(overrides?: Partial<ActivityType>): void;}/** Variant fields container */export interface ActivityTypeVariantFields {readonly Created: {readonly fields: ActivityTypeCreatedFieldControllers}; readonly Edited: {readonly fields: ActivityTypeEditedFieldControllers}; readonly Sent: {readonly fields: ActivityTypeSentFieldControllers}; readonly Viewed: {readonly fields: ActivityTypeViewedFieldControllers}; readonly Commented: {readonly fields: ActivityTypeCommentedFieldControllers}; readonly Paid: {readonly fields: ActivityTypePaidFieldControllers}; }/** Gets default value for a specific variant */function activityTypeGetDefaultForVariant(variant: string): ActivityType {switch(variant){case "Created" : return createdDefaultValue() as ActivityType; case "Edited" : return editedDefaultValue() as ActivityType; case "Sent" : return sentDefaultValue() as ActivityType; case "Viewed" : return viewedDefaultValue() as ActivityType; case "Commented" : return commentedDefaultValue() as ActivityType; case "Paid" : return paidDefaultValue() as ActivityType; default: return createdDefaultValue() as ActivityType;}}/** Creates a new discriminated union Gigaform with variant switching */export function activityTypeCreateForm(initial?: ActivityType): ActivityTypeGigaform {const initialVariant: "Created" | "Edited" | "Sent" | "Viewed" | "Commented" | "Paid" = "Created"; let currentVariant = $state<"Created" | "Edited" | "Sent" | "Viewed" | "Commented" | "Paid">(initialVariant); let data = $state<ActivityType>(initial?? activityTypeGetDefaultForVariant(initialVariant)); let errors = $state<ActivityTypeErrors>({}as ActivityTypeErrors); let tainted = $state<ActivityTypeTainted>({}as ActivityTypeTainted); const variants: ActivityTypeVariantFields = {Created: {fields: {}as ActivityTypeCreatedFieldControllers}, Edited: {fields: {}as ActivityTypeEditedFieldControllers}, Sent: {fields: {}as ActivityTypeSentFieldControllers}, Viewed: {fields: {}as ActivityTypeViewedFieldControllers}, Commented: {fields: {}as ActivityTypeCommentedFieldControllers}, Paid: {fields: {}as ActivityTypePaidFieldControllers}, }; function switchVariant(variant: "Created" | "Edited" | "Sent" | "Viewed" | "Commented" | "Paid"): void {currentVariant = variant; data = activityTypeGetDefaultForVariant(variant); errors = {}as ActivityTypeErrors; tainted = {}as ActivityTypeTainted;}function validate(): Exit<ActivityType, Array<{field: string; message: string}>>{return toExit(activityTypeDeserialize(data));}function reset(overrides?: Partial<ActivityType>): void {data = overrides ? overrides as typeof data : activityTypeGetDefaultForVariant(currentVariant); errors = {}as ActivityTypeErrors; tainted = {}as ActivityTypeTainted;}return {get currentVariant(){return currentVariant;}, get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, variants, switchVariant, validate, reset,};}/** Parses FormData for union type, determining variant from discriminant field */export function activityTypeFromFormData(formData: FormData): Exit<ActivityType, Array<{field: string; message: string}>>{const discriminant = formData.get("_type" )as "Created" | "Edited" | "Sent" | "Viewed" | "Commented" | "Paid" | null; if(!discriminant){return toExit({success: false, errors: [{field: "_type" , message: "Missing discriminant field" }]});}const obj: Record<string, unknown>= {}; obj._type = discriminant; if(discriminant === "Created" ){}else if(discriminant === "Edited" ){}else if(discriminant === "Sent" ){}else if(discriminant === "Viewed" ){}else if(discriminant === "Commented" ){}else if(discriminant === "Paid" ){}return toExit(activityTypeDeserialize(obj));}

export const ActivityType = {
  defaultValue: activityTypeDefaultValue,
  serialize: activityTypeSerialize,
  serializeWithContext: activityTypeSerializeWithContext,
  deserialize: activityTypeDeserialize,
  deserializeWithContext: activityTypeDeserializeWithContext,
  is: activityTypeIs,
  createForm: activityTypeCreateForm,
  fromFormData: activityTypeFromFormData
} as const;


export type RowHeight = 'ExtraSmall' | 'Small' | /** @default */ 'Medium' | 'Large';

export function rowHeightDefaultValue(): RowHeight {return 'Medium';}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function rowHeightSerialize(value: RowHeight): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(rowHeightSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function rowHeightSerializeWithContext(value: RowHeight, ctx: __mf_SerializeContext): unknown {if(typeof(value as any)?.serializeWithContext === "function" ){return(value as any).serializeWithContext(ctx);}return value;}

/** Deserializes input to this type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function rowHeightDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: RowHeight } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = rowHeightDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "RowHeight.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function rowHeightDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): RowHeight | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref)as RowHeight | __mf_PendingRef;}const allowedValues = ['ExtraSmall', 'Small', 'Medium', 'Large', ]as const; if(!allowedValues.includes(value)){throw new __mf_DeserializeError([{field: "_root" , message: "Invalid value for RowHeight: expected one of " + allowedValues.map(v =>JSON.stringify(v)).join(", " )+ ", got " + JSON.stringify(value)}]);}return value as RowHeight; }export function rowHeightIs(value: unknown): value is RowHeight {const allowedValues = ['ExtraSmall', 'Small', 'Medium', 'Large', ]as const; return allowedValues.includes(value as any); }

/** Per-variant error types */export type RowHeightExtraSmallErrors = {_errors: __gf_Option<Array<string>>; }; export type RowHeightSmallErrors = {_errors: __gf_Option<Array<string>>; }; export type RowHeightMediumErrors = {_errors: __gf_Option<Array<string>>; }; export type RowHeightLargeErrors = {_errors: __gf_Option<Array<string>>; }; /** Per-variant tainted types */export type RowHeightExtraSmallTainted = {}; export type RowHeightSmallTainted = {}; export type RowHeightMediumTainted = {}; export type RowHeightLargeTainted = {}; /** Union error type */export type RowHeightErrors = ({ _value: "ExtraSmall" } & RowHeightExtraSmallErrors) | ({ _value: "Small" } & RowHeightSmallErrors) | ({ _value: "Medium" } & RowHeightMediumErrors) | ({ _value: "Large" } & RowHeightLargeErrors); /** Union tainted type */export type RowHeightTainted = ({ _value: "ExtraSmall" } & RowHeightExtraSmallTainted) | ({ _value: "Small" } & RowHeightSmallTainted) | ({ _value: "Medium" } & RowHeightMediumTainted) | ({ _value: "Large" } & RowHeightLargeTainted); /** Per-variant field controller types */export interface RowHeightExtraSmallFieldControllers {}export interface RowHeightSmallFieldControllers {}export interface RowHeightMediumFieldControllers {}export interface RowHeightLargeFieldControllers {}/** Union Gigaform interface with variant switching */export interface RowHeightGigaform {readonly currentVariant: "ExtraSmall" | "Small" | "Medium" | "Large"; readonly data: RowHeight; readonly errors: RowHeightErrors; readonly tainted: RowHeightTainted; readonly variants: RowHeightVariantFields; switchVariant(variant: "ExtraSmall" | "Small" | "Medium" | "Large"): void; validate(): Exit<RowHeight, Array<{field: string; message: string}>>; reset(overrides?: Partial<RowHeight>): void;}/** Variant fields container */export interface RowHeightVariantFields {readonly ExtraSmall: {readonly fields: RowHeightExtraSmallFieldControllers}; readonly Small: {readonly fields: RowHeightSmallFieldControllers}; readonly Medium: {readonly fields: RowHeightMediumFieldControllers}; readonly Large: {readonly fields: RowHeightLargeFieldControllers}; }/** Gets default value for a specific variant */function rowHeightGetDefaultForVariant(variant: string): RowHeight {switch(variant){case "ExtraSmall" : return "ExtraSmall" as RowHeight; case "Small" : return "Small" as RowHeight; case "Medium" : return "Medium" as RowHeight; case "Large" : return "Large" as RowHeight; default: return "ExtraSmall" as RowHeight;}}/** Creates a new discriminated union Gigaform with variant switching */export function rowHeightCreateForm(initial?: RowHeight): RowHeightGigaform {const initialVariant: "ExtraSmall" | "Small" | "Medium" | "Large" = (initial as "ExtraSmall" | "Small" | "Medium" | "Large") ?? "ExtraSmall"; let currentVariant = $state<"ExtraSmall" | "Small" | "Medium" | "Large">(initialVariant); let data = $state<RowHeight>(initial?? rowHeightGetDefaultForVariant(initialVariant)); let errors = $state<RowHeightErrors>({}as RowHeightErrors); let tainted = $state<RowHeightTainted>({}as RowHeightTainted); const variants: RowHeightVariantFields = {ExtraSmall: {fields: {}as RowHeightExtraSmallFieldControllers}, Small: {fields: {}as RowHeightSmallFieldControllers}, Medium: {fields: {}as RowHeightMediumFieldControllers}, Large: {fields: {}as RowHeightLargeFieldControllers}, }; function switchVariant(variant: "ExtraSmall" | "Small" | "Medium" | "Large"): void {currentVariant = variant; data = rowHeightGetDefaultForVariant(variant); errors = {}as RowHeightErrors; tainted = {}as RowHeightTainted;}function validate(): Exit<RowHeight, Array<{field: string; message: string}>>{return toExit(rowHeightDeserialize(data));}function reset(overrides?: Partial<RowHeight>): void {data = overrides ? overrides as typeof data : rowHeightGetDefaultForVariant(currentVariant); errors = {}as RowHeightErrors; tainted = {}as RowHeightTainted;}return {get currentVariant(){return currentVariant;}, get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, variants, switchVariant, validate, reset,};}/** Parses FormData for union type, determining variant from discriminant field */export function rowHeightFromFormData(formData: FormData): Exit<RowHeight, Array<{field: string; message: string}>>{const discriminant = formData.get("_value" )as "ExtraSmall" | "Small" | "Medium" | "Large" | null; if(!discriminant){return toExit({success: false, errors: [{field: "_value" , message: "Missing discriminant field" }]});}const obj: Record<string, unknown>= {}; obj._value = discriminant; if(discriminant === "ExtraSmall" ){}else if(discriminant === "Small" ){}else if(discriminant === "Medium" ){}else if(discriminant === "Large" ){}return toExit(rowHeightDeserialize(obj));}

export const RowHeight = {
  defaultValue: rowHeightDefaultValue,
  serialize: rowHeightSerialize,
  serializeWithContext: rowHeightSerializeWithContext,
  deserialize: rowHeightDeserialize,
  deserializeWithContext: rowHeightDeserializeWithContext,
  is: rowHeightIs,
  createForm: rowHeightCreateForm,
  fromFormData: rowHeightFromFormData
} as const;


export type OrderStage = /** @default */ 'Estimate' | 'Active' | 'Invoice';

export function orderStageDefaultValue(): OrderStage {return 'Estimate';}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function orderStageSerialize(value: OrderStage): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(orderStageSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function orderStageSerializeWithContext(value: OrderStage, ctx: __mf_SerializeContext): unknown {if(typeof(value as any)?.serializeWithContext === "function" ){return(value as any).serializeWithContext(ctx);}return value;}

/** Deserializes input to this type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function orderStageDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: OrderStage } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = orderStageDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "OrderStage.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function orderStageDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): OrderStage | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref)as OrderStage | __mf_PendingRef;}const allowedValues = ['Estimate', 'Active', 'Invoice', ]as const; if(!allowedValues.includes(value)){throw new __mf_DeserializeError([{field: "_root" , message: "Invalid value for OrderStage: expected one of " + allowedValues.map(v =>JSON.stringify(v)).join(", " )+ ", got " + JSON.stringify(value)}]);}return value as OrderStage; }export function orderStageIs(value: unknown): value is OrderStage {const allowedValues = ['Estimate', 'Active', 'Invoice', ]as const; return allowedValues.includes(value as any); }

/** Per-variant error types */export type OrderStageEstimateErrors = {_errors: __gf_Option<Array<string>>; }; export type OrderStageActiveErrors = {_errors: __gf_Option<Array<string>>; }; export type OrderStageInvoiceErrors = {_errors: __gf_Option<Array<string>>; }; /** Per-variant tainted types */export type OrderStageEstimateTainted = {}; export type OrderStageActiveTainted = {}; export type OrderStageInvoiceTainted = {}; /** Union error type */export type OrderStageErrors = ({ _value: "Estimate" } & OrderStageEstimateErrors) | ({ _value: "Active" } & OrderStageActiveErrors) | ({ _value: "Invoice" } & OrderStageInvoiceErrors); /** Union tainted type */export type OrderStageTainted = ({ _value: "Estimate" } & OrderStageEstimateTainted) | ({ _value: "Active" } & OrderStageActiveTainted) | ({ _value: "Invoice" } & OrderStageInvoiceTainted); /** Per-variant field controller types */export interface OrderStageEstimateFieldControllers {}export interface OrderStageActiveFieldControllers {}export interface OrderStageInvoiceFieldControllers {}/** Union Gigaform interface with variant switching */export interface OrderStageGigaform {readonly currentVariant: "Estimate" | "Active" | "Invoice"; readonly data: OrderStage; readonly errors: OrderStageErrors; readonly tainted: OrderStageTainted; readonly variants: OrderStageVariantFields; switchVariant(variant: "Estimate" | "Active" | "Invoice"): void; validate(): Exit<OrderStage, Array<{field: string; message: string}>>; reset(overrides?: Partial<OrderStage>): void;}/** Variant fields container */export interface OrderStageVariantFields {readonly Estimate: {readonly fields: OrderStageEstimateFieldControllers}; readonly Active: {readonly fields: OrderStageActiveFieldControllers}; readonly Invoice: {readonly fields: OrderStageInvoiceFieldControllers}; }/** Gets default value for a specific variant */function orderStageGetDefaultForVariant(variant: string): OrderStage {switch(variant){case "Estimate" : return "Estimate" as OrderStage; case "Active" : return "Active" as OrderStage; case "Invoice" : return "Invoice" as OrderStage; default: return "Estimate" as OrderStage;}}/** Creates a new discriminated union Gigaform with variant switching */export function orderStageCreateForm(initial?: OrderStage): OrderStageGigaform {const initialVariant: "Estimate" | "Active" | "Invoice" = (initial as "Estimate" | "Active" | "Invoice") ?? "Estimate"; let currentVariant = $state<"Estimate" | "Active" | "Invoice">(initialVariant); let data = $state<OrderStage>(initial?? orderStageGetDefaultForVariant(initialVariant)); let errors = $state<OrderStageErrors>({}as OrderStageErrors); let tainted = $state<OrderStageTainted>({}as OrderStageTainted); const variants: OrderStageVariantFields = {Estimate: {fields: {}as OrderStageEstimateFieldControllers}, Active: {fields: {}as OrderStageActiveFieldControllers}, Invoice: {fields: {}as OrderStageInvoiceFieldControllers}, }; function switchVariant(variant: "Estimate" | "Active" | "Invoice"): void {currentVariant = variant; data = orderStageGetDefaultForVariant(variant); errors = {}as OrderStageErrors; tainted = {}as OrderStageTainted;}function validate(): Exit<OrderStage, Array<{field: string; message: string}>>{return toExit(orderStageDeserialize(data));}function reset(overrides?: Partial<OrderStage>): void {data = overrides ? overrides as typeof data : orderStageGetDefaultForVariant(currentVariant); errors = {}as OrderStageErrors; tainted = {}as OrderStageTainted;}return {get currentVariant(){return currentVariant;}, get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, variants, switchVariant, validate, reset,};}/** Parses FormData for union type, determining variant from discriminant field */export function orderStageFromFormData(formData: FormData): Exit<OrderStage, Array<{field: string; message: string}>>{const discriminant = formData.get("_value" )as "Estimate" | "Active" | "Invoice" | null; if(!discriminant){return toExit({success: false, errors: [{field: "_value" , message: "Missing discriminant field" }]});}const obj: Record<string, unknown>= {}; obj._value = discriminant; if(discriminant === "Estimate" ){}else if(discriminant === "Active" ){}else if(discriminant === "Invoice" ){}return toExit(orderStageDeserialize(obj));}

export const OrderStage = {
  defaultValue: orderStageDefaultValue,
  serialize: orderStageSerialize,
  serializeWithContext: orderStageSerializeWithContext,
  deserialize: orderStageDeserialize,
  deserializeWithContext: orderStageDeserializeWithContext,
  is: orderStageIs,
  createForm: orderStageCreateForm,
  fromFormData: orderStageFromFormData
} as const;


export type Table =
    | /** @default */ 'Account'
    | 'Did'
    | 'Appointment'
    | 'Lead'
    | 'TaxRate'
    | 'Site'
    | 'Employee'
    | 'Route'
    | 'Company'
    | 'Product'
    | 'Service'
    | 'User'
    | 'Order'
    | 'Payment'
    | 'Package'
    | 'Promotion'
    | 'Represents'
    | 'Ordered';

export function tableDefaultValue(): Table {return 'Account';}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function tableSerialize(value: Table): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(tableSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function tableSerializeWithContext(value: Table, ctx: __mf_SerializeContext): unknown {if(typeof(value as any)?.serializeWithContext === "function" ){return(value as any).serializeWithContext(ctx);}return value;}

/** Deserializes input to this type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function tableDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: Table } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = tableDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Table.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function tableDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Table | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref)as Table | __mf_PendingRef;}const allowedValues = ['Account', 'Did', 'Appointment', 'Lead', 'TaxRate', 'Site', 'Employee', 'Route', 'Company', 'Product', 'Service', 'User', 'Order', 'Payment', 'Package', 'Promotion', 'Represents', 'Ordered', ]as const; if(!allowedValues.includes(value)){throw new __mf_DeserializeError([{field: "_root" , message: "Invalid value for Table: expected one of " + allowedValues.map(v =>JSON.stringify(v)).join(", " )+ ", got " + JSON.stringify(value)}]);}return value as Table; }export function tableIs(value: unknown): value is Table {const allowedValues = ['Account', 'Did', 'Appointment', 'Lead', 'TaxRate', 'Site', 'Employee', 'Route', 'Company', 'Product', 'Service', 'User', 'Order', 'Payment', 'Package', 'Promotion', 'Represents', 'Ordered', ]as const; return allowedValues.includes(value as any); }

/** Per-variant error types */export type TableAccountErrors = {_errors: __gf_Option<Array<string>>; }; export type TableDidErrors = {_errors: __gf_Option<Array<string>>; }; export type TableAppointmentErrors = {_errors: __gf_Option<Array<string>>; }; export type TableLeadErrors = {_errors: __gf_Option<Array<string>>; }; export type TableTaxRateErrors = {_errors: __gf_Option<Array<string>>; }; export type TableSiteErrors = {_errors: __gf_Option<Array<string>>; }; export type TableEmployeeErrors = {_errors: __gf_Option<Array<string>>; }; export type TableRouteErrors = {_errors: __gf_Option<Array<string>>; }; export type TableCompanyErrors = {_errors: __gf_Option<Array<string>>; }; export type TableProductErrors = {_errors: __gf_Option<Array<string>>; }; export type TableServiceErrors = {_errors: __gf_Option<Array<string>>; }; export type TableUserErrors = {_errors: __gf_Option<Array<string>>; }; export type TableOrderErrors = {_errors: __gf_Option<Array<string>>; }; export type TablePaymentErrors = {_errors: __gf_Option<Array<string>>; }; export type TablePackageErrors = {_errors: __gf_Option<Array<string>>; }; export type TablePromotionErrors = {_errors: __gf_Option<Array<string>>; }; export type TableRepresentsErrors = {_errors: __gf_Option<Array<string>>; }; export type TableOrderedErrors = {_errors: __gf_Option<Array<string>>; }; /** Per-variant tainted types */export type TableAccountTainted = {}; export type TableDidTainted = {}; export type TableAppointmentTainted = {}; export type TableLeadTainted = {}; export type TableTaxRateTainted = {}; export type TableSiteTainted = {}; export type TableEmployeeTainted = {}; export type TableRouteTainted = {}; export type TableCompanyTainted = {}; export type TableProductTainted = {}; export type TableServiceTainted = {}; export type TableUserTainted = {}; export type TableOrderTainted = {}; export type TablePaymentTainted = {}; export type TablePackageTainted = {}; export type TablePromotionTainted = {}; export type TableRepresentsTainted = {}; export type TableOrderedTainted = {}; /** Union error type */export type TableErrors = ({ _value: "Account" } & TableAccountErrors) | ({ _value: "Did" } & TableDidErrors) | ({ _value: "Appointment" } & TableAppointmentErrors) | ({ _value: "Lead" } & TableLeadErrors) | ({ _value: "TaxRate" } & TableTaxRateErrors) | ({ _value: "Site" } & TableSiteErrors) | ({ _value: "Employee" } & TableEmployeeErrors) | ({ _value: "Route" } & TableRouteErrors) | ({ _value: "Company" } & TableCompanyErrors) | ({ _value: "Product" } & TableProductErrors) | ({ _value: "Service" } & TableServiceErrors) | ({ _value: "User" } & TableUserErrors) | ({ _value: "Order" } & TableOrderErrors) | ({ _value: "Payment" } & TablePaymentErrors) | ({ _value: "Package" } & TablePackageErrors) | ({ _value: "Promotion" } & TablePromotionErrors) | ({ _value: "Represents" } & TableRepresentsErrors) | ({ _value: "Ordered" } & TableOrderedErrors); /** Union tainted type */export type TableTainted = ({ _value: "Account" } & TableAccountTainted) | ({ _value: "Did" } & TableDidTainted) | ({ _value: "Appointment" } & TableAppointmentTainted) | ({ _value: "Lead" } & TableLeadTainted) | ({ _value: "TaxRate" } & TableTaxRateTainted) | ({ _value: "Site" } & TableSiteTainted) | ({ _value: "Employee" } & TableEmployeeTainted) | ({ _value: "Route" } & TableRouteTainted) | ({ _value: "Company" } & TableCompanyTainted) | ({ _value: "Product" } & TableProductTainted) | ({ _value: "Service" } & TableServiceTainted) | ({ _value: "User" } & TableUserTainted) | ({ _value: "Order" } & TableOrderTainted) | ({ _value: "Payment" } & TablePaymentTainted) | ({ _value: "Package" } & TablePackageTainted) | ({ _value: "Promotion" } & TablePromotionTainted) | ({ _value: "Represents" } & TableRepresentsTainted) | ({ _value: "Ordered" } & TableOrderedTainted); /** Per-variant field controller types */export interface TableAccountFieldControllers {}export interface TableDidFieldControllers {}export interface TableAppointmentFieldControllers {}export interface TableLeadFieldControllers {}export interface TableTaxRateFieldControllers {}export interface TableSiteFieldControllers {}export interface TableEmployeeFieldControllers {}export interface TableRouteFieldControllers {}export interface TableCompanyFieldControllers {}export interface TableProductFieldControllers {}export interface TableServiceFieldControllers {}export interface TableUserFieldControllers {}export interface TableOrderFieldControllers {}export interface TablePaymentFieldControllers {}export interface TablePackageFieldControllers {}export interface TablePromotionFieldControllers {}export interface TableRepresentsFieldControllers {}export interface TableOrderedFieldControllers {}/** Union Gigaform interface with variant switching */export interface TableGigaform {readonly currentVariant: "Account" | "Did" | "Appointment" | "Lead" | "TaxRate" | "Site" | "Employee" | "Route" | "Company" | "Product" | "Service" | "User" | "Order" | "Payment" | "Package" | "Promotion" | "Represents" | "Ordered"; readonly data: Table; readonly errors: TableErrors; readonly tainted: TableTainted; readonly variants: TableVariantFields; switchVariant(variant: "Account" | "Did" | "Appointment" | "Lead" | "TaxRate" | "Site" | "Employee" | "Route" | "Company" | "Product" | "Service" | "User" | "Order" | "Payment" | "Package" | "Promotion" | "Represents" | "Ordered"): void; validate(): Exit<Table, Array<{field: string; message: string}>>; reset(overrides?: Partial<Table>): void;}/** Variant fields container */export interface TableVariantFields {readonly Account: {readonly fields: TableAccountFieldControllers}; readonly Did: {readonly fields: TableDidFieldControllers}; readonly Appointment: {readonly fields: TableAppointmentFieldControllers}; readonly Lead: {readonly fields: TableLeadFieldControllers}; readonly TaxRate: {readonly fields: TableTaxRateFieldControllers}; readonly Site: {readonly fields: TableSiteFieldControllers}; readonly Employee: {readonly fields: TableEmployeeFieldControllers}; readonly Route: {readonly fields: TableRouteFieldControllers}; readonly Company: {readonly fields: TableCompanyFieldControllers}; readonly Product: {readonly fields: TableProductFieldControllers}; readonly Service: {readonly fields: TableServiceFieldControllers}; readonly User: {readonly fields: TableUserFieldControllers}; readonly Order: {readonly fields: TableOrderFieldControllers}; readonly Payment: {readonly fields: TablePaymentFieldControllers}; readonly Package: {readonly fields: TablePackageFieldControllers}; readonly Promotion: {readonly fields: TablePromotionFieldControllers}; readonly Represents: {readonly fields: TableRepresentsFieldControllers}; readonly Ordered: {readonly fields: TableOrderedFieldControllers}; }/** Gets default value for a specific variant */function tableGetDefaultForVariant(variant: string): Table {switch(variant){case "Account" : return "Account" as Table; case "Did" : return "Did" as Table; case "Appointment" : return "Appointment" as Table; case "Lead" : return "Lead" as Table; case "TaxRate" : return "TaxRate" as Table; case "Site" : return "Site" as Table; case "Employee" : return "Employee" as Table; case "Route" : return "Route" as Table; case "Company" : return "Company" as Table; case "Product" : return "Product" as Table; case "Service" : return "Service" as Table; case "User" : return "User" as Table; case "Order" : return "Order" as Table; case "Payment" : return "Payment" as Table; case "Package" : return "Package" as Table; case "Promotion" : return "Promotion" as Table; case "Represents" : return "Represents" as Table; case "Ordered" : return "Ordered" as Table; default: return "Account" as Table;}}/** Creates a new discriminated union Gigaform with variant switching */export function tableCreateForm(initial?: Table): TableGigaform {const initialVariant: "Account" | "Did" | "Appointment" | "Lead" | "TaxRate" | "Site" | "Employee" | "Route" | "Company" | "Product" | "Service" | "User" | "Order" | "Payment" | "Package" | "Promotion" | "Represents" | "Ordered" = (initial as "Account" | "Did" | "Appointment" | "Lead" | "TaxRate" | "Site" | "Employee" | "Route" | "Company" | "Product" | "Service" | "User" | "Order" | "Payment" | "Package" | "Promotion" | "Represents" | "Ordered") ?? "Account"; let currentVariant = $state<"Account" | "Did" | "Appointment" | "Lead" | "TaxRate" | "Site" | "Employee" | "Route" | "Company" | "Product" | "Service" | "User" | "Order" | "Payment" | "Package" | "Promotion" | "Represents" | "Ordered">(initialVariant); let data = $state<Table>(initial?? tableGetDefaultForVariant(initialVariant)); let errors = $state<TableErrors>({}as TableErrors); let tainted = $state<TableTainted>({}as TableTainted); const variants: TableVariantFields = {Account: {fields: {}as TableAccountFieldControllers}, Did: {fields: {}as TableDidFieldControllers}, Appointment: {fields: {}as TableAppointmentFieldControllers}, Lead: {fields: {}as TableLeadFieldControllers}, TaxRate: {fields: {}as TableTaxRateFieldControllers}, Site: {fields: {}as TableSiteFieldControllers}, Employee: {fields: {}as TableEmployeeFieldControllers}, Route: {fields: {}as TableRouteFieldControllers}, Company: {fields: {}as TableCompanyFieldControllers}, Product: {fields: {}as TableProductFieldControllers}, Service: {fields: {}as TableServiceFieldControllers}, User: {fields: {}as TableUserFieldControllers}, Order: {fields: {}as TableOrderFieldControllers}, Payment: {fields: {}as TablePaymentFieldControllers}, Package: {fields: {}as TablePackageFieldControllers}, Promotion: {fields: {}as TablePromotionFieldControllers}, Represents: {fields: {}as TableRepresentsFieldControllers}, Ordered: {fields: {}as TableOrderedFieldControllers}, }; function switchVariant(variant: "Account" | "Did" | "Appointment" | "Lead" | "TaxRate" | "Site" | "Employee" | "Route" | "Company" | "Product" | "Service" | "User" | "Order" | "Payment" | "Package" | "Promotion" | "Represents" | "Ordered"): void {currentVariant = variant; data = tableGetDefaultForVariant(variant); errors = {}as TableErrors; tainted = {}as TableTainted;}function validate(): Exit<Table, Array<{field: string; message: string}>>{return toExit(tableDeserialize(data));}function reset(overrides?: Partial<Table>): void {data = overrides ? overrides as typeof data : tableGetDefaultForVariant(currentVariant); errors = {}as TableErrors; tainted = {}as TableTainted;}return {get currentVariant(){return currentVariant;}, get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, variants, switchVariant, validate, reset,};}/** Parses FormData for union type, determining variant from discriminant field */export function tableFromFormData(formData: FormData): Exit<Table, Array<{field: string; message: string}>>{const discriminant = formData.get("_value" )as "Account" | "Did" | "Appointment" | "Lead" | "TaxRate" | "Site" | "Employee" | "Route" | "Company" | "Product" | "Service" | "User" | "Order" | "Payment" | "Package" | "Promotion" | "Represents" | "Ordered" | null; if(!discriminant){return toExit({success: false, errors: [{field: "_value" , message: "Missing discriminant field" }]});}const obj: Record<string, unknown>= {}; obj._value = discriminant; if(discriminant === "Account" ){}else if(discriminant === "Did" ){}else if(discriminant === "Appointment" ){}else if(discriminant === "Lead" ){}else if(discriminant === "TaxRate" ){}else if(discriminant === "Site" ){}else if(discriminant === "Employee" ){}else if(discriminant === "Route" ){}else if(discriminant === "Company" ){}else if(discriminant === "Product" ){}else if(discriminant === "Service" ){}else if(discriminant === "User" ){}else if(discriminant === "Order" ){}else if(discriminant === "Payment" ){}else if(discriminant === "Package" ){}else if(discriminant === "Promotion" ){}else if(discriminant === "Represents" ){}else if(discriminant === "Ordered" ){}return toExit(tableDeserialize(obj));}

export const Table = {
  defaultValue: tableDefaultValue,
  serialize: tableSerialize,
  serializeWithContext: tableSerializeWithContext,
  deserialize: tableDeserialize,
  deserializeWithContext: tableDeserializeWithContext,
  is: tableIs,
  createForm: tableCreateForm,
  fromFormData: tableFromFormData
} as const;


export type Item = RecordLink<Product> | /** @default */ RecordLink<Service>;

export function itemDefaultValue(): Item {return recordLinkDefaultValue<Service>();}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function itemSerialize(value: Item): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(itemSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function itemSerializeWithContext(value: Item, ctx: __mf_SerializeContext): unknown {if(typeof(value as any)?.serializeWithContext === "function" ){return(value as any).serializeWithContext(ctx);}return value;}

/** Deserializes input to this type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function itemDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: Item } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = itemDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Item.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function itemDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Item | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref)as Item | __mf_PendingRef;}if(typeof value!== "object" || value === null){throw new __mf_DeserializeError([{field: "_root" , message: "Item.deserializeWithContext: expected an object" }]);}const __typeName = (value as any).__type; if(typeof __typeName!== "string" ){throw new __mf_DeserializeError([{field: "_root" , message: "Item.deserializeWithContext: missing __type field for union dispatch" }]);}if(__typeName === "RecordLink<Product>" ){return recordLinkDeserializeWithContext(value, ctx)as Item;}if(__typeName === "RecordLink<Service>" ){return recordLinkDeserializeWithContext(value, ctx)as Item;}throw new __mf_DeserializeError([{field: "_root" , message: "Item.deserializeWithContext: unknown type \"" + __typeName + "\". Expected one of: RecordLink<Product>, RecordLink<Service>" }]); }export function itemIs(value: unknown): value is Item {if(typeof value!== "object" || value === null){return false;}const __typeName = (value as any).__type; return __typeName === "RecordLink<Product>" || __typeName === "RecordLink<Service>" ; }

/** Per-variant error types */export type ItemRecordLinkProductErrors = {_errors: __gf_Option<Array<string>>; }; export type ItemRecordLinkServiceErrors = {_errors: __gf_Option<Array<string>>; }; /** Per-variant tainted types */export type ItemRecordLinkProductTainted = {}; export type ItemRecordLinkServiceTainted = {}; /** Union error type */export type ItemErrors = ({ _type: "RecordLink<Product>" } & ItemRecordLinkProductErrors) | ({ _type: "RecordLink<Service>" } & ItemRecordLinkServiceErrors); /** Union tainted type */export type ItemTainted = ({ _type: "RecordLink<Product>" } & ItemRecordLinkProductTainted) | ({ _type: "RecordLink<Service>" } & ItemRecordLinkServiceTainted); /** Per-variant field controller types */export interface ItemRecordLinkProductFieldControllers {}export interface ItemRecordLinkServiceFieldControllers {}/** Union Gigaform interface with variant switching */export interface ItemGigaform {readonly currentVariant: "RecordLink<Product>" | "RecordLink<Service>"; readonly data: Item; readonly errors: ItemErrors; readonly tainted: ItemTainted; readonly variants: ItemVariantFields; switchVariant(variant: "RecordLink<Product>" | "RecordLink<Service>"): void; validate(): Exit<Item, Array<{field: string; message: string}>>; reset(overrides?: Partial<Item>): void;}/** Variant fields container */export interface ItemVariantFields {readonly "RecordLink<Product>": {readonly fields: ItemRecordLinkProductFieldControllers}; readonly "RecordLink<Service>": {readonly fields: ItemRecordLinkServiceFieldControllers}; }/** Gets default value for a specific variant */function itemGetDefaultForVariant(variant: string): Item {switch(variant){case "RecordLink<Product>" : return recordLinkDefaultValue<Product>() as Item; case "RecordLink<Service>" : return recordLinkDefaultValue<Service>() as Item; default: return recordLinkDefaultValue<Product>() as Item;}}/** Creates a new discriminated union Gigaform with variant switching */export function itemCreateForm(initial?: Item): ItemGigaform {const initialVariant: "RecordLink<Product>" | "RecordLink<Service>" = "RecordLink<Product>"; let currentVariant = $state<"RecordLink<Product>" | "RecordLink<Service>">(initialVariant); let data = $state<Item>(initial?? itemGetDefaultForVariant(initialVariant)); let errors = $state<ItemErrors>({}as ItemErrors); let tainted = $state<ItemTainted>({}as ItemTainted); const variants: ItemVariantFields = {"RecordLink<Product>": {fields: {}as ItemRecordLinkProductFieldControllers}, "RecordLink<Service>": {fields: {}as ItemRecordLinkServiceFieldControllers}, }; function switchVariant(variant: "RecordLink<Product>" | "RecordLink<Service>"): void {currentVariant = variant; data = itemGetDefaultForVariant(variant); errors = {}as ItemErrors; tainted = {}as ItemTainted;}function validate(): Exit<Item, Array<{field: string; message: string}>>{return toExit(itemDeserialize(data));}function reset(overrides?: Partial<Item>): void {data = overrides ? overrides as typeof data : itemGetDefaultForVariant(currentVariant); errors = {}as ItemErrors; tainted = {}as ItemTainted;}return {get currentVariant(){return currentVariant;}, get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, variants, switchVariant, validate, reset,};}/** Parses FormData for union type, determining variant from discriminant field */export function itemFromFormData(formData: FormData): Exit<Item, Array<{field: string; message: string}>>{const discriminant = formData.get("_type" )as "RecordLink<Product>" | "RecordLink<Service>" | null; if(!discriminant){return toExit({success: false, errors: [{field: "_type" , message: "Missing discriminant field" }]});}const obj: Record<string, unknown>= {}; obj._type = discriminant; if(discriminant === "RecordLink<Product>" ){}else if(discriminant === "RecordLink<Service>" ){}return toExit(itemDeserialize(obj));}

export const Item = {
  defaultValue: itemDefaultValue,
  serialize: itemSerialize,
  serializeWithContext: itemSerializeWithContext,
  deserialize: itemDeserialize,
  deserializeWithContext: itemDeserializeWithContext,
  is: itemIs,
  createForm: itemCreateForm,
  fromFormData: itemFromFormData
} as const;


export type RecordLink<T> = /** @default */ string | T;

export function recordLinkDefaultValue<T>(): RecordLink<T> {return "";}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function recordLinkSerialize<T>(value: RecordLink<T>): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(recordLinkSerializeWithContext<T>(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function recordLinkSerializeWithContext<T>(value: RecordLink<T>, ctx: __mf_SerializeContext): unknown {if(typeof(value as any)?.serializeWithContext === "function" ){return(value as any).serializeWithContext(ctx);}return value;}

/** Deserializes input to this type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function recordLinkDeserialize<T>(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: RecordLink<T> } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = recordLinkDeserializeWithContext<T>(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "RecordLink.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function recordLinkDeserializeWithContext<T>(value: any, ctx: __mf_DeserializeContext): RecordLink<T> | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref)as RecordLink<T> | __mf_PendingRef;}if(typeof value === "string" ){return value as RecordLink<T>;}return value as RecordLink<T>; throw new __mf_DeserializeError([{field: "_root" , message: "RecordLink.deserializeWithContext: value does not match any union member" }]); }export function recordLinkIs<T>(value: unknown): value is RecordLink<T> {if(typeof value === "string" )return true; return true; }


export type Actor = /** @default */ User | Employee | Account;

export function actorDefaultValue(): Actor {return userDefaultValue();}

/** Serializes a value to a JSON string.
@param value - The value to serialize
@returns JSON string representation with cycle detection metadata */export function actorSerialize(value: Actor): string {const ctx = __mf_SerializeContext.create(); return JSON.stringify(actorSerializeWithContext(value, ctx));}/** Serializes with an existing context for nested/cyclic object graphs.
@param value - The value to serialize
@param ctx - The serialization context */export function actorSerializeWithContext(value: Actor, ctx: __mf_SerializeContext): unknown {if(typeof(value as any)?.serializeWithContext === "function" ){return(value as any).serializeWithContext(ctx);}return value;}

/** Deserializes input to this type.
Automatically detects whether input is a JSON string or object.
@param input - JSON string or object to deserialize
@param opts - Optional deserialization options
@returns Result containing the deserialized value or validation errors */export function actorDeserialize(input: unknown, opts?: __mf_DeserializeOptions): { success: true; value: Actor } | { success: false; errors: Array<{ field: string; message: string }> } {try {const data = typeof input === "string" ? JSON.parse(input): input; const ctx = __mf_DeserializeContext.create(); const resultOrRef = actorDeserializeWithContext(data, ctx); if(__mf_PendingRef.is(resultOrRef)){return { success: false, errors: [{ field: "_root", message: "Actor.deserialize: root cannot be a forward reference" }] };}ctx.applyPatches(); if(opts?.freeze){ctx.freezeAll();}return { success: true, value: resultOrRef };}catch(e){if(e instanceof __mf_DeserializeError){return { success: false, errors: e.errors };}const message = e instanceof Error? e.message: String(e); return { success: false, errors: [{ field: "_root", message }] };}}/** Deserializes with an existing context for nested/cyclic object graphs.
@param value - The raw value to deserialize
@param ctx - The deserialization context */export function actorDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Actor | __mf_PendingRef {if(value?.__ref!== undefined){return ctx.getOrDefer(value.__ref)as Actor | __mf_PendingRef;}if(typeof value!== "object" || value === null){throw new __mf_DeserializeError([{field: "_root" , message: "Actor.deserializeWithContext: expected an object" }]);}const __typeName = (value as any).__type; if(typeof __typeName!== "string" ){throw new __mf_DeserializeError([{field: "_root" , message: "Actor.deserializeWithContext: missing __type field for union dispatch" }]);}if(__typeName === "User" ){return userDeserializeWithContext(value, ctx)as Actor;}if(__typeName === "Employee" ){return employeeDeserializeWithContext(value, ctx)as Actor;}if(__typeName === "Account" ){return accountDeserializeWithContext(value, ctx)as Actor;}throw new __mf_DeserializeError([{field: "_root" , message: "Actor.deserializeWithContext: unknown type \"" + __typeName + "\". Expected one of: User, Employee, Account" }]); }export function actorIs(value: unknown): value is Actor {if(typeof value!== "object" || value === null){return false;}const __typeName = (value as any).__type; return __typeName === "User" || __typeName === "Employee" || __typeName === "Account" ; }

/** Per-variant error types */export type ActorUserErrors = {_errors: __gf_Option<Array<string>>; }; export type ActorEmployeeErrors = {_errors: __gf_Option<Array<string>>; }; export type ActorAccountErrors = {_errors: __gf_Option<Array<string>>; }; /** Per-variant tainted types */export type ActorUserTainted = {}; export type ActorEmployeeTainted = {}; export type ActorAccountTainted = {}; /** Union error type */export type ActorErrors = ({ _type: "User" } & ActorUserErrors) | ({ _type: "Employee" } & ActorEmployeeErrors) | ({ _type: "Account" } & ActorAccountErrors); /** Union tainted type */export type ActorTainted = ({ _type: "User" } & ActorUserTainted) | ({ _type: "Employee" } & ActorEmployeeTainted) | ({ _type: "Account" } & ActorAccountTainted); /** Per-variant field controller types */export interface ActorUserFieldControllers {}export interface ActorEmployeeFieldControllers {}export interface ActorAccountFieldControllers {}/** Union Gigaform interface with variant switching */export interface ActorGigaform {readonly currentVariant: "User" | "Employee" | "Account"; readonly data: Actor; readonly errors: ActorErrors; readonly tainted: ActorTainted; readonly variants: ActorVariantFields; switchVariant(variant: "User" | "Employee" | "Account"): void; validate(): Exit<Actor, Array<{field: string; message: string}>>; reset(overrides?: Partial<Actor>): void;}/** Variant fields container */export interface ActorVariantFields {readonly User: {readonly fields: ActorUserFieldControllers}; readonly Employee: {readonly fields: ActorEmployeeFieldControllers}; readonly Account: {readonly fields: ActorAccountFieldControllers}; }/** Gets default value for a specific variant */function actorGetDefaultForVariant(variant: string): Actor {switch(variant){case "User" : return userDefaultValue() as Actor; case "Employee" : return employeeDefaultValue() as Actor; case "Account" : return accountDefaultValue() as Actor; default: return userDefaultValue() as Actor;}}/** Creates a new discriminated union Gigaform with variant switching */export function actorCreateForm(initial?: Actor): ActorGigaform {const initialVariant: "User" | "Employee" | "Account" = "User"; let currentVariant = $state<"User" | "Employee" | "Account">(initialVariant); let data = $state<Actor>(initial?? actorGetDefaultForVariant(initialVariant)); let errors = $state<ActorErrors>({}as ActorErrors); let tainted = $state<ActorTainted>({}as ActorTainted); const variants: ActorVariantFields = {User: {fields: {}as ActorUserFieldControllers}, Employee: {fields: {}as ActorEmployeeFieldControllers}, Account: {fields: {}as ActorAccountFieldControllers}, }; function switchVariant(variant: "User" | "Employee" | "Account"): void {currentVariant = variant; data = actorGetDefaultForVariant(variant); errors = {}as ActorErrors; tainted = {}as ActorTainted;}function validate(): Exit<Actor, Array<{field: string; message: string}>>{return toExit(actorDeserialize(data));}function reset(overrides?: Partial<Actor>): void {data = overrides ? overrides as typeof data : actorGetDefaultForVariant(currentVariant); errors = {}as ActorErrors; tainted = {}as ActorTainted;}return {get currentVariant(){return currentVariant;}, get data(){return data;}, set data(v){data = v;}, get errors(){return errors;}, set errors(v){errors = v;}, get tainted(){return tainted;}, set tainted(v){tainted = v;}, variants, switchVariant, validate, reset,};}/** Parses FormData for union type, determining variant from discriminant field */export function actorFromFormData(formData: FormData): Exit<Actor, Array<{field: string; message: string}>>{const discriminant = formData.get("_type" )as "User" | "Employee" | "Account" | null; if(!discriminant){return toExit({success: false, errors: [{field: "_type" , message: "Missing discriminant field" }]});}const obj: Record<string, unknown>= {}; obj._type = discriminant; if(discriminant === "User" ){}else if(discriminant === "Employee" ){}else if(discriminant === "Account" ){}return toExit(actorDeserialize(obj));}

export const Actor = {
  defaultValue: actorDefaultValue,
  serialize: actorSerialize,
  serializeWithContext: actorSerializeWithContext,
  deserialize: actorDeserialize,
  deserializeWithContext: actorDeserializeWithContext,
  is: actorIs,
  createForm: actorCreateForm,
  fromFormData: actorFromFormData
} as const;