import { SerializeContext as __mf_SerializeContext } from "macroforge/serde";
import { DeserializeContext as __mf_DeserializeContext } from "macroforge/serde";
import { DeserializeError as __mf_DeserializeError } from "macroforge/serde";
import type { DeserializeOptions as __mf_DeserializeOptions } from "macroforge/serde";
import { PendingRef as __mf_PendingRef } from "macroforge/serde";
import type { Exit } from "@playground/macro/gigaform";
import { toExit } from "@playground/macro/gigaform";
import type { Option as __gf_Option } from "@playground/macro/gigaform";
import { optionNone } from "@playground/macro/gigaform";
import type { FieldController } from "@playground/macro/gigaform";
import type { ArrayFieldController } from "@playground/macro/gigaform";
/** import macro {Gigaform} from "@playground/macro"; */


export interface User {
    id: string;
    email: string | null;
    
    firstName: string;
    
    lastName: string;
    password: string | null;
    metadata: Metadata | null;
    settings: Settings;
    
    role: UserRole;
    emailVerified: boolean;
    verificationToken: string | null;
    verificationExpires: string | null;
    passwordResetToken: string | null;
    passwordResetExpires: string | null;
    permissions: AppPermissions;
}

export function userDefaultValue(): User {
    return {
        id: "",
        email: null,
        firstName: "",
        lastName: "",
        password: null,
        metadata: null,
        settings: settingsDefaultValue(),
        role: "Administrator",
        emailVerified: false,
        verificationToken: null,
        verificationExpires: null,
        passwordResetToken: null,
        passwordResetExpires: null,
        permissions: appPermissionsDefaultValue()
    } as User;
}

export function userSerialize(value: User): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(userSerializeWithContext(value, ctx));
}
export function userSerializeWithContext(value: User, ctx: __mf_SerializeContext): Record<string, unknown> {
    const existingId = ctx.getId(value);
    if (existingId !== undefined) {
        return {
            __ref: existingId
        };
    }
    const __id = ctx.register(value);
    const result: Record<string, unknown> = {
        __type: "User",
        __id
    };
    result.id = value.id;
    result.email = value.email;
    result.firstName = value.firstName;
    result.lastName = value.lastName;
    result.password = value.password;
    if (value.metadata !== null) {
        result.metadata = metadataSerializeWithContext(value.metadata, ctx);
    }
    result.settings = settingsSerializeWithContext(value.settings, ctx);
    result.role = userRoleSerializeWithContext(value.role, ctx);
    result.emailVerified = value.emailVerified;
    result.verificationToken = value.verificationToken;
    result.verificationExpires = value.verificationExpires;
    result.passwordResetToken = value.passwordResetToken;
    result.passwordResetExpires = value.passwordResetExpires;
    result.permissions = appPermissionsSerializeWithContext(value.permissions, ctx);
    return result;
}

export function userDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: User } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = userDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "User.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function userDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): User | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
        throw new __mf_DeserializeError([
            {
                field: "_root",
                message: `${"User"}.deserializeWithContext: expected an object`
            }
        ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (!("id" in obj)) {
        errors.push({
            field: "id",
            message: "missing required field"
        });
    }
    if (!("email" in obj)) {
        errors.push({
            field: "email",
            message: "missing required field"
        });
    }
    if (!("firstName" in obj)) {
        errors.push({
            field: "firstName",
            message: "missing required field"
        });
    }
    if (!("lastName" in obj)) {
        errors.push({
            field: "lastName",
            message: "missing required field"
        });
    }
    if (!("password" in obj)) {
        errors.push({
            field: "password",
            message: "missing required field"
        });
    }
    if (!("metadata" in obj)) {
        errors.push({
            field: "metadata",
            message: "missing required field"
        });
    }
    if (!("settings" in obj)) {
        errors.push({
            field: "settings",
            message: "missing required field"
        });
    }
    if (!("role" in obj)) {
        errors.push({
            field: "role",
            message: "missing required field"
        });
    }
    if (!("emailVerified" in obj)) {
        errors.push({
            field: "emailVerified",
            message: "missing required field"
        });
    }
    if (!("verificationToken" in obj)) {
        errors.push({
            field: "verificationToken",
            message: "missing required field"
        });
    }
    if (!("verificationExpires" in obj)) {
        errors.push({
            field: "verificationExpires",
            message: "missing required field"
        });
    }
    if (!("passwordResetToken" in obj)) {
        errors.push({
            field: "passwordResetToken",
            message: "missing required field"
        });
    }
    if (!("passwordResetExpires" in obj)) {
        errors.push({
            field: "passwordResetExpires",
            message: "missing required field"
        });
    }
    if (!("permissions" in obj)) {
        errors.push({
            field: "permissions",
            message: "missing required field"
        });
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
        ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
        const __raw_id = obj["id"] as string;
        instance.id = __raw_id;
    }
    {
        const __raw_email = obj["email"] as string | null;
        instance.email = __raw_email;
    }
    {
        const __raw_firstName = obj["firstName"] as string;
        if (__raw_firstName.trim().length === 0) {
            errors.push({
                field: "firstName",
                message: "User.firstName must not be empty"
            });
        }
        instance.firstName = __raw_firstName;
    }
    {
        const __raw_lastName = obj["lastName"] as string;
        if (__raw_lastName.trim().length === 0) {
            errors.push({
                field: "lastName",
                message: "User.lastName must not be empty"
            });
        }
        instance.lastName = __raw_lastName;
    }
    {
        const __raw_password = obj["password"] as string | null;
        instance.password = __raw_password;
    }
    {
        const __raw_metadata = obj["metadata"] as Metadata | null;
        if (__raw_metadata === null) {
            instance.metadata = null;
        } else {
            const __result = metadataDeserializeWithContext(__raw_metadata, ctx);
            ctx.assignOrDefer(instance, "metadata", __result);
        }
    }
    {
        const __raw_settings = obj["settings"] as Settings;
        {
            const __result = settingsDeserializeWithContext(__raw_settings, ctx);
            ctx.assignOrDefer(instance, "settings", __result);
        }
    }
    {
        const __raw_role = obj["role"] as UserRole;
        {
            const __result = userRoleDeserializeWithContext(__raw_role, ctx);
            ctx.assignOrDefer(instance, "role", __result);
        }
    }
    {
        const __raw_emailVerified = obj["emailVerified"] as boolean;
        instance.emailVerified = __raw_emailVerified;
    }
    {
        const __raw_verificationToken = obj["verificationToken"] as string | null;
        instance.verificationToken = __raw_verificationToken;
    }
    {
        const __raw_verificationExpires = obj["verificationExpires"] as string | null;
        instance.verificationExpires = __raw_verificationExpires;
    }
    {
        const __raw_passwordResetToken = obj["passwordResetToken"] as string | null;
        instance.passwordResetToken = __raw_passwordResetToken;
    }
    {
        const __raw_passwordResetExpires = obj["passwordResetExpires"] as string | null;
        instance.passwordResetExpires = __raw_passwordResetExpires;
    }
    {
        const __raw_permissions = obj["permissions"] as AppPermissions;
        {
            const __result = appPermissionsDeserializeWithContext(__raw_permissions, ctx);
            ctx.assignOrDefer(instance, "permissions", __result);
        }
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    return instance as User;
}
export function userValidateField<K extends keyof User>(_field: K, _value: User[K]): Array<{
    field: string;
    message: string;
}> {
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (_field === "firstName") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "firstName",
                message: "User.firstName must not be empty"
            });
        }
    }
    if (_field === "lastName") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "lastName",
                message: "User.lastName must not be empty"
            });
        }
    }
    return errors;
}
export function userValidateFields(_partial: Partial<User>): Array<{
    field: string;
    message: string;
}> {
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if ("firstName" in _partial && _partial.firstName !== undefined) {
        const __val = _partial.firstName as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "firstName",
                message: "User.firstName must not be empty"
            });
        }
    }
    if ("lastName" in _partial && _partial.lastName !== undefined) {
        const __val = _partial.lastName as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "lastName",
                message: "User.lastName must not be empty"
            });
        }
    }
    return errors;
}
export function userHasShape(obj: unknown): boolean {
    if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
        return false;
    }
    const o = obj as Record<string, unknown>;
    return '"id" in o && "email" in o && "firstName" in o && "lastName" in o && "password" in o && "metadata" in o && "settings" in o && "role" in o && "emailVerified" in o && "verificationToken" in o && "verificationExpires" in o && "passwordResetToken" in o && "passwordResetExpires" in o && "permissions" in o';
}
export function userIs(obj: unknown): obj is User {
    if (!userHasShape(obj)) {
        return false;
    }
    const result = userDeserialize(obj);
    return result.success;
}

export type UserErrors = {
    _errors: __gf_Option<Array<string>>;
    id: __gf_Option<Array<string>>;
    email: __gf_Option<Array<string>>;
    firstName: __gf_Option<Array<string>>;
    lastName: __gf_Option<Array<string>>;
    password: __gf_Option<Array<string>>;
    metadata: __gf_Option<Array<string>>;
    settings: __gf_Option<Array<string>>;
    role: __gf_Option<Array<string>>;
    emailVerified: __gf_Option<Array<string>>;
    verificationToken: __gf_Option<Array<string>>;
    verificationExpires: __gf_Option<Array<string>>;
    passwordResetToken: __gf_Option<Array<string>>;
    passwordResetExpires: __gf_Option<Array<string>>;
    permissions: __gf_Option<Array<string>>;
};
export type UserTainted = {
    id: __gf_Option<boolean>;
    email: __gf_Option<boolean>;
    firstName: __gf_Option<boolean>;
    lastName: __gf_Option<boolean>;
    password: __gf_Option<boolean>;
    metadata: __gf_Option<boolean>;
    settings: __gf_Option<boolean>;
    role: __gf_Option<boolean>;
    emailVerified: __gf_Option<boolean>;
    verificationToken: __gf_Option<boolean>;
    verificationExpires: __gf_Option<boolean>;
    passwordResetToken: __gf_Option<boolean>;
    passwordResetExpires: __gf_Option<boolean>;
    permissions: __gf_Option<boolean>;
};
export interface UserFieldControllers {
    readonly id: FieldController<string>;
    readonly email: FieldController<string | null>;
    readonly firstName: FieldController<string>;
    readonly lastName: FieldController<string>;
    readonly password: FieldController<string | null>;
    readonly metadata: FieldController<Metadata | null>;
    readonly settings: FieldController<Settings>;
    readonly role: FieldController<UserRole>;
    readonly emailVerified: FieldController<boolean>;
    readonly verificationToken: FieldController<string | null>;
    readonly verificationExpires: FieldController<string | null>;
    readonly passwordResetToken: FieldController<string | null>;
    readonly passwordResetExpires: FieldController<string | null>;
    readonly permissions: FieldController<AppPermissions>;
}
export interface UserGigaform {
    readonly data: User;
    readonly errors: UserErrors;
    readonly tainted: UserTainted;
    readonly fields: UserFieldControllers;
    validate(): Exit<User, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<User>): void;
}
export function userCreateForm(overrides?: Partial<User>): UserGigaform {
    let data = $state({
        ...userDefaultValue(),
        ...overrides
    });
    let errors = $state<UserErrors>({
        _errors: optionNone(),
        id: optionNone(),
        email: optionNone(),
        firstName: optionNone(),
        lastName: optionNone(),
        password: optionNone(),
        metadata: optionNone(),
        settings: optionNone(),
        role: optionNone(),
        emailVerified: optionNone(),
        verificationToken: optionNone(),
        verificationExpires: optionNone(),
        passwordResetToken: optionNone(),
        passwordResetExpires: optionNone(),
        permissions: optionNone()
    } as UserErrors);
    let tainted = $state<UserTainted>({
        id: optionNone(),
        email: optionNone(),
        firstName: optionNone(),
        lastName: optionNone(),
        password: optionNone(),
        metadata: optionNone(),
        settings: optionNone(),
        role: optionNone(),
        emailVerified: optionNone(),
        verificationToken: optionNone(),
        verificationExpires: optionNone(),
        passwordResetToken: optionNone(),
        passwordResetExpires: optionNone(),
        permissions: optionNone()
    } as UserTainted);
    const fields = {
        id: {
            path: [
                "id"
            ] as const,
            name: "id",
            constraints: {
                required: true
            },
            get: ()=>data.id,
            set: (value: string)=>{
                data.id = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.id,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.id = value;
            },
            getTainted: ()=>tainted.id,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.id = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = userValidateField("id", data.id);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        email: {
            path: [
                "email"
            ] as const,
            name: "email",
            constraints: {
                required: true
            },
            get: ()=>data.email,
            set: (value: string | null)=>{
                data.email = value;
            },
            transform: (value: string | null): string | null =>value,
            getError: ()=>errors.email,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.email = value;
            },
            getTainted: ()=>tainted.email,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.email = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = userValidateField("email", data.email);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        firstName: {
            path: [
                "firstName"
            ] as const,
            name: "firstName",
            constraints: {
                required: true
            },
            get: ()=>data.firstName,
            set: (value: string)=>{
                data.firstName = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.firstName,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.firstName = value;
            },
            getTainted: ()=>tainted.firstName,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.firstName = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = userValidateField("firstName", data.firstName);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        lastName: {
            path: [
                "lastName"
            ] as const,
            name: "lastName",
            constraints: {
                required: true
            },
            get: ()=>data.lastName,
            set: (value: string)=>{
                data.lastName = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.lastName,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.lastName = value;
            },
            getTainted: ()=>tainted.lastName,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.lastName = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = userValidateField("lastName", data.lastName);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        password: {
            path: [
                "password"
            ] as const,
            name: "password",
            constraints: {
                required: true
            },
            get: ()=>data.password,
            set: (value: string | null)=>{
                data.password = value;
            },
            transform: (value: string | null): string | null =>value,
            getError: ()=>errors.password,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.password = value;
            },
            getTainted: ()=>tainted.password,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.password = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = userValidateField("password", data.password);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        metadata: {
            path: [
                "metadata"
            ] as const,
            name: "metadata",
            constraints: {
                required: true
            },
            get: ()=>data.metadata,
            set: (value: Metadata | null)=>{
                data.metadata = value;
            },
            transform: (value: Metadata | null): Metadata | null =>value,
            getError: ()=>errors.metadata,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.metadata = value;
            },
            getTainted: ()=>tainted.metadata,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.metadata = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = userValidateField("metadata", data.metadata);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        settings: {
            path: [
                "settings"
            ] as const,
            name: "settings",
            constraints: {
                required: true
            },
            get: ()=>data.settings,
            set: (value: Settings)=>{
                data.settings = value;
            },
            transform: (value: Settings): Settings =>value,
            getError: ()=>errors.settings,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.settings = value;
            },
            getTainted: ()=>tainted.settings,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.settings = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = userValidateField("settings", data.settings);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        role: {
            path: [
                "role"
            ] as const,
            name: "role",
            constraints: {
                required: true
            },
            get: ()=>data.role,
            set: (value: UserRole)=>{
                data.role = value;
            },
            transform: (value: UserRole): UserRole =>value,
            getError: ()=>errors.role,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.role = value;
            },
            getTainted: ()=>tainted.role,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.role = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = userValidateField("role", data.role);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        emailVerified: {
            path: [
                "emailVerified"
            ] as const,
            name: "emailVerified",
            constraints: {
                required: true
            },
            get: ()=>data.emailVerified,
            set: (value: boolean)=>{
                data.emailVerified = value;
            },
            transform: (value: boolean): boolean =>value,
            getError: ()=>errors.emailVerified,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.emailVerified = value;
            },
            getTainted: ()=>tainted.emailVerified,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.emailVerified = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = userValidateField("emailVerified", data.emailVerified);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        verificationToken: {
            path: [
                "verificationToken"
            ] as const,
            name: "verificationToken",
            constraints: {
                required: true
            },
            get: ()=>data.verificationToken,
            set: (value: string | null)=>{
                data.verificationToken = value;
            },
            transform: (value: string | null): string | null =>value,
            getError: ()=>errors.verificationToken,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.verificationToken = value;
            },
            getTainted: ()=>tainted.verificationToken,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.verificationToken = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = userValidateField("verificationToken", data.verificationToken);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        verificationExpires: {
            path: [
                "verificationExpires"
            ] as const,
            name: "verificationExpires",
            constraints: {
                required: true
            },
            get: ()=>data.verificationExpires,
            set: (value: string | null)=>{
                data.verificationExpires = value;
            },
            transform: (value: string | null): string | null =>value,
            getError: ()=>errors.verificationExpires,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.verificationExpires = value;
            },
            getTainted: ()=>tainted.verificationExpires,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.verificationExpires = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = userValidateField("verificationExpires", data.verificationExpires);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        passwordResetToken: {
            path: [
                "passwordResetToken"
            ] as const,
            name: "passwordResetToken",
            constraints: {
                required: true
            },
            get: ()=>data.passwordResetToken,
            set: (value: string | null)=>{
                data.passwordResetToken = value;
            },
            transform: (value: string | null): string | null =>value,
            getError: ()=>errors.passwordResetToken,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.passwordResetToken = value;
            },
            getTainted: ()=>tainted.passwordResetToken,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.passwordResetToken = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = userValidateField("passwordResetToken", data.passwordResetToken);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        passwordResetExpires: {
            path: [
                "passwordResetExpires"
            ] as const,
            name: "passwordResetExpires",
            constraints: {
                required: true
            },
            get: ()=>data.passwordResetExpires,
            set: (value: string | null)=>{
                data.passwordResetExpires = value;
            },
            transform: (value: string | null): string | null =>value,
            getError: ()=>errors.passwordResetExpires,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.passwordResetExpires = value;
            },
            getTainted: ()=>tainted.passwordResetExpires,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.passwordResetExpires = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = userValidateField("passwordResetExpires", data.passwordResetExpires);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        permissions: {
            path: [
                "permissions"
            ] as const,
            name: "permissions",
            constraints: {
                required: true
            },
            get: ()=>data.permissions,
            set: (value: AppPermissions)=>{
                data.permissions = value;
            },
            transform: (value: AppPermissions): AppPermissions =>value,
            getError: ()=>errors.permissions,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.permissions = value;
            },
            getTainted: ()=>tainted.permissions,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.permissions = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = userValidateField("permissions", data.permissions);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        }
    } as UserFieldControllers;
    const __gf_getter_hint = "get data() set data(v) get errors() set errors(v) get tainted() set tainted(v)";
    const __gf_validate_hint = ".map((e: { field: string; message: string }) => e.message)";
    function validate(): Exit<User, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(userDeserialize(data));
    }
    function reset(newOverrides?: Partial<User>): void {
        data = {
            ...userDefaultValue(),
            ...newOverrides
        };
        errors = {
            _errors: optionNone(),
            id: optionNone(),
            email: optionNone(),
            firstName: optionNone(),
            lastName: optionNone(),
            password: optionNone(),
            metadata: optionNone(),
            settings: optionNone(),
            role: optionNone(),
            emailVerified: optionNone(),
            verificationToken: optionNone(),
            verificationExpires: optionNone(),
            passwordResetToken: optionNone(),
            passwordResetExpires: optionNone(),
            permissions: optionNone()
        };
        tainted = {
            id: optionNone(),
            email: optionNone(),
            firstName: optionNone(),
            lastName: optionNone(),
            password: optionNone(),
            metadata: optionNone(),
            settings: optionNone(),
            role: optionNone(),
            emailVerified: optionNone(),
            verificationToken: optionNone(),
            verificationExpires: optionNone(),
            passwordResetToken: optionNone(),
            passwordResetExpires: optionNone(),
            permissions: optionNone()
        };
    }
    return {
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        fields,
        validate,
        reset
    };
}
export function userFromFormData(formData: FormData): Exit<User, Array<{
    field: string;
    message: string;
}>> {
    const obj: Record<string, unknown> = {};
    const __gf_exit_hint = "Exit<User, Array<{ field: string; message: string }>>";
    obj.id = formData.get(`${"id"}`) ?? "";
    obj.email = formData.get(`${"email"}`) ?? "";
    obj.firstName = formData.get(`${"firstName"}`) ?? "";
    obj.lastName = formData.get(`${"lastName"}`) ?? "";
    obj.password = formData.get(`${"password"}`) ?? "";
    obj.metadata = formData.get(`${"metadata"}`) ?? "";
    {
        const settingsObj: Record<string, unknown> = {};
        for (const [key, value] of Array.from(formData.entries())){
            if (key.startsWith(`${"settings"}.`)) {
                const fieldName = key.slice(`${"settings"}.`.length);
                const parts = fieldName.split(".");
                let current = settingsObj;
                for(let i = 0; i < parts.length - 1; i++){
                    const part = parts[i]!;
                    if (!(part in current)) {
                        current[part] = {};
                    }
                    current = current[part] as Record<string, unknown>;
                }
                current[parts[parts.length - 1]!] = value;
            }
        }
        obj.settings = settingsObj;
    }
    {
        const roleObj: Record<string, unknown> = {};
        for (const [key, value] of Array.from(formData.entries())){
            if (key.startsWith(`${"role"}.`)) {
                const fieldName = key.slice(`${"role"}.`.length);
                const parts = fieldName.split(".");
                let current = roleObj;
                for(let i = 0; i < parts.length - 1; i++){
                    const part = parts[i]!;
                    if (!(part in current)) {
                        current[part] = {};
                    }
                    current = current[part] as Record<string, unknown>;
                }
                current[parts[parts.length - 1]!] = value;
            }
        }
        obj.role = roleObj;
    }
    {
        const emailVerifiedVal = formData.get(`${"emailVerified"}`);
        obj.emailVerified = emailVerifiedVal === "true" || emailVerifiedVal === "on" || emailVerifiedVal === "1";
    }
    obj.verificationToken = formData.get(`${"verificationToken"}`) ?? "";
    obj.verificationExpires = formData.get(`${"verificationExpires"}`) ?? "";
    obj.passwordResetToken = formData.get(`${"passwordResetToken"}`) ?? "";
    obj.passwordResetExpires = formData.get(`${"passwordResetExpires"}`) ?? "";
    {
        const permissionsObj: Record<string, unknown> = {};
        for (const [key, value] of Array.from(formData.entries())){
            if (key.startsWith(`${"permissions"}.`)) {
                const fieldName = key.slice(`${"permissions"}.`.length);
                const parts = fieldName.split(".");
                let current = permissionsObj;
                for(let i = 0; i < parts.length - 1; i++){
                    const part = parts[i]!;
                    if (!(part in current)) {
                        current[part] = {};
                    }
                    current = current[part] as Record<string, unknown>;
                }
                current[parts[parts.length - 1]!] = value;
            }
        }
        obj.permissions = permissionsObj;
    }
    return toExit(userDeserialize(obj));
}

export const User = {
  defaultValue: userDefaultValue,
  serialize: userSerialize,
  serializeWithContext: userSerializeWithContext,
  deserialize: userDeserialize,
  deserializeWithContext: userDeserializeWithContext,
  validateFields: userValidateFields,
  hasShape: userHasShape,
  is: userIs,
  createForm: userCreateForm,
  fromFormData: userFromFormData
} as const;


export interface Service {
    
    id: string;
    
    
    name: string;
    
    
    quickCode: string;
    
    group: string | null;
    
    subgroup: string | null;
    
    unit: string | null;
    
    active: boolean;
    
    commission: boolean;
    
    favorite: boolean;
    
    averageTime: string | null;
    defaults: ServiceDefaults;
}

export function serviceDefaultValue(): Service {
    return {
        id: "",
        name: "",
        quickCode: "",
        group: null,
        subgroup: null,
        unit: null,
        active: false,
        commission: false,
        favorite: false,
        averageTime: null,
        defaults: serviceDefaultsDefaultValue()
    } as Service;
}

export function serviceSerialize(value: Service): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(serviceSerializeWithContext(value, ctx));
}
export function serviceSerializeWithContext(value: Service, ctx: __mf_SerializeContext): Record<string, unknown> {
    const existingId = ctx.getId(value);
    if (existingId !== undefined) {
        return {
            __ref: existingId
        };
    }
    const __id = ctx.register(value);
    const result: Record<string, unknown> = {
        __type: "Service",
        __id
    };
    result.id = value.id;
    result.name = value.name;
    result.quickCode = value.quickCode;
    result.group = value.group;
    result.subgroup = value.subgroup;
    result.unit = value.unit;
    result.active = value.active;
    result.commission = value.commission;
    result.favorite = value.favorite;
    result.averageTime = value.averageTime;
    result.defaults = serviceDefaultsSerializeWithContext(value.defaults, ctx);
    return result;
}

export function serviceDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: Service } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = serviceDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "Service.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function serviceDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Service | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
        throw new __mf_DeserializeError([
            {
                field: "_root",
                message: `${"Service"}.deserializeWithContext: expected an object`
            }
        ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (!("id" in obj)) {
        errors.push({
            field: "id",
            message: "missing required field"
        });
    }
    if (!("name" in obj)) {
        errors.push({
            field: "name",
            message: "missing required field"
        });
    }
    if (!("quickCode" in obj)) {
        errors.push({
            field: "quickCode",
            message: "missing required field"
        });
    }
    if (!("group" in obj)) {
        errors.push({
            field: "group",
            message: "missing required field"
        });
    }
    if (!("subgroup" in obj)) {
        errors.push({
            field: "subgroup",
            message: "missing required field"
        });
    }
    if (!("unit" in obj)) {
        errors.push({
            field: "unit",
            message: "missing required field"
        });
    }
    if (!("active" in obj)) {
        errors.push({
            field: "active",
            message: "missing required field"
        });
    }
    if (!("commission" in obj)) {
        errors.push({
            field: "commission",
            message: "missing required field"
        });
    }
    if (!("favorite" in obj)) {
        errors.push({
            field: "favorite",
            message: "missing required field"
        });
    }
    if (!("averageTime" in obj)) {
        errors.push({
            field: "averageTime",
            message: "missing required field"
        });
    }
    if (!("defaults" in obj)) {
        errors.push({
            field: "defaults",
            message: "missing required field"
        });
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
        ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
        const __raw_id = obj["id"] as string;
        instance.id = __raw_id;
    }
    {
        const __raw_name = obj["name"] as string;
        if (__raw_name.trim().length === 0) {
            errors.push({
                field: "name",
                message: "Service.name must not be empty"
            });
        }
        instance.name = __raw_name;
    }
    {
        const __raw_quickCode = obj["quickCode"] as string;
        if (__raw_quickCode.trim().length === 0) {
            errors.push({
                field: "quickCode",
                message: "Service.quickCode must not be empty"
            });
        }
        instance.quickCode = __raw_quickCode;
    }
    {
        const __raw_group = obj["group"] as string | null;
        instance.group = __raw_group;
    }
    {
        const __raw_subgroup = obj["subgroup"] as string | null;
        instance.subgroup = __raw_subgroup;
    }
    {
        const __raw_unit = obj["unit"] as string | null;
        instance.unit = __raw_unit;
    }
    {
        const __raw_active = obj["active"] as boolean;
        instance.active = __raw_active;
    }
    {
        const __raw_commission = obj["commission"] as boolean;
        instance.commission = __raw_commission;
    }
    {
        const __raw_favorite = obj["favorite"] as boolean;
        instance.favorite = __raw_favorite;
    }
    {
        const __raw_averageTime = obj["averageTime"] as string | null;
        instance.averageTime = __raw_averageTime;
    }
    {
        const __raw_defaults = obj["defaults"] as ServiceDefaults;
        {
            const __result = serviceDefaultsDeserializeWithContext(__raw_defaults, ctx);
            ctx.assignOrDefer(instance, "defaults", __result);
        }
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    return instance as Service;
}
export function serviceValidateField<K extends keyof Service>(_field: K, _value: Service[K]): Array<{
    field: string;
    message: string;
}> {
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (_field === "name") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "name",
                message: "Service.name must not be empty"
            });
        }
    }
    if (_field === "quickCode") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "quickCode",
                message: "Service.quickCode must not be empty"
            });
        }
    }
    return errors;
}
export function serviceValidateFields(_partial: Partial<Service>): Array<{
    field: string;
    message: string;
}> {
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if ("name" in _partial && _partial.name !== undefined) {
        const __val = _partial.name as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "name",
                message: "Service.name must not be empty"
            });
        }
    }
    if ("quickCode" in _partial && _partial.quickCode !== undefined) {
        const __val = _partial.quickCode as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "quickCode",
                message: "Service.quickCode must not be empty"
            });
        }
    }
    return errors;
}
export function serviceHasShape(obj: unknown): boolean {
    if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
        return false;
    }
    const o = obj as Record<string, unknown>;
    return '"id" in o && "name" in o && "quickCode" in o && "group" in o && "subgroup" in o && "unit" in o && "active" in o && "commission" in o && "favorite" in o && "averageTime" in o && "defaults" in o';
}
export function serviceIs(obj: unknown): obj is Service {
    if (!serviceHasShape(obj)) {
        return false;
    }
    const result = serviceDeserialize(obj);
    return result.success;
}

export type ServiceErrors = {
    _errors: __gf_Option<Array<string>>;
    id: __gf_Option<Array<string>>;
    name: __gf_Option<Array<string>>;
    quickCode: __gf_Option<Array<string>>;
    group: __gf_Option<Array<string>>;
    subgroup: __gf_Option<Array<string>>;
    unit: __gf_Option<Array<string>>;
    active: __gf_Option<Array<string>>;
    commission: __gf_Option<Array<string>>;
    favorite: __gf_Option<Array<string>>;
    averageTime: __gf_Option<Array<string>>;
    defaults: __gf_Option<Array<string>>;
};
export type ServiceTainted = {
    id: __gf_Option<boolean>;
    name: __gf_Option<boolean>;
    quickCode: __gf_Option<boolean>;
    group: __gf_Option<boolean>;
    subgroup: __gf_Option<boolean>;
    unit: __gf_Option<boolean>;
    active: __gf_Option<boolean>;
    commission: __gf_Option<boolean>;
    favorite: __gf_Option<boolean>;
    averageTime: __gf_Option<boolean>;
    defaults: __gf_Option<boolean>;
};
export interface ServiceFieldControllers {
    readonly id: FieldController<string>;
    readonly name: FieldController<string>;
    readonly quickCode: FieldController<string>;
    readonly group: FieldController<string | null>;
    readonly subgroup: FieldController<string | null>;
    readonly unit: FieldController<string | null>;
    readonly active: FieldController<boolean>;
    readonly commission: FieldController<boolean>;
    readonly favorite: FieldController<boolean>;
    readonly averageTime: FieldController<string | null>;
    readonly defaults: FieldController<ServiceDefaults>;
}
export interface ServiceGigaform {
    readonly data: Service;
    readonly errors: ServiceErrors;
    readonly tainted: ServiceTainted;
    readonly fields: ServiceFieldControllers;
    validate(): Exit<Service, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<Service>): void;
}
export function serviceCreateForm(overrides?: Partial<Service>): ServiceGigaform {
    let data = $state({
        ...serviceDefaultValue(),
        ...overrides
    });
    let errors = $state<ServiceErrors>({
        _errors: optionNone(),
        id: optionNone(),
        name: optionNone(),
        quickCode: optionNone(),
        group: optionNone(),
        subgroup: optionNone(),
        unit: optionNone(),
        active: optionNone(),
        commission: optionNone(),
        favorite: optionNone(),
        averageTime: optionNone(),
        defaults: optionNone()
    } as ServiceErrors);
    let tainted = $state<ServiceTainted>({
        id: optionNone(),
        name: optionNone(),
        quickCode: optionNone(),
        group: optionNone(),
        subgroup: optionNone(),
        unit: optionNone(),
        active: optionNone(),
        commission: optionNone(),
        favorite: optionNone(),
        averageTime: optionNone(),
        defaults: optionNone()
    } as ServiceTainted);
    const fields = {
        id: {
            path: [
                "id"
            ] as const,
            name: "id",
            constraints: {
                required: true
            },
            get: ()=>data.id,
            set: (value: string)=>{
                data.id = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.id,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.id = value;
            },
            getTainted: ()=>tainted.id,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.id = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = serviceValidateField("id", data.id);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        name: {
            path: [
                "name"
            ] as const,
            name: "name",
            constraints: {
                required: true
            },
            label: "Name",
            get: ()=>data.name,
            set: (value: string)=>{
                data.name = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.name,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.name = value;
            },
            getTainted: ()=>tainted.name,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.name = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = serviceValidateField("name", data.name);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        quickCode: {
            path: [
                "quickCode"
            ] as const,
            name: "quickCode",
            constraints: {
                required: true
            },
            label: "Quick Code",
            get: ()=>data.quickCode,
            set: (value: string)=>{
                data.quickCode = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.quickCode,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.quickCode = value;
            },
            getTainted: ()=>tainted.quickCode,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.quickCode = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = serviceValidateField("quickCode", data.quickCode);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        group: {
            path: [
                "group"
            ] as const,
            name: "group",
            constraints: {
                required: true
            },
            label: "Group",
            get: ()=>data.group,
            set: (value: string | null)=>{
                data.group = value;
            },
            transform: (value: string | null): string | null =>value,
            getError: ()=>errors.group,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.group = value;
            },
            getTainted: ()=>tainted.group,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.group = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = serviceValidateField("group", data.group);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        subgroup: {
            path: [
                "subgroup"
            ] as const,
            name: "subgroup",
            constraints: {
                required: true
            },
            label: "Subgroup",
            get: ()=>data.subgroup,
            set: (value: string | null)=>{
                data.subgroup = value;
            },
            transform: (value: string | null): string | null =>value,
            getError: ()=>errors.subgroup,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.subgroup = value;
            },
            getTainted: ()=>tainted.subgroup,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.subgroup = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = serviceValidateField("subgroup", data.subgroup);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        unit: {
            path: [
                "unit"
            ] as const,
            name: "unit",
            constraints: {
                required: true
            },
            label: "Unit",
            get: ()=>data.unit,
            set: (value: string | null)=>{
                data.unit = value;
            },
            transform: (value: string | null): string | null =>value,
            getError: ()=>errors.unit,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.unit = value;
            },
            getTainted: ()=>tainted.unit,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.unit = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = serviceValidateField("unit", data.unit);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        active: {
            path: [
                "active"
            ] as const,
            name: "active",
            constraints: {
                required: true
            },
            label: "Active",
            get: ()=>data.active,
            set: (value: boolean)=>{
                data.active = value;
            },
            transform: (value: boolean): boolean =>value,
            getError: ()=>errors.active,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.active = value;
            },
            getTainted: ()=>tainted.active,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.active = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = serviceValidateField("active", data.active);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        commission: {
            path: [
                "commission"
            ] as const,
            name: "commission",
            constraints: {
                required: true
            },
            label: "Commission",
            get: ()=>data.commission,
            set: (value: boolean)=>{
                data.commission = value;
            },
            transform: (value: boolean): boolean =>value,
            getError: ()=>errors.commission,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.commission = value;
            },
            getTainted: ()=>tainted.commission,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.commission = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = serviceValidateField("commission", data.commission);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        favorite: {
            path: [
                "favorite"
            ] as const,
            name: "favorite",
            constraints: {
                required: true
            },
            label: "Favorite",
            get: ()=>data.favorite,
            set: (value: boolean)=>{
                data.favorite = value;
            },
            transform: (value: boolean): boolean =>value,
            getError: ()=>errors.favorite,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.favorite = value;
            },
            getTainted: ()=>tainted.favorite,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.favorite = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = serviceValidateField("favorite", data.favorite);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        averageTime: {
            path: [
                "averageTime"
            ] as const,
            name: "averageTime",
            constraints: {
                required: true
            },
            label: "Average Time",
            get: ()=>data.averageTime,
            set: (value: string | null)=>{
                data.averageTime = value;
            },
            transform: (value: string | null): string | null =>value,
            getError: ()=>errors.averageTime,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.averageTime = value;
            },
            getTainted: ()=>tainted.averageTime,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.averageTime = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = serviceValidateField("averageTime", data.averageTime);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        defaults: {
            path: [
                "defaults"
            ] as const,
            name: "defaults",
            constraints: {
                required: true
            },
            get: ()=>data.defaults,
            set: (value: ServiceDefaults)=>{
                data.defaults = value;
            },
            transform: (value: ServiceDefaults): ServiceDefaults =>value,
            getError: ()=>errors.defaults,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.defaults = value;
            },
            getTainted: ()=>tainted.defaults,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.defaults = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = serviceValidateField("defaults", data.defaults);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        }
    } as ServiceFieldControllers;
    const __gf_getter_hint = "get data() set data(v) get errors() set errors(v) get tainted() set tainted(v)";
    const __gf_validate_hint = ".map((e: { field: string; message: string }) => e.message)";
    function validate(): Exit<Service, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(serviceDeserialize(data));
    }
    function reset(newOverrides?: Partial<Service>): void {
        data = {
            ...serviceDefaultValue(),
            ...newOverrides
        };
        errors = {
            _errors: optionNone(),
            id: optionNone(),
            name: optionNone(),
            quickCode: optionNone(),
            group: optionNone(),
            subgroup: optionNone(),
            unit: optionNone(),
            active: optionNone(),
            commission: optionNone(),
            favorite: optionNone(),
            averageTime: optionNone(),
            defaults: optionNone()
        };
        tainted = {
            id: optionNone(),
            name: optionNone(),
            quickCode: optionNone(),
            group: optionNone(),
            subgroup: optionNone(),
            unit: optionNone(),
            active: optionNone(),
            commission: optionNone(),
            favorite: optionNone(),
            averageTime: optionNone(),
            defaults: optionNone()
        };
    }
    return {
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        fields,
        validate,
        reset
    };
}
export function serviceFromFormData(formData: FormData): Exit<Service, Array<{
    field: string;
    message: string;
}>> {
    const obj: Record<string, unknown> = {};
    const __gf_exit_hint = "Exit<Service, Array<{ field: string; message: string }>>";
    obj.id = formData.get(`${"id"}`) ?? "";
    obj.name = formData.get(`${"name"}`) ?? "";
    obj.quickCode = formData.get(`${"quickCode"}`) ?? "";
    obj.group = formData.get(`${"group"}`) ?? "";
    obj.subgroup = formData.get(`${"subgroup"}`) ?? "";
    obj.unit = formData.get(`${"unit"}`) ?? "";
    {
        const activeVal = formData.get(`${"active"}`);
        obj.active = activeVal === "true" || activeVal === "on" || activeVal === "1";
    }
    {
        const commissionVal = formData.get(`${"commission"}`);
        obj.commission = commissionVal === "true" || commissionVal === "on" || commissionVal === "1";
    }
    {
        const favoriteVal = formData.get(`${"favorite"}`);
        obj.favorite = favoriteVal === "true" || favoriteVal === "on" || favoriteVal === "1";
    }
    obj.averageTime = formData.get(`${"averageTime"}`) ?? "";
    {
        const defaultsObj: Record<string, unknown> = {};
        for (const [key, value] of Array.from(formData.entries())){
            if (key.startsWith(`${"defaults"}.`)) {
                const fieldName = key.slice(`${"defaults"}.`.length);
                const parts = fieldName.split(".");
                let current = defaultsObj;
                for(let i = 0; i < parts.length - 1; i++){
                    const part = parts[i]!;
                    if (!(part in current)) {
                        current[part] = {};
                    }
                    current = current[part] as Record<string, unknown>;
                }
                current[parts[parts.length - 1]!] = value;
            }
        }
        obj.defaults = defaultsObj;
    }
    return toExit(serviceDeserialize(obj));
}

export const Service = {
  defaultValue: serviceDefaultValue,
  serialize: serviceSerialize,
  serializeWithContext: serviceSerializeWithContext,
  deserialize: serviceDeserialize,
  deserializeWithContext: serviceDeserializeWithContext,
  validateFields: serviceValidateFields,
  hasShape: serviceHasShape,
  is: serviceIs,
  createForm: serviceCreateForm,
  fromFormData: serviceFromFormData
} as const;


export interface ServiceDefaults {
    
    price: number;
    
    
    description: string;
}

export function serviceDefaultsDefaultValue(): ServiceDefaults {
    return {
        price: 0,
        description: ""
    } as ServiceDefaults;
}

export function serviceDefaultsSerialize(value: ServiceDefaults): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(serviceDefaultsSerializeWithContext(value, ctx));
}
export function serviceDefaultsSerializeWithContext(value: ServiceDefaults, ctx: __mf_SerializeContext): Record<string, unknown> {
    const existingId = ctx.getId(value);
    if (existingId !== undefined) {
        return {
            __ref: existingId
        };
    }
    const __id = ctx.register(value);
    const result: Record<string, unknown> = {
        __type: "ServiceDefaults",
        __id
    };
    result.price = value.price;
    result.description = value.description;
    return result;
}

export function serviceDefaultsDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: ServiceDefaults } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = serviceDefaultsDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "ServiceDefaults.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function serviceDefaultsDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): ServiceDefaults | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
        throw new __mf_DeserializeError([
            {
                field: "_root",
                message: `${"ServiceDefaults"}.deserializeWithContext: expected an object`
            }
        ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (!("price" in obj)) {
        errors.push({
            field: "price",
            message: "missing required field"
        });
    }
    if (!("description" in obj)) {
        errors.push({
            field: "description",
            message: "missing required field"
        });
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
        ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
        const __raw_price = obj["price"] as number;
        instance.price = __raw_price;
    }
    {
        const __raw_description = obj["description"] as string;
        if (__raw_description.trim().length === 0) {
            errors.push({
                field: "description",
                message: "ServiceDefaults.description must not be empty"
            });
        }
        instance.description = __raw_description;
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    return instance as ServiceDefaults;
}
export function serviceDefaultsValidateField<K extends keyof ServiceDefaults>(_field: K, _value: ServiceDefaults[K]): Array<{
    field: string;
    message: string;
}> {
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (_field === "description") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "description",
                message: "ServiceDefaults.description must not be empty"
            });
        }
    }
    return errors;
}
export function serviceDefaultsValidateFields(_partial: Partial<ServiceDefaults>): Array<{
    field: string;
    message: string;
}> {
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if ("description" in _partial && _partial.description !== undefined) {
        const __val = _partial.description as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "description",
                message: "ServiceDefaults.description must not be empty"
            });
        }
    }
    return errors;
}
export function serviceDefaultsHasShape(obj: unknown): boolean {
    if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
        return false;
    }
    const o = obj as Record<string, unknown>;
    return '"price" in o && "description" in o';
}
export function serviceDefaultsIs(obj: unknown): obj is ServiceDefaults {
    if (!serviceDefaultsHasShape(obj)) {
        return false;
    }
    const result = serviceDefaultsDeserialize(obj);
    return result.success;
}

export type ServiceDefaultsErrors = {
    _errors: __gf_Option<Array<string>>;
    price: __gf_Option<Array<string>>;
    description: __gf_Option<Array<string>>;
};
export type ServiceDefaultsTainted = {
    price: __gf_Option<boolean>;
    description: __gf_Option<boolean>;
};
export interface ServiceDefaultsFieldControllers {
    readonly price: FieldController<number>;
    readonly description: FieldController<string>;
}
export interface ServiceDefaultsGigaform {
    readonly data: ServiceDefaults;
    readonly errors: ServiceDefaultsErrors;
    readonly tainted: ServiceDefaultsTainted;
    readonly fields: ServiceDefaultsFieldControllers;
    validate(): Exit<ServiceDefaults, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<ServiceDefaults>): void;
}
export function serviceDefaultsCreateForm(overrides?: Partial<ServiceDefaults>): ServiceDefaultsGigaform {
    let data = $state({
        ...serviceDefaultsDefaultValue(),
        ...overrides
    });
    let errors = $state<ServiceDefaultsErrors>({
        _errors: optionNone(),
        price: optionNone(),
        description: optionNone()
    } as ServiceDefaultsErrors);
    let tainted = $state<ServiceDefaultsTainted>({
        price: optionNone(),
        description: optionNone()
    } as ServiceDefaultsTainted);
    const fields = {
        price: {
            path: [
                "price"
            ] as const,
            name: "price",
            constraints: {
                required: true
            },
            label: "Price",
            get: ()=>data.price,
            set: (value: number)=>{
                data.price = value;
            },
            transform: (value: number): number =>value,
            getError: ()=>errors.price,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.price = value;
            },
            getTainted: ()=>tainted.price,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.price = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = serviceDefaultsValidateField("price", data.price);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        description: {
            path: [
                "description"
            ] as const,
            name: "description",
            constraints: {
                required: true
            },
            label: "Description",
            get: ()=>data.description,
            set: (value: string)=>{
                data.description = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.description,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.description = value;
            },
            getTainted: ()=>tainted.description,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.description = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = serviceDefaultsValidateField("description", data.description);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        }
    } as ServiceDefaultsFieldControllers;
    const __gf_getter_hint = "get data() set data(v) get errors() set errors(v) get tainted() set tainted(v)";
    const __gf_validate_hint = ".map((e: { field: string; message: string }) => e.message)";
    function validate(): Exit<ServiceDefaults, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(serviceDefaultsDeserialize(data));
    }
    function reset(newOverrides?: Partial<ServiceDefaults>): void {
        data = {
            ...serviceDefaultsDefaultValue(),
            ...newOverrides
        };
        errors = {
            _errors: optionNone(),
            price: optionNone(),
            description: optionNone()
        };
        tainted = {
            price: optionNone(),
            description: optionNone()
        };
    }
    return {
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        fields,
        validate,
        reset
    };
}
export function serviceDefaultsFromFormData(formData: FormData): Exit<ServiceDefaults, Array<{
    field: string;
    message: string;
}>> {
    const obj: Record<string, unknown> = {};
    const __gf_exit_hint = "Exit<ServiceDefaults, Array<{ field: string; message: string }>>";
    {
        const priceStr = formData.get(`${"price"}`);
        obj.price = priceStr ? parseFloat(priceStr as string) : $MfPh5;
        if (obj.price !== undefined && isNaN(obj.price as number)) obj.price = "0";
    }
    obj.description = formData.get(`${"description"}`) ?? "";
    return toExit(serviceDefaultsDeserialize(obj));
}

export const ServiceDefaults = {
  defaultValue: serviceDefaultsDefaultValue,
  serialize: serviceDefaultsSerialize,
  serializeWithContext: serviceDefaultsSerializeWithContext,
  deserialize: serviceDefaultsDeserialize,
  deserializeWithContext: serviceDefaultsDeserializeWithContext,
  validateFields: serviceDefaultsValidateFields,
  hasShape: serviceDefaultsHasShape,
  is: serviceDefaultsIs,
  createForm: serviceDefaultsCreateForm,
  fromFormData: serviceDefaultsFromFormData
} as const;


export interface Did {
    
    in: string | Actor;
    
    out: string | Target;
    id: string;
    activityType: ActivityType;
    createdAt: string;
    metadata: string | null;
}

export function didDefaultValue(): Did {
    return {
        in: "",
        out: "",
        id: "",
        activityType: activityTypeDefaultValue(),
        createdAt: "",
        metadata: null
    } as Did;
}

export function didSerialize(value: Did): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(didSerializeWithContext(value, ctx));
}
export function didSerializeWithContext(value: Did, ctx: __mf_SerializeContext): Record<string, unknown> {
    const existingId = ctx.getId(value);
    if (existingId !== undefined) {
        return {
            __ref: existingId
        };
    }
    const __id = ctx.register(value);
    const result: Record<string, unknown> = {
        __type: "Did",
        __id
    };
    result.in = value.in;
    result.out = value.out;
    result.id = value.id;
    result.activityType = activityTypeSerializeWithContext(value.activityType, ctx);
    result.createdAt = value.createdAt;
    result.metadata = value.metadata;
    return result;
}

export function didDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: Did } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = didDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "Did.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function didDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Did | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
        throw new __mf_DeserializeError([
            {
                field: "_root",
                message: `${"Did"}.deserializeWithContext: expected an object`
            }
        ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (!("in" in obj)) {
        errors.push({
            field: "in",
            message: "missing required field"
        });
    }
    if (!("out" in obj)) {
        errors.push({
            field: "out",
            message: "missing required field"
        });
    }
    if (!("id" in obj)) {
        errors.push({
            field: "id",
            message: "missing required field"
        });
    }
    if (!("activityType" in obj)) {
        errors.push({
            field: "activityType",
            message: "missing required field"
        });
    }
    if (!("createdAt" in obj)) {
        errors.push({
            field: "createdAt",
            message: "missing required field"
        });
    }
    if (!("metadata" in obj)) {
        errors.push({
            field: "metadata",
            message: "missing required field"
        });
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
        ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
        const __raw_in = obj["in"] as string | Actor;
        instance.in = __raw_in;
    }
    {
        const __raw_out = obj["out"] as string | Target;
        instance.out = __raw_out;
    }
    {
        const __raw_id = obj["id"] as string;
        instance.id = __raw_id;
    }
    {
        const __raw_activityType = obj["activityType"] as ActivityType;
        {
            const __result = activityTypeDeserializeWithContext(__raw_activityType, ctx);
            ctx.assignOrDefer(instance, "activityType", __result);
        }
    }
    {
        const __raw_createdAt = obj["createdAt"] as string;
        instance.createdAt = __raw_createdAt;
    }
    {
        const __raw_metadata = obj["metadata"] as string | null;
        instance.metadata = __raw_metadata;
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    return instance as Did;
}
export function didValidateField<K extends keyof Did>(_field: K, _value: Did[K]): Array<{
    field: string;
    message: string;
}> {
    return [];
}
export function didValidateFields(_partial: Partial<Did>): Array<{
    field: string;
    message: string;
}> {
    return [];
}
export function didHasShape(obj: unknown): boolean {
    if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
        return false;
    }
    const o = obj as Record<string, unknown>;
    return '"in" in o && "out" in o && "id" in o && "activityType" in o && "createdAt" in o && "metadata" in o';
}
export function didIs(obj: unknown): obj is Did {
    if (!didHasShape(obj)) {
        return false;
    }
    const result = didDeserialize(obj);
    return result.success;
}

export type DidErrors = {
    _errors: __gf_Option<Array<string>>;
    in: __gf_Option<Array<string>>;
    out: __gf_Option<Array<string>>;
    id: __gf_Option<Array<string>>;
    activityType: __gf_Option<Array<string>>;
    createdAt: __gf_Option<Array<string>>;
    metadata: __gf_Option<Array<string>>;
};
export type DidTainted = {
    in: __gf_Option<boolean>;
    out: __gf_Option<boolean>;
    id: __gf_Option<boolean>;
    activityType: __gf_Option<boolean>;
    createdAt: __gf_Option<boolean>;
    metadata: __gf_Option<boolean>;
};
export interface DidFieldControllers {
    readonly in: FieldController<string | Actor>;
    readonly out: FieldController<string | Target>;
    readonly id: FieldController<string>;
    readonly activityType: FieldController<ActivityType>;
    readonly createdAt: FieldController<string>;
    readonly metadata: FieldController<string | null>;
}
export interface DidGigaform {
    readonly data: Did;
    readonly errors: DidErrors;
    readonly tainted: DidTainted;
    readonly fields: DidFieldControllers;
    validate(): Exit<Did, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<Did>): void;
}
export function didCreateForm(overrides?: Partial<Did>): DidGigaform {
    let data = $state({
        ...didDefaultValue(),
        ...overrides
    });
    let errors = $state<DidErrors>({
        _errors: optionNone(),
        in: optionNone(),
        out: optionNone(),
        id: optionNone(),
        activityType: optionNone(),
        createdAt: optionNone(),
        metadata: optionNone()
    } as DidErrors);
    let tainted = $state<DidTainted>({
        in: optionNone(),
        out: optionNone(),
        id: optionNone(),
        activityType: optionNone(),
        createdAt: optionNone(),
        metadata: optionNone()
    } as DidTainted);
    const fields = {
        in: {
            path: [
                "in"
            ] as const,
            name: "in",
            constraints: {
                required: true
            },
            get: ()=>data.in,
            set: (value: string | Actor)=>{
                data.in = value;
            },
            transform: (value: string | Actor): string | Actor =>value,
            getError: ()=>errors.in,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.in = value;
            },
            getTainted: ()=>tainted.in,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.in = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = didValidateField("in", data.in);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        out: {
            path: [
                "out"
            ] as const,
            name: "out",
            constraints: {
                required: true
            },
            get: ()=>data.out,
            set: (value: string | Target)=>{
                data.out = value;
            },
            transform: (value: string | Target): string | Target =>value,
            getError: ()=>errors.out,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.out = value;
            },
            getTainted: ()=>tainted.out,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.out = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = didValidateField("out", data.out);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        id: {
            path: [
                "id"
            ] as const,
            name: "id",
            constraints: {
                required: true
            },
            get: ()=>data.id,
            set: (value: string)=>{
                data.id = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.id,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.id = value;
            },
            getTainted: ()=>tainted.id,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.id = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = didValidateField("id", data.id);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        activityType: {
            path: [
                "activityType"
            ] as const,
            name: "activityType",
            constraints: {
                required: true
            },
            get: ()=>data.activityType,
            set: (value: ActivityType)=>{
                data.activityType = value;
            },
            transform: (value: ActivityType): ActivityType =>value,
            getError: ()=>errors.activityType,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.activityType = value;
            },
            getTainted: ()=>tainted.activityType,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.activityType = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = didValidateField("activityType", data.activityType);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        createdAt: {
            path: [
                "createdAt"
            ] as const,
            name: "createdAt",
            constraints: {
                required: true
            },
            get: ()=>data.createdAt,
            set: (value: string)=>{
                data.createdAt = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.createdAt,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.createdAt = value;
            },
            getTainted: ()=>tainted.createdAt,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.createdAt = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = didValidateField("createdAt", data.createdAt);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        metadata: {
            path: [
                "metadata"
            ] as const,
            name: "metadata",
            constraints: {
                required: true
            },
            get: ()=>data.metadata,
            set: (value: string | null)=>{
                data.metadata = value;
            },
            transform: (value: string | null): string | null =>value,
            getError: ()=>errors.metadata,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.metadata = value;
            },
            getTainted: ()=>tainted.metadata,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.metadata = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = didValidateField("metadata", data.metadata);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        }
    } as DidFieldControllers;
    const __gf_getter_hint = "get data() set data(v) get errors() set errors(v) get tainted() set tainted(v)";
    const __gf_validate_hint = ".map((e: { field: string; message: string }) => e.message)";
    function validate(): Exit<Did, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(didDeserialize(data));
    }
    function reset(newOverrides?: Partial<Did>): void {
        data = {
            ...didDefaultValue(),
            ...newOverrides
        };
        errors = {
            _errors: optionNone(),
            in: optionNone(),
            out: optionNone(),
            id: optionNone(),
            activityType: optionNone(),
            createdAt: optionNone(),
            metadata: optionNone()
        };
        tainted = {
            in: optionNone(),
            out: optionNone(),
            id: optionNone(),
            activityType: optionNone(),
            createdAt: optionNone(),
            metadata: optionNone()
        };
    }
    return {
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        fields,
        validate,
        reset
    };
}
export function didFromFormData(formData: FormData): Exit<Did, Array<{
    field: string;
    message: string;
}>> {
    const obj: Record<string, unknown> = {};
    const __gf_exit_hint = "Exit<Did, Array<{ field: string; message: string }>>";
    obj.in = formData.get(`${"in"}`) ?? "";
    obj.out = formData.get(`${"out"}`) ?? "";
    obj.id = formData.get(`${"id"}`) ?? "";
    {
        const activityTypeObj: Record<string, unknown> = {};
        for (const [key, value] of Array.from(formData.entries())){
            if (key.startsWith(`${"activityType"}.`)) {
                const fieldName = key.slice(`${"activityType"}.`.length);
                const parts = fieldName.split(".");
                let current = activityTypeObj;
                for(let i = 0; i < parts.length - 1; i++){
                    const part = parts[i]!;
                    if (!(part in current)) {
                        current[part] = {};
                    }
                    current = current[part] as Record<string, unknown>;
                }
                current[parts[parts.length - 1]!] = value;
            }
        }
        obj.activityType = activityTypeObj;
    }
    obj.createdAt = formData.get(`${"createdAt"}`) ?? "";
    obj.metadata = formData.get(`${"metadata"}`) ?? "";
    return toExit(didDeserialize(obj));
}

export const Did = {
  defaultValue: didDefaultValue,
  serialize: didSerialize,
  serializeWithContext: didSerializeWithContext,
  deserialize: didDeserialize,
  deserializeWithContext: didDeserializeWithContext,
  validateFields: didValidateFields,
  hasShape: didHasShape,
  is: didIs,
  createForm: didCreateForm,
  fromFormData: didFromFormData
} as const;


export interface PersonName {
    
    
    firstName: string;
    
    
    lastName: string;
}

export function personNameDefaultValue(): PersonName {
    return {
        firstName: "",
        lastName: ""
    } as PersonName;
}

export function personNameSerialize(value: PersonName): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(personNameSerializeWithContext(value, ctx));
}
export function personNameSerializeWithContext(value: PersonName, ctx: __mf_SerializeContext): Record<string, unknown> {
    const existingId = ctx.getId(value);
    if (existingId !== undefined) {
        return {
            __ref: existingId
        };
    }
    const __id = ctx.register(value);
    const result: Record<string, unknown> = {
        __type: "PersonName",
        __id
    };
    result.firstName = value.firstName;
    result.lastName = value.lastName;
    return result;
}

export function personNameDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: PersonName } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = personNameDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "PersonName.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function personNameDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): PersonName | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
        throw new __mf_DeserializeError([
            {
                field: "_root",
                message: `${"PersonName"}.deserializeWithContext: expected an object`
            }
        ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (!("firstName" in obj)) {
        errors.push({
            field: "firstName",
            message: "missing required field"
        });
    }
    if (!("lastName" in obj)) {
        errors.push({
            field: "lastName",
            message: "missing required field"
        });
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
        ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
        const __raw_firstName = obj["firstName"] as string;
        if (__raw_firstName.trim().length === 0) {
            errors.push({
                field: "firstName",
                message: "PersonName.firstName must not be empty"
            });
        }
        instance.firstName = __raw_firstName;
    }
    {
        const __raw_lastName = obj["lastName"] as string;
        if (__raw_lastName.trim().length === 0) {
            errors.push({
                field: "lastName",
                message: "PersonName.lastName must not be empty"
            });
        }
        instance.lastName = __raw_lastName;
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    return instance as PersonName;
}
export function personNameValidateField<K extends keyof PersonName>(_field: K, _value: PersonName[K]): Array<{
    field: string;
    message: string;
}> {
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (_field === "firstName") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "firstName",
                message: "PersonName.firstName must not be empty"
            });
        }
    }
    if (_field === "lastName") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "lastName",
                message: "PersonName.lastName must not be empty"
            });
        }
    }
    return errors;
}
export function personNameValidateFields(_partial: Partial<PersonName>): Array<{
    field: string;
    message: string;
}> {
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if ("firstName" in _partial && _partial.firstName !== undefined) {
        const __val = _partial.firstName as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "firstName",
                message: "PersonName.firstName must not be empty"
            });
        }
    }
    if ("lastName" in _partial && _partial.lastName !== undefined) {
        const __val = _partial.lastName as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "lastName",
                message: "PersonName.lastName must not be empty"
            });
        }
    }
    return errors;
}
export function personNameHasShape(obj: unknown): boolean {
    if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
        return false;
    }
    const o = obj as Record<string, unknown>;
    return '"firstName" in o && "lastName" in o';
}
export function personNameIs(obj: unknown): obj is PersonName {
    if (!personNameHasShape(obj)) {
        return false;
    }
    const result = personNameDeserialize(obj);
    return result.success;
}

export type PersonNameErrors = {
    _errors: __gf_Option<Array<string>>;
    firstName: __gf_Option<Array<string>>;
    lastName: __gf_Option<Array<string>>;
};
export type PersonNameTainted = {
    firstName: __gf_Option<boolean>;
    lastName: __gf_Option<boolean>;
};
export interface PersonNameFieldControllers {
    readonly firstName: FieldController<string>;
    readonly lastName: FieldController<string>;
}
export interface PersonNameGigaform {
    readonly data: PersonName;
    readonly errors: PersonNameErrors;
    readonly tainted: PersonNameTainted;
    readonly fields: PersonNameFieldControllers;
    validate(): Exit<PersonName, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<PersonName>): void;
}
export function personNameCreateForm(overrides?: Partial<PersonName>): PersonNameGigaform {
    let data = $state({
        ...personNameDefaultValue(),
        ...overrides
    });
    let errors = $state<PersonNameErrors>({
        _errors: optionNone(),
        firstName: optionNone(),
        lastName: optionNone()
    } as PersonNameErrors);
    let tainted = $state<PersonNameTainted>({
        firstName: optionNone(),
        lastName: optionNone()
    } as PersonNameTainted);
    const fields = {
        firstName: {
            path: [
                "firstName"
            ] as const,
            name: "firstName",
            constraints: {
                required: true
            },
            label: "First Name",
            get: ()=>data.firstName,
            set: (value: string)=>{
                data.firstName = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.firstName,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.firstName = value;
            },
            getTainted: ()=>tainted.firstName,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.firstName = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = personNameValidateField("firstName", data.firstName);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        lastName: {
            path: [
                "lastName"
            ] as const,
            name: "lastName",
            constraints: {
                required: true
            },
            label: "Last Name",
            get: ()=>data.lastName,
            set: (value: string)=>{
                data.lastName = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.lastName,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.lastName = value;
            },
            getTainted: ()=>tainted.lastName,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.lastName = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = personNameValidateField("lastName", data.lastName);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        }
    } as PersonNameFieldControllers;
    const __gf_getter_hint = "get data() set data(v) get errors() set errors(v) get tainted() set tainted(v)";
    const __gf_validate_hint = ".map((e: { field: string; message: string }) => e.message)";
    function validate(): Exit<PersonName, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(personNameDeserialize(data));
    }
    function reset(newOverrides?: Partial<PersonName>): void {
        data = {
            ...personNameDefaultValue(),
            ...newOverrides
        };
        errors = {
            _errors: optionNone(),
            firstName: optionNone(),
            lastName: optionNone()
        };
        tainted = {
            firstName: optionNone(),
            lastName: optionNone()
        };
    }
    return {
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        fields,
        validate,
        reset
    };
}
export function personNameFromFormData(formData: FormData): Exit<PersonName, Array<{
    field: string;
    message: string;
}>> {
    const obj: Record<string, unknown> = {};
    const __gf_exit_hint = "Exit<PersonName, Array<{ field: string; message: string }>>";
    obj.firstName = formData.get(`${"firstName"}`) ?? "";
    obj.lastName = formData.get(`${"lastName"}`) ?? "";
    return toExit(personNameDeserialize(obj));
}

export const PersonName = {
  defaultValue: personNameDefaultValue,
  serialize: personNameSerialize,
  serializeWithContext: personNameSerializeWithContext,
  deserialize: personNameDeserialize,
  deserializeWithContext: personNameDeserializeWithContext,
  validateFields: personNameValidateFields,
  hasShape: personNameHasShape,
  is: personNameIs,
  createForm: personNameCreateForm,
  fromFormData: personNameFromFormData
} as const;


export interface Promotion {
    id: string;
    date: string;
}

export function promotionDefaultValue(): Promotion {
    return {
        id: "",
        date: ""
    } as Promotion;
}

export function promotionSerialize(value: Promotion): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(promotionSerializeWithContext(value, ctx));
}
export function promotionSerializeWithContext(value: Promotion, ctx: __mf_SerializeContext): Record<string, unknown> {
    const existingId = ctx.getId(value);
    if (existingId !== undefined) {
        return {
            __ref: existingId
        };
    }
    const __id = ctx.register(value);
    const result: Record<string, unknown> = {
        __type: "Promotion",
        __id
    };
    result.id = value.id;
    result.date = value.date;
    return result;
}

export function promotionDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: Promotion } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = promotionDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "Promotion.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function promotionDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Promotion | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
        throw new __mf_DeserializeError([
            {
                field: "_root",
                message: `${"Promotion"}.deserializeWithContext: expected an object`
            }
        ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (!("id" in obj)) {
        errors.push({
            field: "id",
            message: "missing required field"
        });
    }
    if (!("date" in obj)) {
        errors.push({
            field: "date",
            message: "missing required field"
        });
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
        ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
        const __raw_id = obj["id"] as string;
        instance.id = __raw_id;
    }
    {
        const __raw_date = obj["date"] as string;
        instance.date = __raw_date;
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    return instance as Promotion;
}
export function promotionValidateField<K extends keyof Promotion>(_field: K, _value: Promotion[K]): Array<{
    field: string;
    message: string;
}> {
    return [];
}
export function promotionValidateFields(_partial: Partial<Promotion>): Array<{
    field: string;
    message: string;
}> {
    return [];
}
export function promotionHasShape(obj: unknown): boolean {
    if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
        return false;
    }
    const o = obj as Record<string, unknown>;
    return '"id" in o && "date" in o';
}
export function promotionIs(obj: unknown): obj is Promotion {
    if (!promotionHasShape(obj)) {
        return false;
    }
    const result = promotionDeserialize(obj);
    return result.success;
}

export type PromotionErrors = {
    _errors: __gf_Option<Array<string>>;
    id: __gf_Option<Array<string>>;
    date: __gf_Option<Array<string>>;
};
export type PromotionTainted = {
    id: __gf_Option<boolean>;
    date: __gf_Option<boolean>;
};
export interface PromotionFieldControllers {
    readonly id: FieldController<string>;
    readonly date: FieldController<string>;
}
export interface PromotionGigaform {
    readonly data: Promotion;
    readonly errors: PromotionErrors;
    readonly tainted: PromotionTainted;
    readonly fields: PromotionFieldControllers;
    validate(): Exit<Promotion, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<Promotion>): void;
}
export function promotionCreateForm(overrides?: Partial<Promotion>): PromotionGigaform {
    let data = $state({
        ...promotionDefaultValue(),
        ...overrides
    });
    let errors = $state<PromotionErrors>({
        _errors: optionNone(),
        id: optionNone(),
        date: optionNone()
    } as PromotionErrors);
    let tainted = $state<PromotionTainted>({
        id: optionNone(),
        date: optionNone()
    } as PromotionTainted);
    const fields = {
        id: {
            path: [
                "id"
            ] as const,
            name: "id",
            constraints: {
                required: true
            },
            get: ()=>data.id,
            set: (value: string)=>{
                data.id = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.id,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.id = value;
            },
            getTainted: ()=>tainted.id,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.id = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = promotionValidateField("id", data.id);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        date: {
            path: [
                "date"
            ] as const,
            name: "date",
            constraints: {
                required: true
            },
            get: ()=>data.date,
            set: (value: string)=>{
                data.date = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.date,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.date = value;
            },
            getTainted: ()=>tainted.date,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.date = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = promotionValidateField("date", data.date);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        }
    } as PromotionFieldControllers;
    const __gf_getter_hint = "get data() set data(v) get errors() set errors(v) get tainted() set tainted(v)";
    const __gf_validate_hint = ".map((e: { field: string; message: string }) => e.message)";
    function validate(): Exit<Promotion, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(promotionDeserialize(data));
    }
    function reset(newOverrides?: Partial<Promotion>): void {
        data = {
            ...promotionDefaultValue(),
            ...newOverrides
        };
        errors = {
            _errors: optionNone(),
            id: optionNone(),
            date: optionNone()
        };
        tainted = {
            id: optionNone(),
            date: optionNone()
        };
    }
    return {
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        fields,
        validate,
        reset
    };
}
export function promotionFromFormData(formData: FormData): Exit<Promotion, Array<{
    field: string;
    message: string;
}>> {
    const obj: Record<string, unknown> = {};
    const __gf_exit_hint = "Exit<Promotion, Array<{ field: string; message: string }>>";
    obj.id = formData.get(`${"id"}`) ?? "";
    obj.date = formData.get(`${"date"}`) ?? "";
    return toExit(promotionDeserialize(obj));
}

export const Promotion = {
  defaultValue: promotionDefaultValue,
  serialize: promotionSerialize,
  serializeWithContext: promotionSerializeWithContext,
  deserialize: promotionDeserialize,
  deserializeWithContext: promotionDeserializeWithContext,
  validateFields: promotionValidateFields,
  hasShape: promotionHasShape,
  is: promotionIs,
  createForm: promotionCreateForm,
  fromFormData: promotionFromFormData
} as const;


export interface Site {
    id: string;
    
    addressLine1: string;
    addressLine2: string | null;
    sublocalityLevel1: string | null;
    
    locality: string;
    administrativeAreaLevel3: string | null;
    administrativeAreaLevel2: string | null;
    
    administrativeAreaLevel1: string;
    
    country: string;
    
    postalCode: string;
    postalCodeSuffix: string | null;
    coordinates: Coordinates;
}

export function siteDefaultValue(): Site {
    return {
        id: "",
        addressLine1: "",
        addressLine2: null,
        sublocalityLevel1: null,
        locality: "",
        administrativeAreaLevel3: null,
        administrativeAreaLevel2: null,
        administrativeAreaLevel1: "",
        country: "",
        postalCode: "",
        postalCodeSuffix: null,
        coordinates: coordinatesDefaultValue()
    } as Site;
}

export function siteSerialize(value: Site): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(siteSerializeWithContext(value, ctx));
}
export function siteSerializeWithContext(value: Site, ctx: __mf_SerializeContext): Record<string, unknown> {
    const existingId = ctx.getId(value);
    if (existingId !== undefined) {
        return {
            __ref: existingId
        };
    }
    const __id = ctx.register(value);
    const result: Record<string, unknown> = {
        __type: "Site",
        __id
    };
    result.id = value.id;
    result.addressLine1 = value.addressLine1;
    result.addressLine2 = value.addressLine2;
    result.sublocalityLevel1 = value.sublocalityLevel1;
    result.locality = value.locality;
    result.administrativeAreaLevel3 = value.administrativeAreaLevel3;
    result.administrativeAreaLevel2 = value.administrativeAreaLevel2;
    result.administrativeAreaLevel1 = value.administrativeAreaLevel1;
    result.country = value.country;
    result.postalCode = value.postalCode;
    result.postalCodeSuffix = value.postalCodeSuffix;
    result.coordinates = coordinatesSerializeWithContext(value.coordinates, ctx);
    return result;
}

export function siteDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: Site } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = siteDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "Site.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function siteDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Site | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
        throw new __mf_DeserializeError([
            {
                field: "_root",
                message: `${"Site"}.deserializeWithContext: expected an object`
            }
        ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (!("id" in obj)) {
        errors.push({
            field: "id",
            message: "missing required field"
        });
    }
    if (!("addressLine1" in obj)) {
        errors.push({
            field: "addressLine1",
            message: "missing required field"
        });
    }
    if (!("addressLine2" in obj)) {
        errors.push({
            field: "addressLine2",
            message: "missing required field"
        });
    }
    if (!("sublocalityLevel1" in obj)) {
        errors.push({
            field: "sublocalityLevel1",
            message: "missing required field"
        });
    }
    if (!("locality" in obj)) {
        errors.push({
            field: "locality",
            message: "missing required field"
        });
    }
    if (!("administrativeAreaLevel3" in obj)) {
        errors.push({
            field: "administrativeAreaLevel3",
            message: "missing required field"
        });
    }
    if (!("administrativeAreaLevel2" in obj)) {
        errors.push({
            field: "administrativeAreaLevel2",
            message: "missing required field"
        });
    }
    if (!("administrativeAreaLevel1" in obj)) {
        errors.push({
            field: "administrativeAreaLevel1",
            message: "missing required field"
        });
    }
    if (!("country" in obj)) {
        errors.push({
            field: "country",
            message: "missing required field"
        });
    }
    if (!("postalCode" in obj)) {
        errors.push({
            field: "postalCode",
            message: "missing required field"
        });
    }
    if (!("postalCodeSuffix" in obj)) {
        errors.push({
            field: "postalCodeSuffix",
            message: "missing required field"
        });
    }
    if (!("coordinates" in obj)) {
        errors.push({
            field: "coordinates",
            message: "missing required field"
        });
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
        ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
        const __raw_id = obj["id"] as string;
        instance.id = __raw_id;
    }
    {
        const __raw_addressLine1 = obj["addressLine1"] as string;
        if (__raw_addressLine1.trim().length === 0) {
            errors.push({
                field: "addressLine1",
                message: "Site.addressLine1 must not be empty"
            });
        }
        instance.addressLine1 = __raw_addressLine1;
    }
    {
        const __raw_addressLine2 = obj["addressLine2"] as string | null;
        instance.addressLine2 = __raw_addressLine2;
    }
    {
        const __raw_sublocalityLevel1 = obj["sublocalityLevel1"] as string | null;
        instance.sublocalityLevel1 = __raw_sublocalityLevel1;
    }
    {
        const __raw_locality = obj["locality"] as string;
        if (__raw_locality.trim().length === 0) {
            errors.push({
                field: "locality",
                message: "Site.locality must not be empty"
            });
        }
        instance.locality = __raw_locality;
    }
    {
        const __raw_administrativeAreaLevel3 = obj["administrativeAreaLevel3"] as string | null;
        instance.administrativeAreaLevel3 = __raw_administrativeAreaLevel3;
    }
    {
        const __raw_administrativeAreaLevel2 = obj["administrativeAreaLevel2"] as string | null;
        instance.administrativeAreaLevel2 = __raw_administrativeAreaLevel2;
    }
    {
        const __raw_administrativeAreaLevel1 = obj["administrativeAreaLevel1"] as string;
        if (__raw_administrativeAreaLevel1.trim().length === 0) {
            errors.push({
                field: "administrativeAreaLevel1",
                message: "Site.administrativeAreaLevel1 must not be empty"
            });
        }
        instance.administrativeAreaLevel1 = __raw_administrativeAreaLevel1;
    }
    {
        const __raw_country = obj["country"] as string;
        if (__raw_country.trim().length === 0) {
            errors.push({
                field: "country",
                message: "Site.country must not be empty"
            });
        }
        instance.country = __raw_country;
    }
    {
        const __raw_postalCode = obj["postalCode"] as string;
        if (__raw_postalCode.trim().length === 0) {
            errors.push({
                field: "postalCode",
                message: "Site.postalCode must not be empty"
            });
        }
        instance.postalCode = __raw_postalCode;
    }
    {
        const __raw_postalCodeSuffix = obj["postalCodeSuffix"] as string | null;
        instance.postalCodeSuffix = __raw_postalCodeSuffix;
    }
    {
        const __raw_coordinates = obj["coordinates"] as Coordinates;
        {
            const __result = coordinatesDeserializeWithContext(__raw_coordinates, ctx);
            ctx.assignOrDefer(instance, "coordinates", __result);
        }
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    return instance as Site;
}
export function siteValidateField<K extends keyof Site>(_field: K, _value: Site[K]): Array<{
    field: string;
    message: string;
}> {
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (_field === "addressLine1") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "addressLine1",
                message: "Site.addressLine1 must not be empty"
            });
        }
    }
    if (_field === "locality") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "locality",
                message: "Site.locality must not be empty"
            });
        }
    }
    if (_field === "administrativeAreaLevel1") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "administrativeAreaLevel1",
                message: "Site.administrativeAreaLevel1 must not be empty"
            });
        }
    }
    if (_field === "country") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "country",
                message: "Site.country must not be empty"
            });
        }
    }
    if (_field === "postalCode") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "postalCode",
                message: "Site.postalCode must not be empty"
            });
        }
    }
    return errors;
}
export function siteValidateFields(_partial: Partial<Site>): Array<{
    field: string;
    message: string;
}> {
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if ("addressLine1" in _partial && _partial.addressLine1 !== undefined) {
        const __val = _partial.addressLine1 as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "addressLine1",
                message: "Site.addressLine1 must not be empty"
            });
        }
    }
    if ("locality" in _partial && _partial.locality !== undefined) {
        const __val = _partial.locality as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "locality",
                message: "Site.locality must not be empty"
            });
        }
    }
    if ("administrativeAreaLevel1" in _partial && _partial.administrativeAreaLevel1 !== undefined) {
        const __val = _partial.administrativeAreaLevel1 as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "administrativeAreaLevel1",
                message: "Site.administrativeAreaLevel1 must not be empty"
            });
        }
    }
    if ("country" in _partial && _partial.country !== undefined) {
        const __val = _partial.country as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "country",
                message: "Site.country must not be empty"
            });
        }
    }
    if ("postalCode" in _partial && _partial.postalCode !== undefined) {
        const __val = _partial.postalCode as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "postalCode",
                message: "Site.postalCode must not be empty"
            });
        }
    }
    return errors;
}
export function siteHasShape(obj: unknown): boolean {
    if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
        return false;
    }
    const o = obj as Record<string, unknown>;
    return '"id" in o && "addressLine1" in o && "addressLine2" in o && "sublocalityLevel1" in o && "locality" in o && "administrativeAreaLevel3" in o && "administrativeAreaLevel2" in o && "administrativeAreaLevel1" in o && "country" in o && "postalCode" in o && "postalCodeSuffix" in o && "coordinates" in o';
}
export function siteIs(obj: unknown): obj is Site {
    if (!siteHasShape(obj)) {
        return false;
    }
    const result = siteDeserialize(obj);
    return result.success;
}

export type SiteErrors = {
    _errors: __gf_Option<Array<string>>;
    id: __gf_Option<Array<string>>;
    addressLine1: __gf_Option<Array<string>>;
    addressLine2: __gf_Option<Array<string>>;
    sublocalityLevel1: __gf_Option<Array<string>>;
    locality: __gf_Option<Array<string>>;
    administrativeAreaLevel3: __gf_Option<Array<string>>;
    administrativeAreaLevel2: __gf_Option<Array<string>>;
    administrativeAreaLevel1: __gf_Option<Array<string>>;
    country: __gf_Option<Array<string>>;
    postalCode: __gf_Option<Array<string>>;
    postalCodeSuffix: __gf_Option<Array<string>>;
    coordinates: __gf_Option<Array<string>>;
};
export type SiteTainted = {
    id: __gf_Option<boolean>;
    addressLine1: __gf_Option<boolean>;
    addressLine2: __gf_Option<boolean>;
    sublocalityLevel1: __gf_Option<boolean>;
    locality: __gf_Option<boolean>;
    administrativeAreaLevel3: __gf_Option<boolean>;
    administrativeAreaLevel2: __gf_Option<boolean>;
    administrativeAreaLevel1: __gf_Option<boolean>;
    country: __gf_Option<boolean>;
    postalCode: __gf_Option<boolean>;
    postalCodeSuffix: __gf_Option<boolean>;
    coordinates: __gf_Option<boolean>;
};
export interface SiteFieldControllers {
    readonly id: FieldController<string>;
    readonly addressLine1: FieldController<string>;
    readonly addressLine2: FieldController<string | null>;
    readonly sublocalityLevel1: FieldController<string | null>;
    readonly locality: FieldController<string>;
    readonly administrativeAreaLevel3: FieldController<string | null>;
    readonly administrativeAreaLevel2: FieldController<string | null>;
    readonly administrativeAreaLevel1: FieldController<string>;
    readonly country: FieldController<string>;
    readonly postalCode: FieldController<string>;
    readonly postalCodeSuffix: FieldController<string | null>;
    readonly coordinates: FieldController<Coordinates>;
}
export interface SiteGigaform {
    readonly data: Site;
    readonly errors: SiteErrors;
    readonly tainted: SiteTainted;
    readonly fields: SiteFieldControllers;
    validate(): Exit<Site, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<Site>): void;
}
export function siteCreateForm(overrides?: Partial<Site>): SiteGigaform {
    let data = $state({
        ...siteDefaultValue(),
        ...overrides
    });
    let errors = $state<SiteErrors>({
        _errors: optionNone(),
        id: optionNone(),
        addressLine1: optionNone(),
        addressLine2: optionNone(),
        sublocalityLevel1: optionNone(),
        locality: optionNone(),
        administrativeAreaLevel3: optionNone(),
        administrativeAreaLevel2: optionNone(),
        administrativeAreaLevel1: optionNone(),
        country: optionNone(),
        postalCode: optionNone(),
        postalCodeSuffix: optionNone(),
        coordinates: optionNone()
    } as SiteErrors);
    let tainted = $state<SiteTainted>({
        id: optionNone(),
        addressLine1: optionNone(),
        addressLine2: optionNone(),
        sublocalityLevel1: optionNone(),
        locality: optionNone(),
        administrativeAreaLevel3: optionNone(),
        administrativeAreaLevel2: optionNone(),
        administrativeAreaLevel1: optionNone(),
        country: optionNone(),
        postalCode: optionNone(),
        postalCodeSuffix: optionNone(),
        coordinates: optionNone()
    } as SiteTainted);
    const fields = {
        id: {
            path: [
                "id"
            ] as const,
            name: "id",
            constraints: {
                required: true
            },
            get: ()=>data.id,
            set: (value: string)=>{
                data.id = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.id,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.id = value;
            },
            getTainted: ()=>tainted.id,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.id = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = siteValidateField("id", data.id);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        addressLine1: {
            path: [
                "addressLine1"
            ] as const,
            name: "addressLine1",
            constraints: {
                required: true
            },
            get: ()=>data.addressLine1,
            set: (value: string)=>{
                data.addressLine1 = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.addressLine1,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.addressLine1 = value;
            },
            getTainted: ()=>tainted.addressLine1,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.addressLine1 = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = siteValidateField("addressLine1", data.addressLine1);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        addressLine2: {
            path: [
                "addressLine2"
            ] as const,
            name: "addressLine2",
            constraints: {
                required: true
            },
            get: ()=>data.addressLine2,
            set: (value: string | null)=>{
                data.addressLine2 = value;
            },
            transform: (value: string | null): string | null =>value,
            getError: ()=>errors.addressLine2,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.addressLine2 = value;
            },
            getTainted: ()=>tainted.addressLine2,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.addressLine2 = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = siteValidateField("addressLine2", data.addressLine2);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        sublocalityLevel1: {
            path: [
                "sublocalityLevel1"
            ] as const,
            name: "sublocalityLevel1",
            constraints: {
                required: true
            },
            get: ()=>data.sublocalityLevel1,
            set: (value: string | null)=>{
                data.sublocalityLevel1 = value;
            },
            transform: (value: string | null): string | null =>value,
            getError: ()=>errors.sublocalityLevel1,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.sublocalityLevel1 = value;
            },
            getTainted: ()=>tainted.sublocalityLevel1,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.sublocalityLevel1 = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = siteValidateField("sublocalityLevel1", data.sublocalityLevel1);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        locality: {
            path: [
                "locality"
            ] as const,
            name: "locality",
            constraints: {
                required: true
            },
            get: ()=>data.locality,
            set: (value: string)=>{
                data.locality = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.locality,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.locality = value;
            },
            getTainted: ()=>tainted.locality,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.locality = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = siteValidateField("locality", data.locality);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        administrativeAreaLevel3: {
            path: [
                "administrativeAreaLevel3"
            ] as const,
            name: "administrativeAreaLevel3",
            constraints: {
                required: true
            },
            get: ()=>data.administrativeAreaLevel3,
            set: (value: string | null)=>{
                data.administrativeAreaLevel3 = value;
            },
            transform: (value: string | null): string | null =>value,
            getError: ()=>errors.administrativeAreaLevel3,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.administrativeAreaLevel3 = value;
            },
            getTainted: ()=>tainted.administrativeAreaLevel3,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.administrativeAreaLevel3 = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = siteValidateField("administrativeAreaLevel3", data.administrativeAreaLevel3);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        administrativeAreaLevel2: {
            path: [
                "administrativeAreaLevel2"
            ] as const,
            name: "administrativeAreaLevel2",
            constraints: {
                required: true
            },
            get: ()=>data.administrativeAreaLevel2,
            set: (value: string | null)=>{
                data.administrativeAreaLevel2 = value;
            },
            transform: (value: string | null): string | null =>value,
            getError: ()=>errors.administrativeAreaLevel2,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.administrativeAreaLevel2 = value;
            },
            getTainted: ()=>tainted.administrativeAreaLevel2,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.administrativeAreaLevel2 = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = siteValidateField("administrativeAreaLevel2", data.administrativeAreaLevel2);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        administrativeAreaLevel1: {
            path: [
                "administrativeAreaLevel1"
            ] as const,
            name: "administrativeAreaLevel1",
            constraints: {
                required: true
            },
            get: ()=>data.administrativeAreaLevel1,
            set: (value: string)=>{
                data.administrativeAreaLevel1 = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.administrativeAreaLevel1,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.administrativeAreaLevel1 = value;
            },
            getTainted: ()=>tainted.administrativeAreaLevel1,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.administrativeAreaLevel1 = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = siteValidateField("administrativeAreaLevel1", data.administrativeAreaLevel1);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        country: {
            path: [
                "country"
            ] as const,
            name: "country",
            constraints: {
                required: true
            },
            get: ()=>data.country,
            set: (value: string)=>{
                data.country = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.country,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.country = value;
            },
            getTainted: ()=>tainted.country,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.country = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = siteValidateField("country", data.country);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        postalCode: {
            path: [
                "postalCode"
            ] as const,
            name: "postalCode",
            constraints: {
                required: true
            },
            get: ()=>data.postalCode,
            set: (value: string)=>{
                data.postalCode = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.postalCode,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.postalCode = value;
            },
            getTainted: ()=>tainted.postalCode,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.postalCode = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = siteValidateField("postalCode", data.postalCode);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        postalCodeSuffix: {
            path: [
                "postalCodeSuffix"
            ] as const,
            name: "postalCodeSuffix",
            constraints: {
                required: true
            },
            get: ()=>data.postalCodeSuffix,
            set: (value: string | null)=>{
                data.postalCodeSuffix = value;
            },
            transform: (value: string | null): string | null =>value,
            getError: ()=>errors.postalCodeSuffix,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.postalCodeSuffix = value;
            },
            getTainted: ()=>tainted.postalCodeSuffix,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.postalCodeSuffix = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = siteValidateField("postalCodeSuffix", data.postalCodeSuffix);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        coordinates: {
            path: [
                "coordinates"
            ] as const,
            name: "coordinates",
            constraints: {
                required: true
            },
            get: ()=>data.coordinates,
            set: (value: Coordinates)=>{
                data.coordinates = value;
            },
            transform: (value: Coordinates): Coordinates =>value,
            getError: ()=>errors.coordinates,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.coordinates = value;
            },
            getTainted: ()=>tainted.coordinates,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.coordinates = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = siteValidateField("coordinates", data.coordinates);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        }
    } as SiteFieldControllers;
    const __gf_getter_hint = "get data() set data(v) get errors() set errors(v) get tainted() set tainted(v)";
    const __gf_validate_hint = ".map((e: { field: string; message: string }) => e.message)";
    function validate(): Exit<Site, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(siteDeserialize(data));
    }
    function reset(newOverrides?: Partial<Site>): void {
        data = {
            ...siteDefaultValue(),
            ...newOverrides
        };
        errors = {
            _errors: optionNone(),
            id: optionNone(),
            addressLine1: optionNone(),
            addressLine2: optionNone(),
            sublocalityLevel1: optionNone(),
            locality: optionNone(),
            administrativeAreaLevel3: optionNone(),
            administrativeAreaLevel2: optionNone(),
            administrativeAreaLevel1: optionNone(),
            country: optionNone(),
            postalCode: optionNone(),
            postalCodeSuffix: optionNone(),
            coordinates: optionNone()
        };
        tainted = {
            id: optionNone(),
            addressLine1: optionNone(),
            addressLine2: optionNone(),
            sublocalityLevel1: optionNone(),
            locality: optionNone(),
            administrativeAreaLevel3: optionNone(),
            administrativeAreaLevel2: optionNone(),
            administrativeAreaLevel1: optionNone(),
            country: optionNone(),
            postalCode: optionNone(),
            postalCodeSuffix: optionNone(),
            coordinates: optionNone()
        };
    }
    return {
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        fields,
        validate,
        reset
    };
}
export function siteFromFormData(formData: FormData): Exit<Site, Array<{
    field: string;
    message: string;
}>> {
    const obj: Record<string, unknown> = {};
    const __gf_exit_hint = "Exit<Site, Array<{ field: string; message: string }>>";
    obj.id = formData.get(`${"id"}`) ?? "";
    obj.addressLine1 = formData.get(`${"addressLine1"}`) ?? "";
    obj.addressLine2 = formData.get(`${"addressLine2"}`) ?? "";
    obj.sublocalityLevel1 = formData.get(`${"sublocalityLevel1"}`) ?? "";
    obj.locality = formData.get(`${"locality"}`) ?? "";
    obj.administrativeAreaLevel3 = formData.get(`${"administrativeAreaLevel3"}`) ?? "";
    obj.administrativeAreaLevel2 = formData.get(`${"administrativeAreaLevel2"}`) ?? "";
    obj.administrativeAreaLevel1 = formData.get(`${"administrativeAreaLevel1"}`) ?? "";
    obj.country = formData.get(`${"country"}`) ?? "";
    obj.postalCode = formData.get(`${"postalCode"}`) ?? "";
    obj.postalCodeSuffix = formData.get(`${"postalCodeSuffix"}`) ?? "";
    {
        const coordinatesObj: Record<string, unknown> = {};
        for (const [key, value] of Array.from(formData.entries())){
            if (key.startsWith(`${"coordinates"}.`)) {
                const fieldName = key.slice(`${"coordinates"}.`.length);
                const parts = fieldName.split(".");
                let current = coordinatesObj;
                for(let i = 0; i < parts.length - 1; i++){
                    const part = parts[i]!;
                    if (!(part in current)) {
                        current[part] = {};
                    }
                    current = current[part] as Record<string, unknown>;
                }
                current[parts[parts.length - 1]!] = value;
            }
        }
        obj.coordinates = coordinatesObj;
    }
    return toExit(siteDeserialize(obj));
}

export const Site = {
  defaultValue: siteDefaultValue,
  serialize: siteSerialize,
  serializeWithContext: siteSerializeWithContext,
  deserialize: siteDeserialize,
  deserializeWithContext: siteDeserializeWithContext,
  validateFields: siteValidateFields,
  hasShape: siteHasShape,
  is: siteIs,
  createForm: siteCreateForm,
  fromFormData: siteFromFormData
} as const;


export interface Metadata {
    createdAt: string;
    lastLogin: string | null;
    isActive: boolean;
    roles: Array<string>;
}

export function metadataDefaultValue(): Metadata {
    return {
        createdAt: "",
        lastLogin: null,
        isActive: false,
        roles: []
    } as Metadata;
}

export function metadataSerialize(value: Metadata): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(metadataSerializeWithContext(value, ctx));
}
export function metadataSerializeWithContext(value: Metadata, ctx: __mf_SerializeContext): Record<string, unknown> {
    const existingId = ctx.getId(value);
    if (existingId !== undefined) {
        return {
            __ref: existingId
        };
    }
    const __id = ctx.register(value);
    const result: Record<string, unknown> = {
        __type: "Metadata",
        __id
    };
    result.createdAt = value.createdAt;
    result.lastLogin = value.lastLogin;
    result.isActive = value.isActive;
    result.roles = value.roles;
    return result;
}

export function metadataDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: Metadata } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = metadataDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "Metadata.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function metadataDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Metadata | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
        throw new __mf_DeserializeError([
            {
                field: "_root",
                message: `${"Metadata"}.deserializeWithContext: expected an object`
            }
        ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (!("createdAt" in obj)) {
        errors.push({
            field: "createdAt",
            message: "missing required field"
        });
    }
    if (!("lastLogin" in obj)) {
        errors.push({
            field: "lastLogin",
            message: "missing required field"
        });
    }
    if (!("isActive" in obj)) {
        errors.push({
            field: "isActive",
            message: "missing required field"
        });
    }
    if (!("roles" in obj)) {
        errors.push({
            field: "roles",
            message: "missing required field"
        });
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
        ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
        const __raw_createdAt = obj["createdAt"] as string;
        instance.createdAt = __raw_createdAt;
    }
    {
        const __raw_lastLogin = obj["lastLogin"] as string | null;
        instance.lastLogin = __raw_lastLogin;
    }
    {
        const __raw_isActive = obj["isActive"] as boolean;
        instance.isActive = __raw_isActive;
    }
    {
        const __raw_roles = obj["roles"] as Array<string>;
        if (Array.isArray(__raw_roles)) {
            instance.roles = __raw_roles as string[];
        }
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    return instance as Metadata;
}
export function metadataValidateField<K extends keyof Metadata>(_field: K, _value: Metadata[K]): Array<{
    field: string;
    message: string;
}> {
    return [];
}
export function metadataValidateFields(_partial: Partial<Metadata>): Array<{
    field: string;
    message: string;
}> {
    return [];
}
export function metadataHasShape(obj: unknown): boolean {
    if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
        return false;
    }
    const o = obj as Record<string, unknown>;
    return '"createdAt" in o && "lastLogin" in o && "isActive" in o && "roles" in o';
}
export function metadataIs(obj: unknown): obj is Metadata {
    if (!metadataHasShape(obj)) {
        return false;
    }
    const result = metadataDeserialize(obj);
    return result.success;
}

export type MetadataErrors = {
    _errors: __gf_Option<Array<string>>;
    createdAt: __gf_Option<Array<string>>;
    lastLogin: __gf_Option<Array<string>>;
    isActive: __gf_Option<Array<string>>;
    roles: __gf_Option<Array<string>>;
};
export type MetadataTainted = {
    createdAt: __gf_Option<boolean>;
    lastLogin: __gf_Option<boolean>;
    isActive: __gf_Option<boolean>;
    roles: __gf_Option<boolean>;
};
export interface MetadataFieldControllers {
    readonly createdAt: FieldController<string>;
    readonly lastLogin: FieldController<string | null>;
    readonly isActive: FieldController<boolean>;
    readonly roles: ArrayFieldController<string>;
}
export interface MetadataGigaform {
    readonly data: Metadata;
    readonly errors: MetadataErrors;
    readonly tainted: MetadataTainted;
    readonly fields: MetadataFieldControllers;
    validate(): Exit<Metadata, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<Metadata>): void;
}
export function metadataCreateForm(overrides?: Partial<Metadata>): MetadataGigaform {
    let data = $state({
        ...metadataDefaultValue(),
        ...overrides
    });
    let errors = $state<MetadataErrors>({
        _errors: optionNone(),
        createdAt: optionNone(),
        lastLogin: optionNone(),
        isActive: optionNone(),
        roles: optionNone()
    } as MetadataErrors);
    let tainted = $state<MetadataTainted>({
        createdAt: optionNone(),
        lastLogin: optionNone(),
        isActive: optionNone(),
        roles: optionNone()
    } as MetadataTainted);
    const fields = {
        createdAt: {
            path: [
                "createdAt"
            ] as const,
            name: "createdAt",
            constraints: {
                required: true
            },
            get: ()=>data.createdAt,
            set: (value: string)=>{
                data.createdAt = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.createdAt,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.createdAt = value;
            },
            getTainted: ()=>tainted.createdAt,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.createdAt = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = metadataValidateField("createdAt", data.createdAt);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        lastLogin: {
            path: [
                "lastLogin"
            ] as const,
            name: "lastLogin",
            constraints: {
                required: true
            },
            get: ()=>data.lastLogin,
            set: (value: string | null)=>{
                data.lastLogin = value;
            },
            transform: (value: string | null): string | null =>value,
            getError: ()=>errors.lastLogin,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.lastLogin = value;
            },
            getTainted: ()=>tainted.lastLogin,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.lastLogin = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = metadataValidateField("lastLogin", data.lastLogin);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        isActive: {
            path: [
                "isActive"
            ] as const,
            name: "isActive",
            constraints: {
                required: true
            },
            get: ()=>data.isActive,
            set: (value: boolean)=>{
                data.isActive = value;
            },
            transform: (value: boolean): boolean =>value,
            getError: ()=>errors.isActive,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.isActive = value;
            },
            getTainted: ()=>tainted.isActive,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.isActive = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = metadataValidateField("isActive", data.isActive);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        roles: {
            path: [
                "roles"
            ] as const,
            name: "roles",
            constraints: {
                required: true
            },
            get: ()=>data.roles,
            set: (value: Array<string>)=>{
                data.roles = value;
            },
            transform: (value: Array<string>): Array<string> =>value,
            getError: ()=>errors.roles,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.roles = value;
            },
            getTainted: ()=>tainted.roles,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.roles = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = metadataValidateField("roles", data.roles);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            },
            at: (index: number)=>({
                    path: [
                        "roles",
                        index
                    ] as const,
                    name: "'^roles.${index}^'",
                    constraints: {
                        required: true
                    },
                    get: ()=>data.roles[index]!,
                    set: (value: string)=>{
                        data.roles[index] = value;
                    },
                    transform: (value: string): string =>value,
                    getError: ()=>errors.roles,
                    setError: (value: __gf_Option<Array<string>>)=>{
                        errors.roles = value;
                    },
                    getTainted: ()=>tainted.roles,
                    setTainted: (value: __gf_Option<boolean>)=>{
                        tainted.roles = value;
                    },
                    validate: (): Array<string> =>[]
                }),
            push: (item: string)=>{
                data.roles.push(item);
            },
            remove: (index: number)=>{
                data.roles.splice(index, 1);
            },
            swap: (a: number, b: number)=>{
                const tmp = data.roles[a]!;
                data.roles[a] = data.roles[b]!;
                data.roles[b] = tmp;
            }
        }
    } as MetadataFieldControllers;
    const __gf_getter_hint = "get data() set data(v) get errors() set errors(v) get tainted() set tainted(v)";
    const __gf_validate_hint = ".map((e: { field: string; message: string }) => e.message)";
    function validate(): Exit<Metadata, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(metadataDeserialize(data));
    }
    function reset(newOverrides?: Partial<Metadata>): void {
        data = {
            ...metadataDefaultValue(),
            ...newOverrides
        };
        errors = {
            _errors: optionNone(),
            createdAt: optionNone(),
            lastLogin: optionNone(),
            isActive: optionNone(),
            roles: optionNone()
        };
        tainted = {
            createdAt: optionNone(),
            lastLogin: optionNone(),
            isActive: optionNone(),
            roles: optionNone()
        };
    }
    return {
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        fields,
        validate,
        reset
    };
}
export function metadataFromFormData(formData: FormData): Exit<Metadata, Array<{
    field: string;
    message: string;
}>> {
    const obj: Record<string, unknown> = {};
    const __gf_exit_hint = "Exit<Metadata, Array<{ field: string; message: string }>>";
    obj.createdAt = formData.get(`${"createdAt"}`) ?? "";
    obj.lastLogin = formData.get(`${"lastLogin"}`) ?? "";
    {
        const isActiveVal = formData.get(`${"isActive"}`);
        obj.isActive = isActiveVal === "true" || isActiveVal === "on" || isActiveVal === "1";
    }
    obj.roles = formData.getAll(`${"roles"}`) as Array<string>;
    return toExit(metadataDeserialize(obj));
}

export const Metadata = {
  defaultValue: metadataDefaultValue,
  serialize: metadataSerialize,
  serializeWithContext: metadataSerializeWithContext,
  deserialize: metadataDeserialize,
  deserializeWithContext: metadataDeserializeWithContext,
  validateFields: metadataValidateFields,
  hasShape: metadataHasShape,
  is: metadataIs,
  createForm: metadataCreateForm,
  fromFormData: metadataFromFormData
} as const;


export interface ColumnConfig {
    
    heading: string;
    dataPath: DataPath;
}

export function columnConfigDefaultValue(): ColumnConfig {
    return {
        heading: "",
        dataPath: dataPathDefaultValue()
    } as ColumnConfig;
}

export function columnConfigSerialize(value: ColumnConfig): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(columnConfigSerializeWithContext(value, ctx));
}
export function columnConfigSerializeWithContext(value: ColumnConfig, ctx: __mf_SerializeContext): Record<string, unknown> {
    const existingId = ctx.getId(value);
    if (existingId !== undefined) {
        return {
            __ref: existingId
        };
    }
    const __id = ctx.register(value);
    const result: Record<string, unknown> = {
        __type: "ColumnConfig",
        __id
    };
    result.heading = value.heading;
    result.dataPath = dataPathSerializeWithContext(value.dataPath, ctx);
    return result;
}

export function columnConfigDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: ColumnConfig } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = columnConfigDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "ColumnConfig.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function columnConfigDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): ColumnConfig | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
        throw new __mf_DeserializeError([
            {
                field: "_root",
                message: `${"ColumnConfig"}.deserializeWithContext: expected an object`
            }
        ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (!("heading" in obj)) {
        errors.push({
            field: "heading",
            message: "missing required field"
        });
    }
    if (!("dataPath" in obj)) {
        errors.push({
            field: "dataPath",
            message: "missing required field"
        });
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
        ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
        const __raw_heading = obj["heading"] as string;
        if (__raw_heading.trim().length === 0) {
            errors.push({
                field: "heading",
                message: "ColumnConfig.heading must not be empty"
            });
        }
        instance.heading = __raw_heading;
    }
    {
        const __raw_dataPath = obj["dataPath"] as DataPath;
        {
            const __result = dataPathDeserializeWithContext(__raw_dataPath, ctx);
            ctx.assignOrDefer(instance, "dataPath", __result);
        }
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    return instance as ColumnConfig;
}
export function columnConfigValidateField<K extends keyof ColumnConfig>(_field: K, _value: ColumnConfig[K]): Array<{
    field: string;
    message: string;
}> {
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (_field === "heading") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "heading",
                message: "ColumnConfig.heading must not be empty"
            });
        }
    }
    return errors;
}
export function columnConfigValidateFields(_partial: Partial<ColumnConfig>): Array<{
    field: string;
    message: string;
}> {
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if ("heading" in _partial && _partial.heading !== undefined) {
        const __val = _partial.heading as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "heading",
                message: "ColumnConfig.heading must not be empty"
            });
        }
    }
    return errors;
}
export function columnConfigHasShape(obj: unknown): boolean {
    if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
        return false;
    }
    const o = obj as Record<string, unknown>;
    return '"heading" in o && "dataPath" in o';
}
export function columnConfigIs(obj: unknown): obj is ColumnConfig {
    if (!columnConfigHasShape(obj)) {
        return false;
    }
    const result = columnConfigDeserialize(obj);
    return result.success;
}

export type ColumnConfigErrors = {
    _errors: __gf_Option<Array<string>>;
    heading: __gf_Option<Array<string>>;
    dataPath: __gf_Option<Array<string>>;
};
export type ColumnConfigTainted = {
    heading: __gf_Option<boolean>;
    dataPath: __gf_Option<boolean>;
};
export interface ColumnConfigFieldControllers {
    readonly heading: FieldController<string>;
    readonly dataPath: FieldController<DataPath>;
}
export interface ColumnConfigGigaform {
    readonly data: ColumnConfig;
    readonly errors: ColumnConfigErrors;
    readonly tainted: ColumnConfigTainted;
    readonly fields: ColumnConfigFieldControllers;
    validate(): Exit<ColumnConfig, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<ColumnConfig>): void;
}
export function columnConfigCreateForm(overrides?: Partial<ColumnConfig>): ColumnConfigGigaform {
    let data = $state({
        ...columnConfigDefaultValue(),
        ...overrides
    });
    let errors = $state<ColumnConfigErrors>({
        _errors: optionNone(),
        heading: optionNone(),
        dataPath: optionNone()
    } as ColumnConfigErrors);
    let tainted = $state<ColumnConfigTainted>({
        heading: optionNone(),
        dataPath: optionNone()
    } as ColumnConfigTainted);
    const fields = {
        heading: {
            path: [
                "heading"
            ] as const,
            name: "heading",
            constraints: {
                required: true
            },
            get: ()=>data.heading,
            set: (value: string)=>{
                data.heading = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.heading,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.heading = value;
            },
            getTainted: ()=>tainted.heading,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.heading = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = columnConfigValidateField("heading", data.heading);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        dataPath: {
            path: [
                "dataPath"
            ] as const,
            name: "dataPath",
            constraints: {
                required: true
            },
            get: ()=>data.dataPath,
            set: (value: DataPath)=>{
                data.dataPath = value;
            },
            transform: (value: DataPath): DataPath =>value,
            getError: ()=>errors.dataPath,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.dataPath = value;
            },
            getTainted: ()=>tainted.dataPath,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.dataPath = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = columnConfigValidateField("dataPath", data.dataPath);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        }
    } as ColumnConfigFieldControllers;
    const __gf_getter_hint = "get data() set data(v) get errors() set errors(v) get tainted() set tainted(v)";
    const __gf_validate_hint = ".map((e: { field: string; message: string }) => e.message)";
    function validate(): Exit<ColumnConfig, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(columnConfigDeserialize(data));
    }
    function reset(newOverrides?: Partial<ColumnConfig>): void {
        data = {
            ...columnConfigDefaultValue(),
            ...newOverrides
        };
        errors = {
            _errors: optionNone(),
            heading: optionNone(),
            dataPath: optionNone()
        };
        tainted = {
            heading: optionNone(),
            dataPath: optionNone()
        };
    }
    return {
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        fields,
        validate,
        reset
    };
}
export function columnConfigFromFormData(formData: FormData): Exit<ColumnConfig, Array<{
    field: string;
    message: string;
}>> {
    const obj: Record<string, unknown> = {};
    const __gf_exit_hint = "Exit<ColumnConfig, Array<{ field: string; message: string }>>";
    obj.heading = formData.get(`${"heading"}`) ?? "";
    {
        const dataPathObj: Record<string, unknown> = {};
        for (const [key, value] of Array.from(formData.entries())){
            if (key.startsWith(`${"dataPath"}.`)) {
                const fieldName = key.slice(`${"dataPath"}.`.length);
                const parts = fieldName.split(".");
                let current = dataPathObj;
                for(let i = 0; i < parts.length - 1; i++){
                    const part = parts[i]!;
                    if (!(part in current)) {
                        current[part] = {};
                    }
                    current = current[part] as Record<string, unknown>;
                }
                current[parts[parts.length - 1]!] = value;
            }
        }
        obj.dataPath = dataPathObj;
    }
    return toExit(columnConfigDeserialize(obj));
}

export const ColumnConfig = {
  defaultValue: columnConfigDefaultValue,
  serialize: columnConfigSerialize,
  serializeWithContext: columnConfigSerializeWithContext,
  deserialize: columnConfigDeserialize,
  deserializeWithContext: columnConfigDeserializeWithContext,
  validateFields: columnConfigValidateFields,
  hasShape: columnConfigHasShape,
  is: columnConfigIs,
  createForm: columnConfigCreateForm,
  fromFormData: columnConfigFromFormData
} as const;


export interface PhoneNumber {
    
    main: boolean;
    
    
    phoneType: string;
    
    
    number: string;
    
    canText: boolean;
    
    canCall: boolean;
}

export function phoneNumberDefaultValue(): PhoneNumber {
    return {
        main: false,
        phoneType: "",
        number: "",
        canText: false,
        canCall: false
    } as PhoneNumber;
}

export function phoneNumberSerialize(value: PhoneNumber): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(phoneNumberSerializeWithContext(value, ctx));
}
export function phoneNumberSerializeWithContext(value: PhoneNumber, ctx: __mf_SerializeContext): Record<string, unknown> {
    const existingId = ctx.getId(value);
    if (existingId !== undefined) {
        return {
            __ref: existingId
        };
    }
    const __id = ctx.register(value);
    const result: Record<string, unknown> = {
        __type: "PhoneNumber",
        __id
    };
    result.main = value.main;
    result.phoneType = value.phoneType;
    result.number = value.number;
    result.canText = value.canText;
    result.canCall = value.canCall;
    return result;
}

export function phoneNumberDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: PhoneNumber } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = phoneNumberDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "PhoneNumber.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function phoneNumberDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): PhoneNumber | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
        throw new __mf_DeserializeError([
            {
                field: "_root",
                message: `${"PhoneNumber"}.deserializeWithContext: expected an object`
            }
        ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (!("main" in obj)) {
        errors.push({
            field: "main",
            message: "missing required field"
        });
    }
    if (!("phoneType" in obj)) {
        errors.push({
            field: "phoneType",
            message: "missing required field"
        });
    }
    if (!("number" in obj)) {
        errors.push({
            field: "number",
            message: "missing required field"
        });
    }
    if (!("canText" in obj)) {
        errors.push({
            field: "canText",
            message: "missing required field"
        });
    }
    if (!("canCall" in obj)) {
        errors.push({
            field: "canCall",
            message: "missing required field"
        });
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
        ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
        const __raw_main = obj["main"] as boolean;
        instance.main = __raw_main;
    }
    {
        const __raw_phoneType = obj["phoneType"] as string;
        if (__raw_phoneType.trim().length === 0) {
            errors.push({
                field: "phoneType",
                message: "PhoneNumber.phoneType must not be empty"
            });
        }
        instance.phoneType = __raw_phoneType;
    }
    {
        const __raw_number = obj["number"] as string;
        if (__raw_number.trim().length === 0) {
            errors.push({
                field: "number",
                message: "PhoneNumber.number must not be empty"
            });
        }
        instance.number = __raw_number;
    }
    {
        const __raw_canText = obj["canText"] as boolean;
        instance.canText = __raw_canText;
    }
    {
        const __raw_canCall = obj["canCall"] as boolean;
        instance.canCall = __raw_canCall;
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    return instance as PhoneNumber;
}
export function phoneNumberValidateField<K extends keyof PhoneNumber>(_field: K, _value: PhoneNumber[K]): Array<{
    field: string;
    message: string;
}> {
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (_field === "phoneType") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "phoneType",
                message: "PhoneNumber.phoneType must not be empty"
            });
        }
    }
    if (_field === "number") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "number",
                message: "PhoneNumber.number must not be empty"
            });
        }
    }
    return errors;
}
export function phoneNumberValidateFields(_partial: Partial<PhoneNumber>): Array<{
    field: string;
    message: string;
}> {
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if ("phoneType" in _partial && _partial.phoneType !== undefined) {
        const __val = _partial.phoneType as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "phoneType",
                message: "PhoneNumber.phoneType must not be empty"
            });
        }
    }
    if ("number" in _partial && _partial.number !== undefined) {
        const __val = _partial.number as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "number",
                message: "PhoneNumber.number must not be empty"
            });
        }
    }
    return errors;
}
export function phoneNumberHasShape(obj: unknown): boolean {
    if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
        return false;
    }
    const o = obj as Record<string, unknown>;
    return '"main" in o && "phoneType" in o && "number" in o && "canText" in o && "canCall" in o';
}
export function phoneNumberIs(obj: unknown): obj is PhoneNumber {
    if (!phoneNumberHasShape(obj)) {
        return false;
    }
    const result = phoneNumberDeserialize(obj);
    return result.success;
}

export type PhoneNumberErrors = {
    _errors: __gf_Option<Array<string>>;
    main: __gf_Option<Array<string>>;
    phoneType: __gf_Option<Array<string>>;
    number: __gf_Option<Array<string>>;
    canText: __gf_Option<Array<string>>;
    canCall: __gf_Option<Array<string>>;
};
export type PhoneNumberTainted = {
    main: __gf_Option<boolean>;
    phoneType: __gf_Option<boolean>;
    number: __gf_Option<boolean>;
    canText: __gf_Option<boolean>;
    canCall: __gf_Option<boolean>;
};
export interface PhoneNumberFieldControllers {
    readonly main: FieldController<boolean>;
    readonly phoneType: FieldController<string>;
    readonly number: FieldController<string>;
    readonly canText: FieldController<boolean>;
    readonly canCall: FieldController<boolean>;
}
export interface PhoneNumberGigaform {
    readonly data: PhoneNumber;
    readonly errors: PhoneNumberErrors;
    readonly tainted: PhoneNumberTainted;
    readonly fields: PhoneNumberFieldControllers;
    validate(): Exit<PhoneNumber, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<PhoneNumber>): void;
}
export function phoneNumberCreateForm(overrides?: Partial<PhoneNumber>): PhoneNumberGigaform {
    let data = $state({
        ...phoneNumberDefaultValue(),
        ...overrides
    });
    let errors = $state<PhoneNumberErrors>({
        _errors: optionNone(),
        main: optionNone(),
        phoneType: optionNone(),
        number: optionNone(),
        canText: optionNone(),
        canCall: optionNone()
    } as PhoneNumberErrors);
    let tainted = $state<PhoneNumberTainted>({
        main: optionNone(),
        phoneType: optionNone(),
        number: optionNone(),
        canText: optionNone(),
        canCall: optionNone()
    } as PhoneNumberTainted);
    const fields = {
        main: {
            path: [
                "main"
            ] as const,
            name: "main",
            constraints: {
                required: true
            },
            label: "Main",
            get: ()=>data.main,
            set: (value: boolean)=>{
                data.main = value;
            },
            transform: (value: boolean): boolean =>value,
            getError: ()=>errors.main,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.main = value;
            },
            getTainted: ()=>tainted.main,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.main = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = phoneNumberValidateField("main", data.main);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        phoneType: {
            path: [
                "phoneType"
            ] as const,
            name: "phoneType",
            constraints: {
                required: true
            },
            label: "Phone Type",
            get: ()=>data.phoneType,
            set: (value: string)=>{
                data.phoneType = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.phoneType,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.phoneType = value;
            },
            getTainted: ()=>tainted.phoneType,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.phoneType = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = phoneNumberValidateField("phoneType", data.phoneType);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        number: {
            path: [
                "number"
            ] as const,
            name: "number",
            constraints: {
                required: true
            },
            label: "Number",
            get: ()=>data.number,
            set: (value: string)=>{
                data.number = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.number,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.number = value;
            },
            getTainted: ()=>tainted.number,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.number = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = phoneNumberValidateField("number", data.number);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        canText: {
            path: [
                "canText"
            ] as const,
            name: "canText",
            constraints: {
                required: true
            },
            label: "Can Text",
            get: ()=>data.canText,
            set: (value: boolean)=>{
                data.canText = value;
            },
            transform: (value: boolean): boolean =>value,
            getError: ()=>errors.canText,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.canText = value;
            },
            getTainted: ()=>tainted.canText,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.canText = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = phoneNumberValidateField("canText", data.canText);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        canCall: {
            path: [
                "canCall"
            ] as const,
            name: "canCall",
            constraints: {
                required: true
            },
            label: "Can Call",
            get: ()=>data.canCall,
            set: (value: boolean)=>{
                data.canCall = value;
            },
            transform: (value: boolean): boolean =>value,
            getError: ()=>errors.canCall,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.canCall = value;
            },
            getTainted: ()=>tainted.canCall,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.canCall = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = phoneNumberValidateField("canCall", data.canCall);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        }
    } as PhoneNumberFieldControllers;
    const __gf_getter_hint = "get data() set data(v) get errors() set errors(v) get tainted() set tainted(v)";
    const __gf_validate_hint = ".map((e: { field: string; message: string }) => e.message)";
    function validate(): Exit<PhoneNumber, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(phoneNumberDeserialize(data));
    }
    function reset(newOverrides?: Partial<PhoneNumber>): void {
        data = {
            ...phoneNumberDefaultValue(),
            ...newOverrides
        };
        errors = {
            _errors: optionNone(),
            main: optionNone(),
            phoneType: optionNone(),
            number: optionNone(),
            canText: optionNone(),
            canCall: optionNone()
        };
        tainted = {
            main: optionNone(),
            phoneType: optionNone(),
            number: optionNone(),
            canText: optionNone(),
            canCall: optionNone()
        };
    }
    return {
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        fields,
        validate,
        reset
    };
}
export function phoneNumberFromFormData(formData: FormData): Exit<PhoneNumber, Array<{
    field: string;
    message: string;
}>> {
    const obj: Record<string, unknown> = {};
    const __gf_exit_hint = "Exit<PhoneNumber, Array<{ field: string; message: string }>>";
    {
        const mainVal = formData.get(`${"main"}`);
        obj.main = mainVal === "true" || mainVal === "on" || mainVal === "1";
    }
    obj.phoneType = formData.get(`${"phoneType"}`) ?? "";
    obj.number = formData.get(`${"number"}`) ?? "";
    {
        const canTextVal = formData.get(`${"canText"}`);
        obj.canText = canTextVal === "true" || canTextVal === "on" || canTextVal === "1";
    }
    {
        const canCallVal = formData.get(`${"canCall"}`);
        obj.canCall = canCallVal === "true" || canCallVal === "on" || canCallVal === "1";
    }
    return toExit(phoneNumberDeserialize(obj));
}

export const PhoneNumber = {
  defaultValue: phoneNumberDefaultValue,
  serialize: phoneNumberSerialize,
  serializeWithContext: phoneNumberSerializeWithContext,
  deserialize: phoneNumberDeserialize,
  deserializeWithContext: phoneNumberDeserializeWithContext,
  validateFields: phoneNumberValidateFields,
  hasShape: phoneNumberHasShape,
  is: phoneNumberIs,
  createForm: phoneNumberCreateForm,
  fromFormData: phoneNumberFromFormData
} as const;


export interface Gradient {
    startHue: number;
}

export function gradientDefaultValue(): Gradient {
    return {
        startHue: 0
    } as Gradient;
}

export function gradientSerialize(value: Gradient): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(gradientSerializeWithContext(value, ctx));
}
export function gradientSerializeWithContext(value: Gradient, ctx: __mf_SerializeContext): Record<string, unknown> {
    const existingId = ctx.getId(value);
    if (existingId !== undefined) {
        return {
            __ref: existingId
        };
    }
    const __id = ctx.register(value);
    const result: Record<string, unknown> = {
        __type: "Gradient",
        __id
    };
    result.startHue = value.startHue;
    return result;
}

export function gradientDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: Gradient } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = gradientDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "Gradient.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function gradientDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Gradient | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
        throw new __mf_DeserializeError([
            {
                field: "_root",
                message: `${"Gradient"}.deserializeWithContext: expected an object`
            }
        ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (!("startHue" in obj)) {
        errors.push({
            field: "startHue",
            message: "missing required field"
        });
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
        ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
        const __raw_startHue = obj["startHue"] as number;
        instance.startHue = __raw_startHue;
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    return instance as Gradient;
}
export function gradientValidateField<K extends keyof Gradient>(_field: K, _value: Gradient[K]): Array<{
    field: string;
    message: string;
}> {
    return [];
}
export function gradientValidateFields(_partial: Partial<Gradient>): Array<{
    field: string;
    message: string;
}> {
    return [];
}
export function gradientHasShape(obj: unknown): boolean {
    if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
        return false;
    }
    const o = obj as Record<string, unknown>;
    return '"startHue" in o';
}
export function gradientIs(obj: unknown): obj is Gradient {
    if (!gradientHasShape(obj)) {
        return false;
    }
    const result = gradientDeserialize(obj);
    return result.success;
}

export type GradientErrors = {
    _errors: __gf_Option<Array<string>>;
    startHue: __gf_Option<Array<string>>;
};
export type GradientTainted = {
    startHue: __gf_Option<boolean>;
};
export interface GradientFieldControllers {
    readonly startHue: FieldController<number>;
}
export interface GradientGigaform {
    readonly data: Gradient;
    readonly errors: GradientErrors;
    readonly tainted: GradientTainted;
    readonly fields: GradientFieldControllers;
    validate(): Exit<Gradient, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<Gradient>): void;
}
export function gradientCreateForm(overrides?: Partial<Gradient>): GradientGigaform {
    let data = $state({
        ...gradientDefaultValue(),
        ...overrides
    });
    let errors = $state<GradientErrors>({
        _errors: optionNone(),
        startHue: optionNone()
    } as GradientErrors);
    let tainted = $state<GradientTainted>({
        startHue: optionNone()
    } as GradientTainted);
    const fields = {
        startHue: {
            path: [
                "startHue"
            ] as const,
            name: "startHue",
            constraints: {
                required: true
            },
            get: ()=>data.startHue,
            set: (value: number)=>{
                data.startHue = value;
            },
            transform: (value: number): number =>value,
            getError: ()=>errors.startHue,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.startHue = value;
            },
            getTainted: ()=>tainted.startHue,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.startHue = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = gradientValidateField("startHue", data.startHue);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        }
    } as GradientFieldControllers;
    const __gf_getter_hint = "get data() set data(v) get errors() set errors(v) get tainted() set tainted(v)";
    const __gf_validate_hint = ".map((e: { field: string; message: string }) => e.message)";
    function validate(): Exit<Gradient, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(gradientDeserialize(data));
    }
    function reset(newOverrides?: Partial<Gradient>): void {
        data = {
            ...gradientDefaultValue(),
            ...newOverrides
        };
        errors = {
            _errors: optionNone(),
            startHue: optionNone()
        };
        tainted = {
            startHue: optionNone()
        };
    }
    return {
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        fields,
        validate,
        reset
    };
}
export function gradientFromFormData(formData: FormData): Exit<Gradient, Array<{
    field: string;
    message: string;
}>> {
    const obj: Record<string, unknown> = {};
    const __gf_exit_hint = "Exit<Gradient, Array<{ field: string; message: string }>>";
    {
        const startHueStr = formData.get(`${"startHue"}`);
        obj.startHue = startHueStr ? parseFloat(startHueStr as string) : $MfPh5;
        if (obj.startHue !== undefined && isNaN(obj.startHue as number)) obj.startHue = "0";
    }
    return toExit(gradientDeserialize(obj));
}

export const Gradient = {
  defaultValue: gradientDefaultValue,
  serialize: gradientSerialize,
  serializeWithContext: gradientSerializeWithContext,
  deserialize: gradientDeserialize,
  deserializeWithContext: gradientDeserializeWithContext,
  validateFields: gradientValidateFields,
  hasShape: gradientHasShape,
  is: gradientIs,
  createForm: gradientCreateForm,
  fromFormData: gradientFromFormData
} as const;


export interface Product {
    
    id: string;
    
    
    name: string;
    
    
    quickCode: string;
    
    group: string | null;
    
    subgroup: string | null;
    
    unit: string | null;
    
    active: boolean;
    
    commission: boolean;
    
    favorite: boolean;
    defaults: ProductDefaults;
}

export function productDefaultValue(): Product {
    return {
        id: "",
        name: "",
        quickCode: "",
        group: null,
        subgroup: null,
        unit: null,
        active: false,
        commission: false,
        favorite: false,
        defaults: productDefaultsDefaultValue()
    } as Product;
}

export function productSerialize(value: Product): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(productSerializeWithContext(value, ctx));
}
export function productSerializeWithContext(value: Product, ctx: __mf_SerializeContext): Record<string, unknown> {
    const existingId = ctx.getId(value);
    if (existingId !== undefined) {
        return {
            __ref: existingId
        };
    }
    const __id = ctx.register(value);
    const result: Record<string, unknown> = {
        __type: "Product",
        __id
    };
    result.id = value.id;
    result.name = value.name;
    result.quickCode = value.quickCode;
    result.group = value.group;
    result.subgroup = value.subgroup;
    result.unit = value.unit;
    result.active = value.active;
    result.commission = value.commission;
    result.favorite = value.favorite;
    result.defaults = productDefaultsSerializeWithContext(value.defaults, ctx);
    return result;
}

export function productDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: Product } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = productDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "Product.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function productDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Product | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
        throw new __mf_DeserializeError([
            {
                field: "_root",
                message: `${"Product"}.deserializeWithContext: expected an object`
            }
        ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (!("id" in obj)) {
        errors.push({
            field: "id",
            message: "missing required field"
        });
    }
    if (!("name" in obj)) {
        errors.push({
            field: "name",
            message: "missing required field"
        });
    }
    if (!("quickCode" in obj)) {
        errors.push({
            field: "quickCode",
            message: "missing required field"
        });
    }
    if (!("group" in obj)) {
        errors.push({
            field: "group",
            message: "missing required field"
        });
    }
    if (!("subgroup" in obj)) {
        errors.push({
            field: "subgroup",
            message: "missing required field"
        });
    }
    if (!("unit" in obj)) {
        errors.push({
            field: "unit",
            message: "missing required field"
        });
    }
    if (!("active" in obj)) {
        errors.push({
            field: "active",
            message: "missing required field"
        });
    }
    if (!("commission" in obj)) {
        errors.push({
            field: "commission",
            message: "missing required field"
        });
    }
    if (!("favorite" in obj)) {
        errors.push({
            field: "favorite",
            message: "missing required field"
        });
    }
    if (!("defaults" in obj)) {
        errors.push({
            field: "defaults",
            message: "missing required field"
        });
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
        ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
        const __raw_id = obj["id"] as string;
        instance.id = __raw_id;
    }
    {
        const __raw_name = obj["name"] as string;
        if (__raw_name.trim().length === 0) {
            errors.push({
                field: "name",
                message: "Product.name must not be empty"
            });
        }
        instance.name = __raw_name;
    }
    {
        const __raw_quickCode = obj["quickCode"] as string;
        if (__raw_quickCode.trim().length === 0) {
            errors.push({
                field: "quickCode",
                message: "Product.quickCode must not be empty"
            });
        }
        instance.quickCode = __raw_quickCode;
    }
    {
        const __raw_group = obj["group"] as string | null;
        instance.group = __raw_group;
    }
    {
        const __raw_subgroup = obj["subgroup"] as string | null;
        instance.subgroup = __raw_subgroup;
    }
    {
        const __raw_unit = obj["unit"] as string | null;
        instance.unit = __raw_unit;
    }
    {
        const __raw_active = obj["active"] as boolean;
        instance.active = __raw_active;
    }
    {
        const __raw_commission = obj["commission"] as boolean;
        instance.commission = __raw_commission;
    }
    {
        const __raw_favorite = obj["favorite"] as boolean;
        instance.favorite = __raw_favorite;
    }
    {
        const __raw_defaults = obj["defaults"] as ProductDefaults;
        {
            const __result = productDefaultsDeserializeWithContext(__raw_defaults, ctx);
            ctx.assignOrDefer(instance, "defaults", __result);
        }
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    return instance as Product;
}
export function productValidateField<K extends keyof Product>(_field: K, _value: Product[K]): Array<{
    field: string;
    message: string;
}> {
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (_field === "name") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "name",
                message: "Product.name must not be empty"
            });
        }
    }
    if (_field === "quickCode") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "quickCode",
                message: "Product.quickCode must not be empty"
            });
        }
    }
    return errors;
}
export function productValidateFields(_partial: Partial<Product>): Array<{
    field: string;
    message: string;
}> {
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if ("name" in _partial && _partial.name !== undefined) {
        const __val = _partial.name as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "name",
                message: "Product.name must not be empty"
            });
        }
    }
    if ("quickCode" in _partial && _partial.quickCode !== undefined) {
        const __val = _partial.quickCode as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "quickCode",
                message: "Product.quickCode must not be empty"
            });
        }
    }
    return errors;
}
export function productHasShape(obj: unknown): boolean {
    if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
        return false;
    }
    const o = obj as Record<string, unknown>;
    return '"id" in o && "name" in o && "quickCode" in o && "group" in o && "subgroup" in o && "unit" in o && "active" in o && "commission" in o && "favorite" in o && "defaults" in o';
}
export function productIs(obj: unknown): obj is Product {
    if (!productHasShape(obj)) {
        return false;
    }
    const result = productDeserialize(obj);
    return result.success;
}

export type ProductErrors = {
    _errors: __gf_Option<Array<string>>;
    id: __gf_Option<Array<string>>;
    name: __gf_Option<Array<string>>;
    quickCode: __gf_Option<Array<string>>;
    group: __gf_Option<Array<string>>;
    subgroup: __gf_Option<Array<string>>;
    unit: __gf_Option<Array<string>>;
    active: __gf_Option<Array<string>>;
    commission: __gf_Option<Array<string>>;
    favorite: __gf_Option<Array<string>>;
    defaults: __gf_Option<Array<string>>;
};
export type ProductTainted = {
    id: __gf_Option<boolean>;
    name: __gf_Option<boolean>;
    quickCode: __gf_Option<boolean>;
    group: __gf_Option<boolean>;
    subgroup: __gf_Option<boolean>;
    unit: __gf_Option<boolean>;
    active: __gf_Option<boolean>;
    commission: __gf_Option<boolean>;
    favorite: __gf_Option<boolean>;
    defaults: __gf_Option<boolean>;
};
export interface ProductFieldControllers {
    readonly id: FieldController<string>;
    readonly name: FieldController<string>;
    readonly quickCode: FieldController<string>;
    readonly group: FieldController<string | null>;
    readonly subgroup: FieldController<string | null>;
    readonly unit: FieldController<string | null>;
    readonly active: FieldController<boolean>;
    readonly commission: FieldController<boolean>;
    readonly favorite: FieldController<boolean>;
    readonly defaults: FieldController<ProductDefaults>;
}
export interface ProductGigaform {
    readonly data: Product;
    readonly errors: ProductErrors;
    readonly tainted: ProductTainted;
    readonly fields: ProductFieldControllers;
    validate(): Exit<Product, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<Product>): void;
}
export function productCreateForm(overrides?: Partial<Product>): ProductGigaform {
    let data = $state({
        ...productDefaultValue(),
        ...overrides
    });
    let errors = $state<ProductErrors>({
        _errors: optionNone(),
        id: optionNone(),
        name: optionNone(),
        quickCode: optionNone(),
        group: optionNone(),
        subgroup: optionNone(),
        unit: optionNone(),
        active: optionNone(),
        commission: optionNone(),
        favorite: optionNone(),
        defaults: optionNone()
    } as ProductErrors);
    let tainted = $state<ProductTainted>({
        id: optionNone(),
        name: optionNone(),
        quickCode: optionNone(),
        group: optionNone(),
        subgroup: optionNone(),
        unit: optionNone(),
        active: optionNone(),
        commission: optionNone(),
        favorite: optionNone(),
        defaults: optionNone()
    } as ProductTainted);
    const fields = {
        id: {
            path: [
                "id"
            ] as const,
            name: "id",
            constraints: {
                required: true
            },
            get: ()=>data.id,
            set: (value: string)=>{
                data.id = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.id,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.id = value;
            },
            getTainted: ()=>tainted.id,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.id = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = productValidateField("id", data.id);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        name: {
            path: [
                "name"
            ] as const,
            name: "name",
            constraints: {
                required: true
            },
            label: "Name",
            get: ()=>data.name,
            set: (value: string)=>{
                data.name = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.name,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.name = value;
            },
            getTainted: ()=>tainted.name,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.name = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = productValidateField("name", data.name);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        quickCode: {
            path: [
                "quickCode"
            ] as const,
            name: "quickCode",
            constraints: {
                required: true
            },
            label: "Quick Code",
            get: ()=>data.quickCode,
            set: (value: string)=>{
                data.quickCode = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.quickCode,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.quickCode = value;
            },
            getTainted: ()=>tainted.quickCode,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.quickCode = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = productValidateField("quickCode", data.quickCode);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        group: {
            path: [
                "group"
            ] as const,
            name: "group",
            constraints: {
                required: true
            },
            label: "Group",
            get: ()=>data.group,
            set: (value: string | null)=>{
                data.group = value;
            },
            transform: (value: string | null): string | null =>value,
            getError: ()=>errors.group,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.group = value;
            },
            getTainted: ()=>tainted.group,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.group = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = productValidateField("group", data.group);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        subgroup: {
            path: [
                "subgroup"
            ] as const,
            name: "subgroup",
            constraints: {
                required: true
            },
            label: "Subgroup",
            get: ()=>data.subgroup,
            set: (value: string | null)=>{
                data.subgroup = value;
            },
            transform: (value: string | null): string | null =>value,
            getError: ()=>errors.subgroup,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.subgroup = value;
            },
            getTainted: ()=>tainted.subgroup,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.subgroup = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = productValidateField("subgroup", data.subgroup);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        unit: {
            path: [
                "unit"
            ] as const,
            name: "unit",
            constraints: {
                required: true
            },
            label: "Unit",
            get: ()=>data.unit,
            set: (value: string | null)=>{
                data.unit = value;
            },
            transform: (value: string | null): string | null =>value,
            getError: ()=>errors.unit,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.unit = value;
            },
            getTainted: ()=>tainted.unit,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.unit = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = productValidateField("unit", data.unit);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        active: {
            path: [
                "active"
            ] as const,
            name: "active",
            constraints: {
                required: true
            },
            label: "Active",
            get: ()=>data.active,
            set: (value: boolean)=>{
                data.active = value;
            },
            transform: (value: boolean): boolean =>value,
            getError: ()=>errors.active,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.active = value;
            },
            getTainted: ()=>tainted.active,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.active = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = productValidateField("active", data.active);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        commission: {
            path: [
                "commission"
            ] as const,
            name: "commission",
            constraints: {
                required: true
            },
            label: "Commission",
            get: ()=>data.commission,
            set: (value: boolean)=>{
                data.commission = value;
            },
            transform: (value: boolean): boolean =>value,
            getError: ()=>errors.commission,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.commission = value;
            },
            getTainted: ()=>tainted.commission,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.commission = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = productValidateField("commission", data.commission);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        favorite: {
            path: [
                "favorite"
            ] as const,
            name: "favorite",
            constraints: {
                required: true
            },
            label: "Favorite",
            get: ()=>data.favorite,
            set: (value: boolean)=>{
                data.favorite = value;
            },
            transform: (value: boolean): boolean =>value,
            getError: ()=>errors.favorite,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.favorite = value;
            },
            getTainted: ()=>tainted.favorite,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.favorite = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = productValidateField("favorite", data.favorite);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        defaults: {
            path: [
                "defaults"
            ] as const,
            name: "defaults",
            constraints: {
                required: true
            },
            get: ()=>data.defaults,
            set: (value: ProductDefaults)=>{
                data.defaults = value;
            },
            transform: (value: ProductDefaults): ProductDefaults =>value,
            getError: ()=>errors.defaults,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.defaults = value;
            },
            getTainted: ()=>tainted.defaults,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.defaults = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = productValidateField("defaults", data.defaults);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        }
    } as ProductFieldControllers;
    const __gf_getter_hint = "get data() set data(v) get errors() set errors(v) get tainted() set tainted(v)";
    const __gf_validate_hint = ".map((e: { field: string; message: string }) => e.message)";
    function validate(): Exit<Product, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(productDeserialize(data));
    }
    function reset(newOverrides?: Partial<Product>): void {
        data = {
            ...productDefaultValue(),
            ...newOverrides
        };
        errors = {
            _errors: optionNone(),
            id: optionNone(),
            name: optionNone(),
            quickCode: optionNone(),
            group: optionNone(),
            subgroup: optionNone(),
            unit: optionNone(),
            active: optionNone(),
            commission: optionNone(),
            favorite: optionNone(),
            defaults: optionNone()
        };
        tainted = {
            id: optionNone(),
            name: optionNone(),
            quickCode: optionNone(),
            group: optionNone(),
            subgroup: optionNone(),
            unit: optionNone(),
            active: optionNone(),
            commission: optionNone(),
            favorite: optionNone(),
            defaults: optionNone()
        };
    }
    return {
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        fields,
        validate,
        reset
    };
}
export function productFromFormData(formData: FormData): Exit<Product, Array<{
    field: string;
    message: string;
}>> {
    const obj: Record<string, unknown> = {};
    const __gf_exit_hint = "Exit<Product, Array<{ field: string; message: string }>>";
    obj.id = formData.get(`${"id"}`) ?? "";
    obj.name = formData.get(`${"name"}`) ?? "";
    obj.quickCode = formData.get(`${"quickCode"}`) ?? "";
    obj.group = formData.get(`${"group"}`) ?? "";
    obj.subgroup = formData.get(`${"subgroup"}`) ?? "";
    obj.unit = formData.get(`${"unit"}`) ?? "";
    {
        const activeVal = formData.get(`${"active"}`);
        obj.active = activeVal === "true" || activeVal === "on" || activeVal === "1";
    }
    {
        const commissionVal = formData.get(`${"commission"}`);
        obj.commission = commissionVal === "true" || commissionVal === "on" || commissionVal === "1";
    }
    {
        const favoriteVal = formData.get(`${"favorite"}`);
        obj.favorite = favoriteVal === "true" || favoriteVal === "on" || favoriteVal === "1";
    }
    {
        const defaultsObj: Record<string, unknown> = {};
        for (const [key, value] of Array.from(formData.entries())){
            if (key.startsWith(`${"defaults"}.`)) {
                const fieldName = key.slice(`${"defaults"}.`.length);
                const parts = fieldName.split(".");
                let current = defaultsObj;
                for(let i = 0; i < parts.length - 1; i++){
                    const part = parts[i]!;
                    if (!(part in current)) {
                        current[part] = {};
                    }
                    current = current[part] as Record<string, unknown>;
                }
                current[parts[parts.length - 1]!] = value;
            }
        }
        obj.defaults = defaultsObj;
    }
    return toExit(productDeserialize(obj));
}

export const Product = {
  defaultValue: productDefaultValue,
  serialize: productSerialize,
  serializeWithContext: productSerializeWithContext,
  deserialize: productDeserialize,
  deserializeWithContext: productDeserializeWithContext,
  validateFields: productValidateFields,
  hasShape: productHasShape,
  is: productIs,
  createForm: productCreateForm,
  fromFormData: productFromFormData
} as const;


export interface YearlyRecurrenceRule {
    quantityOfYears: number;
}

export function yearlyRecurrenceRuleDefaultValue(): YearlyRecurrenceRule {
    return {
        quantityOfYears: 0
    } as YearlyRecurrenceRule;
}

export function yearlyRecurrenceRuleSerialize(value: YearlyRecurrenceRule): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(yearlyRecurrenceRuleSerializeWithContext(value, ctx));
}
export function yearlyRecurrenceRuleSerializeWithContext(value: YearlyRecurrenceRule, ctx: __mf_SerializeContext): Record<string, unknown> {
    const existingId = ctx.getId(value);
    if (existingId !== undefined) {
        return {
            __ref: existingId
        };
    }
    const __id = ctx.register(value);
    const result: Record<string, unknown> = {
        __type: "YearlyRecurrenceRule",
        __id
    };
    result.quantityOfYears = value.quantityOfYears;
    return result;
}

export function yearlyRecurrenceRuleDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: YearlyRecurrenceRule } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = yearlyRecurrenceRuleDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "YearlyRecurrenceRule.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function yearlyRecurrenceRuleDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): YearlyRecurrenceRule | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
        throw new __mf_DeserializeError([
            {
                field: "_root",
                message: `${"YearlyRecurrenceRule"}.deserializeWithContext: expected an object`
            }
        ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (!("quantityOfYears" in obj)) {
        errors.push({
            field: "quantityOfYears",
            message: "missing required field"
        });
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
        ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
        const __raw_quantityOfYears = obj["quantityOfYears"] as number;
        instance.quantityOfYears = __raw_quantityOfYears;
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    return instance as YearlyRecurrenceRule;
}
export function yearlyRecurrenceRuleValidateField<K extends keyof YearlyRecurrenceRule>(_field: K, _value: YearlyRecurrenceRule[K]): Array<{
    field: string;
    message: string;
}> {
    return [];
}
export function yearlyRecurrenceRuleValidateFields(_partial: Partial<YearlyRecurrenceRule>): Array<{
    field: string;
    message: string;
}> {
    return [];
}
export function yearlyRecurrenceRuleHasShape(obj: unknown): boolean {
    if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
        return false;
    }
    const o = obj as Record<string, unknown>;
    return '"quantityOfYears" in o';
}
export function yearlyRecurrenceRuleIs(obj: unknown): obj is YearlyRecurrenceRule {
    if (!yearlyRecurrenceRuleHasShape(obj)) {
        return false;
    }
    const result = yearlyRecurrenceRuleDeserialize(obj);
    return result.success;
}

export type YearlyRecurrenceRuleErrors = {
    _errors: __gf_Option<Array<string>>;
    quantityOfYears: __gf_Option<Array<string>>;
};
export type YearlyRecurrenceRuleTainted = {
    quantityOfYears: __gf_Option<boolean>;
};
export interface YearlyRecurrenceRuleFieldControllers {
    readonly quantityOfYears: FieldController<number>;
}
export interface YearlyRecurrenceRuleGigaform {
    readonly data: YearlyRecurrenceRule;
    readonly errors: YearlyRecurrenceRuleErrors;
    readonly tainted: YearlyRecurrenceRuleTainted;
    readonly fields: YearlyRecurrenceRuleFieldControllers;
    validate(): Exit<YearlyRecurrenceRule, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<YearlyRecurrenceRule>): void;
}
export function yearlyRecurrenceRuleCreateForm(overrides?: Partial<YearlyRecurrenceRule>): YearlyRecurrenceRuleGigaform {
    let data = $state({
        ...yearlyRecurrenceRuleDefaultValue(),
        ...overrides
    });
    let errors = $state<YearlyRecurrenceRuleErrors>({
        _errors: optionNone(),
        quantityOfYears: optionNone()
    } as YearlyRecurrenceRuleErrors);
    let tainted = $state<YearlyRecurrenceRuleTainted>({
        quantityOfYears: optionNone()
    } as YearlyRecurrenceRuleTainted);
    const fields = {
        quantityOfYears: {
            path: [
                "quantityOfYears"
            ] as const,
            name: "quantityOfYears",
            constraints: {
                required: true
            },
            get: ()=>data.quantityOfYears,
            set: (value: number)=>{
                data.quantityOfYears = value;
            },
            transform: (value: number): number =>value,
            getError: ()=>errors.quantityOfYears,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.quantityOfYears = value;
            },
            getTainted: ()=>tainted.quantityOfYears,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.quantityOfYears = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = yearlyRecurrenceRuleValidateField("quantityOfYears", data.quantityOfYears);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        }
    } as YearlyRecurrenceRuleFieldControllers;
    const __gf_getter_hint = "get data() set data(v) get errors() set errors(v) get tainted() set tainted(v)";
    const __gf_validate_hint = ".map((e: { field: string; message: string }) => e.message)";
    function validate(): Exit<YearlyRecurrenceRule, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(yearlyRecurrenceRuleDeserialize(data));
    }
    function reset(newOverrides?: Partial<YearlyRecurrenceRule>): void {
        data = {
            ...yearlyRecurrenceRuleDefaultValue(),
            ...newOverrides
        };
        errors = {
            _errors: optionNone(),
            quantityOfYears: optionNone()
        };
        tainted = {
            quantityOfYears: optionNone()
        };
    }
    return {
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        fields,
        validate,
        reset
    };
}
export function yearlyRecurrenceRuleFromFormData(formData: FormData): Exit<YearlyRecurrenceRule, Array<{
    field: string;
    message: string;
}>> {
    const obj: Record<string, unknown> = {};
    const __gf_exit_hint = "Exit<YearlyRecurrenceRule, Array<{ field: string; message: string }>>";
    {
        const quantityOfYearsStr = formData.get(`${"quantityOfYears"}`);
        obj.quantityOfYears = quantityOfYearsStr ? parseFloat(quantityOfYearsStr as string) : $MfPh5;
        if (obj.quantityOfYears !== undefined && isNaN(obj.quantityOfYears as number)) obj.quantityOfYears = "0";
    }
    return toExit(yearlyRecurrenceRuleDeserialize(obj));
}

export const YearlyRecurrenceRule = {
  defaultValue: yearlyRecurrenceRuleDefaultValue,
  serialize: yearlyRecurrenceRuleSerialize,
  serializeWithContext: yearlyRecurrenceRuleSerializeWithContext,
  deserialize: yearlyRecurrenceRuleDeserialize,
  deserializeWithContext: yearlyRecurrenceRuleDeserializeWithContext,
  validateFields: yearlyRecurrenceRuleValidateFields,
  hasShape: yearlyRecurrenceRuleHasShape,
  is: yearlyRecurrenceRuleIs,
  createForm: yearlyRecurrenceRuleCreateForm,
  fromFormData: yearlyRecurrenceRuleFromFormData
} as const;


export interface AppointmentNotifications {
    
    personalScheduleChangeNotifications: string;
    
    allScheduleChangeNotifications: string;
}

export function appointmentNotificationsDefaultValue(): AppointmentNotifications {
    return {
        personalScheduleChangeNotifications: "",
        allScheduleChangeNotifications: ""
    } as AppointmentNotifications;
}

export function appointmentNotificationsSerialize(value: AppointmentNotifications): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(appointmentNotificationsSerializeWithContext(value, ctx));
}
export function appointmentNotificationsSerializeWithContext(value: AppointmentNotifications, ctx: __mf_SerializeContext): Record<string, unknown> {
    const existingId = ctx.getId(value);
    if (existingId !== undefined) {
        return {
            __ref: existingId
        };
    }
    const __id = ctx.register(value);
    const result: Record<string, unknown> = {
        __type: "AppointmentNotifications",
        __id
    };
    result.personalScheduleChangeNotifications = value.personalScheduleChangeNotifications;
    result.allScheduleChangeNotifications = value.allScheduleChangeNotifications;
    return result;
}

export function appointmentNotificationsDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: AppointmentNotifications } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = appointmentNotificationsDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "AppointmentNotifications.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function appointmentNotificationsDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): AppointmentNotifications | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
        throw new __mf_DeserializeError([
            {
                field: "_root",
                message: `${"AppointmentNotifications"}.deserializeWithContext: expected an object`
            }
        ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (!("personalScheduleChangeNotifications" in obj)) {
        errors.push({
            field: "personalScheduleChangeNotifications",
            message: "missing required field"
        });
    }
    if (!("allScheduleChangeNotifications" in obj)) {
        errors.push({
            field: "allScheduleChangeNotifications",
            message: "missing required field"
        });
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
        ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
        const __raw_personalScheduleChangeNotifications = obj["personalScheduleChangeNotifications"] as string;
        if (__raw_personalScheduleChangeNotifications.trim().length === 0) {
            errors.push({
                field: "personalScheduleChangeNotifications",
                message: "AppointmentNotifications.personalScheduleChangeNotifications must not be empty"
            });
        }
        instance.personalScheduleChangeNotifications = __raw_personalScheduleChangeNotifications;
    }
    {
        const __raw_allScheduleChangeNotifications = obj["allScheduleChangeNotifications"] as string;
        if (__raw_allScheduleChangeNotifications.trim().length === 0) {
            errors.push({
                field: "allScheduleChangeNotifications",
                message: "AppointmentNotifications.allScheduleChangeNotifications must not be empty"
            });
        }
        instance.allScheduleChangeNotifications = __raw_allScheduleChangeNotifications;
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    return instance as AppointmentNotifications;
}
export function appointmentNotificationsValidateField<K extends keyof AppointmentNotifications>(_field: K, _value: AppointmentNotifications[K]): Array<{
    field: string;
    message: string;
}> {
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (_field === "personalScheduleChangeNotifications") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "personalScheduleChangeNotifications",
                message: "AppointmentNotifications.personalScheduleChangeNotifications must not be empty"
            });
        }
    }
    if (_field === "allScheduleChangeNotifications") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "allScheduleChangeNotifications",
                message: "AppointmentNotifications.allScheduleChangeNotifications must not be empty"
            });
        }
    }
    return errors;
}
export function appointmentNotificationsValidateFields(_partial: Partial<AppointmentNotifications>): Array<{
    field: string;
    message: string;
}> {
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if ("personalScheduleChangeNotifications" in _partial && _partial.personalScheduleChangeNotifications !== undefined) {
        const __val = _partial.personalScheduleChangeNotifications as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "personalScheduleChangeNotifications",
                message: "AppointmentNotifications.personalScheduleChangeNotifications must not be empty"
            });
        }
    }
    if ("allScheduleChangeNotifications" in _partial && _partial.allScheduleChangeNotifications !== undefined) {
        const __val = _partial.allScheduleChangeNotifications as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "allScheduleChangeNotifications",
                message: "AppointmentNotifications.allScheduleChangeNotifications must not be empty"
            });
        }
    }
    return errors;
}
export function appointmentNotificationsHasShape(obj: unknown): boolean {
    if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
        return false;
    }
    const o = obj as Record<string, unknown>;
    return '"personalScheduleChangeNotifications" in o && "allScheduleChangeNotifications" in o';
}
export function appointmentNotificationsIs(obj: unknown): obj is AppointmentNotifications {
    if (!appointmentNotificationsHasShape(obj)) {
        return false;
    }
    const result = appointmentNotificationsDeserialize(obj);
    return result.success;
}

export type AppointmentNotificationsErrors = {
    _errors: __gf_Option<Array<string>>;
    personalScheduleChangeNotifications: __gf_Option<Array<string>>;
    allScheduleChangeNotifications: __gf_Option<Array<string>>;
};
export type AppointmentNotificationsTainted = {
    personalScheduleChangeNotifications: __gf_Option<boolean>;
    allScheduleChangeNotifications: __gf_Option<boolean>;
};
export interface AppointmentNotificationsFieldControllers {
    readonly personalScheduleChangeNotifications: FieldController<string>;
    readonly allScheduleChangeNotifications: FieldController<string>;
}
export interface AppointmentNotificationsGigaform {
    readonly data: AppointmentNotifications;
    readonly errors: AppointmentNotificationsErrors;
    readonly tainted: AppointmentNotificationsTainted;
    readonly fields: AppointmentNotificationsFieldControllers;
    validate(): Exit<AppointmentNotifications, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<AppointmentNotifications>): void;
}
export function appointmentNotificationsCreateForm(overrides?: Partial<AppointmentNotifications>): AppointmentNotificationsGigaform {
    let data = $state({
        ...appointmentNotificationsDefaultValue(),
        ...overrides
    });
    let errors = $state<AppointmentNotificationsErrors>({
        _errors: optionNone(),
        personalScheduleChangeNotifications: optionNone(),
        allScheduleChangeNotifications: optionNone()
    } as AppointmentNotificationsErrors);
    let tainted = $state<AppointmentNotificationsTainted>({
        personalScheduleChangeNotifications: optionNone(),
        allScheduleChangeNotifications: optionNone()
    } as AppointmentNotificationsTainted);
    const fields = {
        personalScheduleChangeNotifications: {
            path: [
                "personalScheduleChangeNotifications"
            ] as const,
            name: "personalScheduleChangeNotifications",
            constraints: {
                required: true
            },
            get: ()=>data.personalScheduleChangeNotifications,
            set: (value: string)=>{
                data.personalScheduleChangeNotifications = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.personalScheduleChangeNotifications,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.personalScheduleChangeNotifications = value;
            },
            getTainted: ()=>tainted.personalScheduleChangeNotifications,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.personalScheduleChangeNotifications = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = appointmentNotificationsValidateField("personalScheduleChangeNotifications", data.personalScheduleChangeNotifications);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        allScheduleChangeNotifications: {
            path: [
                "allScheduleChangeNotifications"
            ] as const,
            name: "allScheduleChangeNotifications",
            constraints: {
                required: true
            },
            get: ()=>data.allScheduleChangeNotifications,
            set: (value: string)=>{
                data.allScheduleChangeNotifications = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.allScheduleChangeNotifications,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.allScheduleChangeNotifications = value;
            },
            getTainted: ()=>tainted.allScheduleChangeNotifications,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.allScheduleChangeNotifications = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = appointmentNotificationsValidateField("allScheduleChangeNotifications", data.allScheduleChangeNotifications);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        }
    } as AppointmentNotificationsFieldControllers;
    const __gf_getter_hint = "get data() set data(v) get errors() set errors(v) get tainted() set tainted(v)";
    const __gf_validate_hint = ".map((e: { field: string; message: string }) => e.message)";
    function validate(): Exit<AppointmentNotifications, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(appointmentNotificationsDeserialize(data));
    }
    function reset(newOverrides?: Partial<AppointmentNotifications>): void {
        data = {
            ...appointmentNotificationsDefaultValue(),
            ...newOverrides
        };
        errors = {
            _errors: optionNone(),
            personalScheduleChangeNotifications: optionNone(),
            allScheduleChangeNotifications: optionNone()
        };
        tainted = {
            personalScheduleChangeNotifications: optionNone(),
            allScheduleChangeNotifications: optionNone()
        };
    }
    return {
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        fields,
        validate,
        reset
    };
}
export function appointmentNotificationsFromFormData(formData: FormData): Exit<AppointmentNotifications, Array<{
    field: string;
    message: string;
}>> {
    const obj: Record<string, unknown> = {};
    const __gf_exit_hint = "Exit<AppointmentNotifications, Array<{ field: string; message: string }>>";
    obj.personalScheduleChangeNotifications = formData.get(`${"personalScheduleChangeNotifications"}`) ?? "";
    obj.allScheduleChangeNotifications = formData.get(`${"allScheduleChangeNotifications"}`) ?? "";
    return toExit(appointmentNotificationsDeserialize(obj));
}

export const AppointmentNotifications = {
  defaultValue: appointmentNotificationsDefaultValue,
  serialize: appointmentNotificationsSerialize,
  serializeWithContext: appointmentNotificationsSerializeWithContext,
  deserialize: appointmentNotificationsDeserialize,
  deserializeWithContext: appointmentNotificationsDeserializeWithContext,
  validateFields: appointmentNotificationsValidateFields,
  hasShape: appointmentNotificationsHasShape,
  is: appointmentNotificationsIs,
  createForm: appointmentNotificationsCreateForm,
  fromFormData: appointmentNotificationsFromFormData
} as const;


export interface DirectionHue {
    bearing: number;
    hue: number;
}

export function directionHueDefaultValue(): DirectionHue {
    return {
        bearing: 0,
        hue: 0
    } as DirectionHue;
}

export function directionHueSerialize(value: DirectionHue): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(directionHueSerializeWithContext(value, ctx));
}
export function directionHueSerializeWithContext(value: DirectionHue, ctx: __mf_SerializeContext): Record<string, unknown> {
    const existingId = ctx.getId(value);
    if (existingId !== undefined) {
        return {
            __ref: existingId
        };
    }
    const __id = ctx.register(value);
    const result: Record<string, unknown> = {
        __type: "DirectionHue",
        __id
    };
    result.bearing = value.bearing;
    result.hue = value.hue;
    return result;
}

export function directionHueDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: DirectionHue } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = directionHueDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "DirectionHue.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function directionHueDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): DirectionHue | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
        throw new __mf_DeserializeError([
            {
                field: "_root",
                message: `${"DirectionHue"}.deserializeWithContext: expected an object`
            }
        ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (!("bearing" in obj)) {
        errors.push({
            field: "bearing",
            message: "missing required field"
        });
    }
    if (!("hue" in obj)) {
        errors.push({
            field: "hue",
            message: "missing required field"
        });
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
        ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
        const __raw_bearing = obj["bearing"] as number;
        instance.bearing = __raw_bearing;
    }
    {
        const __raw_hue = obj["hue"] as number;
        instance.hue = __raw_hue;
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    return instance as DirectionHue;
}
export function directionHueValidateField<K extends keyof DirectionHue>(_field: K, _value: DirectionHue[K]): Array<{
    field: string;
    message: string;
}> {
    return [];
}
export function directionHueValidateFields(_partial: Partial<DirectionHue>): Array<{
    field: string;
    message: string;
}> {
    return [];
}
export function directionHueHasShape(obj: unknown): boolean {
    if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
        return false;
    }
    const o = obj as Record<string, unknown>;
    return '"bearing" in o && "hue" in o';
}
export function directionHueIs(obj: unknown): obj is DirectionHue {
    if (!directionHueHasShape(obj)) {
        return false;
    }
    const result = directionHueDeserialize(obj);
    return result.success;
}

export type DirectionHueErrors = {
    _errors: __gf_Option<Array<string>>;
    bearing: __gf_Option<Array<string>>;
    hue: __gf_Option<Array<string>>;
};
export type DirectionHueTainted = {
    bearing: __gf_Option<boolean>;
    hue: __gf_Option<boolean>;
};
export interface DirectionHueFieldControllers {
    readonly bearing: FieldController<number>;
    readonly hue: FieldController<number>;
}
export interface DirectionHueGigaform {
    readonly data: DirectionHue;
    readonly errors: DirectionHueErrors;
    readonly tainted: DirectionHueTainted;
    readonly fields: DirectionHueFieldControllers;
    validate(): Exit<DirectionHue, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<DirectionHue>): void;
}
export function directionHueCreateForm(overrides?: Partial<DirectionHue>): DirectionHueGigaform {
    let data = $state({
        ...directionHueDefaultValue(),
        ...overrides
    });
    let errors = $state<DirectionHueErrors>({
        _errors: optionNone(),
        bearing: optionNone(),
        hue: optionNone()
    } as DirectionHueErrors);
    let tainted = $state<DirectionHueTainted>({
        bearing: optionNone(),
        hue: optionNone()
    } as DirectionHueTainted);
    const fields = {
        bearing: {
            path: [
                "bearing"
            ] as const,
            name: "bearing",
            constraints: {
                required: true
            },
            get: ()=>data.bearing,
            set: (value: number)=>{
                data.bearing = value;
            },
            transform: (value: number): number =>value,
            getError: ()=>errors.bearing,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.bearing = value;
            },
            getTainted: ()=>tainted.bearing,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.bearing = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = directionHueValidateField("bearing", data.bearing);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        hue: {
            path: [
                "hue"
            ] as const,
            name: "hue",
            constraints: {
                required: true
            },
            get: ()=>data.hue,
            set: (value: number)=>{
                data.hue = value;
            },
            transform: (value: number): number =>value,
            getError: ()=>errors.hue,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.hue = value;
            },
            getTainted: ()=>tainted.hue,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.hue = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = directionHueValidateField("hue", data.hue);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        }
    } as DirectionHueFieldControllers;
    const __gf_getter_hint = "get data() set data(v) get errors() set errors(v) get tainted() set tainted(v)";
    const __gf_validate_hint = ".map((e: { field: string; message: string }) => e.message)";
    function validate(): Exit<DirectionHue, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(directionHueDeserialize(data));
    }
    function reset(newOverrides?: Partial<DirectionHue>): void {
        data = {
            ...directionHueDefaultValue(),
            ...newOverrides
        };
        errors = {
            _errors: optionNone(),
            bearing: optionNone(),
            hue: optionNone()
        };
        tainted = {
            bearing: optionNone(),
            hue: optionNone()
        };
    }
    return {
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        fields,
        validate,
        reset
    };
}
export function directionHueFromFormData(formData: FormData): Exit<DirectionHue, Array<{
    field: string;
    message: string;
}>> {
    const obj: Record<string, unknown> = {};
    const __gf_exit_hint = "Exit<DirectionHue, Array<{ field: string; message: string }>>";
    {
        const bearingStr = formData.get(`${"bearing"}`);
        obj.bearing = bearingStr ? parseFloat(bearingStr as string) : $MfPh5;
        if (obj.bearing !== undefined && isNaN(obj.bearing as number)) obj.bearing = "0";
    }
    {
        const hueStr = formData.get(`${"hue"}`);
        obj.hue = hueStr ? parseFloat(hueStr as string) : $MfPh5;
        if (obj.hue !== undefined && isNaN(obj.hue as number)) obj.hue = "0";
    }
    return toExit(directionHueDeserialize(obj));
}

export const DirectionHue = {
  defaultValue: directionHueDefaultValue,
  serialize: directionHueSerialize,
  serializeWithContext: directionHueSerializeWithContext,
  deserialize: directionHueDeserialize,
  deserializeWithContext: directionHueDeserializeWithContext,
  validateFields: directionHueValidateFields,
  hasShape: directionHueHasShape,
  is: directionHueIs,
  createForm: directionHueCreateForm,
  fromFormData: directionHueFromFormData
} as const;


export interface MonthlyRecurrenceRule {
    quantityOfMonths: number;
    day: number;
    
    name: string;
}

export function monthlyRecurrenceRuleDefaultValue(): MonthlyRecurrenceRule {
    return {
        quantityOfMonths: 0,
        day: 0,
        name: ""
    } as MonthlyRecurrenceRule;
}

export function monthlyRecurrenceRuleSerialize(value: MonthlyRecurrenceRule): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(monthlyRecurrenceRuleSerializeWithContext(value, ctx));
}
export function monthlyRecurrenceRuleSerializeWithContext(value: MonthlyRecurrenceRule, ctx: __mf_SerializeContext): Record<string, unknown> {
    const existingId = ctx.getId(value);
    if (existingId !== undefined) {
        return {
            __ref: existingId
        };
    }
    const __id = ctx.register(value);
    const result: Record<string, unknown> = {
        __type: "MonthlyRecurrenceRule",
        __id
    };
    result.quantityOfMonths = value.quantityOfMonths;
    result.day = value.day;
    result.name = value.name;
    return result;
}

export function monthlyRecurrenceRuleDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: MonthlyRecurrenceRule } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = monthlyRecurrenceRuleDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "MonthlyRecurrenceRule.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function monthlyRecurrenceRuleDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): MonthlyRecurrenceRule | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
        throw new __mf_DeserializeError([
            {
                field: "_root",
                message: `${"MonthlyRecurrenceRule"}.deserializeWithContext: expected an object`
            }
        ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (!("quantityOfMonths" in obj)) {
        errors.push({
            field: "quantityOfMonths",
            message: "missing required field"
        });
    }
    if (!("day" in obj)) {
        errors.push({
            field: "day",
            message: "missing required field"
        });
    }
    if (!("name" in obj)) {
        errors.push({
            field: "name",
            message: "missing required field"
        });
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
        ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
        const __raw_quantityOfMonths = obj["quantityOfMonths"] as number;
        instance.quantityOfMonths = __raw_quantityOfMonths;
    }
    {
        const __raw_day = obj["day"] as number;
        instance.day = __raw_day;
    }
    {
        const __raw_name = obj["name"] as string;
        if (__raw_name.trim().length === 0) {
            errors.push({
                field: "name",
                message: "MonthlyRecurrenceRule.name must not be empty"
            });
        }
        instance.name = __raw_name;
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    return instance as MonthlyRecurrenceRule;
}
export function monthlyRecurrenceRuleValidateField<K extends keyof MonthlyRecurrenceRule>(_field: K, _value: MonthlyRecurrenceRule[K]): Array<{
    field: string;
    message: string;
}> {
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (_field === "name") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "name",
                message: "MonthlyRecurrenceRule.name must not be empty"
            });
        }
    }
    return errors;
}
export function monthlyRecurrenceRuleValidateFields(_partial: Partial<MonthlyRecurrenceRule>): Array<{
    field: string;
    message: string;
}> {
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if ("name" in _partial && _partial.name !== undefined) {
        const __val = _partial.name as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "name",
                message: "MonthlyRecurrenceRule.name must not be empty"
            });
        }
    }
    return errors;
}
export function monthlyRecurrenceRuleHasShape(obj: unknown): boolean {
    if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
        return false;
    }
    const o = obj as Record<string, unknown>;
    return '"quantityOfMonths" in o && "day" in o && "name" in o';
}
export function monthlyRecurrenceRuleIs(obj: unknown): obj is MonthlyRecurrenceRule {
    if (!monthlyRecurrenceRuleHasShape(obj)) {
        return false;
    }
    const result = monthlyRecurrenceRuleDeserialize(obj);
    return result.success;
}

export type MonthlyRecurrenceRuleErrors = {
    _errors: __gf_Option<Array<string>>;
    quantityOfMonths: __gf_Option<Array<string>>;
    day: __gf_Option<Array<string>>;
    name: __gf_Option<Array<string>>;
};
export type MonthlyRecurrenceRuleTainted = {
    quantityOfMonths: __gf_Option<boolean>;
    day: __gf_Option<boolean>;
    name: __gf_Option<boolean>;
};
export interface MonthlyRecurrenceRuleFieldControllers {
    readonly quantityOfMonths: FieldController<number>;
    readonly day: FieldController<number>;
    readonly name: FieldController<string>;
}
export interface MonthlyRecurrenceRuleGigaform {
    readonly data: MonthlyRecurrenceRule;
    readonly errors: MonthlyRecurrenceRuleErrors;
    readonly tainted: MonthlyRecurrenceRuleTainted;
    readonly fields: MonthlyRecurrenceRuleFieldControllers;
    validate(): Exit<MonthlyRecurrenceRule, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<MonthlyRecurrenceRule>): void;
}
export function monthlyRecurrenceRuleCreateForm(overrides?: Partial<MonthlyRecurrenceRule>): MonthlyRecurrenceRuleGigaform {
    let data = $state({
        ...monthlyRecurrenceRuleDefaultValue(),
        ...overrides
    });
    let errors = $state<MonthlyRecurrenceRuleErrors>({
        _errors: optionNone(),
        quantityOfMonths: optionNone(),
        day: optionNone(),
        name: optionNone()
    } as MonthlyRecurrenceRuleErrors);
    let tainted = $state<MonthlyRecurrenceRuleTainted>({
        quantityOfMonths: optionNone(),
        day: optionNone(),
        name: optionNone()
    } as MonthlyRecurrenceRuleTainted);
    const fields = {
        quantityOfMonths: {
            path: [
                "quantityOfMonths"
            ] as const,
            name: "quantityOfMonths",
            constraints: {
                required: true
            },
            get: ()=>data.quantityOfMonths,
            set: (value: number)=>{
                data.quantityOfMonths = value;
            },
            transform: (value: number): number =>value,
            getError: ()=>errors.quantityOfMonths,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.quantityOfMonths = value;
            },
            getTainted: ()=>tainted.quantityOfMonths,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.quantityOfMonths = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = monthlyRecurrenceRuleValidateField("quantityOfMonths", data.quantityOfMonths);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        day: {
            path: [
                "day"
            ] as const,
            name: "day",
            constraints: {
                required: true
            },
            get: ()=>data.day,
            set: (value: number)=>{
                data.day = value;
            },
            transform: (value: number): number =>value,
            getError: ()=>errors.day,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.day = value;
            },
            getTainted: ()=>tainted.day,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.day = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = monthlyRecurrenceRuleValidateField("day", data.day);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        name: {
            path: [
                "name"
            ] as const,
            name: "name",
            constraints: {
                required: true
            },
            get: ()=>data.name,
            set: (value: string)=>{
                data.name = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.name,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.name = value;
            },
            getTainted: ()=>tainted.name,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.name = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = monthlyRecurrenceRuleValidateField("name", data.name);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        }
    } as MonthlyRecurrenceRuleFieldControllers;
    const __gf_getter_hint = "get data() set data(v) get errors() set errors(v) get tainted() set tainted(v)";
    const __gf_validate_hint = ".map((e: { field: string; message: string }) => e.message)";
    function validate(): Exit<MonthlyRecurrenceRule, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(monthlyRecurrenceRuleDeserialize(data));
    }
    function reset(newOverrides?: Partial<MonthlyRecurrenceRule>): void {
        data = {
            ...monthlyRecurrenceRuleDefaultValue(),
            ...newOverrides
        };
        errors = {
            _errors: optionNone(),
            quantityOfMonths: optionNone(),
            day: optionNone(),
            name: optionNone()
        };
        tainted = {
            quantityOfMonths: optionNone(),
            day: optionNone(),
            name: optionNone()
        };
    }
    return {
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        fields,
        validate,
        reset
    };
}
export function monthlyRecurrenceRuleFromFormData(formData: FormData): Exit<MonthlyRecurrenceRule, Array<{
    field: string;
    message: string;
}>> {
    const obj: Record<string, unknown> = {};
    const __gf_exit_hint = "Exit<MonthlyRecurrenceRule, Array<{ field: string; message: string }>>";
    {
        const quantityOfMonthsStr = formData.get(`${"quantityOfMonths"}`);
        obj.quantityOfMonths = quantityOfMonthsStr ? parseFloat(quantityOfMonthsStr as string) : $MfPh5;
        if (obj.quantityOfMonths !== undefined && isNaN(obj.quantityOfMonths as number)) obj.quantityOfMonths = "0";
    }
    {
        const dayStr = formData.get(`${"day"}`);
        obj.day = dayStr ? parseFloat(dayStr as string) : $MfPh5;
        if (obj.day !== undefined && isNaN(obj.day as number)) obj.day = "0";
    }
    obj.name = formData.get(`${"name"}`) ?? "";
    return toExit(monthlyRecurrenceRuleDeserialize(obj));
}

export const MonthlyRecurrenceRule = {
  defaultValue: monthlyRecurrenceRuleDefaultValue,
  serialize: monthlyRecurrenceRuleSerialize,
  serializeWithContext: monthlyRecurrenceRuleSerializeWithContext,
  deserialize: monthlyRecurrenceRuleDeserialize,
  deserializeWithContext: monthlyRecurrenceRuleDeserializeWithContext,
  validateFields: monthlyRecurrenceRuleValidateFields,
  hasShape: monthlyRecurrenceRuleHasShape,
  is: monthlyRecurrenceRuleIs,
  createForm: monthlyRecurrenceRuleCreateForm,
  fromFormData: monthlyRecurrenceRuleFromFormData
} as const;


export interface Represents {
    
    in: string | Employee;
    
    out: string | Account;
    id: string;
    dateStarted: string;
}

export function representsDefaultValue(): Represents {
    return {
        in: "",
        out: "",
        id: "",
        dateStarted: ""
    } as Represents;
}

export function representsSerialize(value: Represents): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(representsSerializeWithContext(value, ctx));
}
export function representsSerializeWithContext(value: Represents, ctx: __mf_SerializeContext): Record<string, unknown> {
    const existingId = ctx.getId(value);
    if (existingId !== undefined) {
        return {
            __ref: existingId
        };
    }
    const __id = ctx.register(value);
    const result: Record<string, unknown> = {
        __type: "Represents",
        __id
    };
    result.in = value.in;
    result.out = value.out;
    result.id = value.id;
    result.dateStarted = value.dateStarted;
    return result;
}

export function representsDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: Represents } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = representsDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "Represents.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function representsDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Represents | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
        throw new __mf_DeserializeError([
            {
                field: "_root",
                message: `${"Represents"}.deserializeWithContext: expected an object`
            }
        ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (!("in" in obj)) {
        errors.push({
            field: "in",
            message: "missing required field"
        });
    }
    if (!("out" in obj)) {
        errors.push({
            field: "out",
            message: "missing required field"
        });
    }
    if (!("id" in obj)) {
        errors.push({
            field: "id",
            message: "missing required field"
        });
    }
    if (!("dateStarted" in obj)) {
        errors.push({
            field: "dateStarted",
            message: "missing required field"
        });
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
        ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
        const __raw_in = obj["in"] as string | Employee;
        instance.in = __raw_in;
    }
    {
        const __raw_out = obj["out"] as string | Account;
        instance.out = __raw_out;
    }
    {
        const __raw_id = obj["id"] as string;
        instance.id = __raw_id;
    }
    {
        const __raw_dateStarted = obj["dateStarted"] as string;
        instance.dateStarted = __raw_dateStarted;
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    return instance as Represents;
}
export function representsValidateField<K extends keyof Represents>(_field: K, _value: Represents[K]): Array<{
    field: string;
    message: string;
}> {
    return [];
}
export function representsValidateFields(_partial: Partial<Represents>): Array<{
    field: string;
    message: string;
}> {
    return [];
}
export function representsHasShape(obj: unknown): boolean {
    if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
        return false;
    }
    const o = obj as Record<string, unknown>;
    return '"in" in o && "out" in o && "id" in o && "dateStarted" in o';
}
export function representsIs(obj: unknown): obj is Represents {
    if (!representsHasShape(obj)) {
        return false;
    }
    const result = representsDeserialize(obj);
    return result.success;
}

export type RepresentsErrors = {
    _errors: __gf_Option<Array<string>>;
    in: __gf_Option<Array<string>>;
    out: __gf_Option<Array<string>>;
    id: __gf_Option<Array<string>>;
    dateStarted: __gf_Option<Array<string>>;
};
export type RepresentsTainted = {
    in: __gf_Option<boolean>;
    out: __gf_Option<boolean>;
    id: __gf_Option<boolean>;
    dateStarted: __gf_Option<boolean>;
};
export interface RepresentsFieldControllers {
    readonly in: FieldController<string | Employee>;
    readonly out: FieldController<string | Account>;
    readonly id: FieldController<string>;
    readonly dateStarted: FieldController<string>;
}
export interface RepresentsGigaform {
    readonly data: Represents;
    readonly errors: RepresentsErrors;
    readonly tainted: RepresentsTainted;
    readonly fields: RepresentsFieldControllers;
    validate(): Exit<Represents, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<Represents>): void;
}
export function representsCreateForm(overrides?: Partial<Represents>): RepresentsGigaform {
    let data = $state({
        ...representsDefaultValue(),
        ...overrides
    });
    let errors = $state<RepresentsErrors>({
        _errors: optionNone(),
        in: optionNone(),
        out: optionNone(),
        id: optionNone(),
        dateStarted: optionNone()
    } as RepresentsErrors);
    let tainted = $state<RepresentsTainted>({
        in: optionNone(),
        out: optionNone(),
        id: optionNone(),
        dateStarted: optionNone()
    } as RepresentsTainted);
    const fields = {
        in: {
            path: [
                "in"
            ] as const,
            name: "in",
            constraints: {
                required: true
            },
            get: ()=>data.in,
            set: (value: string | Employee)=>{
                data.in = value;
            },
            transform: (value: string | Employee): string | Employee =>value,
            getError: ()=>errors.in,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.in = value;
            },
            getTainted: ()=>tainted.in,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.in = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = representsValidateField("in", data.in);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        out: {
            path: [
                "out"
            ] as const,
            name: "out",
            constraints: {
                required: true
            },
            get: ()=>data.out,
            set: (value: string | Account)=>{
                data.out = value;
            },
            transform: (value: string | Account): string | Account =>value,
            getError: ()=>errors.out,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.out = value;
            },
            getTainted: ()=>tainted.out,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.out = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = representsValidateField("out", data.out);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        id: {
            path: [
                "id"
            ] as const,
            name: "id",
            constraints: {
                required: true
            },
            get: ()=>data.id,
            set: (value: string)=>{
                data.id = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.id,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.id = value;
            },
            getTainted: ()=>tainted.id,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.id = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = representsValidateField("id", data.id);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        dateStarted: {
            path: [
                "dateStarted"
            ] as const,
            name: "dateStarted",
            constraints: {
                required: true
            },
            get: ()=>data.dateStarted,
            set: (value: string)=>{
                data.dateStarted = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.dateStarted,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.dateStarted = value;
            },
            getTainted: ()=>tainted.dateStarted,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.dateStarted = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = representsValidateField("dateStarted", data.dateStarted);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        }
    } as RepresentsFieldControllers;
    const __gf_getter_hint = "get data() set data(v) get errors() set errors(v) get tainted() set tainted(v)";
    const __gf_validate_hint = ".map((e: { field: string; message: string }) => e.message)";
    function validate(): Exit<Represents, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(representsDeserialize(data));
    }
    function reset(newOverrides?: Partial<Represents>): void {
        data = {
            ...representsDefaultValue(),
            ...newOverrides
        };
        errors = {
            _errors: optionNone(),
            in: optionNone(),
            out: optionNone(),
            id: optionNone(),
            dateStarted: optionNone()
        };
        tainted = {
            in: optionNone(),
            out: optionNone(),
            id: optionNone(),
            dateStarted: optionNone()
        };
    }
    return {
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        fields,
        validate,
        reset
    };
}
export function representsFromFormData(formData: FormData): Exit<Represents, Array<{
    field: string;
    message: string;
}>> {
    const obj: Record<string, unknown> = {};
    const __gf_exit_hint = "Exit<Represents, Array<{ field: string; message: string }>>";
    obj.in = formData.get(`${"in"}`) ?? "";
    obj.out = formData.get(`${"out"}`) ?? "";
    obj.id = formData.get(`${"id"}`) ?? "";
    obj.dateStarted = formData.get(`${"dateStarted"}`) ?? "";
    return toExit(representsDeserialize(obj));
}

export const Represents = {
  defaultValue: representsDefaultValue,
  serialize: representsSerialize,
  serializeWithContext: representsSerializeWithContext,
  deserialize: representsDeserialize,
  deserializeWithContext: representsDeserializeWithContext,
  validateFields: representsValidateFields,
  hasShape: representsHasShape,
  is: representsIs,
  createForm: representsCreateForm,
  fromFormData: representsFromFormData
} as const;


export interface Payment {
    id: string;
    date: string;
}

export function paymentDefaultValue(): Payment {
    return {
        id: "",
        date: ""
    } as Payment;
}

export function paymentSerialize(value: Payment): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(paymentSerializeWithContext(value, ctx));
}
export function paymentSerializeWithContext(value: Payment, ctx: __mf_SerializeContext): Record<string, unknown> {
    const existingId = ctx.getId(value);
    if (existingId !== undefined) {
        return {
            __ref: existingId
        };
    }
    const __id = ctx.register(value);
    const result: Record<string, unknown> = {
        __type: "Payment",
        __id
    };
    result.id = value.id;
    result.date = value.date;
    return result;
}

export function paymentDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: Payment } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = paymentDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "Payment.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function paymentDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Payment | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
        throw new __mf_DeserializeError([
            {
                field: "_root",
                message: `${"Payment"}.deserializeWithContext: expected an object`
            }
        ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (!("id" in obj)) {
        errors.push({
            field: "id",
            message: "missing required field"
        });
    }
    if (!("date" in obj)) {
        errors.push({
            field: "date",
            message: "missing required field"
        });
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
        ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
        const __raw_id = obj["id"] as string;
        instance.id = __raw_id;
    }
    {
        const __raw_date = obj["date"] as string;
        instance.date = __raw_date;
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    return instance as Payment;
}
export function paymentValidateField<K extends keyof Payment>(_field: K, _value: Payment[K]): Array<{
    field: string;
    message: string;
}> {
    return [];
}
export function paymentValidateFields(_partial: Partial<Payment>): Array<{
    field: string;
    message: string;
}> {
    return [];
}
export function paymentHasShape(obj: unknown): boolean {
    if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
        return false;
    }
    const o = obj as Record<string, unknown>;
    return '"id" in o && "date" in o';
}
export function paymentIs(obj: unknown): obj is Payment {
    if (!paymentHasShape(obj)) {
        return false;
    }
    const result = paymentDeserialize(obj);
    return result.success;
}

export type PaymentErrors = {
    _errors: __gf_Option<Array<string>>;
    id: __gf_Option<Array<string>>;
    date: __gf_Option<Array<string>>;
};
export type PaymentTainted = {
    id: __gf_Option<boolean>;
    date: __gf_Option<boolean>;
};
export interface PaymentFieldControllers {
    readonly id: FieldController<string>;
    readonly date: FieldController<string>;
}
export interface PaymentGigaform {
    readonly data: Payment;
    readonly errors: PaymentErrors;
    readonly tainted: PaymentTainted;
    readonly fields: PaymentFieldControllers;
    validate(): Exit<Payment, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<Payment>): void;
}
export function paymentCreateForm(overrides?: Partial<Payment>): PaymentGigaform {
    let data = $state({
        ...paymentDefaultValue(),
        ...overrides
    });
    let errors = $state<PaymentErrors>({
        _errors: optionNone(),
        id: optionNone(),
        date: optionNone()
    } as PaymentErrors);
    let tainted = $state<PaymentTainted>({
        id: optionNone(),
        date: optionNone()
    } as PaymentTainted);
    const fields = {
        id: {
            path: [
                "id"
            ] as const,
            name: "id",
            constraints: {
                required: true
            },
            get: ()=>data.id,
            set: (value: string)=>{
                data.id = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.id,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.id = value;
            },
            getTainted: ()=>tainted.id,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.id = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = paymentValidateField("id", data.id);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        date: {
            path: [
                "date"
            ] as const,
            name: "date",
            constraints: {
                required: true
            },
            get: ()=>data.date,
            set: (value: string)=>{
                data.date = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.date,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.date = value;
            },
            getTainted: ()=>tainted.date,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.date = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = paymentValidateField("date", data.date);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        }
    } as PaymentFieldControllers;
    const __gf_getter_hint = "get data() set data(v) get errors() set errors(v) get tainted() set tainted(v)";
    const __gf_validate_hint = ".map((e: { field: string; message: string }) => e.message)";
    function validate(): Exit<Payment, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(paymentDeserialize(data));
    }
    function reset(newOverrides?: Partial<Payment>): void {
        data = {
            ...paymentDefaultValue(),
            ...newOverrides
        };
        errors = {
            _errors: optionNone(),
            id: optionNone(),
            date: optionNone()
        };
        tainted = {
            id: optionNone(),
            date: optionNone()
        };
    }
    return {
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        fields,
        validate,
        reset
    };
}
export function paymentFromFormData(formData: FormData): Exit<Payment, Array<{
    field: string;
    message: string;
}>> {
    const obj: Record<string, unknown> = {};
    const __gf_exit_hint = "Exit<Payment, Array<{ field: string; message: string }>>";
    obj.id = formData.get(`${"id"}`) ?? "";
    obj.date = formData.get(`${"date"}`) ?? "";
    return toExit(paymentDeserialize(obj));
}

export const Payment = {
  defaultValue: paymentDefaultValue,
  serialize: paymentSerialize,
  serializeWithContext: paymentSerializeWithContext,
  deserialize: paymentDeserialize,
  deserializeWithContext: paymentDeserializeWithContext,
  validateFields: paymentValidateFields,
  hasShape: paymentHasShape,
  is: paymentIs,
  createForm: paymentCreateForm,
  fromFormData: paymentFromFormData
} as const;


export interface Settings {
    appointmentNotifications: AppointmentNotifications | null;
    commissions: Commissions | null;
    scheduleSettings: ScheduleSettings;
    accountOverviewSettings: OverviewSettings;
    serviceOverviewSettings: OverviewSettings;
    appointmentOverviewSettings: OverviewSettings;
    leadOverviewSettings: OverviewSettings;
    packageOverviewSettings: OverviewSettings;
    productOverviewSettings: OverviewSettings;
    orderOverviewSettings: OverviewSettings;
    taxRateOverviewSettings: OverviewSettings;
    
    homePage: Page;
}

export function settingsDefaultValue(): Settings {
    return {
        appointmentNotifications: null,
        commissions: null,
        scheduleSettings: scheduleSettingsDefaultValue(),
        accountOverviewSettings: overviewSettingsDefaultValue(),
        serviceOverviewSettings: overviewSettingsDefaultValue(),
        appointmentOverviewSettings: overviewSettingsDefaultValue(),
        leadOverviewSettings: overviewSettingsDefaultValue(),
        packageOverviewSettings: overviewSettingsDefaultValue(),
        productOverviewSettings: overviewSettingsDefaultValue(),
        orderOverviewSettings: overviewSettingsDefaultValue(),
        taxRateOverviewSettings: overviewSettingsDefaultValue(),
        homePage: "UserHome"
    } as Settings;
}

export function settingsSerialize(value: Settings): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(settingsSerializeWithContext(value, ctx));
}
export function settingsSerializeWithContext(value: Settings, ctx: __mf_SerializeContext): Record<string, unknown> {
    const existingId = ctx.getId(value);
    if (existingId !== undefined) {
        return {
            __ref: existingId
        };
    }
    const __id = ctx.register(value);
    const result: Record<string, unknown> = {
        __type: "Settings",
        __id
    };
    if (value.appointmentNotifications !== null) {
        result.appointmentNotifications = appointmentNotificationsSerializeWithContext(value.appointmentNotifications, ctx);
    }
    if (value.commissions !== null) {
        result.commissions = commissionsSerializeWithContext(value.commissions, ctx);
    }
    result.scheduleSettings = scheduleSettingsSerializeWithContext(value.scheduleSettings, ctx);
    result.accountOverviewSettings = overviewSettingsSerializeWithContext(value.accountOverviewSettings, ctx);
    result.serviceOverviewSettings = overviewSettingsSerializeWithContext(value.serviceOverviewSettings, ctx);
    result.appointmentOverviewSettings = overviewSettingsSerializeWithContext(value.appointmentOverviewSettings, ctx);
    result.leadOverviewSettings = overviewSettingsSerializeWithContext(value.leadOverviewSettings, ctx);
    result.packageOverviewSettings = overviewSettingsSerializeWithContext(value.packageOverviewSettings, ctx);
    result.productOverviewSettings = overviewSettingsSerializeWithContext(value.productOverviewSettings, ctx);
    result.orderOverviewSettings = overviewSettingsSerializeWithContext(value.orderOverviewSettings, ctx);
    result.taxRateOverviewSettings = overviewSettingsSerializeWithContext(value.taxRateOverviewSettings, ctx);
    result.homePage = pageSerializeWithContext(value.homePage, ctx);
    return result;
}

export function settingsDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: Settings } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = settingsDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "Settings.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function settingsDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Settings | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
        throw new __mf_DeserializeError([
            {
                field: "_root",
                message: `${"Settings"}.deserializeWithContext: expected an object`
            }
        ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (!("appointmentNotifications" in obj)) {
        errors.push({
            field: "appointmentNotifications",
            message: "missing required field"
        });
    }
    if (!("commissions" in obj)) {
        errors.push({
            field: "commissions",
            message: "missing required field"
        });
    }
    if (!("scheduleSettings" in obj)) {
        errors.push({
            field: "scheduleSettings",
            message: "missing required field"
        });
    }
    if (!("accountOverviewSettings" in obj)) {
        errors.push({
            field: "accountOverviewSettings",
            message: "missing required field"
        });
    }
    if (!("serviceOverviewSettings" in obj)) {
        errors.push({
            field: "serviceOverviewSettings",
            message: "missing required field"
        });
    }
    if (!("appointmentOverviewSettings" in obj)) {
        errors.push({
            field: "appointmentOverviewSettings",
            message: "missing required field"
        });
    }
    if (!("leadOverviewSettings" in obj)) {
        errors.push({
            field: "leadOverviewSettings",
            message: "missing required field"
        });
    }
    if (!("packageOverviewSettings" in obj)) {
        errors.push({
            field: "packageOverviewSettings",
            message: "missing required field"
        });
    }
    if (!("productOverviewSettings" in obj)) {
        errors.push({
            field: "productOverviewSettings",
            message: "missing required field"
        });
    }
    if (!("orderOverviewSettings" in obj)) {
        errors.push({
            field: "orderOverviewSettings",
            message: "missing required field"
        });
    }
    if (!("taxRateOverviewSettings" in obj)) {
        errors.push({
            field: "taxRateOverviewSettings",
            message: "missing required field"
        });
    }
    if (!("homePage" in obj)) {
        errors.push({
            field: "homePage",
            message: "missing required field"
        });
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
        ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
        const __raw_appointmentNotifications = obj["appointmentNotifications"] as AppointmentNotifications | null;
        if (__raw_appointmentNotifications === null) {
            instance.appointmentNotifications = null;
        } else {
            const __result = appointmentNotificationsDeserializeWithContext(__raw_appointmentNotifications, ctx);
            ctx.assignOrDefer(instance, "appointmentNotifications", __result);
        }
    }
    {
        const __raw_commissions = obj["commissions"] as Commissions | null;
        if (__raw_commissions === null) {
            instance.commissions = null;
        } else {
            const __result = commissionsDeserializeWithContext(__raw_commissions, ctx);
            ctx.assignOrDefer(instance, "commissions", __result);
        }
    }
    {
        const __raw_scheduleSettings = obj["scheduleSettings"] as ScheduleSettings;
        {
            const __result = scheduleSettingsDeserializeWithContext(__raw_scheduleSettings, ctx);
            ctx.assignOrDefer(instance, "scheduleSettings", __result);
        }
    }
    {
        const __raw_accountOverviewSettings = obj["accountOverviewSettings"] as OverviewSettings;
        {
            const __result = overviewSettingsDeserializeWithContext(__raw_accountOverviewSettings, ctx);
            ctx.assignOrDefer(instance, "accountOverviewSettings", __result);
        }
    }
    {
        const __raw_serviceOverviewSettings = obj["serviceOverviewSettings"] as OverviewSettings;
        {
            const __result = overviewSettingsDeserializeWithContext(__raw_serviceOverviewSettings, ctx);
            ctx.assignOrDefer(instance, "serviceOverviewSettings", __result);
        }
    }
    {
        const __raw_appointmentOverviewSettings = obj["appointmentOverviewSettings"] as OverviewSettings;
        {
            const __result = overviewSettingsDeserializeWithContext(__raw_appointmentOverviewSettings, ctx);
            ctx.assignOrDefer(instance, "appointmentOverviewSettings", __result);
        }
    }
    {
        const __raw_leadOverviewSettings = obj["leadOverviewSettings"] as OverviewSettings;
        {
            const __result = overviewSettingsDeserializeWithContext(__raw_leadOverviewSettings, ctx);
            ctx.assignOrDefer(instance, "leadOverviewSettings", __result);
        }
    }
    {
        const __raw_packageOverviewSettings = obj["packageOverviewSettings"] as OverviewSettings;
        {
            const __result = overviewSettingsDeserializeWithContext(__raw_packageOverviewSettings, ctx);
            ctx.assignOrDefer(instance, "packageOverviewSettings", __result);
        }
    }
    {
        const __raw_productOverviewSettings = obj["productOverviewSettings"] as OverviewSettings;
        {
            const __result = overviewSettingsDeserializeWithContext(__raw_productOverviewSettings, ctx);
            ctx.assignOrDefer(instance, "productOverviewSettings", __result);
        }
    }
    {
        const __raw_orderOverviewSettings = obj["orderOverviewSettings"] as OverviewSettings;
        {
            const __result = overviewSettingsDeserializeWithContext(__raw_orderOverviewSettings, ctx);
            ctx.assignOrDefer(instance, "orderOverviewSettings", __result);
        }
    }
    {
        const __raw_taxRateOverviewSettings = obj["taxRateOverviewSettings"] as OverviewSettings;
        {
            const __result = overviewSettingsDeserializeWithContext(__raw_taxRateOverviewSettings, ctx);
            ctx.assignOrDefer(instance, "taxRateOverviewSettings", __result);
        }
    }
    {
        const __raw_homePage = obj["homePage"] as Page;
        {
            const __result = pageDeserializeWithContext(__raw_homePage, ctx);
            ctx.assignOrDefer(instance, "homePage", __result);
        }
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    return instance as Settings;
}
export function settingsValidateField<K extends keyof Settings>(_field: K, _value: Settings[K]): Array<{
    field: string;
    message: string;
}> {
    return [];
}
export function settingsValidateFields(_partial: Partial<Settings>): Array<{
    field: string;
    message: string;
}> {
    return [];
}
export function settingsHasShape(obj: unknown): boolean {
    if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
        return false;
    }
    const o = obj as Record<string, unknown>;
    return '"appointmentNotifications" in o && "commissions" in o && "scheduleSettings" in o && "accountOverviewSettings" in o && "serviceOverviewSettings" in o && "appointmentOverviewSettings" in o && "leadOverviewSettings" in o && "packageOverviewSettings" in o && "productOverviewSettings" in o && "orderOverviewSettings" in o && "taxRateOverviewSettings" in o && "homePage" in o';
}
export function settingsIs(obj: unknown): obj is Settings {
    if (!settingsHasShape(obj)) {
        return false;
    }
    const result = settingsDeserialize(obj);
    return result.success;
}

export type SettingsErrors = {
    _errors: __gf_Option<Array<string>>;
    appointmentNotifications: __gf_Option<Array<string>>;
    commissions: __gf_Option<Array<string>>;
    scheduleSettings: __gf_Option<Array<string>>;
    accountOverviewSettings: __gf_Option<Array<string>>;
    serviceOverviewSettings: __gf_Option<Array<string>>;
    appointmentOverviewSettings: __gf_Option<Array<string>>;
    leadOverviewSettings: __gf_Option<Array<string>>;
    packageOverviewSettings: __gf_Option<Array<string>>;
    productOverviewSettings: __gf_Option<Array<string>>;
    orderOverviewSettings: __gf_Option<Array<string>>;
    taxRateOverviewSettings: __gf_Option<Array<string>>;
    homePage: __gf_Option<Array<string>>;
};
export type SettingsTainted = {
    appointmentNotifications: __gf_Option<boolean>;
    commissions: __gf_Option<boolean>;
    scheduleSettings: __gf_Option<boolean>;
    accountOverviewSettings: __gf_Option<boolean>;
    serviceOverviewSettings: __gf_Option<boolean>;
    appointmentOverviewSettings: __gf_Option<boolean>;
    leadOverviewSettings: __gf_Option<boolean>;
    packageOverviewSettings: __gf_Option<boolean>;
    productOverviewSettings: __gf_Option<boolean>;
    orderOverviewSettings: __gf_Option<boolean>;
    taxRateOverviewSettings: __gf_Option<boolean>;
    homePage: __gf_Option<boolean>;
};
export interface SettingsFieldControllers {
    readonly appointmentNotifications: FieldController<AppointmentNotifications | null>;
    readonly commissions: FieldController<Commissions | null>;
    readonly scheduleSettings: FieldController<ScheduleSettings>;
    readonly accountOverviewSettings: FieldController<OverviewSettings>;
    readonly serviceOverviewSettings: FieldController<OverviewSettings>;
    readonly appointmentOverviewSettings: FieldController<OverviewSettings>;
    readonly leadOverviewSettings: FieldController<OverviewSettings>;
    readonly packageOverviewSettings: FieldController<OverviewSettings>;
    readonly productOverviewSettings: FieldController<OverviewSettings>;
    readonly orderOverviewSettings: FieldController<OverviewSettings>;
    readonly taxRateOverviewSettings: FieldController<OverviewSettings>;
    readonly homePage: FieldController<Page>;
}
export interface SettingsGigaform {
    readonly data: Settings;
    readonly errors: SettingsErrors;
    readonly tainted: SettingsTainted;
    readonly fields: SettingsFieldControllers;
    validate(): Exit<Settings, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<Settings>): void;
}
export function settingsCreateForm(overrides?: Partial<Settings>): SettingsGigaform {
    let data = $state({
        ...settingsDefaultValue(),
        ...overrides
    });
    let errors = $state<SettingsErrors>({
        _errors: optionNone(),
        appointmentNotifications: optionNone(),
        commissions: optionNone(),
        scheduleSettings: optionNone(),
        accountOverviewSettings: optionNone(),
        serviceOverviewSettings: optionNone(),
        appointmentOverviewSettings: optionNone(),
        leadOverviewSettings: optionNone(),
        packageOverviewSettings: optionNone(),
        productOverviewSettings: optionNone(),
        orderOverviewSettings: optionNone(),
        taxRateOverviewSettings: optionNone(),
        homePage: optionNone()
    } as SettingsErrors);
    let tainted = $state<SettingsTainted>({
        appointmentNotifications: optionNone(),
        commissions: optionNone(),
        scheduleSettings: optionNone(),
        accountOverviewSettings: optionNone(),
        serviceOverviewSettings: optionNone(),
        appointmentOverviewSettings: optionNone(),
        leadOverviewSettings: optionNone(),
        packageOverviewSettings: optionNone(),
        productOverviewSettings: optionNone(),
        orderOverviewSettings: optionNone(),
        taxRateOverviewSettings: optionNone(),
        homePage: optionNone()
    } as SettingsTainted);
    const fields = {
        appointmentNotifications: {
            path: [
                "appointmentNotifications"
            ] as const,
            name: "appointmentNotifications",
            constraints: {
                required: true
            },
            get: ()=>data.appointmentNotifications,
            set: (value: AppointmentNotifications | null)=>{
                data.appointmentNotifications = value;
            },
            transform: (value: AppointmentNotifications | null): AppointmentNotifications | null =>value,
            getError: ()=>errors.appointmentNotifications,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.appointmentNotifications = value;
            },
            getTainted: ()=>tainted.appointmentNotifications,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.appointmentNotifications = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = settingsValidateField("appointmentNotifications", data.appointmentNotifications);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        commissions: {
            path: [
                "commissions"
            ] as const,
            name: "commissions",
            constraints: {
                required: true
            },
            get: ()=>data.commissions,
            set: (value: Commissions | null)=>{
                data.commissions = value;
            },
            transform: (value: Commissions | null): Commissions | null =>value,
            getError: ()=>errors.commissions,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.commissions = value;
            },
            getTainted: ()=>tainted.commissions,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.commissions = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = settingsValidateField("commissions", data.commissions);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        scheduleSettings: {
            path: [
                "scheduleSettings"
            ] as const,
            name: "scheduleSettings",
            constraints: {
                required: true
            },
            get: ()=>data.scheduleSettings,
            set: (value: ScheduleSettings)=>{
                data.scheduleSettings = value;
            },
            transform: (value: ScheduleSettings): ScheduleSettings =>value,
            getError: ()=>errors.scheduleSettings,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.scheduleSettings = value;
            },
            getTainted: ()=>tainted.scheduleSettings,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.scheduleSettings = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = settingsValidateField("scheduleSettings", data.scheduleSettings);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        accountOverviewSettings: {
            path: [
                "accountOverviewSettings"
            ] as const,
            name: "accountOverviewSettings",
            constraints: {
                required: true
            },
            get: ()=>data.accountOverviewSettings,
            set: (value: OverviewSettings)=>{
                data.accountOverviewSettings = value;
            },
            transform: (value: OverviewSettings): OverviewSettings =>value,
            getError: ()=>errors.accountOverviewSettings,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.accountOverviewSettings = value;
            },
            getTainted: ()=>tainted.accountOverviewSettings,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.accountOverviewSettings = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = settingsValidateField("accountOverviewSettings", data.accountOverviewSettings);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        serviceOverviewSettings: {
            path: [
                "serviceOverviewSettings"
            ] as const,
            name: "serviceOverviewSettings",
            constraints: {
                required: true
            },
            get: ()=>data.serviceOverviewSettings,
            set: (value: OverviewSettings)=>{
                data.serviceOverviewSettings = value;
            },
            transform: (value: OverviewSettings): OverviewSettings =>value,
            getError: ()=>errors.serviceOverviewSettings,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.serviceOverviewSettings = value;
            },
            getTainted: ()=>tainted.serviceOverviewSettings,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.serviceOverviewSettings = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = settingsValidateField("serviceOverviewSettings", data.serviceOverviewSettings);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        appointmentOverviewSettings: {
            path: [
                "appointmentOverviewSettings"
            ] as const,
            name: "appointmentOverviewSettings",
            constraints: {
                required: true
            },
            get: ()=>data.appointmentOverviewSettings,
            set: (value: OverviewSettings)=>{
                data.appointmentOverviewSettings = value;
            },
            transform: (value: OverviewSettings): OverviewSettings =>value,
            getError: ()=>errors.appointmentOverviewSettings,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.appointmentOverviewSettings = value;
            },
            getTainted: ()=>tainted.appointmentOverviewSettings,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.appointmentOverviewSettings = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = settingsValidateField("appointmentOverviewSettings", data.appointmentOverviewSettings);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        leadOverviewSettings: {
            path: [
                "leadOverviewSettings"
            ] as const,
            name: "leadOverviewSettings",
            constraints: {
                required: true
            },
            get: ()=>data.leadOverviewSettings,
            set: (value: OverviewSettings)=>{
                data.leadOverviewSettings = value;
            },
            transform: (value: OverviewSettings): OverviewSettings =>value,
            getError: ()=>errors.leadOverviewSettings,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.leadOverviewSettings = value;
            },
            getTainted: ()=>tainted.leadOverviewSettings,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.leadOverviewSettings = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = settingsValidateField("leadOverviewSettings", data.leadOverviewSettings);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        packageOverviewSettings: {
            path: [
                "packageOverviewSettings"
            ] as const,
            name: "packageOverviewSettings",
            constraints: {
                required: true
            },
            get: ()=>data.packageOverviewSettings,
            set: (value: OverviewSettings)=>{
                data.packageOverviewSettings = value;
            },
            transform: (value: OverviewSettings): OverviewSettings =>value,
            getError: ()=>errors.packageOverviewSettings,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.packageOverviewSettings = value;
            },
            getTainted: ()=>tainted.packageOverviewSettings,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.packageOverviewSettings = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = settingsValidateField("packageOverviewSettings", data.packageOverviewSettings);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        productOverviewSettings: {
            path: [
                "productOverviewSettings"
            ] as const,
            name: "productOverviewSettings",
            constraints: {
                required: true
            },
            get: ()=>data.productOverviewSettings,
            set: (value: OverviewSettings)=>{
                data.productOverviewSettings = value;
            },
            transform: (value: OverviewSettings): OverviewSettings =>value,
            getError: ()=>errors.productOverviewSettings,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.productOverviewSettings = value;
            },
            getTainted: ()=>tainted.productOverviewSettings,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.productOverviewSettings = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = settingsValidateField("productOverviewSettings", data.productOverviewSettings);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        orderOverviewSettings: {
            path: [
                "orderOverviewSettings"
            ] as const,
            name: "orderOverviewSettings",
            constraints: {
                required: true
            },
            get: ()=>data.orderOverviewSettings,
            set: (value: OverviewSettings)=>{
                data.orderOverviewSettings = value;
            },
            transform: (value: OverviewSettings): OverviewSettings =>value,
            getError: ()=>errors.orderOverviewSettings,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.orderOverviewSettings = value;
            },
            getTainted: ()=>tainted.orderOverviewSettings,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.orderOverviewSettings = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = settingsValidateField("orderOverviewSettings", data.orderOverviewSettings);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        taxRateOverviewSettings: {
            path: [
                "taxRateOverviewSettings"
            ] as const,
            name: "taxRateOverviewSettings",
            constraints: {
                required: true
            },
            get: ()=>data.taxRateOverviewSettings,
            set: (value: OverviewSettings)=>{
                data.taxRateOverviewSettings = value;
            },
            transform: (value: OverviewSettings): OverviewSettings =>value,
            getError: ()=>errors.taxRateOverviewSettings,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.taxRateOverviewSettings = value;
            },
            getTainted: ()=>tainted.taxRateOverviewSettings,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.taxRateOverviewSettings = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = settingsValidateField("taxRateOverviewSettings", data.taxRateOverviewSettings);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        homePage: {
            path: [
                "homePage"
            ] as const,
            name: "homePage",
            constraints: {
                required: true
            },
            get: ()=>data.homePage,
            set: (value: Page)=>{
                data.homePage = value;
            },
            transform: (value: Page): Page =>value,
            getError: ()=>errors.homePage,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.homePage = value;
            },
            getTainted: ()=>tainted.homePage,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.homePage = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = settingsValidateField("homePage", data.homePage);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        }
    } as SettingsFieldControllers;
    const __gf_getter_hint = "get data() set data(v) get errors() set errors(v) get tainted() set tainted(v)";
    const __gf_validate_hint = ".map((e: { field: string; message: string }) => e.message)";
    function validate(): Exit<Settings, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(settingsDeserialize(data));
    }
    function reset(newOverrides?: Partial<Settings>): void {
        data = {
            ...settingsDefaultValue(),
            ...newOverrides
        };
        errors = {
            _errors: optionNone(),
            appointmentNotifications: optionNone(),
            commissions: optionNone(),
            scheduleSettings: optionNone(),
            accountOverviewSettings: optionNone(),
            serviceOverviewSettings: optionNone(),
            appointmentOverviewSettings: optionNone(),
            leadOverviewSettings: optionNone(),
            packageOverviewSettings: optionNone(),
            productOverviewSettings: optionNone(),
            orderOverviewSettings: optionNone(),
            taxRateOverviewSettings: optionNone(),
            homePage: optionNone()
        };
        tainted = {
            appointmentNotifications: optionNone(),
            commissions: optionNone(),
            scheduleSettings: optionNone(),
            accountOverviewSettings: optionNone(),
            serviceOverviewSettings: optionNone(),
            appointmentOverviewSettings: optionNone(),
            leadOverviewSettings: optionNone(),
            packageOverviewSettings: optionNone(),
            productOverviewSettings: optionNone(),
            orderOverviewSettings: optionNone(),
            taxRateOverviewSettings: optionNone(),
            homePage: optionNone()
        };
    }
    return {
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        fields,
        validate,
        reset
    };
}
export function settingsFromFormData(formData: FormData): Exit<Settings, Array<{
    field: string;
    message: string;
}>> {
    const obj: Record<string, unknown> = {};
    const __gf_exit_hint = "Exit<Settings, Array<{ field: string; message: string }>>";
    obj.appointmentNotifications = formData.get(`${"appointmentNotifications"}`) ?? "";
    obj.commissions = formData.get(`${"commissions"}`) ?? "";
    {
        const scheduleSettingsObj: Record<string, unknown> = {};
        for (const [key, value] of Array.from(formData.entries())){
            if (key.startsWith(`${"scheduleSettings"}.`)) {
                const fieldName = key.slice(`${"scheduleSettings"}.`.length);
                const parts = fieldName.split(".");
                let current = scheduleSettingsObj;
                for(let i = 0; i < parts.length - 1; i++){
                    const part = parts[i]!;
                    if (!(part in current)) {
                        current[part] = {};
                    }
                    current = current[part] as Record<string, unknown>;
                }
                current[parts[parts.length - 1]!] = value;
            }
        }
        obj.scheduleSettings = scheduleSettingsObj;
    }
    {
        const accountOverviewSettingsObj: Record<string, unknown> = {};
        for (const [key, value] of Array.from(formData.entries())){
            if (key.startsWith(`${"accountOverviewSettings"}.`)) {
                const fieldName = key.slice(`${"accountOverviewSettings"}.`.length);
                const parts = fieldName.split(".");
                let current = accountOverviewSettingsObj;
                for(let i = 0; i < parts.length - 1; i++){
                    const part = parts[i]!;
                    if (!(part in current)) {
                        current[part] = {};
                    }
                    current = current[part] as Record<string, unknown>;
                }
                current[parts[parts.length - 1]!] = value;
            }
        }
        obj.accountOverviewSettings = accountOverviewSettingsObj;
    }
    {
        const serviceOverviewSettingsObj: Record<string, unknown> = {};
        for (const [key, value] of Array.from(formData.entries())){
            if (key.startsWith(`${"serviceOverviewSettings"}.`)) {
                const fieldName = key.slice(`${"serviceOverviewSettings"}.`.length);
                const parts = fieldName.split(".");
                let current = serviceOverviewSettingsObj;
                for(let i = 0; i < parts.length - 1; i++){
                    const part = parts[i]!;
                    if (!(part in current)) {
                        current[part] = {};
                    }
                    current = current[part] as Record<string, unknown>;
                }
                current[parts[parts.length - 1]!] = value;
            }
        }
        obj.serviceOverviewSettings = serviceOverviewSettingsObj;
    }
    {
        const appointmentOverviewSettingsObj: Record<string, unknown> = {};
        for (const [key, value] of Array.from(formData.entries())){
            if (key.startsWith(`${"appointmentOverviewSettings"}.`)) {
                const fieldName = key.slice(`${"appointmentOverviewSettings"}.`.length);
                const parts = fieldName.split(".");
                let current = appointmentOverviewSettingsObj;
                for(let i = 0; i < parts.length - 1; i++){
                    const part = parts[i]!;
                    if (!(part in current)) {
                        current[part] = {};
                    }
                    current = current[part] as Record<string, unknown>;
                }
                current[parts[parts.length - 1]!] = value;
            }
        }
        obj.appointmentOverviewSettings = appointmentOverviewSettingsObj;
    }
    {
        const leadOverviewSettingsObj: Record<string, unknown> = {};
        for (const [key, value] of Array.from(formData.entries())){
            if (key.startsWith(`${"leadOverviewSettings"}.`)) {
                const fieldName = key.slice(`${"leadOverviewSettings"}.`.length);
                const parts = fieldName.split(".");
                let current = leadOverviewSettingsObj;
                for(let i = 0; i < parts.length - 1; i++){
                    const part = parts[i]!;
                    if (!(part in current)) {
                        current[part] = {};
                    }
                    current = current[part] as Record<string, unknown>;
                }
                current[parts[parts.length - 1]!] = value;
            }
        }
        obj.leadOverviewSettings = leadOverviewSettingsObj;
    }
    {
        const packageOverviewSettingsObj: Record<string, unknown> = {};
        for (const [key, value] of Array.from(formData.entries())){
            if (key.startsWith(`${"packageOverviewSettings"}.`)) {
                const fieldName = key.slice(`${"packageOverviewSettings"}.`.length);
                const parts = fieldName.split(".");
                let current = packageOverviewSettingsObj;
                for(let i = 0; i < parts.length - 1; i++){
                    const part = parts[i]!;
                    if (!(part in current)) {
                        current[part] = {};
                    }
                    current = current[part] as Record<string, unknown>;
                }
                current[parts[parts.length - 1]!] = value;
            }
        }
        obj.packageOverviewSettings = packageOverviewSettingsObj;
    }
    {
        const productOverviewSettingsObj: Record<string, unknown> = {};
        for (const [key, value] of Array.from(formData.entries())){
            if (key.startsWith(`${"productOverviewSettings"}.`)) {
                const fieldName = key.slice(`${"productOverviewSettings"}.`.length);
                const parts = fieldName.split(".");
                let current = productOverviewSettingsObj;
                for(let i = 0; i < parts.length - 1; i++){
                    const part = parts[i]!;
                    if (!(part in current)) {
                        current[part] = {};
                    }
                    current = current[part] as Record<string, unknown>;
                }
                current[parts[parts.length - 1]!] = value;
            }
        }
        obj.productOverviewSettings = productOverviewSettingsObj;
    }
    {
        const orderOverviewSettingsObj: Record<string, unknown> = {};
        for (const [key, value] of Array.from(formData.entries())){
            if (key.startsWith(`${"orderOverviewSettings"}.`)) {
                const fieldName = key.slice(`${"orderOverviewSettings"}.`.length);
                const parts = fieldName.split(".");
                let current = orderOverviewSettingsObj;
                for(let i = 0; i < parts.length - 1; i++){
                    const part = parts[i]!;
                    if (!(part in current)) {
                        current[part] = {};
                    }
                    current = current[part] as Record<string, unknown>;
                }
                current[parts[parts.length - 1]!] = value;
            }
        }
        obj.orderOverviewSettings = orderOverviewSettingsObj;
    }
    {
        const taxRateOverviewSettingsObj: Record<string, unknown> = {};
        for (const [key, value] of Array.from(formData.entries())){
            if (key.startsWith(`${"taxRateOverviewSettings"}.`)) {
                const fieldName = key.slice(`${"taxRateOverviewSettings"}.`.length);
                const parts = fieldName.split(".");
                let current = taxRateOverviewSettingsObj;
                for(let i = 0; i < parts.length - 1; i++){
                    const part = parts[i]!;
                    if (!(part in current)) {
                        current[part] = {};
                    }
                    current = current[part] as Record<string, unknown>;
                }
                current[parts[parts.length - 1]!] = value;
            }
        }
        obj.taxRateOverviewSettings = taxRateOverviewSettingsObj;
    }
    {
        const homePageObj: Record<string, unknown> = {};
        for (const [key, value] of Array.from(formData.entries())){
            if (key.startsWith(`${"homePage"}.`)) {
                const fieldName = key.slice(`${"homePage"}.`.length);
                const parts = fieldName.split(".");
                let current = homePageObj;
                for(let i = 0; i < parts.length - 1; i++){
                    const part = parts[i]!;
                    if (!(part in current)) {
                        current[part] = {};
                    }
                    current = current[part] as Record<string, unknown>;
                }
                current[parts[parts.length - 1]!] = value;
            }
        }
        obj.homePage = homePageObj;
    }
    return toExit(settingsDeserialize(obj));
}

export const Settings = {
  defaultValue: settingsDefaultValue,
  serialize: settingsSerialize,
  serializeWithContext: settingsSerializeWithContext,
  deserialize: settingsDeserialize,
  deserializeWithContext: settingsDeserializeWithContext,
  validateFields: settingsValidateFields,
  hasShape: settingsHasShape,
  is: settingsIs,
  createForm: settingsCreateForm,
  fromFormData: settingsFromFormData
} as const;


export interface Color {
    red: number;
    green: number;
    blue: number;
}

export function colorDefaultValue(): Color {
    return {
        red: 0,
        green: 0,
        blue: 0
    } as Color;
}

export function colorSerialize(value: Color): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(colorSerializeWithContext(value, ctx));
}
export function colorSerializeWithContext(value: Color, ctx: __mf_SerializeContext): Record<string, unknown> {
    const existingId = ctx.getId(value);
    if (existingId !== undefined) {
        return {
            __ref: existingId
        };
    }
    const __id = ctx.register(value);
    const result: Record<string, unknown> = {
        __type: "Color",
        __id
    };
    result.red = value.red;
    result.green = value.green;
    result.blue = value.blue;
    return result;
}

export function colorDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: Color } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = colorDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "Color.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function colorDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Color | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
        throw new __mf_DeserializeError([
            {
                field: "_root",
                message: `${"Color"}.deserializeWithContext: expected an object`
            }
        ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (!("red" in obj)) {
        errors.push({
            field: "red",
            message: "missing required field"
        });
    }
    if (!("green" in obj)) {
        errors.push({
            field: "green",
            message: "missing required field"
        });
    }
    if (!("blue" in obj)) {
        errors.push({
            field: "blue",
            message: "missing required field"
        });
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
        ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
        const __raw_red = obj["red"] as number;
        instance.red = __raw_red;
    }
    {
        const __raw_green = obj["green"] as number;
        instance.green = __raw_green;
    }
    {
        const __raw_blue = obj["blue"] as number;
        instance.blue = __raw_blue;
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    return instance as Color;
}
export function colorValidateField<K extends keyof Color>(_field: K, _value: Color[K]): Array<{
    field: string;
    message: string;
}> {
    return [];
}
export function colorValidateFields(_partial: Partial<Color>): Array<{
    field: string;
    message: string;
}> {
    return [];
}
export function colorHasShape(obj: unknown): boolean {
    if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
        return false;
    }
    const o = obj as Record<string, unknown>;
    return '"red" in o && "green" in o && "blue" in o';
}
export function colorIs(obj: unknown): obj is Color {
    if (!colorHasShape(obj)) {
        return false;
    }
    const result = colorDeserialize(obj);
    return result.success;
}

export type ColorErrors = {
    _errors: __gf_Option<Array<string>>;
    red: __gf_Option<Array<string>>;
    green: __gf_Option<Array<string>>;
    blue: __gf_Option<Array<string>>;
};
export type ColorTainted = {
    red: __gf_Option<boolean>;
    green: __gf_Option<boolean>;
    blue: __gf_Option<boolean>;
};
export interface ColorFieldControllers {
    readonly red: FieldController<number>;
    readonly green: FieldController<number>;
    readonly blue: FieldController<number>;
}
export interface ColorGigaform {
    readonly data: Color;
    readonly errors: ColorErrors;
    readonly tainted: ColorTainted;
    readonly fields: ColorFieldControllers;
    validate(): Exit<Color, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<Color>): void;
}
export function colorCreateForm(overrides?: Partial<Color>): ColorGigaform {
    let data = $state({
        ...colorDefaultValue(),
        ...overrides
    });
    let errors = $state<ColorErrors>({
        _errors: optionNone(),
        red: optionNone(),
        green: optionNone(),
        blue: optionNone()
    } as ColorErrors);
    let tainted = $state<ColorTainted>({
        red: optionNone(),
        green: optionNone(),
        blue: optionNone()
    } as ColorTainted);
    const fields = {
        red: {
            path: [
                "red"
            ] as const,
            name: "red",
            constraints: {
                required: true
            },
            get: ()=>data.red,
            set: (value: number)=>{
                data.red = value;
            },
            transform: (value: number): number =>value,
            getError: ()=>errors.red,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.red = value;
            },
            getTainted: ()=>tainted.red,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.red = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = colorValidateField("red", data.red);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        green: {
            path: [
                "green"
            ] as const,
            name: "green",
            constraints: {
                required: true
            },
            get: ()=>data.green,
            set: (value: number)=>{
                data.green = value;
            },
            transform: (value: number): number =>value,
            getError: ()=>errors.green,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.green = value;
            },
            getTainted: ()=>tainted.green,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.green = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = colorValidateField("green", data.green);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        blue: {
            path: [
                "blue"
            ] as const,
            name: "blue",
            constraints: {
                required: true
            },
            get: ()=>data.blue,
            set: (value: number)=>{
                data.blue = value;
            },
            transform: (value: number): number =>value,
            getError: ()=>errors.blue,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.blue = value;
            },
            getTainted: ()=>tainted.blue,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.blue = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = colorValidateField("blue", data.blue);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        }
    } as ColorFieldControllers;
    const __gf_getter_hint = "get data() set data(v) get errors() set errors(v) get tainted() set tainted(v)";
    const __gf_validate_hint = ".map((e: { field: string; message: string }) => e.message)";
    function validate(): Exit<Color, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(colorDeserialize(data));
    }
    function reset(newOverrides?: Partial<Color>): void {
        data = {
            ...colorDefaultValue(),
            ...newOverrides
        };
        errors = {
            _errors: optionNone(),
            red: optionNone(),
            green: optionNone(),
            blue: optionNone()
        };
        tainted = {
            red: optionNone(),
            green: optionNone(),
            blue: optionNone()
        };
    }
    return {
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        fields,
        validate,
        reset
    };
}
export function colorFromFormData(formData: FormData): Exit<Color, Array<{
    field: string;
    message: string;
}>> {
    const obj: Record<string, unknown> = {};
    const __gf_exit_hint = "Exit<Color, Array<{ field: string; message: string }>>";
    {
        const redStr = formData.get(`${"red"}`);
        obj.red = redStr ? parseFloat(redStr as string) : $MfPh5;
        if (obj.red !== undefined && isNaN(obj.red as number)) obj.red = "0";
    }
    {
        const greenStr = formData.get(`${"green"}`);
        obj.green = greenStr ? parseFloat(greenStr as string) : $MfPh5;
        if (obj.green !== undefined && isNaN(obj.green as number)) obj.green = "0";
    }
    {
        const blueStr = formData.get(`${"blue"}`);
        obj.blue = blueStr ? parseFloat(blueStr as string) : $MfPh5;
        if (obj.blue !== undefined && isNaN(obj.blue as number)) obj.blue = "0";
    }
    return toExit(colorDeserialize(obj));
}

export const Color = {
  defaultValue: colorDefaultValue,
  serialize: colorSerialize,
  serializeWithContext: colorSerializeWithContext,
  deserialize: colorDeserialize,
  deserializeWithContext: colorDeserializeWithContext,
  validateFields: colorValidateFields,
  hasShape: colorHasShape,
  is: colorIs,
  createForm: colorCreateForm,
  fromFormData: colorFromFormData
} as const;


export interface CompanyName {
    
    
    companyName: string;
}

export function companyNameDefaultValue(): CompanyName {
    return {
        companyName: ""
    } as CompanyName;
}

export function companyNameSerialize(value: CompanyName): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(companyNameSerializeWithContext(value, ctx));
}
export function companyNameSerializeWithContext(value: CompanyName, ctx: __mf_SerializeContext): Record<string, unknown> {
    const existingId = ctx.getId(value);
    if (existingId !== undefined) {
        return {
            __ref: existingId
        };
    }
    const __id = ctx.register(value);
    const result: Record<string, unknown> = {
        __type: "CompanyName",
        __id
    };
    result.companyName = value.companyName;
    return result;
}

export function companyNameDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: CompanyName } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = companyNameDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "CompanyName.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function companyNameDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): CompanyName | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
        throw new __mf_DeserializeError([
            {
                field: "_root",
                message: `${"CompanyName"}.deserializeWithContext: expected an object`
            }
        ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (!("companyName" in obj)) {
        errors.push({
            field: "companyName",
            message: "missing required field"
        });
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
        ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
        const __raw_companyName = obj["companyName"] as string;
        if (__raw_companyName.trim().length === 0) {
            errors.push({
                field: "companyName",
                message: "CompanyName.companyName must not be empty"
            });
        }
        instance.companyName = __raw_companyName;
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    return instance as CompanyName;
}
export function companyNameValidateField<K extends keyof CompanyName>(_field: K, _value: CompanyName[K]): Array<{
    field: string;
    message: string;
}> {
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (_field === "companyName") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "companyName",
                message: "CompanyName.companyName must not be empty"
            });
        }
    }
    return errors;
}
export function companyNameValidateFields(_partial: Partial<CompanyName>): Array<{
    field: string;
    message: string;
}> {
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if ("companyName" in _partial && _partial.companyName !== undefined) {
        const __val = _partial.companyName as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "companyName",
                message: "CompanyName.companyName must not be empty"
            });
        }
    }
    return errors;
}
export function companyNameHasShape(obj: unknown): boolean {
    if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
        return false;
    }
    const o = obj as Record<string, unknown>;
    return '"companyName" in o';
}
export function companyNameIs(obj: unknown): obj is CompanyName {
    if (!companyNameHasShape(obj)) {
        return false;
    }
    const result = companyNameDeserialize(obj);
    return result.success;
}

export type CompanyNameErrors = {
    _errors: __gf_Option<Array<string>>;
    companyName: __gf_Option<Array<string>>;
};
export type CompanyNameTainted = {
    companyName: __gf_Option<boolean>;
};
export interface CompanyNameFieldControllers {
    readonly companyName: FieldController<string>;
}
export interface CompanyNameGigaform {
    readonly data: CompanyName;
    readonly errors: CompanyNameErrors;
    readonly tainted: CompanyNameTainted;
    readonly fields: CompanyNameFieldControllers;
    validate(): Exit<CompanyName, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<CompanyName>): void;
}
export function companyNameCreateForm(overrides?: Partial<CompanyName>): CompanyNameGigaform {
    let data = $state({
        ...companyNameDefaultValue(),
        ...overrides
    });
    let errors = $state<CompanyNameErrors>({
        _errors: optionNone(),
        companyName: optionNone()
    } as CompanyNameErrors);
    let tainted = $state<CompanyNameTainted>({
        companyName: optionNone()
    } as CompanyNameTainted);
    const fields = {
        companyName: {
            path: [
                "companyName"
            ] as const,
            name: "companyName",
            constraints: {
                required: true
            },
            label: "Company Name",
            get: ()=>data.companyName,
            set: (value: string)=>{
                data.companyName = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.companyName,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.companyName = value;
            },
            getTainted: ()=>tainted.companyName,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.companyName = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = companyNameValidateField("companyName", data.companyName);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        }
    } as CompanyNameFieldControllers;
    const __gf_getter_hint = "get data() set data(v) get errors() set errors(v) get tainted() set tainted(v)";
    const __gf_validate_hint = ".map((e: { field: string; message: string }) => e.message)";
    function validate(): Exit<CompanyName, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(companyNameDeserialize(data));
    }
    function reset(newOverrides?: Partial<CompanyName>): void {
        data = {
            ...companyNameDefaultValue(),
            ...newOverrides
        };
        errors = {
            _errors: optionNone(),
            companyName: optionNone()
        };
        tainted = {
            companyName: optionNone()
        };
    }
    return {
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        fields,
        validate,
        reset
    };
}
export function companyNameFromFormData(formData: FormData): Exit<CompanyName, Array<{
    field: string;
    message: string;
}>> {
    const obj: Record<string, unknown> = {};
    const __gf_exit_hint = "Exit<CompanyName, Array<{ field: string; message: string }>>";
    obj.companyName = formData.get(`${"companyName"}`) ?? "";
    return toExit(companyNameDeserialize(obj));
}

export const CompanyName = {
  defaultValue: companyNameDefaultValue,
  serialize: companyNameSerialize,
  serializeWithContext: companyNameSerializeWithContext,
  deserialize: companyNameDeserialize,
  deserializeWithContext: companyNameDeserializeWithContext,
  validateFields: companyNameValidateFields,
  hasShape: companyNameHasShape,
  is: companyNameIs,
  createForm: companyNameCreateForm,
  fromFormData: companyNameFromFormData
} as const;


export interface Appointment {
    
    id: string;
    
    
    title: string;
    
    
    status: Status;
    
    begins: string;
    
    duration: number;
    
    timeZone: string;
    
    offsetMs: number;
    
    allDay: boolean;
    
    multiDay: boolean;
    
    employees: Array<string | Employee>;
    
    
    location: string | Site;
    
    description: string | null;
    
    
    colors: Colors;
    
    recurrenceRule: RecurrenceRule | null;
}

export function appointmentDefaultValue(): Appointment {
    return {
        id: "",
        title: "",
        status: "Scheduled",
        begins: "",
        duration: 0,
        timeZone: "",
        offsetMs: 0,
        allDay: false,
        multiDay: false,
        employees: [],
        location: "",
        description: null,
        colors: {
            main: "#000000",
            hover: "#333333",
            active: "#666666"
        },
        recurrenceRule: null
    } as Appointment;
}

export function appointmentSerialize(value: Appointment): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(appointmentSerializeWithContext(value, ctx));
}
export function appointmentSerializeWithContext(value: Appointment, ctx: __mf_SerializeContext): Record<string, unknown> {
    const existingId = ctx.getId(value);
    if (existingId !== undefined) {
        return {
            __ref: existingId
        };
    }
    const __id = ctx.register(value);
    const result: Record<string, unknown> = {
        __type: "Appointment",
        __id
    };
    result.id = value.id;
    result.title = value.title;
    result.status = statusSerializeWithContext(value.status, ctx);
    result.begins = value.begins;
    result.duration = value.duration;
    result.timeZone = value.timeZone;
    result.offsetMs = value.offsetMs;
    result.allDay = value.allDay;
    result.multiDay = value.multiDay;
    result.employees = value.employees;
    result.location = value.location;
    result.description = value.description;
    result.colors = colorsSerializeWithContext(value.colors, ctx);
    if (value.recurrenceRule !== null) {
        result.recurrenceRule = recurrenceRuleSerializeWithContext(value.recurrenceRule, ctx);
    }
    return result;
}

export function appointmentDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: Appointment } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = appointmentDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "Appointment.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function appointmentDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Appointment | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
        throw new __mf_DeserializeError([
            {
                field: "_root",
                message: `${"Appointment"}.deserializeWithContext: expected an object`
            }
        ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (!("id" in obj)) {
        errors.push({
            field: "id",
            message: "missing required field"
        });
    }
    if (!("title" in obj)) {
        errors.push({
            field: "title",
            message: "missing required field"
        });
    }
    if (!("status" in obj)) {
        errors.push({
            field: "status",
            message: "missing required field"
        });
    }
    if (!("begins" in obj)) {
        errors.push({
            field: "begins",
            message: "missing required field"
        });
    }
    if (!("duration" in obj)) {
        errors.push({
            field: "duration",
            message: "missing required field"
        });
    }
    if (!("timeZone" in obj)) {
        errors.push({
            field: "timeZone",
            message: "missing required field"
        });
    }
    if (!("offsetMs" in obj)) {
        errors.push({
            field: "offsetMs",
            message: "missing required field"
        });
    }
    if (!("allDay" in obj)) {
        errors.push({
            field: "allDay",
            message: "missing required field"
        });
    }
    if (!("multiDay" in obj)) {
        errors.push({
            field: "multiDay",
            message: "missing required field"
        });
    }
    if (!("employees" in obj)) {
        errors.push({
            field: "employees",
            message: "missing required field"
        });
    }
    if (!("location" in obj)) {
        errors.push({
            field: "location",
            message: "missing required field"
        });
    }
    if (!("description" in obj)) {
        errors.push({
            field: "description",
            message: "missing required field"
        });
    }
    if (!("colors" in obj)) {
        errors.push({
            field: "colors",
            message: "missing required field"
        });
    }
    if (!("recurrenceRule" in obj)) {
        errors.push({
            field: "recurrenceRule",
            message: "missing required field"
        });
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
        ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
        const __raw_id = obj["id"] as string;
        instance.id = __raw_id;
    }
    {
        const __raw_title = obj["title"] as string;
        if (__raw_title.trim().length === 0) {
            errors.push({
                field: "title",
                message: "Appointment.title must not be empty"
            });
        }
        instance.title = __raw_title;
    }
    {
        const __raw_status = obj["status"] as Status;
        {
            const __result = statusDeserializeWithContext(__raw_status, ctx);
            ctx.assignOrDefer(instance, "status", __result);
        }
    }
    {
        const __raw_begins = obj["begins"] as string;
        instance.begins = __raw_begins;
    }
    {
        const __raw_duration = obj["duration"] as number;
        instance.duration = __raw_duration;
    }
    {
        const __raw_timeZone = obj["timeZone"] as string;
        instance.timeZone = __raw_timeZone;
    }
    {
        const __raw_offsetMs = obj["offsetMs"] as number;
        instance.offsetMs = __raw_offsetMs;
    }
    {
        const __raw_allDay = obj["allDay"] as boolean;
        instance.allDay = __raw_allDay;
    }
    {
        const __raw_multiDay = obj["multiDay"] as boolean;
        instance.multiDay = __raw_multiDay;
    }
    {
        const __raw_employees = obj["employees"] as Array<string | Employee>;
        if (Array.isArray(__raw_employees)) {
            instance.employees = __raw_employees as string | Employee[];
        }
    }
    {
        const __raw_location = obj["location"] as string | Site;
        instance.location = __raw_location;
    }
    {
        const __raw_description = obj["description"] as string | null;
        instance.description = __raw_description;
    }
    {
        const __raw_colors = obj["colors"] as Colors;
        {
            const __result = colorsDeserializeWithContext(__raw_colors, ctx);
            ctx.assignOrDefer(instance, "colors", __result);
        }
    }
    {
        const __raw_recurrenceRule = obj["recurrenceRule"] as RecurrenceRule | null;
        if (__raw_recurrenceRule === null) {
            instance.recurrenceRule = null;
        } else {
            const __result = recurrenceRuleDeserializeWithContext(__raw_recurrenceRule, ctx);
            ctx.assignOrDefer(instance, "recurrenceRule", __result);
        }
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    return instance as Appointment;
}
export function appointmentValidateField<K extends keyof Appointment>(_field: K, _value: Appointment[K]): Array<{
    field: string;
    message: string;
}> {
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (_field === "title") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "title",
                message: "Appointment.title must not be empty"
            });
        }
    }
    return errors;
}
export function appointmentValidateFields(_partial: Partial<Appointment>): Array<{
    field: string;
    message: string;
}> {
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if ("title" in _partial && _partial.title !== undefined) {
        const __val = _partial.title as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "title",
                message: "Appointment.title must not be empty"
            });
        }
    }
    return errors;
}
export function appointmentHasShape(obj: unknown): boolean {
    if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
        return false;
    }
    const o = obj as Record<string, unknown>;
    return '"id" in o && "title" in o && "status" in o && "begins" in o && "duration" in o && "timeZone" in o && "offsetMs" in o && "allDay" in o && "multiDay" in o && "employees" in o && "location" in o && "description" in o && "colors" in o && "recurrenceRule" in o';
}
export function appointmentIs(obj: unknown): obj is Appointment {
    if (!appointmentHasShape(obj)) {
        return false;
    }
    const result = appointmentDeserialize(obj);
    return result.success;
}

export type AppointmentErrors = {
    _errors: __gf_Option<Array<string>>;
    id: __gf_Option<Array<string>>;
    title: __gf_Option<Array<string>>;
    status: __gf_Option<Array<string>>;
    begins: __gf_Option<Array<string>>;
    duration: __gf_Option<Array<string>>;
    timeZone: __gf_Option<Array<string>>;
    offsetMs: __gf_Option<Array<string>>;
    allDay: __gf_Option<Array<string>>;
    multiDay: __gf_Option<Array<string>>;
    employees: __gf_Option<Array<string>>;
    location: __gf_Option<Array<string>>;
    description: __gf_Option<Array<string>>;
    colors: __gf_Option<Array<string>>;
    recurrenceRule: __gf_Option<Array<string>>;
};
export type AppointmentTainted = {
    id: __gf_Option<boolean>;
    title: __gf_Option<boolean>;
    status: __gf_Option<boolean>;
    begins: __gf_Option<boolean>;
    duration: __gf_Option<boolean>;
    timeZone: __gf_Option<boolean>;
    offsetMs: __gf_Option<boolean>;
    allDay: __gf_Option<boolean>;
    multiDay: __gf_Option<boolean>;
    employees: __gf_Option<boolean>;
    location: __gf_Option<boolean>;
    description: __gf_Option<boolean>;
    colors: __gf_Option<boolean>;
    recurrenceRule: __gf_Option<boolean>;
};
export interface AppointmentFieldControllers {
    readonly id: FieldController<string>;
    readonly title: FieldController<string>;
    readonly status: FieldController<Status>;
    readonly begins: FieldController<string>;
    readonly duration: FieldController<number>;
    readonly timeZone: FieldController<string>;
    readonly offsetMs: FieldController<number>;
    readonly allDay: FieldController<boolean>;
    readonly multiDay: FieldController<boolean>;
    readonly employees: ArrayFieldController<string | Employee>;
    readonly location: FieldController<string | Site>;
    readonly description: FieldController<string | null>;
    readonly colors: FieldController<Colors>;
    readonly recurrenceRule: FieldController<RecurrenceRule | null>;
}
export interface AppointmentGigaform {
    readonly data: Appointment;
    readonly errors: AppointmentErrors;
    readonly tainted: AppointmentTainted;
    readonly fields: AppointmentFieldControllers;
    validate(): Exit<Appointment, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<Appointment>): void;
}
export function appointmentCreateForm(overrides?: Partial<Appointment>): AppointmentGigaform {
    let data = $state({
        ...appointmentDefaultValue(),
        ...overrides
    });
    let errors = $state<AppointmentErrors>({
        _errors: optionNone(),
        id: optionNone(),
        title: optionNone(),
        status: optionNone(),
        begins: optionNone(),
        duration: optionNone(),
        timeZone: optionNone(),
        offsetMs: optionNone(),
        allDay: optionNone(),
        multiDay: optionNone(),
        employees: optionNone(),
        location: optionNone(),
        description: optionNone(),
        colors: optionNone(),
        recurrenceRule: optionNone()
    } as AppointmentErrors);
    let tainted = $state<AppointmentTainted>({
        id: optionNone(),
        title: optionNone(),
        status: optionNone(),
        begins: optionNone(),
        duration: optionNone(),
        timeZone: optionNone(),
        offsetMs: optionNone(),
        allDay: optionNone(),
        multiDay: optionNone(),
        employees: optionNone(),
        location: optionNone(),
        description: optionNone(),
        colors: optionNone(),
        recurrenceRule: optionNone()
    } as AppointmentTainted);
    const fields = {
        id: {
            path: [
                "id"
            ] as const,
            name: "id",
            constraints: {
                required: true
            },
            get: ()=>data.id,
            set: (value: string)=>{
                data.id = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.id,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.id = value;
            },
            getTainted: ()=>tainted.id,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.id = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = appointmentValidateField("id", data.id);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        title: {
            path: [
                "title"
            ] as const,
            name: "title",
            constraints: {
                required: true
            },
            label: "Title",
            get: ()=>data.title,
            set: (value: string)=>{
                data.title = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.title,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.title = value;
            },
            getTainted: ()=>tainted.title,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.title = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = appointmentValidateField("title", data.title);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        status: {
            path: [
                "status"
            ] as const,
            name: "status",
            constraints: {
                required: true
            },
            label: "Status",
            get: ()=>data.status,
            set: (value: Status)=>{
                data.status = value;
            },
            transform: (value: Status): Status =>value,
            getError: ()=>errors.status,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.status = value;
            },
            getTainted: ()=>tainted.status,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.status = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = appointmentValidateField("status", data.status);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        begins: {
            path: [
                "begins"
            ] as const,
            name: "begins",
            constraints: {
                required: true
            },
            label: "Begins",
            get: ()=>data.begins,
            set: (value: string)=>{
                data.begins = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.begins,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.begins = value;
            },
            getTainted: ()=>tainted.begins,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.begins = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = appointmentValidateField("begins", data.begins);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        duration: {
            path: [
                "duration"
            ] as const,
            name: "duration",
            constraints: {
                required: true
            },
            label: "Duration",
            get: ()=>data.duration,
            set: (value: number)=>{
                data.duration = value;
            },
            transform: (value: number): number =>value,
            getError: ()=>errors.duration,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.duration = value;
            },
            getTainted: ()=>tainted.duration,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.duration = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = appointmentValidateField("duration", data.duration);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        timeZone: {
            path: [
                "timeZone"
            ] as const,
            name: "timeZone",
            constraints: {
                required: true
            },
            label: "Time Zone",
            get: ()=>data.timeZone,
            set: (value: string)=>{
                data.timeZone = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.timeZone,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.timeZone = value;
            },
            getTainted: ()=>tainted.timeZone,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.timeZone = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = appointmentValidateField("timeZone", data.timeZone);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        offsetMs: {
            path: [
                "offsetMs"
            ] as const,
            name: "offsetMs",
            constraints: {
                required: true
            },
            get: ()=>data.offsetMs,
            set: (value: number)=>{
                data.offsetMs = value;
            },
            transform: (value: number): number =>value,
            getError: ()=>errors.offsetMs,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.offsetMs = value;
            },
            getTainted: ()=>tainted.offsetMs,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.offsetMs = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = appointmentValidateField("offsetMs", data.offsetMs);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        allDay: {
            path: [
                "allDay"
            ] as const,
            name: "allDay",
            constraints: {
                required: true
            },
            label: "All Day",
            get: ()=>data.allDay,
            set: (value: boolean)=>{
                data.allDay = value;
            },
            transform: (value: boolean): boolean =>value,
            getError: ()=>errors.allDay,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.allDay = value;
            },
            getTainted: ()=>tainted.allDay,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.allDay = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = appointmentValidateField("allDay", data.allDay);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        multiDay: {
            path: [
                "multiDay"
            ] as const,
            name: "multiDay",
            constraints: {
                required: true
            },
            label: "Multi Day",
            get: ()=>data.multiDay,
            set: (value: boolean)=>{
                data.multiDay = value;
            },
            transform: (value: boolean): boolean =>value,
            getError: ()=>errors.multiDay,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.multiDay = value;
            },
            getTainted: ()=>tainted.multiDay,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.multiDay = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = appointmentValidateField("multiDay", data.multiDay);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        employees: {
            path: [
                "employees"
            ] as const,
            name: "employees",
            constraints: {
                required: true
            },
            label: "Employees",
            get: ()=>data.employees,
            set: (value: Array<string | Employee>)=>{
                data.employees = value;
            },
            transform: (value: Array<string | Employee>): Array<string | Employee> =>value,
            getError: ()=>errors.employees,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.employees = value;
            },
            getTainted: ()=>tainted.employees,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.employees = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = appointmentValidateField("employees", data.employees);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            },
            at: (index: number)=>({
                    path: [
                        "employees",
                        index
                    ] as const,
                    name: "'^employees.${index}^'",
                    constraints: {
                        required: true
                    },
                    get: ()=>data.employees[index]!,
                    set: (value: string | Employee)=>{
                        data.employees[index] = value;
                    },
                    transform: (value: string | Employee): string | Employee =>value,
                    getError: ()=>errors.employees,
                    setError: (value: __gf_Option<Array<string>>)=>{
                        errors.employees = value;
                    },
                    getTainted: ()=>tainted.employees,
                    setTainted: (value: __gf_Option<boolean>)=>{
                        tainted.employees = value;
                    },
                    validate: (): Array<string> =>[]
                }),
            push: (item: string | Employee)=>{
                data.employees.push(item);
            },
            remove: (index: number)=>{
                data.employees.splice(index, 1);
            },
            swap: (a: number, b: number)=>{
                const tmp = data.employees[a]!;
                data.employees[a] = data.employees[b]!;
                data.employees[b] = tmp;
            }
        },
        location: {
            path: [
                "location"
            ] as const,
            name: "location",
            constraints: {
                required: true
            },
            label: "Location",
            get: ()=>data.location,
            set: (value: string | Site)=>{
                data.location = value;
            },
            transform: (value: string | Site): string | Site =>value,
            getError: ()=>errors.location,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.location = value;
            },
            getTainted: ()=>tainted.location,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.location = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = appointmentValidateField("location", data.location);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        description: {
            path: [
                "description"
            ] as const,
            name: "description",
            constraints: {
                required: true
            },
            label: "Description",
            get: ()=>data.description,
            set: (value: string | null)=>{
                data.description = value;
            },
            transform: (value: string | null): string | null =>value,
            getError: ()=>errors.description,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.description = value;
            },
            getTainted: ()=>tainted.description,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.description = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = appointmentValidateField("description", data.description);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        colors: {
            path: [
                "colors"
            ] as const,
            name: "colors",
            constraints: {
                required: true
            },
            get: ()=>data.colors,
            set: (value: Colors)=>{
                data.colors = value;
            },
            transform: (value: Colors): Colors =>value,
            getError: ()=>errors.colors,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.colors = value;
            },
            getTainted: ()=>tainted.colors,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.colors = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = appointmentValidateField("colors", data.colors);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        recurrenceRule: {
            path: [
                "recurrenceRule"
            ] as const,
            name: "recurrenceRule",
            constraints: {
                required: true
            },
            get: ()=>data.recurrenceRule,
            set: (value: RecurrenceRule | null)=>{
                data.recurrenceRule = value;
            },
            transform: (value: RecurrenceRule | null): RecurrenceRule | null =>value,
            getError: ()=>errors.recurrenceRule,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.recurrenceRule = value;
            },
            getTainted: ()=>tainted.recurrenceRule,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.recurrenceRule = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = appointmentValidateField("recurrenceRule", data.recurrenceRule);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        }
    } as AppointmentFieldControllers;
    const __gf_getter_hint = "get data() set data(v) get errors() set errors(v) get tainted() set tainted(v)";
    const __gf_validate_hint = ".map((e: { field: string; message: string }) => e.message)";
    function validate(): Exit<Appointment, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(appointmentDeserialize(data));
    }
    function reset(newOverrides?: Partial<Appointment>): void {
        data = {
            ...appointmentDefaultValue(),
            ...newOverrides
        };
        errors = {
            _errors: optionNone(),
            id: optionNone(),
            title: optionNone(),
            status: optionNone(),
            begins: optionNone(),
            duration: optionNone(),
            timeZone: optionNone(),
            offsetMs: optionNone(),
            allDay: optionNone(),
            multiDay: optionNone(),
            employees: optionNone(),
            location: optionNone(),
            description: optionNone(),
            colors: optionNone(),
            recurrenceRule: optionNone()
        };
        tainted = {
            id: optionNone(),
            title: optionNone(),
            status: optionNone(),
            begins: optionNone(),
            duration: optionNone(),
            timeZone: optionNone(),
            offsetMs: optionNone(),
            allDay: optionNone(),
            multiDay: optionNone(),
            employees: optionNone(),
            location: optionNone(),
            description: optionNone(),
            colors: optionNone(),
            recurrenceRule: optionNone()
        };
    }
    return {
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        fields,
        validate,
        reset
    };
}
export function appointmentFromFormData(formData: FormData): Exit<Appointment, Array<{
    field: string;
    message: string;
}>> {
    const obj: Record<string, unknown> = {};
    const __gf_exit_hint = "Exit<Appointment, Array<{ field: string; message: string }>>";
    obj.id = formData.get(`${"id"}`) ?? "";
    obj.title = formData.get(`${"title"}`) ?? "";
    {
        const statusObj: Record<string, unknown> = {};
        for (const [key, value] of Array.from(formData.entries())){
            if (key.startsWith(`${"status"}.`)) {
                const fieldName = key.slice(`${"status"}.`.length);
                const parts = fieldName.split(".");
                let current = statusObj;
                for(let i = 0; i < parts.length - 1; i++){
                    const part = parts[i]!;
                    if (!(part in current)) {
                        current[part] = {};
                    }
                    current = current[part] as Record<string, unknown>;
                }
                current[parts[parts.length - 1]!] = value;
            }
        }
        obj.status = statusObj;
    }
    obj.begins = formData.get(`${"begins"}`) ?? "";
    {
        const durationStr = formData.get(`${"duration"}`);
        obj.duration = durationStr ? parseFloat(durationStr as string) : $MfPh5;
        if (obj.duration !== undefined && isNaN(obj.duration as number)) obj.duration = "0";
    }
    obj.timeZone = formData.get(`${"timeZone"}`) ?? "";
    {
        const offsetMsStr = formData.get(`${"offsetMs"}`);
        obj.offsetMs = offsetMsStr ? parseFloat(offsetMsStr as string) : $MfPh5;
        if (obj.offsetMs !== undefined && isNaN(obj.offsetMs as number)) obj.offsetMs = "0";
    }
    {
        const allDayVal = formData.get(`${"allDay"}`);
        obj.allDay = allDayVal === "true" || allDayVal === "on" || allDayVal === "1";
    }
    {
        const multiDayVal = formData.get(`${"multiDay"}`);
        obj.multiDay = multiDayVal === "true" || multiDayVal === "on" || multiDayVal === "1";
    }
    obj.employees = formData.getAll(`${"employees"}`) as Array<string>;
    obj.location = formData.get(`${"location"}`) ?? "";
    obj.description = formData.get(`${"description"}`) ?? "";
    {
        const colorsObj: Record<string, unknown> = {};
        for (const [key, value] of Array.from(formData.entries())){
            if (key.startsWith(`${"colors"}.`)) {
                const fieldName = key.slice(`${"colors"}.`.length);
                const parts = fieldName.split(".");
                let current = colorsObj;
                for(let i = 0; i < parts.length - 1; i++){
                    const part = parts[i]!;
                    if (!(part in current)) {
                        current[part] = {};
                    }
                    current = current[part] as Record<string, unknown>;
                }
                current[parts[parts.length - 1]!] = value;
            }
        }
        obj.colors = colorsObj;
    }
    obj.recurrenceRule = formData.get(`${"recurrenceRule"}`) ?? "";
    return toExit(appointmentDeserialize(obj));
}

export const Appointment = {
  defaultValue: appointmentDefaultValue,
  serialize: appointmentSerialize,
  serializeWithContext: appointmentSerializeWithContext,
  deserialize: appointmentDeserialize,
  deserializeWithContext: appointmentDeserializeWithContext,
  validateFields: appointmentValidateFields,
  hasShape: appointmentHasShape,
  is: appointmentIs,
  createForm: appointmentCreateForm,
  fromFormData: appointmentFromFormData
} as const;


export interface Package {
    
    id: string;
    
    date: string;
}

export function packageDefaultValue(): Package {
    return {
        id: "",
        date: ""
    } as Package;
}

export function packageSerialize(value: Package): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(packageSerializeWithContext(value, ctx));
}
export function packageSerializeWithContext(value: Package, ctx: __mf_SerializeContext): Record<string, unknown> {
    const existingId = ctx.getId(value);
    if (existingId !== undefined) {
        return {
            __ref: existingId
        };
    }
    const __id = ctx.register(value);
    const result: Record<string, unknown> = {
        __type: "Package",
        __id
    };
    result.id = value.id;
    result.date = value.date;
    return result;
}

export function packageDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: Package } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = packageDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "Package.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function packageDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Package | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
        throw new __mf_DeserializeError([
            {
                field: "_root",
                message: `${"Package"}.deserializeWithContext: expected an object`
            }
        ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (!("id" in obj)) {
        errors.push({
            field: "id",
            message: "missing required field"
        });
    }
    if (!("date" in obj)) {
        errors.push({
            field: "date",
            message: "missing required field"
        });
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
        ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
        const __raw_id = obj["id"] as string;
        instance.id = __raw_id;
    }
    {
        const __raw_date = obj["date"] as string;
        instance.date = __raw_date;
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    return instance as Package;
}
export function packageValidateField<K extends keyof Package>(_field: K, _value: Package[K]): Array<{
    field: string;
    message: string;
}> {
    return [];
}
export function packageValidateFields(_partial: Partial<Package>): Array<{
    field: string;
    message: string;
}> {
    return [];
}
export function packageHasShape(obj: unknown): boolean {
    if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
        return false;
    }
    const o = obj as Record<string, unknown>;
    return '"id" in o && "date" in o';
}
export function packageIs(obj: unknown): obj is Package {
    if (!packageHasShape(obj)) {
        return false;
    }
    const result = packageDeserialize(obj);
    return result.success;
}

export type PackageErrors = {
    _errors: __gf_Option<Array<string>>;
    id: __gf_Option<Array<string>>;
    date: __gf_Option<Array<string>>;
};
export type PackageTainted = {
    id: __gf_Option<boolean>;
    date: __gf_Option<boolean>;
};
export interface PackageFieldControllers {
    readonly id: FieldController<string>;
    readonly date: FieldController<string>;
}
export interface PackageGigaform {
    readonly data: Package;
    readonly errors: PackageErrors;
    readonly tainted: PackageTainted;
    readonly fields: PackageFieldControllers;
    validate(): Exit<Package, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<Package>): void;
}
export function packageCreateForm(overrides?: Partial<Package>): PackageGigaform {
    let data = $state({
        ...packageDefaultValue(),
        ...overrides
    });
    let errors = $state<PackageErrors>({
        _errors: optionNone(),
        id: optionNone(),
        date: optionNone()
    } as PackageErrors);
    let tainted = $state<PackageTainted>({
        id: optionNone(),
        date: optionNone()
    } as PackageTainted);
    const fields = {
        id: {
            path: [
                "id"
            ] as const,
            name: "id",
            constraints: {
                required: true
            },
            get: ()=>data.id,
            set: (value: string)=>{
                data.id = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.id,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.id = value;
            },
            getTainted: ()=>tainted.id,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.id = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = packageValidateField("id", data.id);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        date: {
            path: [
                "date"
            ] as const,
            name: "date",
            constraints: {
                required: true
            },
            label: "Date",
            get: ()=>data.date,
            set: (value: string)=>{
                data.date = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.date,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.date = value;
            },
            getTainted: ()=>tainted.date,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.date = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = packageValidateField("date", data.date);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        }
    } as PackageFieldControllers;
    const __gf_getter_hint = "get data() set data(v) get errors() set errors(v) get tainted() set tainted(v)";
    const __gf_validate_hint = ".map((e: { field: string; message: string }) => e.message)";
    function validate(): Exit<Package, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(packageDeserialize(data));
    }
    function reset(newOverrides?: Partial<Package>): void {
        data = {
            ...packageDefaultValue(),
            ...newOverrides
        };
        errors = {
            _errors: optionNone(),
            id: optionNone(),
            date: optionNone()
        };
        tainted = {
            id: optionNone(),
            date: optionNone()
        };
    }
    return {
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        fields,
        validate,
        reset
    };
}
export function packageFromFormData(formData: FormData): Exit<Package, Array<{
    field: string;
    message: string;
}>> {
    const obj: Record<string, unknown> = {};
    const __gf_exit_hint = "Exit<Package, Array<{ field: string; message: string }>>";
    obj.id = formData.get(`${"id"}`) ?? "";
    obj.date = formData.get(`${"date"}`) ?? "";
    return toExit(packageDeserialize(obj));
}

export const Package = {
  defaultValue: packageDefaultValue,
  serialize: packageSerialize,
  serializeWithContext: packageSerializeWithContext,
  deserialize: packageDeserialize,
  deserializeWithContext: packageDeserializeWithContext,
  validateFields: packageValidateFields,
  hasShape: packageHasShape,
  is: packageIs,
  createForm: packageCreateForm,
  fromFormData: packageFromFormData
} as const;


export interface ScheduleSettings {
    daysPerWeek: number;
    
    rowHeight: RowHeight;
    visibleRoutes: Array<string>;
    detailedCards: boolean;
}

export function scheduleSettingsDefaultValue(): ScheduleSettings {
    return {
        daysPerWeek: 0,
        rowHeight: "Medium",
        visibleRoutes: [],
        detailedCards: false
    } as ScheduleSettings;
}

export function scheduleSettingsSerialize(value: ScheduleSettings): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(scheduleSettingsSerializeWithContext(value, ctx));
}
export function scheduleSettingsSerializeWithContext(value: ScheduleSettings, ctx: __mf_SerializeContext): Record<string, unknown> {
    const existingId = ctx.getId(value);
    if (existingId !== undefined) {
        return {
            __ref: existingId
        };
    }
    const __id = ctx.register(value);
    const result: Record<string, unknown> = {
        __type: "ScheduleSettings",
        __id
    };
    result.daysPerWeek = value.daysPerWeek;
    result.rowHeight = rowHeightSerializeWithContext(value.rowHeight, ctx);
    result.visibleRoutes = value.visibleRoutes;
    result.detailedCards = value.detailedCards;
    return result;
}

export function scheduleSettingsDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: ScheduleSettings } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = scheduleSettingsDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "ScheduleSettings.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function scheduleSettingsDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): ScheduleSettings | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
        throw new __mf_DeserializeError([
            {
                field: "_root",
                message: `${"ScheduleSettings"}.deserializeWithContext: expected an object`
            }
        ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (!("daysPerWeek" in obj)) {
        errors.push({
            field: "daysPerWeek",
            message: "missing required field"
        });
    }
    if (!("rowHeight" in obj)) {
        errors.push({
            field: "rowHeight",
            message: "missing required field"
        });
    }
    if (!("visibleRoutes" in obj)) {
        errors.push({
            field: "visibleRoutes",
            message: "missing required field"
        });
    }
    if (!("detailedCards" in obj)) {
        errors.push({
            field: "detailedCards",
            message: "missing required field"
        });
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
        ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
        const __raw_daysPerWeek = obj["daysPerWeek"] as number;
        instance.daysPerWeek = __raw_daysPerWeek;
    }
    {
        const __raw_rowHeight = obj["rowHeight"] as RowHeight;
        {
            const __result = rowHeightDeserializeWithContext(__raw_rowHeight, ctx);
            ctx.assignOrDefer(instance, "rowHeight", __result);
        }
    }
    {
        const __raw_visibleRoutes = obj["visibleRoutes"] as Array<string>;
        if (Array.isArray(__raw_visibleRoutes)) {
            instance.visibleRoutes = __raw_visibleRoutes as string[];
        }
    }
    {
        const __raw_detailedCards = obj["detailedCards"] as boolean;
        instance.detailedCards = __raw_detailedCards;
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    return instance as ScheduleSettings;
}
export function scheduleSettingsValidateField<K extends keyof ScheduleSettings>(_field: K, _value: ScheduleSettings[K]): Array<{
    field: string;
    message: string;
}> {
    return [];
}
export function scheduleSettingsValidateFields(_partial: Partial<ScheduleSettings>): Array<{
    field: string;
    message: string;
}> {
    return [];
}
export function scheduleSettingsHasShape(obj: unknown): boolean {
    if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
        return false;
    }
    const o = obj as Record<string, unknown>;
    return '"daysPerWeek" in o && "rowHeight" in o && "visibleRoutes" in o && "detailedCards" in o';
}
export function scheduleSettingsIs(obj: unknown): obj is ScheduleSettings {
    if (!scheduleSettingsHasShape(obj)) {
        return false;
    }
    const result = scheduleSettingsDeserialize(obj);
    return result.success;
}

export type ScheduleSettingsErrors = {
    _errors: __gf_Option<Array<string>>;
    daysPerWeek: __gf_Option<Array<string>>;
    rowHeight: __gf_Option<Array<string>>;
    visibleRoutes: __gf_Option<Array<string>>;
    detailedCards: __gf_Option<Array<string>>;
};
export type ScheduleSettingsTainted = {
    daysPerWeek: __gf_Option<boolean>;
    rowHeight: __gf_Option<boolean>;
    visibleRoutes: __gf_Option<boolean>;
    detailedCards: __gf_Option<boolean>;
};
export interface ScheduleSettingsFieldControllers {
    readonly daysPerWeek: FieldController<number>;
    readonly rowHeight: FieldController<RowHeight>;
    readonly visibleRoutes: ArrayFieldController<string>;
    readonly detailedCards: FieldController<boolean>;
}
export interface ScheduleSettingsGigaform {
    readonly data: ScheduleSettings;
    readonly errors: ScheduleSettingsErrors;
    readonly tainted: ScheduleSettingsTainted;
    readonly fields: ScheduleSettingsFieldControllers;
    validate(): Exit<ScheduleSettings, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<ScheduleSettings>): void;
}
export function scheduleSettingsCreateForm(overrides?: Partial<ScheduleSettings>): ScheduleSettingsGigaform {
    let data = $state({
        ...scheduleSettingsDefaultValue(),
        ...overrides
    });
    let errors = $state<ScheduleSettingsErrors>({
        _errors: optionNone(),
        daysPerWeek: optionNone(),
        rowHeight: optionNone(),
        visibleRoutes: optionNone(),
        detailedCards: optionNone()
    } as ScheduleSettingsErrors);
    let tainted = $state<ScheduleSettingsTainted>({
        daysPerWeek: optionNone(),
        rowHeight: optionNone(),
        visibleRoutes: optionNone(),
        detailedCards: optionNone()
    } as ScheduleSettingsTainted);
    const fields = {
        daysPerWeek: {
            path: [
                "daysPerWeek"
            ] as const,
            name: "daysPerWeek",
            constraints: {
                required: true
            },
            get: ()=>data.daysPerWeek,
            set: (value: number)=>{
                data.daysPerWeek = value;
            },
            transform: (value: number): number =>value,
            getError: ()=>errors.daysPerWeek,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.daysPerWeek = value;
            },
            getTainted: ()=>tainted.daysPerWeek,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.daysPerWeek = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = scheduleSettingsValidateField("daysPerWeek", data.daysPerWeek);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        rowHeight: {
            path: [
                "rowHeight"
            ] as const,
            name: "rowHeight",
            constraints: {
                required: true
            },
            get: ()=>data.rowHeight,
            set: (value: RowHeight)=>{
                data.rowHeight = value;
            },
            transform: (value: RowHeight): RowHeight =>value,
            getError: ()=>errors.rowHeight,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.rowHeight = value;
            },
            getTainted: ()=>tainted.rowHeight,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.rowHeight = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = scheduleSettingsValidateField("rowHeight", data.rowHeight);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        visibleRoutes: {
            path: [
                "visibleRoutes"
            ] as const,
            name: "visibleRoutes",
            constraints: {
                required: true
            },
            get: ()=>data.visibleRoutes,
            set: (value: Array<string>)=>{
                data.visibleRoutes = value;
            },
            transform: (value: Array<string>): Array<string> =>value,
            getError: ()=>errors.visibleRoutes,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.visibleRoutes = value;
            },
            getTainted: ()=>tainted.visibleRoutes,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.visibleRoutes = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = scheduleSettingsValidateField("visibleRoutes", data.visibleRoutes);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            },
            at: (index: number)=>({
                    path: [
                        "visibleRoutes",
                        index
                    ] as const,
                    name: "'^visibleRoutes.${index}^'",
                    constraints: {
                        required: true
                    },
                    get: ()=>data.visibleRoutes[index]!,
                    set: (value: string)=>{
                        data.visibleRoutes[index] = value;
                    },
                    transform: (value: string): string =>value,
                    getError: ()=>errors.visibleRoutes,
                    setError: (value: __gf_Option<Array<string>>)=>{
                        errors.visibleRoutes = value;
                    },
                    getTainted: ()=>tainted.visibleRoutes,
                    setTainted: (value: __gf_Option<boolean>)=>{
                        tainted.visibleRoutes = value;
                    },
                    validate: (): Array<string> =>[]
                }),
            push: (item: string)=>{
                data.visibleRoutes.push(item);
            },
            remove: (index: number)=>{
                data.visibleRoutes.splice(index, 1);
            },
            swap: (a: number, b: number)=>{
                const tmp = data.visibleRoutes[a]!;
                data.visibleRoutes[a] = data.visibleRoutes[b]!;
                data.visibleRoutes[b] = tmp;
            }
        },
        detailedCards: {
            path: [
                "detailedCards"
            ] as const,
            name: "detailedCards",
            constraints: {
                required: true
            },
            get: ()=>data.detailedCards,
            set: (value: boolean)=>{
                data.detailedCards = value;
            },
            transform: (value: boolean): boolean =>value,
            getError: ()=>errors.detailedCards,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.detailedCards = value;
            },
            getTainted: ()=>tainted.detailedCards,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.detailedCards = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = scheduleSettingsValidateField("detailedCards", data.detailedCards);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        }
    } as ScheduleSettingsFieldControllers;
    const __gf_getter_hint = "get data() set data(v) get errors() set errors(v) get tainted() set tainted(v)";
    const __gf_validate_hint = ".map((e: { field: string; message: string }) => e.message)";
    function validate(): Exit<ScheduleSettings, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(scheduleSettingsDeserialize(data));
    }
    function reset(newOverrides?: Partial<ScheduleSettings>): void {
        data = {
            ...scheduleSettingsDefaultValue(),
            ...newOverrides
        };
        errors = {
            _errors: optionNone(),
            daysPerWeek: optionNone(),
            rowHeight: optionNone(),
            visibleRoutes: optionNone(),
            detailedCards: optionNone()
        };
        tainted = {
            daysPerWeek: optionNone(),
            rowHeight: optionNone(),
            visibleRoutes: optionNone(),
            detailedCards: optionNone()
        };
    }
    return {
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        fields,
        validate,
        reset
    };
}
export function scheduleSettingsFromFormData(formData: FormData): Exit<ScheduleSettings, Array<{
    field: string;
    message: string;
}>> {
    const obj: Record<string, unknown> = {};
    const __gf_exit_hint = "Exit<ScheduleSettings, Array<{ field: string; message: string }>>";
    {
        const daysPerWeekStr = formData.get(`${"daysPerWeek"}`);
        obj.daysPerWeek = daysPerWeekStr ? parseFloat(daysPerWeekStr as string) : $MfPh5;
        if (obj.daysPerWeek !== undefined && isNaN(obj.daysPerWeek as number)) obj.daysPerWeek = "0";
    }
    {
        const rowHeightObj: Record<string, unknown> = {};
        for (const [key, value] of Array.from(formData.entries())){
            if (key.startsWith(`${"rowHeight"}.`)) {
                const fieldName = key.slice(`${"rowHeight"}.`.length);
                const parts = fieldName.split(".");
                let current = rowHeightObj;
                for(let i = 0; i < parts.length - 1; i++){
                    const part = parts[i]!;
                    if (!(part in current)) {
                        current[part] = {};
                    }
                    current = current[part] as Record<string, unknown>;
                }
                current[parts[parts.length - 1]!] = value;
            }
        }
        obj.rowHeight = rowHeightObj;
    }
    obj.visibleRoutes = formData.getAll(`${"visibleRoutes"}`) as Array<string>;
    {
        const detailedCardsVal = formData.get(`${"detailedCards"}`);
        obj.detailedCards = detailedCardsVal === "true" || detailedCardsVal === "on" || detailedCardsVal === "1";
    }
    return toExit(scheduleSettingsDeserialize(obj));
}

export const ScheduleSettings = {
  defaultValue: scheduleSettingsDefaultValue,
  serialize: scheduleSettingsSerialize,
  serializeWithContext: scheduleSettingsSerializeWithContext,
  deserialize: scheduleSettingsDeserialize,
  deserializeWithContext: scheduleSettingsDeserializeWithContext,
  validateFields: scheduleSettingsValidateFields,
  hasShape: scheduleSettingsHasShape,
  is: scheduleSettingsIs,
  createForm: scheduleSettingsCreateForm,
  fromFormData: scheduleSettingsFromFormData
} as const;


export interface DailyRecurrenceRule {
    quantityOfDays: number;
}

export function dailyRecurrenceRuleDefaultValue(): DailyRecurrenceRule {
    return {
        quantityOfDays: 0
    } as DailyRecurrenceRule;
}

export function dailyRecurrenceRuleSerialize(value: DailyRecurrenceRule): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(dailyRecurrenceRuleSerializeWithContext(value, ctx));
}
export function dailyRecurrenceRuleSerializeWithContext(value: DailyRecurrenceRule, ctx: __mf_SerializeContext): Record<string, unknown> {
    const existingId = ctx.getId(value);
    if (existingId !== undefined) {
        return {
            __ref: existingId
        };
    }
    const __id = ctx.register(value);
    const result: Record<string, unknown> = {
        __type: "DailyRecurrenceRule",
        __id
    };
    result.quantityOfDays = value.quantityOfDays;
    return result;
}

export function dailyRecurrenceRuleDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: DailyRecurrenceRule } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = dailyRecurrenceRuleDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "DailyRecurrenceRule.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function dailyRecurrenceRuleDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): DailyRecurrenceRule | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
        throw new __mf_DeserializeError([
            {
                field: "_root",
                message: `${"DailyRecurrenceRule"}.deserializeWithContext: expected an object`
            }
        ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (!("quantityOfDays" in obj)) {
        errors.push({
            field: "quantityOfDays",
            message: "missing required field"
        });
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
        ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
        const __raw_quantityOfDays = obj["quantityOfDays"] as number;
        instance.quantityOfDays = __raw_quantityOfDays;
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    return instance as DailyRecurrenceRule;
}
export function dailyRecurrenceRuleValidateField<K extends keyof DailyRecurrenceRule>(_field: K, _value: DailyRecurrenceRule[K]): Array<{
    field: string;
    message: string;
}> {
    return [];
}
export function dailyRecurrenceRuleValidateFields(_partial: Partial<DailyRecurrenceRule>): Array<{
    field: string;
    message: string;
}> {
    return [];
}
export function dailyRecurrenceRuleHasShape(obj: unknown): boolean {
    if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
        return false;
    }
    const o = obj as Record<string, unknown>;
    return '"quantityOfDays" in o';
}
export function dailyRecurrenceRuleIs(obj: unknown): obj is DailyRecurrenceRule {
    if (!dailyRecurrenceRuleHasShape(obj)) {
        return false;
    }
    const result = dailyRecurrenceRuleDeserialize(obj);
    return result.success;
}

export type DailyRecurrenceRuleErrors = {
    _errors: __gf_Option<Array<string>>;
    quantityOfDays: __gf_Option<Array<string>>;
};
export type DailyRecurrenceRuleTainted = {
    quantityOfDays: __gf_Option<boolean>;
};
export interface DailyRecurrenceRuleFieldControllers {
    readonly quantityOfDays: FieldController<number>;
}
export interface DailyRecurrenceRuleGigaform {
    readonly data: DailyRecurrenceRule;
    readonly errors: DailyRecurrenceRuleErrors;
    readonly tainted: DailyRecurrenceRuleTainted;
    readonly fields: DailyRecurrenceRuleFieldControllers;
    validate(): Exit<DailyRecurrenceRule, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<DailyRecurrenceRule>): void;
}
export function dailyRecurrenceRuleCreateForm(overrides?: Partial<DailyRecurrenceRule>): DailyRecurrenceRuleGigaform {
    let data = $state({
        ...dailyRecurrenceRuleDefaultValue(),
        ...overrides
    });
    let errors = $state<DailyRecurrenceRuleErrors>({
        _errors: optionNone(),
        quantityOfDays: optionNone()
    } as DailyRecurrenceRuleErrors);
    let tainted = $state<DailyRecurrenceRuleTainted>({
        quantityOfDays: optionNone()
    } as DailyRecurrenceRuleTainted);
    const fields = {
        quantityOfDays: {
            path: [
                "quantityOfDays"
            ] as const,
            name: "quantityOfDays",
            constraints: {
                required: true
            },
            get: ()=>data.quantityOfDays,
            set: (value: number)=>{
                data.quantityOfDays = value;
            },
            transform: (value: number): number =>value,
            getError: ()=>errors.quantityOfDays,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.quantityOfDays = value;
            },
            getTainted: ()=>tainted.quantityOfDays,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.quantityOfDays = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = dailyRecurrenceRuleValidateField("quantityOfDays", data.quantityOfDays);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        }
    } as DailyRecurrenceRuleFieldControllers;
    const __gf_getter_hint = "get data() set data(v) get errors() set errors(v) get tainted() set tainted(v)";
    const __gf_validate_hint = ".map((e: { field: string; message: string }) => e.message)";
    function validate(): Exit<DailyRecurrenceRule, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(dailyRecurrenceRuleDeserialize(data));
    }
    function reset(newOverrides?: Partial<DailyRecurrenceRule>): void {
        data = {
            ...dailyRecurrenceRuleDefaultValue(),
            ...newOverrides
        };
        errors = {
            _errors: optionNone(),
            quantityOfDays: optionNone()
        };
        tainted = {
            quantityOfDays: optionNone()
        };
    }
    return {
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        fields,
        validate,
        reset
    };
}
export function dailyRecurrenceRuleFromFormData(formData: FormData): Exit<DailyRecurrenceRule, Array<{
    field: string;
    message: string;
}>> {
    const obj: Record<string, unknown> = {};
    const __gf_exit_hint = "Exit<DailyRecurrenceRule, Array<{ field: string; message: string }>>";
    {
        const quantityOfDaysStr = formData.get(`${"quantityOfDays"}`);
        obj.quantityOfDays = quantityOfDaysStr ? parseFloat(quantityOfDaysStr as string) : $MfPh5;
        if (obj.quantityOfDays !== undefined && isNaN(obj.quantityOfDays as number)) obj.quantityOfDays = "0";
    }
    return toExit(dailyRecurrenceRuleDeserialize(obj));
}

export const DailyRecurrenceRule = {
  defaultValue: dailyRecurrenceRuleDefaultValue,
  serialize: dailyRecurrenceRuleSerialize,
  serializeWithContext: dailyRecurrenceRuleSerializeWithContext,
  deserialize: dailyRecurrenceRuleDeserialize,
  deserializeWithContext: dailyRecurrenceRuleDeserializeWithContext,
  validateFields: dailyRecurrenceRuleValidateFields,
  hasShape: dailyRecurrenceRuleHasShape,
  is: dailyRecurrenceRuleIs,
  createForm: dailyRecurrenceRuleCreateForm,
  fromFormData: dailyRecurrenceRuleFromFormData
} as const;


export interface SignUpCredentials {
    firstName: FirstName;
    lastName: LastName;
    email: EmailParts;
    password: Password;
    rememberMe: boolean;
}

export function signUpCredentialsDefaultValue(): SignUpCredentials {
    return {
        firstName: firstNameDefaultValue(),
        lastName: lastNameDefaultValue(),
        email: emailPartsDefaultValue(),
        password: passwordDefaultValue(),
        rememberMe: false
    } as SignUpCredentials;
}

export function signUpCredentialsSerialize(value: SignUpCredentials): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(signUpCredentialsSerializeWithContext(value, ctx));
}
export function signUpCredentialsSerializeWithContext(value: SignUpCredentials, ctx: __mf_SerializeContext): Record<string, unknown> {
    const existingId = ctx.getId(value);
    if (existingId !== undefined) {
        return {
            __ref: existingId
        };
    }
    const __id = ctx.register(value);
    const result: Record<string, unknown> = {
        __type: "SignUpCredentials",
        __id
    };
    result.firstName = firstNameSerializeWithContext(value.firstName, ctx);
    result.lastName = lastNameSerializeWithContext(value.lastName, ctx);
    result.email = emailPartsSerializeWithContext(value.email, ctx);
    result.password = passwordSerializeWithContext(value.password, ctx);
    result.rememberMe = value.rememberMe;
    return result;
}

export function signUpCredentialsDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: SignUpCredentials } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = signUpCredentialsDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "SignUpCredentials.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function signUpCredentialsDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): SignUpCredentials | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
        throw new __mf_DeserializeError([
            {
                field: "_root",
                message: `${"SignUpCredentials"}.deserializeWithContext: expected an object`
            }
        ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (!("firstName" in obj)) {
        errors.push({
            field: "firstName",
            message: "missing required field"
        });
    }
    if (!("lastName" in obj)) {
        errors.push({
            field: "lastName",
            message: "missing required field"
        });
    }
    if (!("email" in obj)) {
        errors.push({
            field: "email",
            message: "missing required field"
        });
    }
    if (!("password" in obj)) {
        errors.push({
            field: "password",
            message: "missing required field"
        });
    }
    if (!("rememberMe" in obj)) {
        errors.push({
            field: "rememberMe",
            message: "missing required field"
        });
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
        ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
        const __raw_firstName = obj["firstName"] as FirstName;
        {
            const __result = firstNameDeserializeWithContext(__raw_firstName, ctx);
            ctx.assignOrDefer(instance, "firstName", __result);
        }
    }
    {
        const __raw_lastName = obj["lastName"] as LastName;
        {
            const __result = lastNameDeserializeWithContext(__raw_lastName, ctx);
            ctx.assignOrDefer(instance, "lastName", __result);
        }
    }
    {
        const __raw_email = obj["email"] as EmailParts;
        {
            const __result = emailPartsDeserializeWithContext(__raw_email, ctx);
            ctx.assignOrDefer(instance, "email", __result);
        }
    }
    {
        const __raw_password = obj["password"] as Password;
        {
            const __result = passwordDeserializeWithContext(__raw_password, ctx);
            ctx.assignOrDefer(instance, "password", __result);
        }
    }
    {
        const __raw_rememberMe = obj["rememberMe"] as boolean;
        instance.rememberMe = __raw_rememberMe;
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    return instance as SignUpCredentials;
}
export function signUpCredentialsValidateField<K extends keyof SignUpCredentials>(_field: K, _value: SignUpCredentials[K]): Array<{
    field: string;
    message: string;
}> {
    return [];
}
export function signUpCredentialsValidateFields(_partial: Partial<SignUpCredentials>): Array<{
    field: string;
    message: string;
}> {
    return [];
}
export function signUpCredentialsHasShape(obj: unknown): boolean {
    if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
        return false;
    }
    const o = obj as Record<string, unknown>;
    return '"firstName" in o && "lastName" in o && "email" in o && "password" in o && "rememberMe" in o';
}
export function signUpCredentialsIs(obj: unknown): obj is SignUpCredentials {
    if (!signUpCredentialsHasShape(obj)) {
        return false;
    }
    const result = signUpCredentialsDeserialize(obj);
    return result.success;
}

export type SignUpCredentialsErrors = {
    _errors: __gf_Option<Array<string>>;
    firstName: __gf_Option<Array<string>>;
    lastName: __gf_Option<Array<string>>;
    email: __gf_Option<Array<string>>;
    password: __gf_Option<Array<string>>;
    rememberMe: __gf_Option<Array<string>>;
};
export type SignUpCredentialsTainted = {
    firstName: __gf_Option<boolean>;
    lastName: __gf_Option<boolean>;
    email: __gf_Option<boolean>;
    password: __gf_Option<boolean>;
    rememberMe: __gf_Option<boolean>;
};
export interface SignUpCredentialsFieldControllers {
    readonly firstName: FieldController<FirstName>;
    readonly lastName: FieldController<LastName>;
    readonly email: FieldController<EmailParts>;
    readonly password: FieldController<Password>;
    readonly rememberMe: FieldController<boolean>;
}
export interface SignUpCredentialsGigaform {
    readonly data: SignUpCredentials;
    readonly errors: SignUpCredentialsErrors;
    readonly tainted: SignUpCredentialsTainted;
    readonly fields: SignUpCredentialsFieldControllers;
    validate(): Exit<SignUpCredentials, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<SignUpCredentials>): void;
}
export function signUpCredentialsCreateForm(overrides?: Partial<SignUpCredentials>): SignUpCredentialsGigaform {
    let data = $state({
        ...signUpCredentialsDefaultValue(),
        ...overrides
    });
    let errors = $state<SignUpCredentialsErrors>({
        _errors: optionNone(),
        firstName: optionNone(),
        lastName: optionNone(),
        email: optionNone(),
        password: optionNone(),
        rememberMe: optionNone()
    } as SignUpCredentialsErrors);
    let tainted = $state<SignUpCredentialsTainted>({
        firstName: optionNone(),
        lastName: optionNone(),
        email: optionNone(),
        password: optionNone(),
        rememberMe: optionNone()
    } as SignUpCredentialsTainted);
    const fields = {
        firstName: {
            path: [
                "firstName"
            ] as const,
            name: "firstName",
            constraints: {
                required: true
            },
            get: ()=>data.firstName,
            set: (value: FirstName)=>{
                data.firstName = value;
            },
            transform: (value: FirstName): FirstName =>value,
            getError: ()=>errors.firstName,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.firstName = value;
            },
            getTainted: ()=>tainted.firstName,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.firstName = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = signUpCredentialsValidateField("firstName", data.firstName);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        lastName: {
            path: [
                "lastName"
            ] as const,
            name: "lastName",
            constraints: {
                required: true
            },
            get: ()=>data.lastName,
            set: (value: LastName)=>{
                data.lastName = value;
            },
            transform: (value: LastName): LastName =>value,
            getError: ()=>errors.lastName,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.lastName = value;
            },
            getTainted: ()=>tainted.lastName,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.lastName = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = signUpCredentialsValidateField("lastName", data.lastName);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        email: {
            path: [
                "email"
            ] as const,
            name: "email",
            constraints: {
                required: true
            },
            get: ()=>data.email,
            set: (value: EmailParts)=>{
                data.email = value;
            },
            transform: (value: EmailParts): EmailParts =>value,
            getError: ()=>errors.email,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.email = value;
            },
            getTainted: ()=>tainted.email,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.email = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = signUpCredentialsValidateField("email", data.email);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        password: {
            path: [
                "password"
            ] as const,
            name: "password",
            constraints: {
                required: true
            },
            get: ()=>data.password,
            set: (value: Password)=>{
                data.password = value;
            },
            transform: (value: Password): Password =>value,
            getError: ()=>errors.password,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.password = value;
            },
            getTainted: ()=>tainted.password,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.password = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = signUpCredentialsValidateField("password", data.password);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        rememberMe: {
            path: [
                "rememberMe"
            ] as const,
            name: "rememberMe",
            constraints: {
                required: true
            },
            get: ()=>data.rememberMe,
            set: (value: boolean)=>{
                data.rememberMe = value;
            },
            transform: (value: boolean): boolean =>value,
            getError: ()=>errors.rememberMe,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.rememberMe = value;
            },
            getTainted: ()=>tainted.rememberMe,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.rememberMe = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = signUpCredentialsValidateField("rememberMe", data.rememberMe);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        }
    } as SignUpCredentialsFieldControllers;
    const __gf_getter_hint = "get data() set data(v) get errors() set errors(v) get tainted() set tainted(v)";
    const __gf_validate_hint = ".map((e: { field: string; message: string }) => e.message)";
    function validate(): Exit<SignUpCredentials, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(signUpCredentialsDeserialize(data));
    }
    function reset(newOverrides?: Partial<SignUpCredentials>): void {
        data = {
            ...signUpCredentialsDefaultValue(),
            ...newOverrides
        };
        errors = {
            _errors: optionNone(),
            firstName: optionNone(),
            lastName: optionNone(),
            email: optionNone(),
            password: optionNone(),
            rememberMe: optionNone()
        };
        tainted = {
            firstName: optionNone(),
            lastName: optionNone(),
            email: optionNone(),
            password: optionNone(),
            rememberMe: optionNone()
        };
    }
    return {
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        fields,
        validate,
        reset
    };
}
export function signUpCredentialsFromFormData(formData: FormData): Exit<SignUpCredentials, Array<{
    field: string;
    message: string;
}>> {
    const obj: Record<string, unknown> = {};
    const __gf_exit_hint = "Exit<SignUpCredentials, Array<{ field: string; message: string }>>";
    {
        const firstNameObj: Record<string, unknown> = {};
        for (const [key, value] of Array.from(formData.entries())){
            if (key.startsWith(`${"firstName"}.`)) {
                const fieldName = key.slice(`${"firstName"}.`.length);
                const parts = fieldName.split(".");
                let current = firstNameObj;
                for(let i = 0; i < parts.length - 1; i++){
                    const part = parts[i]!;
                    if (!(part in current)) {
                        current[part] = {};
                    }
                    current = current[part] as Record<string, unknown>;
                }
                current[parts[parts.length - 1]!] = value;
            }
        }
        obj.firstName = firstNameObj;
    }
    {
        const lastNameObj: Record<string, unknown> = {};
        for (const [key, value] of Array.from(formData.entries())){
            if (key.startsWith(`${"lastName"}.`)) {
                const fieldName = key.slice(`${"lastName"}.`.length);
                const parts = fieldName.split(".");
                let current = lastNameObj;
                for(let i = 0; i < parts.length - 1; i++){
                    const part = parts[i]!;
                    if (!(part in current)) {
                        current[part] = {};
                    }
                    current = current[part] as Record<string, unknown>;
                }
                current[parts[parts.length - 1]!] = value;
            }
        }
        obj.lastName = lastNameObj;
    }
    {
        const emailObj: Record<string, unknown> = {};
        for (const [key, value] of Array.from(formData.entries())){
            if (key.startsWith(`${"email"}.`)) {
                const fieldName = key.slice(`${"email"}.`.length);
                const parts = fieldName.split(".");
                let current = emailObj;
                for(let i = 0; i < parts.length - 1; i++){
                    const part = parts[i]!;
                    if (!(part in current)) {
                        current[part] = {};
                    }
                    current = current[part] as Record<string, unknown>;
                }
                current[parts[parts.length - 1]!] = value;
            }
        }
        obj.email = emailObj;
    }
    {
        const passwordObj: Record<string, unknown> = {};
        for (const [key, value] of Array.from(formData.entries())){
            if (key.startsWith(`${"password"}.`)) {
                const fieldName = key.slice(`${"password"}.`.length);
                const parts = fieldName.split(".");
                let current = passwordObj;
                for(let i = 0; i < parts.length - 1; i++){
                    const part = parts[i]!;
                    if (!(part in current)) {
                        current[part] = {};
                    }
                    current = current[part] as Record<string, unknown>;
                }
                current[parts[parts.length - 1]!] = value;
            }
        }
        obj.password = passwordObj;
    }
    {
        const rememberMeVal = formData.get(`${"rememberMe"}`);
        obj.rememberMe = rememberMeVal === "true" || rememberMeVal === "on" || rememberMeVal === "1";
    }
    return toExit(signUpCredentialsDeserialize(obj));
}

export const SignUpCredentials = {
  defaultValue: signUpCredentialsDefaultValue,
  serialize: signUpCredentialsSerialize,
  serializeWithContext: signUpCredentialsSerializeWithContext,
  deserialize: signUpCredentialsDeserialize,
  deserializeWithContext: signUpCredentialsDeserializeWithContext,
  validateFields: signUpCredentialsValidateFields,
  hasShape: signUpCredentialsHasShape,
  is: signUpCredentialsIs,
  createForm: signUpCredentialsCreateForm,
  fromFormData: signUpCredentialsFromFormData
} as const;


export interface OverviewSettings {
    
    rowHeight: RowHeight;
    
    cardOrRow: OverviewDisplay;
    perPage: number;
    columnConfigs: Array<ColumnConfig>;
}

export function overviewSettingsDefaultValue(): OverviewSettings {
    return {
        rowHeight: "Medium",
        cardOrRow: "Table",
        perPage: 0,
        columnConfigs: []
    } as OverviewSettings;
}

export function overviewSettingsSerialize(value: OverviewSettings): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(overviewSettingsSerializeWithContext(value, ctx));
}
export function overviewSettingsSerializeWithContext(value: OverviewSettings, ctx: __mf_SerializeContext): Record<string, unknown> {
    const existingId = ctx.getId(value);
    if (existingId !== undefined) {
        return {
            __ref: existingId
        };
    }
    const __id = ctx.register(value);
    const result: Record<string, unknown> = {
        __type: "OverviewSettings",
        __id
    };
    result.rowHeight = rowHeightSerializeWithContext(value.rowHeight, ctx);
    result.cardOrRow = overviewDisplaySerializeWithContext(value.cardOrRow, ctx);
    result.perPage = value.perPage;
    result.columnConfigs = value.columnConfigs.map((item)=>columnConfigSerializeWithContext(item, ctx));
    return result;
}

export function overviewSettingsDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: OverviewSettings } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = overviewSettingsDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "OverviewSettings.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function overviewSettingsDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): OverviewSettings | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
        throw new __mf_DeserializeError([
            {
                field: "_root",
                message: `${"OverviewSettings"}.deserializeWithContext: expected an object`
            }
        ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (!("rowHeight" in obj)) {
        errors.push({
            field: "rowHeight",
            message: "missing required field"
        });
    }
    if (!("cardOrRow" in obj)) {
        errors.push({
            field: "cardOrRow",
            message: "missing required field"
        });
    }
    if (!("perPage" in obj)) {
        errors.push({
            field: "perPage",
            message: "missing required field"
        });
    }
    if (!("columnConfigs" in obj)) {
        errors.push({
            field: "columnConfigs",
            message: "missing required field"
        });
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
        ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
        const __raw_rowHeight = obj["rowHeight"] as RowHeight;
        {
            const __result = rowHeightDeserializeWithContext(__raw_rowHeight, ctx);
            ctx.assignOrDefer(instance, "rowHeight", __result);
        }
    }
    {
        const __raw_cardOrRow = obj["cardOrRow"] as OverviewDisplay;
        {
            const __result = overviewDisplayDeserializeWithContext(__raw_cardOrRow, ctx);
            ctx.assignOrDefer(instance, "cardOrRow", __result);
        }
    }
    {
        const __raw_perPage = obj["perPage"] as number;
        instance.perPage = __raw_perPage;
    }
    {
        const __raw_columnConfigs = obj["columnConfigs"] as Array<ColumnConfig>;
        if (Array.isArray(__raw_columnConfigs)) {
            instance.columnConfigs = __raw_columnConfigs as ColumnConfig[];
        }
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    return instance as OverviewSettings;
}
export function overviewSettingsValidateField<K extends keyof OverviewSettings>(_field: K, _value: OverviewSettings[K]): Array<{
    field: string;
    message: string;
}> {
    return [];
}
export function overviewSettingsValidateFields(_partial: Partial<OverviewSettings>): Array<{
    field: string;
    message: string;
}> {
    return [];
}
export function overviewSettingsHasShape(obj: unknown): boolean {
    if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
        return false;
    }
    const o = obj as Record<string, unknown>;
    return '"rowHeight" in o && "cardOrRow" in o && "perPage" in o && "columnConfigs" in o';
}
export function overviewSettingsIs(obj: unknown): obj is OverviewSettings {
    if (!overviewSettingsHasShape(obj)) {
        return false;
    }
    const result = overviewSettingsDeserialize(obj);
    return result.success;
}

export type OverviewSettingsErrors = {
    _errors: __gf_Option<Array<string>>;
    rowHeight: __gf_Option<Array<string>>;
    cardOrRow: __gf_Option<Array<string>>;
    perPage: __gf_Option<Array<string>>;
    columnConfigs: __gf_Option<Array<string>>;
};
export type OverviewSettingsTainted = {
    rowHeight: __gf_Option<boolean>;
    cardOrRow: __gf_Option<boolean>;
    perPage: __gf_Option<boolean>;
    columnConfigs: __gf_Option<boolean>;
};
export interface OverviewSettingsFieldControllers {
    readonly rowHeight: FieldController<RowHeight>;
    readonly cardOrRow: FieldController<OverviewDisplay>;
    readonly perPage: FieldController<number>;
    readonly columnConfigs: ArrayFieldController<ColumnConfig>;
}
export interface OverviewSettingsGigaform {
    readonly data: OverviewSettings;
    readonly errors: OverviewSettingsErrors;
    readonly tainted: OverviewSettingsTainted;
    readonly fields: OverviewSettingsFieldControllers;
    validate(): Exit<OverviewSettings, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<OverviewSettings>): void;
}
export function overviewSettingsCreateForm(overrides?: Partial<OverviewSettings>): OverviewSettingsGigaform {
    let data = $state({
        ...overviewSettingsDefaultValue(),
        ...overrides
    });
    let errors = $state<OverviewSettingsErrors>({
        _errors: optionNone(),
        rowHeight: optionNone(),
        cardOrRow: optionNone(),
        perPage: optionNone(),
        columnConfigs: optionNone()
    } as OverviewSettingsErrors);
    let tainted = $state<OverviewSettingsTainted>({
        rowHeight: optionNone(),
        cardOrRow: optionNone(),
        perPage: optionNone(),
        columnConfigs: optionNone()
    } as OverviewSettingsTainted);
    const fields = {
        rowHeight: {
            path: [
                "rowHeight"
            ] as const,
            name: "rowHeight",
            constraints: {
                required: true
            },
            get: ()=>data.rowHeight,
            set: (value: RowHeight)=>{
                data.rowHeight = value;
            },
            transform: (value: RowHeight): RowHeight =>value,
            getError: ()=>errors.rowHeight,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.rowHeight = value;
            },
            getTainted: ()=>tainted.rowHeight,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.rowHeight = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = overviewSettingsValidateField("rowHeight", data.rowHeight);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        cardOrRow: {
            path: [
                "cardOrRow"
            ] as const,
            name: "cardOrRow",
            constraints: {
                required: true
            },
            get: ()=>data.cardOrRow,
            set: (value: OverviewDisplay)=>{
                data.cardOrRow = value;
            },
            transform: (value: OverviewDisplay): OverviewDisplay =>value,
            getError: ()=>errors.cardOrRow,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.cardOrRow = value;
            },
            getTainted: ()=>tainted.cardOrRow,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.cardOrRow = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = overviewSettingsValidateField("cardOrRow", data.cardOrRow);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        perPage: {
            path: [
                "perPage"
            ] as const,
            name: "perPage",
            constraints: {
                required: true
            },
            get: ()=>data.perPage,
            set: (value: number)=>{
                data.perPage = value;
            },
            transform: (value: number): number =>value,
            getError: ()=>errors.perPage,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.perPage = value;
            },
            getTainted: ()=>tainted.perPage,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.perPage = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = overviewSettingsValidateField("perPage", data.perPage);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        columnConfigs: {
            path: [
                "columnConfigs"
            ] as const,
            name: "columnConfigs",
            constraints: {
                required: true
            },
            get: ()=>data.columnConfigs,
            set: (value: Array<ColumnConfig>)=>{
                data.columnConfigs = value;
            },
            transform: (value: Array<ColumnConfig>): Array<ColumnConfig> =>value,
            getError: ()=>errors.columnConfigs,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.columnConfigs = value;
            },
            getTainted: ()=>tainted.columnConfigs,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.columnConfigs = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = overviewSettingsValidateField("columnConfigs", data.columnConfigs);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            },
            at: (index: number)=>({
                    path: [
                        "columnConfigs",
                        index
                    ] as const,
                    name: "'^columnConfigs.${index}^'",
                    constraints: {
                        required: true
                    },
                    get: ()=>data.columnConfigs[index]!,
                    set: (value: ColumnConfig)=>{
                        data.columnConfigs[index] = value;
                    },
                    transform: (value: ColumnConfig): ColumnConfig =>value,
                    getError: ()=>errors.columnConfigs,
                    setError: (value: __gf_Option<Array<string>>)=>{
                        errors.columnConfigs = value;
                    },
                    getTainted: ()=>tainted.columnConfigs,
                    setTainted: (value: __gf_Option<boolean>)=>{
                        tainted.columnConfigs = value;
                    },
                    validate: (): Array<string> =>[]
                }),
            push: (item: ColumnConfig)=>{
                data.columnConfigs.push(item);
            },
            remove: (index: number)=>{
                data.columnConfigs.splice(index, 1);
            },
            swap: (a: number, b: number)=>{
                const tmp = data.columnConfigs[a]!;
                data.columnConfigs[a] = data.columnConfigs[b]!;
                data.columnConfigs[b] = tmp;
            }
        }
    } as OverviewSettingsFieldControllers;
    const __gf_getter_hint = "get data() set data(v) get errors() set errors(v) get tainted() set tainted(v)";
    const __gf_validate_hint = ".map((e: { field: string; message: string }) => e.message)";
    function validate(): Exit<OverviewSettings, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(overviewSettingsDeserialize(data));
    }
    function reset(newOverrides?: Partial<OverviewSettings>): void {
        data = {
            ...overviewSettingsDefaultValue(),
            ...newOverrides
        };
        errors = {
            _errors: optionNone(),
            rowHeight: optionNone(),
            cardOrRow: optionNone(),
            perPage: optionNone(),
            columnConfigs: optionNone()
        };
        tainted = {
            rowHeight: optionNone(),
            cardOrRow: optionNone(),
            perPage: optionNone(),
            columnConfigs: optionNone()
        };
    }
    return {
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        fields,
        validate,
        reset
    };
}
export function overviewSettingsFromFormData(formData: FormData): Exit<OverviewSettings, Array<{
    field: string;
    message: string;
}>> {
    const obj: Record<string, unknown> = {};
    const __gf_exit_hint = "Exit<OverviewSettings, Array<{ field: string; message: string }>>";
    {
        const rowHeightObj: Record<string, unknown> = {};
        for (const [key, value] of Array.from(formData.entries())){
            if (key.startsWith(`${"rowHeight"}.`)) {
                const fieldName = key.slice(`${"rowHeight"}.`.length);
                const parts = fieldName.split(".");
                let current = rowHeightObj;
                for(let i = 0; i < parts.length - 1; i++){
                    const part = parts[i]!;
                    if (!(part in current)) {
                        current[part] = {};
                    }
                    current = current[part] as Record<string, unknown>;
                }
                current[parts[parts.length - 1]!] = value;
            }
        }
        obj.rowHeight = rowHeightObj;
    }
    {
        const cardOrRowObj: Record<string, unknown> = {};
        for (const [key, value] of Array.from(formData.entries())){
            if (key.startsWith(`${"cardOrRow"}.`)) {
                const fieldName = key.slice(`${"cardOrRow"}.`.length);
                const parts = fieldName.split(".");
                let current = cardOrRowObj;
                for(let i = 0; i < parts.length - 1; i++){
                    const part = parts[i]!;
                    if (!(part in current)) {
                        current[part] = {};
                    }
                    current = current[part] as Record<string, unknown>;
                }
                current[parts[parts.length - 1]!] = value;
            }
        }
        obj.cardOrRow = cardOrRowObj;
    }
    {
        const perPageStr = formData.get(`${"perPage"}`);
        obj.perPage = perPageStr ? parseFloat(perPageStr as string) : $MfPh5;
        if (obj.perPage !== undefined && isNaN(obj.perPage as number)) obj.perPage = "0";
    }
    {
        const columnConfigsItems: Array<Record<string, unknown>> = [];
        let idx = 0;
        while(formData.has(`${"columnConfigs"}.` + idx + ".") || idx === 0){
            const hasAny = Array.from(formData.keys()).some((k)=>k.startsWith(`${"columnConfigs"}.` + idx + "."));
            if (!hasAny && idx > 0) break;
            if (hasAny) {
                const item: Record<string, unknown> = {};
                for (const [key, value] of Array.from(formData.entries())){
                    if (key.startsWith(`${"columnConfigs"}.` + idx + ".")) {
                        const fieldName = key.slice(`${"columnConfigs"}.`.length + String(idx).length + 1);
                        item[fieldName] = value;
                    }
                }
                columnConfigsItems.push(item);
            }
            idx++;
            if (idx > 1000) break;
        }
        obj.columnConfigs = columnConfigsItems;
    }
    return toExit(overviewSettingsDeserialize(obj));
}

export const OverviewSettings = {
  defaultValue: overviewSettingsDefaultValue,
  serialize: overviewSettingsSerialize,
  serializeWithContext: overviewSettingsSerializeWithContext,
  deserialize: overviewSettingsDeserialize,
  deserializeWithContext: overviewSettingsDeserializeWithContext,
  validateFields: overviewSettingsValidateFields,
  hasShape: overviewSettingsHasShape,
  is: overviewSettingsIs,
  createForm: overviewSettingsCreateForm,
  fromFormData: overviewSettingsFromFormData
} as const;


export interface FirstName {
    
    name: string;
}

export function firstNameDefaultValue(): FirstName {
    return {
        name: ""
    } as FirstName;
}

export function firstNameSerialize(value: FirstName): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(firstNameSerializeWithContext(value, ctx));
}
export function firstNameSerializeWithContext(value: FirstName, ctx: __mf_SerializeContext): Record<string, unknown> {
    const existingId = ctx.getId(value);
    if (existingId !== undefined) {
        return {
            __ref: existingId
        };
    }
    const __id = ctx.register(value);
    const result: Record<string, unknown> = {
        __type: "FirstName",
        __id
    };
    result.name = value.name;
    return result;
}

export function firstNameDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: FirstName } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = firstNameDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "FirstName.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function firstNameDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): FirstName | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
        throw new __mf_DeserializeError([
            {
                field: "_root",
                message: `${"FirstName"}.deserializeWithContext: expected an object`
            }
        ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (!("name" in obj)) {
        errors.push({
            field: "name",
            message: "missing required field"
        });
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
        ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
        const __raw_name = obj["name"] as string;
        if (__raw_name.trim().length === 0) {
            errors.push({
                field: "name",
                message: "FirstName.name must not be empty"
            });
        }
        instance.name = __raw_name;
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    return instance as FirstName;
}
export function firstNameValidateField<K extends keyof FirstName>(_field: K, _value: FirstName[K]): Array<{
    field: string;
    message: string;
}> {
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (_field === "name") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "name",
                message: "FirstName.name must not be empty"
            });
        }
    }
    return errors;
}
export function firstNameValidateFields(_partial: Partial<FirstName>): Array<{
    field: string;
    message: string;
}> {
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if ("name" in _partial && _partial.name !== undefined) {
        const __val = _partial.name as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "name",
                message: "FirstName.name must not be empty"
            });
        }
    }
    return errors;
}
export function firstNameHasShape(obj: unknown): boolean {
    if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
        return false;
    }
    const o = obj as Record<string, unknown>;
    return '"name" in o';
}
export function firstNameIs(obj: unknown): obj is FirstName {
    if (!firstNameHasShape(obj)) {
        return false;
    }
    const result = firstNameDeserialize(obj);
    return result.success;
}

export type FirstNameErrors = {
    _errors: __gf_Option<Array<string>>;
    name: __gf_Option<Array<string>>;
};
export type FirstNameTainted = {
    name: __gf_Option<boolean>;
};
export interface FirstNameFieldControllers {
    readonly name: FieldController<string>;
}
export interface FirstNameGigaform {
    readonly data: FirstName;
    readonly errors: FirstNameErrors;
    readonly tainted: FirstNameTainted;
    readonly fields: FirstNameFieldControllers;
    validate(): Exit<FirstName, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<FirstName>): void;
}
export function firstNameCreateForm(overrides?: Partial<FirstName>): FirstNameGigaform {
    let data = $state({
        ...firstNameDefaultValue(),
        ...overrides
    });
    let errors = $state<FirstNameErrors>({
        _errors: optionNone(),
        name: optionNone()
    } as FirstNameErrors);
    let tainted = $state<FirstNameTainted>({
        name: optionNone()
    } as FirstNameTainted);
    const fields = {
        name: {
            path: [
                "name"
            ] as const,
            name: "name",
            constraints: {
                required: true
            },
            get: ()=>data.name,
            set: (value: string)=>{
                data.name = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.name,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.name = value;
            },
            getTainted: ()=>tainted.name,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.name = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = firstNameValidateField("name", data.name);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        }
    } as FirstNameFieldControllers;
    const __gf_getter_hint = "get data() set data(v) get errors() set errors(v) get tainted() set tainted(v)";
    const __gf_validate_hint = ".map((e: { field: string; message: string }) => e.message)";
    function validate(): Exit<FirstName, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(firstNameDeserialize(data));
    }
    function reset(newOverrides?: Partial<FirstName>): void {
        data = {
            ...firstNameDefaultValue(),
            ...newOverrides
        };
        errors = {
            _errors: optionNone(),
            name: optionNone()
        };
        tainted = {
            name: optionNone()
        };
    }
    return {
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        fields,
        validate,
        reset
    };
}
export function firstNameFromFormData(formData: FormData): Exit<FirstName, Array<{
    field: string;
    message: string;
}>> {
    const obj: Record<string, unknown> = {};
    const __gf_exit_hint = "Exit<FirstName, Array<{ field: string; message: string }>>";
    obj.name = formData.get(`${"name"}`) ?? "";
    return toExit(firstNameDeserialize(obj));
}

export const FirstName = {
  defaultValue: firstNameDefaultValue,
  serialize: firstNameSerialize,
  serializeWithContext: firstNameSerializeWithContext,
  deserialize: firstNameDeserialize,
  deserializeWithContext: firstNameDeserializeWithContext,
  validateFields: firstNameValidateFields,
  hasShape: firstNameHasShape,
  is: firstNameIs,
  createForm: firstNameCreateForm,
  fromFormData: firstNameFromFormData
} as const;


export interface Account {
    
    id: string;
    
    
    taxRate: string | TaxRate;
    
    
    site: string | Site;
    
    salesRep: Array<Represents> | null;
    
    orders: Array<Ordered>;
    
    activity: Array<Did>;
    
    customFields: Array<[string, string]>;
    
    accountName: AccountName;
    
    
    sector: Sector;
    
    memo: string | null;
    
    phones: Array<PhoneNumber>;
    
    email: Email;
    
    
    leadSource: string;
    
    colors: Colors;
    
    needsReview: boolean;
    
    hasAlert: boolean;
    
    
    accountType: string;
    
    
    subtype: string;
    
    isTaxExempt: boolean;
    
    
    paymentTerms: string;
    
    tags: Array<string>;
    
    dateAdded: string;
}

export function accountDefaultValue(): Account {
    return {
        id: "",
        taxRate: "",
        site: "",
        salesRep: null,
        orders: [],
        activity: [],
        customFields: [],
        accountName: accountNameDefaultValue(),
        sector: "Residential",
        memo: null,
        phones: [],
        email: emailDefaultValue(),
        leadSource: "",
        colors: colorsDefaultValue(),
        needsReview: false,
        hasAlert: false,
        accountType: "",
        subtype: "",
        isTaxExempt: false,
        paymentTerms: "",
        tags: [],
        dateAdded: ""
    } as Account;
}

export function accountSerialize(value: Account): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(accountSerializeWithContext(value, ctx));
}
export function accountSerializeWithContext(value: Account, ctx: __mf_SerializeContext): Record<string, unknown> {
    const existingId = ctx.getId(value);
    if (existingId !== undefined) {
        return {
            __ref: existingId
        };
    }
    const __id = ctx.register(value);
    const result: Record<string, unknown> = {
        __type: "Account",
        __id
    };
    result.id = value.id;
    result.taxRate = value.taxRate;
    result.site = value.site;
    if (value.salesRep !== null) {
        result.salesRep = value.salesRep;
    }
    result.orders = value.orders.map((item)=>orderedSerializeWithContext(item, ctx));
    result.activity = value.activity.map((item)=>didSerializeWithContext(item, ctx));
    result.customFields = value.customFields;
    result.accountName = accountNameSerializeWithContext(value.accountName, ctx);
    result.sector = sectorSerializeWithContext(value.sector, ctx);
    result.memo = value.memo;
    result.phones = value.phones.map((item)=>phoneNumberSerializeWithContext(item, ctx));
    result.email = emailSerializeWithContext(value.email, ctx);
    result.leadSource = value.leadSource;
    result.colors = colorsSerializeWithContext(value.colors, ctx);
    result.needsReview = value.needsReview;
    result.hasAlert = value.hasAlert;
    result.accountType = value.accountType;
    result.subtype = value.subtype;
    result.isTaxExempt = value.isTaxExempt;
    result.paymentTerms = value.paymentTerms;
    result.tags = value.tags;
    result.dateAdded = value.dateAdded;
    return result;
}

export function accountDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: Account } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = accountDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "Account.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function accountDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Account | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
        throw new __mf_DeserializeError([
            {
                field: "_root",
                message: `${"Account"}.deserializeWithContext: expected an object`
            }
        ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (!("id" in obj)) {
        errors.push({
            field: "id",
            message: "missing required field"
        });
    }
    if (!("taxRate" in obj)) {
        errors.push({
            field: "taxRate",
            message: "missing required field"
        });
    }
    if (!("site" in obj)) {
        errors.push({
            field: "site",
            message: "missing required field"
        });
    }
    if (!("salesRep" in obj)) {
        errors.push({
            field: "salesRep",
            message: "missing required field"
        });
    }
    if (!("orders" in obj)) {
        errors.push({
            field: "orders",
            message: "missing required field"
        });
    }
    if (!("activity" in obj)) {
        errors.push({
            field: "activity",
            message: "missing required field"
        });
    }
    if (!("customFields" in obj)) {
        errors.push({
            field: "customFields",
            message: "missing required field"
        });
    }
    if (!("accountName" in obj)) {
        errors.push({
            field: "accountName",
            message: "missing required field"
        });
    }
    if (!("sector" in obj)) {
        errors.push({
            field: "sector",
            message: "missing required field"
        });
    }
    if (!("memo" in obj)) {
        errors.push({
            field: "memo",
            message: "missing required field"
        });
    }
    if (!("phones" in obj)) {
        errors.push({
            field: "phones",
            message: "missing required field"
        });
    }
    if (!("email" in obj)) {
        errors.push({
            field: "email",
            message: "missing required field"
        });
    }
    if (!("leadSource" in obj)) {
        errors.push({
            field: "leadSource",
            message: "missing required field"
        });
    }
    if (!("colors" in obj)) {
        errors.push({
            field: "colors",
            message: "missing required field"
        });
    }
    if (!("needsReview" in obj)) {
        errors.push({
            field: "needsReview",
            message: "missing required field"
        });
    }
    if (!("hasAlert" in obj)) {
        errors.push({
            field: "hasAlert",
            message: "missing required field"
        });
    }
    if (!("accountType" in obj)) {
        errors.push({
            field: "accountType",
            message: "missing required field"
        });
    }
    if (!("subtype" in obj)) {
        errors.push({
            field: "subtype",
            message: "missing required field"
        });
    }
    if (!("isTaxExempt" in obj)) {
        errors.push({
            field: "isTaxExempt",
            message: "missing required field"
        });
    }
    if (!("paymentTerms" in obj)) {
        errors.push({
            field: "paymentTerms",
            message: "missing required field"
        });
    }
    if (!("tags" in obj)) {
        errors.push({
            field: "tags",
            message: "missing required field"
        });
    }
    if (!("dateAdded" in obj)) {
        errors.push({
            field: "dateAdded",
            message: "missing required field"
        });
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
        ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
        const __raw_id = obj["id"] as string;
        instance.id = __raw_id;
    }
    {
        const __raw_taxRate = obj["taxRate"] as string | TaxRate;
        instance.taxRate = __raw_taxRate;
    }
    {
        const __raw_site = obj["site"] as string | Site;
        instance.site = __raw_site;
    }
    {
        const __raw_salesRep = obj["salesRep"] as Array<Represents> | null;
        if (__raw_salesRep === null) {
            instance.salesRep = null;
        } else {
            instance.salesRep = __raw_salesRep;
        }
    }
    {
        const __raw_orders = obj["orders"] as Array<Ordered>;
        if (Array.isArray(__raw_orders)) {
            instance.orders = __raw_orders as Ordered[];
        }
    }
    {
        const __raw_activity = obj["activity"] as Array<Did>;
        if (Array.isArray(__raw_activity)) {
            instance.activity = __raw_activity as Did[];
        }
    }
    {
        const __raw_customFields = obj["customFields"] as Array<[string, string]>;
        if (Array.isArray(__raw_customFields)) {
            instance.customFields = __raw_customFields as [string, string][];
        }
    }
    {
        const __raw_accountName = obj["accountName"] as AccountName;
        {
            const __result = accountNameDeserializeWithContext(__raw_accountName, ctx);
            ctx.assignOrDefer(instance, "accountName", __result);
        }
    }
    {
        const __raw_sector = obj["sector"] as Sector;
        {
            const __result = sectorDeserializeWithContext(__raw_sector, ctx);
            ctx.assignOrDefer(instance, "sector", __result);
        }
    }
    {
        const __raw_memo = obj["memo"] as string | null;
        instance.memo = __raw_memo;
    }
    {
        const __raw_phones = obj["phones"] as Array<PhoneNumber>;
        if (Array.isArray(__raw_phones)) {
            instance.phones = __raw_phones as PhoneNumber[];
        }
    }
    {
        const __raw_email = obj["email"] as Email;
        {
            const __result = emailDeserializeWithContext(__raw_email, ctx);
            ctx.assignOrDefer(instance, "email", __result);
        }
    }
    {
        const __raw_leadSource = obj["leadSource"] as string;
        if (__raw_leadSource.trim().length === 0) {
            errors.push({
                field: "leadSource",
                message: "Account.leadSource must not be empty"
            });
        }
        instance.leadSource = __raw_leadSource;
    }
    {
        const __raw_colors = obj["colors"] as Colors;
        {
            const __result = colorsDeserializeWithContext(__raw_colors, ctx);
            ctx.assignOrDefer(instance, "colors", __result);
        }
    }
    {
        const __raw_needsReview = obj["needsReview"] as boolean;
        instance.needsReview = __raw_needsReview;
    }
    {
        const __raw_hasAlert = obj["hasAlert"] as boolean;
        instance.hasAlert = __raw_hasAlert;
    }
    {
        const __raw_accountType = obj["accountType"] as string;
        if (__raw_accountType.trim().length === 0) {
            errors.push({
                field: "accountType",
                message: "Account.accountType must not be empty"
            });
        }
        instance.accountType = __raw_accountType;
    }
    {
        const __raw_subtype = obj["subtype"] as string;
        if (__raw_subtype.trim().length === 0) {
            errors.push({
                field: "subtype",
                message: "Account.subtype must not be empty"
            });
        }
        instance.subtype = __raw_subtype;
    }
    {
        const __raw_isTaxExempt = obj["isTaxExempt"] as boolean;
        instance.isTaxExempt = __raw_isTaxExempt;
    }
    {
        const __raw_paymentTerms = obj["paymentTerms"] as string;
        if (__raw_paymentTerms.trim().length === 0) {
            errors.push({
                field: "paymentTerms",
                message: "Account.paymentTerms must not be empty"
            });
        }
        instance.paymentTerms = __raw_paymentTerms;
    }
    {
        const __raw_tags = obj["tags"] as Array<string>;
        if (Array.isArray(__raw_tags)) {
            instance.tags = __raw_tags as string[];
        }
    }
    {
        const __raw_dateAdded = obj["dateAdded"] as string;
        instance.dateAdded = __raw_dateAdded;
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    return instance as Account;
}
export function accountValidateField<K extends keyof Account>(_field: K, _value: Account[K]): Array<{
    field: string;
    message: string;
}> {
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (_field === "leadSource") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "leadSource",
                message: "Account.leadSource must not be empty"
            });
        }
    }
    if (_field === "accountType") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "accountType",
                message: "Account.accountType must not be empty"
            });
        }
    }
    if (_field === "subtype") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "subtype",
                message: "Account.subtype must not be empty"
            });
        }
    }
    if (_field === "paymentTerms") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "paymentTerms",
                message: "Account.paymentTerms must not be empty"
            });
        }
    }
    return errors;
}
export function accountValidateFields(_partial: Partial<Account>): Array<{
    field: string;
    message: string;
}> {
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if ("leadSource" in _partial && _partial.leadSource !== undefined) {
        const __val = _partial.leadSource as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "leadSource",
                message: "Account.leadSource must not be empty"
            });
        }
    }
    if ("accountType" in _partial && _partial.accountType !== undefined) {
        const __val = _partial.accountType as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "accountType",
                message: "Account.accountType must not be empty"
            });
        }
    }
    if ("subtype" in _partial && _partial.subtype !== undefined) {
        const __val = _partial.subtype as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "subtype",
                message: "Account.subtype must not be empty"
            });
        }
    }
    if ("paymentTerms" in _partial && _partial.paymentTerms !== undefined) {
        const __val = _partial.paymentTerms as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "paymentTerms",
                message: "Account.paymentTerms must not be empty"
            });
        }
    }
    return errors;
}
export function accountHasShape(obj: unknown): boolean {
    if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
        return false;
    }
    const o = obj as Record<string, unknown>;
    return '"id" in o && "taxRate" in o && "site" in o && "salesRep" in o && "orders" in o && "activity" in o && "customFields" in o && "accountName" in o && "sector" in o && "memo" in o && "phones" in o && "email" in o && "leadSource" in o && "colors" in o && "needsReview" in o && "hasAlert" in o && "accountType" in o && "subtype" in o && "isTaxExempt" in o && "paymentTerms" in o && "tags" in o && "dateAdded" in o';
}
export function accountIs(obj: unknown): obj is Account {
    if (!accountHasShape(obj)) {
        return false;
    }
    const result = accountDeserialize(obj);
    return result.success;
}

export type AccountErrors = {
    _errors: __gf_Option<Array<string>>;
    id: __gf_Option<Array<string>>;
    taxRate: __gf_Option<Array<string>>;
    site: __gf_Option<Array<string>>;
    salesRep: __gf_Option<Array<string>>;
    orders: __gf_Option<Array<string>>;
    activity: __gf_Option<Array<string>>;
    customFields: __gf_Option<Array<string>>;
    accountName: __gf_Option<Array<string>>;
    sector: __gf_Option<Array<string>>;
    memo: __gf_Option<Array<string>>;
    phones: __gf_Option<Array<string>>;
    email: __gf_Option<Array<string>>;
    leadSource: __gf_Option<Array<string>>;
    colors: __gf_Option<Array<string>>;
    needsReview: __gf_Option<Array<string>>;
    hasAlert: __gf_Option<Array<string>>;
    accountType: __gf_Option<Array<string>>;
    subtype: __gf_Option<Array<string>>;
    isTaxExempt: __gf_Option<Array<string>>;
    paymentTerms: __gf_Option<Array<string>>;
    tags: __gf_Option<Array<string>>;
    dateAdded: __gf_Option<Array<string>>;
};
export type AccountTainted = {
    id: __gf_Option<boolean>;
    taxRate: __gf_Option<boolean>;
    site: __gf_Option<boolean>;
    salesRep: __gf_Option<boolean>;
    orders: __gf_Option<boolean>;
    activity: __gf_Option<boolean>;
    customFields: __gf_Option<boolean>;
    accountName: __gf_Option<boolean>;
    sector: __gf_Option<boolean>;
    memo: __gf_Option<boolean>;
    phones: __gf_Option<boolean>;
    email: __gf_Option<boolean>;
    leadSource: __gf_Option<boolean>;
    colors: __gf_Option<boolean>;
    needsReview: __gf_Option<boolean>;
    hasAlert: __gf_Option<boolean>;
    accountType: __gf_Option<boolean>;
    subtype: __gf_Option<boolean>;
    isTaxExempt: __gf_Option<boolean>;
    paymentTerms: __gf_Option<boolean>;
    tags: __gf_Option<boolean>;
    dateAdded: __gf_Option<boolean>;
};
export interface AccountFieldControllers {
    readonly id: FieldController<string>;
    readonly taxRate: FieldController<string | TaxRate>;
    readonly site: FieldController<string | Site>;
    readonly salesRep: FieldController<Array<Represents> | null>;
    readonly orders: ArrayFieldController<Ordered>;
    readonly activity: ArrayFieldController<Did>;
    readonly customFields: ArrayFieldController<[string, string]>;
    readonly accountName: FieldController<AccountName>;
    readonly sector: FieldController<Sector>;
    readonly memo: FieldController<string | null>;
    readonly phones: ArrayFieldController<PhoneNumber>;
    readonly email: FieldController<Email>;
    readonly leadSource: FieldController<string>;
    readonly colors: FieldController<Colors>;
    readonly needsReview: FieldController<boolean>;
    readonly hasAlert: FieldController<boolean>;
    readonly accountType: FieldController<string>;
    readonly subtype: FieldController<string>;
    readonly isTaxExempt: FieldController<boolean>;
    readonly paymentTerms: FieldController<string>;
    readonly tags: ArrayFieldController<string>;
    readonly dateAdded: FieldController<string>;
}
export interface AccountGigaform {
    readonly data: Account;
    readonly errors: AccountErrors;
    readonly tainted: AccountTainted;
    readonly fields: AccountFieldControllers;
    validate(): Exit<Account, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<Account>): void;
}
export function accountCreateForm(overrides?: Partial<Account>): AccountGigaform {
    let data = $state({
        ...accountDefaultValue(),
        ...overrides
    });
    let errors = $state<AccountErrors>({
        _errors: optionNone(),
        id: optionNone(),
        taxRate: optionNone(),
        site: optionNone(),
        salesRep: optionNone(),
        orders: optionNone(),
        activity: optionNone(),
        customFields: optionNone(),
        accountName: optionNone(),
        sector: optionNone(),
        memo: optionNone(),
        phones: optionNone(),
        email: optionNone(),
        leadSource: optionNone(),
        colors: optionNone(),
        needsReview: optionNone(),
        hasAlert: optionNone(),
        accountType: optionNone(),
        subtype: optionNone(),
        isTaxExempt: optionNone(),
        paymentTerms: optionNone(),
        tags: optionNone(),
        dateAdded: optionNone()
    } as AccountErrors);
    let tainted = $state<AccountTainted>({
        id: optionNone(),
        taxRate: optionNone(),
        site: optionNone(),
        salesRep: optionNone(),
        orders: optionNone(),
        activity: optionNone(),
        customFields: optionNone(),
        accountName: optionNone(),
        sector: optionNone(),
        memo: optionNone(),
        phones: optionNone(),
        email: optionNone(),
        leadSource: optionNone(),
        colors: optionNone(),
        needsReview: optionNone(),
        hasAlert: optionNone(),
        accountType: optionNone(),
        subtype: optionNone(),
        isTaxExempt: optionNone(),
        paymentTerms: optionNone(),
        tags: optionNone(),
        dateAdded: optionNone()
    } as AccountTainted);
    const fields = {
        id: {
            path: [
                "id"
            ] as const,
            name: "id",
            constraints: {
                required: true
            },
            get: ()=>data.id,
            set: (value: string)=>{
                data.id = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.id,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.id = value;
            },
            getTainted: ()=>tainted.id,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.id = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = accountValidateField("id", data.id);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        taxRate: {
            path: [
                "taxRate"
            ] as const,
            name: "taxRate",
            constraints: {
                required: true
            },
            label: "Tax Rate",
            get: ()=>data.taxRate,
            set: (value: string | TaxRate)=>{
                data.taxRate = value;
            },
            transform: (value: string | TaxRate): string | TaxRate =>value,
            getError: ()=>errors.taxRate,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.taxRate = value;
            },
            getTainted: ()=>tainted.taxRate,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.taxRate = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = accountValidateField("taxRate", data.taxRate);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        site: {
            path: [
                "site"
            ] as const,
            name: "site",
            constraints: {
                required: true
            },
            label: "Site",
            get: ()=>data.site,
            set: (value: string | Site)=>{
                data.site = value;
            },
            transform: (value: string | Site): string | Site =>value,
            getError: ()=>errors.site,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.site = value;
            },
            getTainted: ()=>tainted.site,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.site = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = accountValidateField("site", data.site);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        salesRep: {
            path: [
                "salesRep"
            ] as const,
            name: "salesRep",
            constraints: {
                required: true
            },
            label: "Sales Rep",
            get: ()=>data.salesRep,
            set: (value: Array<Represents> | null)=>{
                data.salesRep = value;
            },
            transform: (value: Array<Represents> | null): Array<Represents> | null =>value,
            getError: ()=>errors.salesRep,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.salesRep = value;
            },
            getTainted: ()=>tainted.salesRep,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.salesRep = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = accountValidateField("salesRep", data.salesRep);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        orders: {
            path: [
                "orders"
            ] as const,
            name: "orders",
            constraints: {
                required: true
            },
            get: ()=>data.orders,
            set: (value: Array<Ordered>)=>{
                data.orders = value;
            },
            transform: (value: Array<Ordered>): Array<Ordered> =>value,
            getError: ()=>errors.orders,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.orders = value;
            },
            getTainted: ()=>tainted.orders,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.orders = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = accountValidateField("orders", data.orders);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            },
            at: (index: number)=>({
                    path: [
                        "orders",
                        index
                    ] as const,
                    name: "'^orders.${index}^'",
                    constraints: {
                        required: true
                    },
                    get: ()=>data.orders[index]!,
                    set: (value: Ordered)=>{
                        data.orders[index] = value;
                    },
                    transform: (value: Ordered): Ordered =>value,
                    getError: ()=>errors.orders,
                    setError: (value: __gf_Option<Array<string>>)=>{
                        errors.orders = value;
                    },
                    getTainted: ()=>tainted.orders,
                    setTainted: (value: __gf_Option<boolean>)=>{
                        tainted.orders = value;
                    },
                    validate: (): Array<string> =>[]
                }),
            push: (item: Ordered)=>{
                data.orders.push(item);
            },
            remove: (index: number)=>{
                data.orders.splice(index, 1);
            },
            swap: (a: number, b: number)=>{
                const tmp = data.orders[a]!;
                data.orders[a] = data.orders[b]!;
                data.orders[b] = tmp;
            }
        },
        activity: {
            path: [
                "activity"
            ] as const,
            name: "activity",
            constraints: {
                required: true
            },
            get: ()=>data.activity,
            set: (value: Array<Did>)=>{
                data.activity = value;
            },
            transform: (value: Array<Did>): Array<Did> =>value,
            getError: ()=>errors.activity,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.activity = value;
            },
            getTainted: ()=>tainted.activity,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.activity = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = accountValidateField("activity", data.activity);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            },
            at: (index: number)=>({
                    path: [
                        "activity",
                        index
                    ] as const,
                    name: "'^activity.${index}^'",
                    constraints: {
                        required: true
                    },
                    get: ()=>data.activity[index]!,
                    set: (value: Did)=>{
                        data.activity[index] = value;
                    },
                    transform: (value: Did): Did =>value,
                    getError: ()=>errors.activity,
                    setError: (value: __gf_Option<Array<string>>)=>{
                        errors.activity = value;
                    },
                    getTainted: ()=>tainted.activity,
                    setTainted: (value: __gf_Option<boolean>)=>{
                        tainted.activity = value;
                    },
                    validate: (): Array<string> =>[]
                }),
            push: (item: Did)=>{
                data.activity.push(item);
            },
            remove: (index: number)=>{
                data.activity.splice(index, 1);
            },
            swap: (a: number, b: number)=>{
                const tmp = data.activity[a]!;
                data.activity[a] = data.activity[b]!;
                data.activity[b] = tmp;
            }
        },
        customFields: {
            path: [
                "customFields"
            ] as const,
            name: "customFields",
            constraints: {
                required: true
            },
            get: ()=>data.customFields,
            set: (value: Array<[string, string]>)=>{
                data.customFields = value;
            },
            transform: (value: Array<[string, string]>): Array<[string, string]> =>value,
            getError: ()=>errors.customFields,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.customFields = value;
            },
            getTainted: ()=>tainted.customFields,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.customFields = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = accountValidateField("customFields", data.customFields);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            },
            at: (index: number)=>({
                    path: [
                        "customFields",
                        index
                    ] as const,
                    name: "'^customFields.${index}^'",
                    constraints: {
                        required: true
                    },
                    get: ()=>data.customFields[index]!,
                    set: (value: [string, string])=>{
                        data.customFields[index] = value;
                    },
                    transform: (value: [string, string]): [string, string] =>value,
                    getError: ()=>errors.customFields,
                    setError: (value: __gf_Option<Array<string>>)=>{
                        errors.customFields = value;
                    },
                    getTainted: ()=>tainted.customFields,
                    setTainted: (value: __gf_Option<boolean>)=>{
                        tainted.customFields = value;
                    },
                    validate: (): Array<string> =>[]
                }),
            push: (item: [string, string])=>{
                data.customFields.push(item);
            },
            remove: (index: number)=>{
                data.customFields.splice(index, 1);
            },
            swap: (a: number, b: number)=>{
                const tmp = data.customFields[a]!;
                data.customFields[a] = data.customFields[b]!;
                data.customFields[b] = tmp;
            }
        },
        accountName: {
            path: [
                "accountName"
            ] as const,
            name: "accountName",
            constraints: {
                required: true
            },
            get: ()=>data.accountName,
            set: (value: AccountName)=>{
                data.accountName = value;
            },
            transform: (value: AccountName): AccountName =>value,
            getError: ()=>errors.accountName,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.accountName = value;
            },
            getTainted: ()=>tainted.accountName,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.accountName = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = accountValidateField("accountName", data.accountName);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        sector: {
            path: [
                "sector"
            ] as const,
            name: "sector",
            constraints: {
                required: true
            },
            label: "Sector",
            get: ()=>data.sector,
            set: (value: Sector)=>{
                data.sector = value;
            },
            transform: (value: Sector): Sector =>value,
            getError: ()=>errors.sector,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.sector = value;
            },
            getTainted: ()=>tainted.sector,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.sector = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = accountValidateField("sector", data.sector);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        memo: {
            path: [
                "memo"
            ] as const,
            name: "memo",
            constraints: {
                required: true
            },
            label: "Memo",
            get: ()=>data.memo,
            set: (value: string | null)=>{
                data.memo = value;
            },
            transform: (value: string | null): string | null =>value,
            getError: ()=>errors.memo,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.memo = value;
            },
            getTainted: ()=>tainted.memo,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.memo = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = accountValidateField("memo", data.memo);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        phones: {
            path: [
                "phones"
            ] as const,
            name: "phones",
            constraints: {
                required: true
            },
            get: ()=>data.phones,
            set: (value: Array<PhoneNumber>)=>{
                data.phones = value;
            },
            transform: (value: Array<PhoneNumber>): Array<PhoneNumber> =>value,
            getError: ()=>errors.phones,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.phones = value;
            },
            getTainted: ()=>tainted.phones,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.phones = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = accountValidateField("phones", data.phones);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            },
            at: (index: number)=>({
                    path: [
                        "phones",
                        index
                    ] as const,
                    name: "'^phones.${index}^'",
                    constraints: {
                        required: true
                    },
                    get: ()=>data.phones[index]!,
                    set: (value: PhoneNumber)=>{
                        data.phones[index] = value;
                    },
                    transform: (value: PhoneNumber): PhoneNumber =>value,
                    getError: ()=>errors.phones,
                    setError: (value: __gf_Option<Array<string>>)=>{
                        errors.phones = value;
                    },
                    getTainted: ()=>tainted.phones,
                    setTainted: (value: __gf_Option<boolean>)=>{
                        tainted.phones = value;
                    },
                    validate: (): Array<string> =>[]
                }),
            push: (item: PhoneNumber)=>{
                data.phones.push(item);
            },
            remove: (index: number)=>{
                data.phones.splice(index, 1);
            },
            swap: (a: number, b: number)=>{
                const tmp = data.phones[a]!;
                data.phones[a] = data.phones[b]!;
                data.phones[b] = tmp;
            }
        },
        email: {
            path: [
                "email"
            ] as const,
            name: "email",
            constraints: {
                required: true
            },
            label: "Email",
            get: ()=>data.email,
            set: (value: Email)=>{
                data.email = value;
            },
            transform: (value: Email): Email =>value,
            getError: ()=>errors.email,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.email = value;
            },
            getTainted: ()=>tainted.email,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.email = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = accountValidateField("email", data.email);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        leadSource: {
            path: [
                "leadSource"
            ] as const,
            name: "leadSource",
            constraints: {
                required: true
            },
            label: "Lead Source",
            get: ()=>data.leadSource,
            set: (value: string)=>{
                data.leadSource = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.leadSource,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.leadSource = value;
            },
            getTainted: ()=>tainted.leadSource,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.leadSource = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = accountValidateField("leadSource", data.leadSource);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        colors: {
            path: [
                "colors"
            ] as const,
            name: "colors",
            constraints: {
                required: true
            },
            get: ()=>data.colors,
            set: (value: Colors)=>{
                data.colors = value;
            },
            transform: (value: Colors): Colors =>value,
            getError: ()=>errors.colors,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.colors = value;
            },
            getTainted: ()=>tainted.colors,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.colors = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = accountValidateField("colors", data.colors);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        needsReview: {
            path: [
                "needsReview"
            ] as const,
            name: "needsReview",
            constraints: {
                required: true
            },
            label: "Needs Review",
            get: ()=>data.needsReview,
            set: (value: boolean)=>{
                data.needsReview = value;
            },
            transform: (value: boolean): boolean =>value,
            getError: ()=>errors.needsReview,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.needsReview = value;
            },
            getTainted: ()=>tainted.needsReview,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.needsReview = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = accountValidateField("needsReview", data.needsReview);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        hasAlert: {
            path: [
                "hasAlert"
            ] as const,
            name: "hasAlert",
            constraints: {
                required: true
            },
            label: "Has Alert",
            get: ()=>data.hasAlert,
            set: (value: boolean)=>{
                data.hasAlert = value;
            },
            transform: (value: boolean): boolean =>value,
            getError: ()=>errors.hasAlert,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.hasAlert = value;
            },
            getTainted: ()=>tainted.hasAlert,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.hasAlert = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = accountValidateField("hasAlert", data.hasAlert);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        accountType: {
            path: [
                "accountType"
            ] as const,
            name: "accountType",
            constraints: {
                required: true
            },
            label: "Account Type",
            get: ()=>data.accountType,
            set: (value: string)=>{
                data.accountType = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.accountType,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.accountType = value;
            },
            getTainted: ()=>tainted.accountType,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.accountType = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = accountValidateField("accountType", data.accountType);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        subtype: {
            path: [
                "subtype"
            ] as const,
            name: "subtype",
            constraints: {
                required: true
            },
            label: "Subtype",
            get: ()=>data.subtype,
            set: (value: string)=>{
                data.subtype = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.subtype,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.subtype = value;
            },
            getTainted: ()=>tainted.subtype,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.subtype = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = accountValidateField("subtype", data.subtype);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        isTaxExempt: {
            path: [
                "isTaxExempt"
            ] as const,
            name: "isTaxExempt",
            constraints: {
                required: true
            },
            label: "Tax Exempt",
            get: ()=>data.isTaxExempt,
            set: (value: boolean)=>{
                data.isTaxExempt = value;
            },
            transform: (value: boolean): boolean =>value,
            getError: ()=>errors.isTaxExempt,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.isTaxExempt = value;
            },
            getTainted: ()=>tainted.isTaxExempt,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.isTaxExempt = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = accountValidateField("isTaxExempt", data.isTaxExempt);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        paymentTerms: {
            path: [
                "paymentTerms"
            ] as const,
            name: "paymentTerms",
            constraints: {
                required: true
            },
            label: "Payment Terms",
            get: ()=>data.paymentTerms,
            set: (value: string)=>{
                data.paymentTerms = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.paymentTerms,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.paymentTerms = value;
            },
            getTainted: ()=>tainted.paymentTerms,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.paymentTerms = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = accountValidateField("paymentTerms", data.paymentTerms);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        tags: {
            path: [
                "tags"
            ] as const,
            name: "tags",
            constraints: {
                required: true
            },
            label: "Tags",
            get: ()=>data.tags,
            set: (value: Array<string>)=>{
                data.tags = value;
            },
            transform: (value: Array<string>): Array<string> =>value,
            getError: ()=>errors.tags,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.tags = value;
            },
            getTainted: ()=>tainted.tags,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.tags = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = accountValidateField("tags", data.tags);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            },
            at: (index: number)=>({
                    path: [
                        "tags",
                        index
                    ] as const,
                    name: "'^tags.${index}^'",
                    constraints: {
                        required: true
                    },
                    get: ()=>data.tags[index]!,
                    set: (value: string)=>{
                        data.tags[index] = value;
                    },
                    transform: (value: string): string =>value,
                    getError: ()=>errors.tags,
                    setError: (value: __gf_Option<Array<string>>)=>{
                        errors.tags = value;
                    },
                    getTainted: ()=>tainted.tags,
                    setTainted: (value: __gf_Option<boolean>)=>{
                        tainted.tags = value;
                    },
                    validate: (): Array<string> =>[]
                }),
            push: (item: string)=>{
                data.tags.push(item);
            },
            remove: (index: number)=>{
                data.tags.splice(index, 1);
            },
            swap: (a: number, b: number)=>{
                const tmp = data.tags[a]!;
                data.tags[a] = data.tags[b]!;
                data.tags[b] = tmp;
            }
        },
        dateAdded: {
            path: [
                "dateAdded"
            ] as const,
            name: "dateAdded",
            constraints: {
                required: true
            },
            get: ()=>data.dateAdded,
            set: (value: string)=>{
                data.dateAdded = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.dateAdded,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.dateAdded = value;
            },
            getTainted: ()=>tainted.dateAdded,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.dateAdded = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = accountValidateField("dateAdded", data.dateAdded);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        }
    } as AccountFieldControllers;
    const __gf_getter_hint = "get data() set data(v) get errors() set errors(v) get tainted() set tainted(v)";
    const __gf_validate_hint = ".map((e: { field: string; message: string }) => e.message)";
    function validate(): Exit<Account, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(accountDeserialize(data));
    }
    function reset(newOverrides?: Partial<Account>): void {
        data = {
            ...accountDefaultValue(),
            ...newOverrides
        };
        errors = {
            _errors: optionNone(),
            id: optionNone(),
            taxRate: optionNone(),
            site: optionNone(),
            salesRep: optionNone(),
            orders: optionNone(),
            activity: optionNone(),
            customFields: optionNone(),
            accountName: optionNone(),
            sector: optionNone(),
            memo: optionNone(),
            phones: optionNone(),
            email: optionNone(),
            leadSource: optionNone(),
            colors: optionNone(),
            needsReview: optionNone(),
            hasAlert: optionNone(),
            accountType: optionNone(),
            subtype: optionNone(),
            isTaxExempt: optionNone(),
            paymentTerms: optionNone(),
            tags: optionNone(),
            dateAdded: optionNone()
        };
        tainted = {
            id: optionNone(),
            taxRate: optionNone(),
            site: optionNone(),
            salesRep: optionNone(),
            orders: optionNone(),
            activity: optionNone(),
            customFields: optionNone(),
            accountName: optionNone(),
            sector: optionNone(),
            memo: optionNone(),
            phones: optionNone(),
            email: optionNone(),
            leadSource: optionNone(),
            colors: optionNone(),
            needsReview: optionNone(),
            hasAlert: optionNone(),
            accountType: optionNone(),
            subtype: optionNone(),
            isTaxExempt: optionNone(),
            paymentTerms: optionNone(),
            tags: optionNone(),
            dateAdded: optionNone()
        };
    }
    return {
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        fields,
        validate,
        reset
    };
}
export function accountFromFormData(formData: FormData): Exit<Account, Array<{
    field: string;
    message: string;
}>> {
    const obj: Record<string, unknown> = {};
    const __gf_exit_hint = "Exit<Account, Array<{ field: string; message: string }>>";
    obj.id = formData.get(`${"id"}`) ?? "";
    obj.taxRate = formData.get(`${"taxRate"}`) ?? "";
    obj.site = formData.get(`${"site"}`) ?? "";
    obj.salesRep = formData.get(`${"salesRep"}`) ?? "";
    {
        const ordersItems: Array<Record<string, unknown>> = [];
        let idx = 0;
        while(formData.has(`${"orders"}.` + idx + ".") || idx === 0){
            const hasAny = Array.from(formData.keys()).some((k)=>k.startsWith(`${"orders"}.` + idx + "."));
            if (!hasAny && idx > 0) break;
            if (hasAny) {
                const item: Record<string, unknown> = {};
                for (const [key, value] of Array.from(formData.entries())){
                    if (key.startsWith(`${"orders"}.` + idx + ".")) {
                        const fieldName = key.slice(`${"orders"}.`.length + String(idx).length + 1);
                        item[fieldName] = value;
                    }
                }
                ordersItems.push(item);
            }
            idx++;
            if (idx > 1000) break;
        }
        obj.orders = ordersItems;
    }
    {
        const activityItems: Array<Record<string, unknown>> = [];
        let idx = 0;
        while(formData.has(`${"activity"}.` + idx + ".") || idx === 0){
            const hasAny = Array.from(formData.keys()).some((k)=>k.startsWith(`${"activity"}.` + idx + "."));
            if (!hasAny && idx > 0) break;
            if (hasAny) {
                const item: Record<string, unknown> = {};
                for (const [key, value] of Array.from(formData.entries())){
                    if (key.startsWith(`${"activity"}.` + idx + ".")) {
                        const fieldName = key.slice(`${"activity"}.`.length + String(idx).length + 1);
                        item[fieldName] = value;
                    }
                }
                activityItems.push(item);
            }
            idx++;
            if (idx > 1000) break;
        }
        obj.activity = activityItems;
    }
    {
        const customFieldsItems: Array<Record<string, unknown>> = [];
        let idx = 0;
        while(formData.has(`${"customFields"}.` + idx + ".") || idx === 0){
            const hasAny = Array.from(formData.keys()).some((k)=>k.startsWith(`${"customFields"}.` + idx + "."));
            if (!hasAny && idx > 0) break;
            if (hasAny) {
                const item: Record<string, unknown> = {};
                for (const [key, value] of Array.from(formData.entries())){
                    if (key.startsWith(`${"customFields"}.` + idx + ".")) {
                        const fieldName = key.slice(`${"customFields"}.`.length + String(idx).length + 1);
                        item[fieldName] = value;
                    }
                }
                customFieldsItems.push(item);
            }
            idx++;
            if (idx > 1000) break;
        }
        obj.customFields = customFieldsItems;
    }
    {
        const accountNameObj: Record<string, unknown> = {};
        for (const [key, value] of Array.from(formData.entries())){
            if (key.startsWith(`${"accountName"}.`)) {
                const fieldName = key.slice(`${"accountName"}.`.length);
                const parts = fieldName.split(".");
                let current = accountNameObj;
                for(let i = 0; i < parts.length - 1; i++){
                    const part = parts[i]!;
                    if (!(part in current)) {
                        current[part] = {};
                    }
                    current = current[part] as Record<string, unknown>;
                }
                current[parts[parts.length - 1]!] = value;
            }
        }
        obj.accountName = accountNameObj;
    }
    {
        const sectorObj: Record<string, unknown> = {};
        for (const [key, value] of Array.from(formData.entries())){
            if (key.startsWith(`${"sector"}.`)) {
                const fieldName = key.slice(`${"sector"}.`.length);
                const parts = fieldName.split(".");
                let current = sectorObj;
                for(let i = 0; i < parts.length - 1; i++){
                    const part = parts[i]!;
                    if (!(part in current)) {
                        current[part] = {};
                    }
                    current = current[part] as Record<string, unknown>;
                }
                current[parts[parts.length - 1]!] = value;
            }
        }
        obj.sector = sectorObj;
    }
    obj.memo = formData.get(`${"memo"}`) ?? "";
    {
        const phonesItems: Array<Record<string, unknown>> = [];
        let idx = 0;
        while(formData.has(`${"phones"}.` + idx + ".") || idx === 0){
            const hasAny = Array.from(formData.keys()).some((k)=>k.startsWith(`${"phones"}.` + idx + "."));
            if (!hasAny && idx > 0) break;
            if (hasAny) {
                const item: Record<string, unknown> = {};
                for (const [key, value] of Array.from(formData.entries())){
                    if (key.startsWith(`${"phones"}.` + idx + ".")) {
                        const fieldName = key.slice(`${"phones"}.`.length + String(idx).length + 1);
                        item[fieldName] = value;
                    }
                }
                phonesItems.push(item);
            }
            idx++;
            if (idx > 1000) break;
        }
        obj.phones = phonesItems;
    }
    {
        const emailObj: Record<string, unknown> = {};
        for (const [key, value] of Array.from(formData.entries())){
            if (key.startsWith(`${"email"}.`)) {
                const fieldName = key.slice(`${"email"}.`.length);
                const parts = fieldName.split(".");
                let current = emailObj;
                for(let i = 0; i < parts.length - 1; i++){
                    const part = parts[i]!;
                    if (!(part in current)) {
                        current[part] = {};
                    }
                    current = current[part] as Record<string, unknown>;
                }
                current[parts[parts.length - 1]!] = value;
            }
        }
        obj.email = emailObj;
    }
    obj.leadSource = formData.get(`${"leadSource"}`) ?? "";
    {
        const colorsObj: Record<string, unknown> = {};
        for (const [key, value] of Array.from(formData.entries())){
            if (key.startsWith(`${"colors"}.`)) {
                const fieldName = key.slice(`${"colors"}.`.length);
                const parts = fieldName.split(".");
                let current = colorsObj;
                for(let i = 0; i < parts.length - 1; i++){
                    const part = parts[i]!;
                    if (!(part in current)) {
                        current[part] = {};
                    }
                    current = current[part] as Record<string, unknown>;
                }
                current[parts[parts.length - 1]!] = value;
            }
        }
        obj.colors = colorsObj;
    }
    {
        const needsReviewVal = formData.get(`${"needsReview"}`);
        obj.needsReview = needsReviewVal === "true" || needsReviewVal === "on" || needsReviewVal === "1";
    }
    {
        const hasAlertVal = formData.get(`${"hasAlert"}`);
        obj.hasAlert = hasAlertVal === "true" || hasAlertVal === "on" || hasAlertVal === "1";
    }
    obj.accountType = formData.get(`${"accountType"}`) ?? "";
    obj.subtype = formData.get(`${"subtype"}`) ?? "";
    {
        const isTaxExemptVal = formData.get(`${"isTaxExempt"}`);
        obj.isTaxExempt = isTaxExemptVal === "true" || isTaxExemptVal === "on" || isTaxExemptVal === "1";
    }
    obj.paymentTerms = formData.get(`${"paymentTerms"}`) ?? "";
    obj.tags = formData.getAll(`${"tags"}`) as Array<string>;
    obj.dateAdded = formData.get(`${"dateAdded"}`) ?? "";
    return toExit(accountDeserialize(obj));
}

export const Account = {
  defaultValue: accountDefaultValue,
  serialize: accountSerialize,
  serializeWithContext: accountSerializeWithContext,
  deserialize: accountDeserialize,
  deserializeWithContext: accountDeserializeWithContext,
  validateFields: accountValidateFields,
  hasShape: accountHasShape,
  is: accountIs,
  createForm: accountCreateForm,
  fromFormData: accountFromFormData
} as const;


export interface Edited {
    
    fieldName: string;
    oldValue: string | null;
    newValue: string | null;
}

export function editedDefaultValue(): Edited {
    return {
        fieldName: "",
        oldValue: null,
        newValue: null
    } as Edited;
}

export function editedSerialize(value: Edited): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(editedSerializeWithContext(value, ctx));
}
export function editedSerializeWithContext(value: Edited, ctx: __mf_SerializeContext): Record<string, unknown> {
    const existingId = ctx.getId(value);
    if (existingId !== undefined) {
        return {
            __ref: existingId
        };
    }
    const __id = ctx.register(value);
    const result: Record<string, unknown> = {
        __type: "Edited",
        __id
    };
    result.fieldName = value.fieldName;
    result.oldValue = value.oldValue;
    result.newValue = value.newValue;
    return result;
}

export function editedDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: Edited } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = editedDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "Edited.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function editedDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Edited | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
        throw new __mf_DeserializeError([
            {
                field: "_root",
                message: `${"Edited"}.deserializeWithContext: expected an object`
            }
        ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (!("fieldName" in obj)) {
        errors.push({
            field: "fieldName",
            message: "missing required field"
        });
    }
    if (!("oldValue" in obj)) {
        errors.push({
            field: "oldValue",
            message: "missing required field"
        });
    }
    if (!("newValue" in obj)) {
        errors.push({
            field: "newValue",
            message: "missing required field"
        });
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
        ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
        const __raw_fieldName = obj["fieldName"] as string;
        if (__raw_fieldName.trim().length === 0) {
            errors.push({
                field: "fieldName",
                message: "Edited.fieldName must not be empty"
            });
        }
        instance.fieldName = __raw_fieldName;
    }
    {
        const __raw_oldValue = obj["oldValue"] as string | null;
        instance.oldValue = __raw_oldValue;
    }
    {
        const __raw_newValue = obj["newValue"] as string | null;
        instance.newValue = __raw_newValue;
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    return instance as Edited;
}
export function editedValidateField<K extends keyof Edited>(_field: K, _value: Edited[K]): Array<{
    field: string;
    message: string;
}> {
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (_field === "fieldName") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "fieldName",
                message: "Edited.fieldName must not be empty"
            });
        }
    }
    return errors;
}
export function editedValidateFields(_partial: Partial<Edited>): Array<{
    field: string;
    message: string;
}> {
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if ("fieldName" in _partial && _partial.fieldName !== undefined) {
        const __val = _partial.fieldName as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "fieldName",
                message: "Edited.fieldName must not be empty"
            });
        }
    }
    return errors;
}
export function editedHasShape(obj: unknown): boolean {
    if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
        return false;
    }
    const o = obj as Record<string, unknown>;
    return '"fieldName" in o && "oldValue" in o && "newValue" in o';
}
export function editedIs(obj: unknown): obj is Edited {
    if (!editedHasShape(obj)) {
        return false;
    }
    const result = editedDeserialize(obj);
    return result.success;
}

export type EditedErrors = {
    _errors: __gf_Option<Array<string>>;
    fieldName: __gf_Option<Array<string>>;
    oldValue: __gf_Option<Array<string>>;
    newValue: __gf_Option<Array<string>>;
};
export type EditedTainted = {
    fieldName: __gf_Option<boolean>;
    oldValue: __gf_Option<boolean>;
    newValue: __gf_Option<boolean>;
};
export interface EditedFieldControllers {
    readonly fieldName: FieldController<string>;
    readonly oldValue: FieldController<string | null>;
    readonly newValue: FieldController<string | null>;
}
export interface EditedGigaform {
    readonly data: Edited;
    readonly errors: EditedErrors;
    readonly tainted: EditedTainted;
    readonly fields: EditedFieldControllers;
    validate(): Exit<Edited, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<Edited>): void;
}
export function editedCreateForm(overrides?: Partial<Edited>): EditedGigaform {
    let data = $state({
        ...editedDefaultValue(),
        ...overrides
    });
    let errors = $state<EditedErrors>({
        _errors: optionNone(),
        fieldName: optionNone(),
        oldValue: optionNone(),
        newValue: optionNone()
    } as EditedErrors);
    let tainted = $state<EditedTainted>({
        fieldName: optionNone(),
        oldValue: optionNone(),
        newValue: optionNone()
    } as EditedTainted);
    const fields = {
        fieldName: {
            path: [
                "fieldName"
            ] as const,
            name: "fieldName",
            constraints: {
                required: true
            },
            get: ()=>data.fieldName,
            set: (value: string)=>{
                data.fieldName = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.fieldName,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.fieldName = value;
            },
            getTainted: ()=>tainted.fieldName,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.fieldName = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = editedValidateField("fieldName", data.fieldName);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        oldValue: {
            path: [
                "oldValue"
            ] as const,
            name: "oldValue",
            constraints: {
                required: true
            },
            get: ()=>data.oldValue,
            set: (value: string | null)=>{
                data.oldValue = value;
            },
            transform: (value: string | null): string | null =>value,
            getError: ()=>errors.oldValue,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.oldValue = value;
            },
            getTainted: ()=>tainted.oldValue,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.oldValue = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = editedValidateField("oldValue", data.oldValue);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        newValue: {
            path: [
                "newValue"
            ] as const,
            name: "newValue",
            constraints: {
                required: true
            },
            get: ()=>data.newValue,
            set: (value: string | null)=>{
                data.newValue = value;
            },
            transform: (value: string | null): string | null =>value,
            getError: ()=>errors.newValue,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.newValue = value;
            },
            getTainted: ()=>tainted.newValue,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.newValue = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = editedValidateField("newValue", data.newValue);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        }
    } as EditedFieldControllers;
    const __gf_getter_hint = "get data() set data(v) get errors() set errors(v) get tainted() set tainted(v)";
    const __gf_validate_hint = ".map((e: { field: string; message: string }) => e.message)";
    function validate(): Exit<Edited, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(editedDeserialize(data));
    }
    function reset(newOverrides?: Partial<Edited>): void {
        data = {
            ...editedDefaultValue(),
            ...newOverrides
        };
        errors = {
            _errors: optionNone(),
            fieldName: optionNone(),
            oldValue: optionNone(),
            newValue: optionNone()
        };
        tainted = {
            fieldName: optionNone(),
            oldValue: optionNone(),
            newValue: optionNone()
        };
    }
    return {
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        fields,
        validate,
        reset
    };
}
export function editedFromFormData(formData: FormData): Exit<Edited, Array<{
    field: string;
    message: string;
}>> {
    const obj: Record<string, unknown> = {};
    const __gf_exit_hint = "Exit<Edited, Array<{ field: string; message: string }>>";
    obj.fieldName = formData.get(`${"fieldName"}`) ?? "";
    obj.oldValue = formData.get(`${"oldValue"}`) ?? "";
    obj.newValue = formData.get(`${"newValue"}`) ?? "";
    return toExit(editedDeserialize(obj));
}

export const Edited = {
  defaultValue: editedDefaultValue,
  serialize: editedSerialize,
  serializeWithContext: editedSerializeWithContext,
  deserialize: editedDeserialize,
  deserializeWithContext: editedDeserializeWithContext,
  validateFields: editedValidateFields,
  hasShape: editedHasShape,
  is: editedIs,
  createForm: editedCreateForm,
  fromFormData: editedFromFormData
} as const;


export interface Order {
    
    id: string;
    
    
    account: string | Account;
    
    
    stage: OrderStage;
    
    number: number;
    
    payments: Array<string | Payment>;
    
    
    opportunity: string;
    
    
    reference: string;
    
    
    leadSource: string;
    
    
    salesRep: string | Employee;
    
    
    group: string;
    
    
    subgroup: string;
    
    isPosted: boolean;
    
    needsReview: boolean;
    
    
    actionItem: string;
    
    upsale: number;
    
    dateCreated: string;
    
    
    appointment: string | Appointment;
    
    lastTechs: Array<string | Employee>;
    
    package: Array<string | Package> | null;
    
    promotion: Array<string | Promotion> | null;
    
    balance: number;
    
    due: string;
    
    total: number;
    
    
    site: string | Site;
    
    billedItems: Array<BilledItem>;
    
    
    memo: string;
    
    discount: number;
    
    tip: number;
    
    commissions: Array<number>;
}

export function orderDefaultValue(): Order {
    return {
        id: "",
        account: "",
        stage: "Estimate",
        number: 0,
        payments: [],
        opportunity: "",
        reference: "",
        leadSource: "",
        salesRep: "",
        group: "",
        subgroup: "",
        isPosted: false,
        needsReview: false,
        actionItem: "",
        upsale: 0,
        dateCreated: "",
        appointment: "",
        lastTechs: [],
        package: null,
        promotion: null,
        balance: 0,
        due: "",
        total: 0,
        site: "",
        billedItems: [],
        memo: "",
        discount: 0,
        tip: 0,
        commissions: []
    } as Order;
}

export function orderSerialize(value: Order): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(orderSerializeWithContext(value, ctx));
}
export function orderSerializeWithContext(value: Order, ctx: __mf_SerializeContext): Record<string, unknown> {
    const existingId = ctx.getId(value);
    if (existingId !== undefined) {
        return {
            __ref: existingId
        };
    }
    const __id = ctx.register(value);
    const result: Record<string, unknown> = {
        __type: "Order",
        __id
    };
    result.id = value.id;
    result.account = value.account;
    result.stage = orderStageSerializeWithContext(value.stage, ctx);
    result.number = value.number;
    result.payments = value.payments;
    result.opportunity = value.opportunity;
    result.reference = value.reference;
    result.leadSource = value.leadSource;
    result.salesRep = value.salesRep;
    result.group = value.group;
    result.subgroup = value.subgroup;
    result.isPosted = value.isPosted;
    result.needsReview = value.needsReview;
    result.actionItem = value.actionItem;
    result.upsale = value.upsale;
    result.dateCreated = value.dateCreated;
    result.appointment = value.appointment;
    result.lastTechs = value.lastTechs;
    if (value.package !== null) {
        result.package = value.package;
    }
    if (value.promotion !== null) {
        result.promotion = value.promotion;
    }
    result.balance = value.balance;
    result.due = value.due;
    result.total = value.total;
    result.site = value.site;
    result.billedItems = value.billedItems.map((item)=>billedItemSerializeWithContext(item, ctx));
    result.memo = value.memo;
    result.discount = value.discount;
    result.tip = value.tip;
    result.commissions = value.commissions;
    return result;
}

export function orderDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: Order } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = orderDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "Order.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function orderDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Order | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
        throw new __mf_DeserializeError([
            {
                field: "_root",
                message: `${"Order"}.deserializeWithContext: expected an object`
            }
        ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (!("id" in obj)) {
        errors.push({
            field: "id",
            message: "missing required field"
        });
    }
    if (!("account" in obj)) {
        errors.push({
            field: "account",
            message: "missing required field"
        });
    }
    if (!("stage" in obj)) {
        errors.push({
            field: "stage",
            message: "missing required field"
        });
    }
    if (!("number" in obj)) {
        errors.push({
            field: "number",
            message: "missing required field"
        });
    }
    if (!("payments" in obj)) {
        errors.push({
            field: "payments",
            message: "missing required field"
        });
    }
    if (!("opportunity" in obj)) {
        errors.push({
            field: "opportunity",
            message: "missing required field"
        });
    }
    if (!("reference" in obj)) {
        errors.push({
            field: "reference",
            message: "missing required field"
        });
    }
    if (!("leadSource" in obj)) {
        errors.push({
            field: "leadSource",
            message: "missing required field"
        });
    }
    if (!("salesRep" in obj)) {
        errors.push({
            field: "salesRep",
            message: "missing required field"
        });
    }
    if (!("group" in obj)) {
        errors.push({
            field: "group",
            message: "missing required field"
        });
    }
    if (!("subgroup" in obj)) {
        errors.push({
            field: "subgroup",
            message: "missing required field"
        });
    }
    if (!("isPosted" in obj)) {
        errors.push({
            field: "isPosted",
            message: "missing required field"
        });
    }
    if (!("needsReview" in obj)) {
        errors.push({
            field: "needsReview",
            message: "missing required field"
        });
    }
    if (!("actionItem" in obj)) {
        errors.push({
            field: "actionItem",
            message: "missing required field"
        });
    }
    if (!("upsale" in obj)) {
        errors.push({
            field: "upsale",
            message: "missing required field"
        });
    }
    if (!("dateCreated" in obj)) {
        errors.push({
            field: "dateCreated",
            message: "missing required field"
        });
    }
    if (!("appointment" in obj)) {
        errors.push({
            field: "appointment",
            message: "missing required field"
        });
    }
    if (!("lastTechs" in obj)) {
        errors.push({
            field: "lastTechs",
            message: "missing required field"
        });
    }
    if (!("package" in obj)) {
        errors.push({
            field: "package",
            message: "missing required field"
        });
    }
    if (!("promotion" in obj)) {
        errors.push({
            field: "promotion",
            message: "missing required field"
        });
    }
    if (!("balance" in obj)) {
        errors.push({
            field: "balance",
            message: "missing required field"
        });
    }
    if (!("due" in obj)) {
        errors.push({
            field: "due",
            message: "missing required field"
        });
    }
    if (!("total" in obj)) {
        errors.push({
            field: "total",
            message: "missing required field"
        });
    }
    if (!("site" in obj)) {
        errors.push({
            field: "site",
            message: "missing required field"
        });
    }
    if (!("billedItems" in obj)) {
        errors.push({
            field: "billedItems",
            message: "missing required field"
        });
    }
    if (!("memo" in obj)) {
        errors.push({
            field: "memo",
            message: "missing required field"
        });
    }
    if (!("discount" in obj)) {
        errors.push({
            field: "discount",
            message: "missing required field"
        });
    }
    if (!("tip" in obj)) {
        errors.push({
            field: "tip",
            message: "missing required field"
        });
    }
    if (!("commissions" in obj)) {
        errors.push({
            field: "commissions",
            message: "missing required field"
        });
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
        ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
        const __raw_id = obj["id"] as string;
        instance.id = __raw_id;
    }
    {
        const __raw_account = obj["account"] as string | Account;
        instance.account = __raw_account;
    }
    {
        const __raw_stage = obj["stage"] as OrderStage;
        {
            const __result = orderStageDeserializeWithContext(__raw_stage, ctx);
            ctx.assignOrDefer(instance, "stage", __result);
        }
    }
    {
        const __raw_number = obj["number"] as number;
        instance.number = __raw_number;
    }
    {
        const __raw_payments = obj["payments"] as Array<string | Payment>;
        if (Array.isArray(__raw_payments)) {
            instance.payments = __raw_payments as string | Payment[];
        }
    }
    {
        const __raw_opportunity = obj["opportunity"] as string;
        if (__raw_opportunity.trim().length === 0) {
            errors.push({
                field: "opportunity",
                message: "Order.opportunity must not be empty"
            });
        }
        instance.opportunity = __raw_opportunity;
    }
    {
        const __raw_reference = obj["reference"] as string;
        if (__raw_reference.trim().length === 0) {
            errors.push({
                field: "reference",
                message: "Order.reference must not be empty"
            });
        }
        instance.reference = __raw_reference;
    }
    {
        const __raw_leadSource = obj["leadSource"] as string;
        if (__raw_leadSource.trim().length === 0) {
            errors.push({
                field: "leadSource",
                message: "Order.leadSource must not be empty"
            });
        }
        instance.leadSource = __raw_leadSource;
    }
    {
        const __raw_salesRep = obj["salesRep"] as string | Employee;
        instance.salesRep = __raw_salesRep;
    }
    {
        const __raw_group = obj["group"] as string;
        if (__raw_group.trim().length === 0) {
            errors.push({
                field: "group",
                message: "Order.group must not be empty"
            });
        }
        instance.group = __raw_group;
    }
    {
        const __raw_subgroup = obj["subgroup"] as string;
        if (__raw_subgroup.trim().length === 0) {
            errors.push({
                field: "subgroup",
                message: "Order.subgroup must not be empty"
            });
        }
        instance.subgroup = __raw_subgroup;
    }
    {
        const __raw_isPosted = obj["isPosted"] as boolean;
        instance.isPosted = __raw_isPosted;
    }
    {
        const __raw_needsReview = obj["needsReview"] as boolean;
        instance.needsReview = __raw_needsReview;
    }
    {
        const __raw_actionItem = obj["actionItem"] as string;
        if (__raw_actionItem.trim().length === 0) {
            errors.push({
                field: "actionItem",
                message: "Order.actionItem must not be empty"
            });
        }
        instance.actionItem = __raw_actionItem;
    }
    {
        const __raw_upsale = obj["upsale"] as number;
        instance.upsale = __raw_upsale;
    }
    {
        const __raw_dateCreated = obj["dateCreated"] as string;
        instance.dateCreated = __raw_dateCreated;
    }
    {
        const __raw_appointment = obj["appointment"] as string | Appointment;
        instance.appointment = __raw_appointment;
    }
    {
        const __raw_lastTechs = obj["lastTechs"] as Array<string | Employee>;
        if (Array.isArray(__raw_lastTechs)) {
            instance.lastTechs = __raw_lastTechs as string | Employee[];
        }
    }
    {
        const __raw_package = obj["package"] as Array<string | Package> | null;
        if (__raw_package === null) {
            instance.package = null;
        } else {
            instance.package = __raw_package;
        }
    }
    {
        const __raw_promotion = obj["promotion"] as Array<string | Promotion> | null;
        if (__raw_promotion === null) {
            instance.promotion = null;
        } else {
            instance.promotion = __raw_promotion;
        }
    }
    {
        const __raw_balance = obj["balance"] as number;
        instance.balance = __raw_balance;
    }
    {
        const __raw_due = obj["due"] as string;
        instance.due = __raw_due;
    }
    {
        const __raw_total = obj["total"] as number;
        instance.total = __raw_total;
    }
    {
        const __raw_site = obj["site"] as string | Site;
        instance.site = __raw_site;
    }
    {
        const __raw_billedItems = obj["billedItems"] as Array<BilledItem>;
        if (Array.isArray(__raw_billedItems)) {
            instance.billedItems = __raw_billedItems as BilledItem[];
        }
    }
    {
        const __raw_memo = obj["memo"] as string;
        if (__raw_memo.trim().length === 0) {
            errors.push({
                field: "memo",
                message: "Order.memo must not be empty"
            });
        }
        instance.memo = __raw_memo;
    }
    {
        const __raw_discount = obj["discount"] as number;
        instance.discount = __raw_discount;
    }
    {
        const __raw_tip = obj["tip"] as number;
        instance.tip = __raw_tip;
    }
    {
        const __raw_commissions = obj["commissions"] as Array<number>;
        if (Array.isArray(__raw_commissions)) {
            instance.commissions = __raw_commissions as number[];
        }
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    return instance as Order;
}
export function orderValidateField<K extends keyof Order>(_field: K, _value: Order[K]): Array<{
    field: string;
    message: string;
}> {
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (_field === "opportunity") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "opportunity",
                message: "Order.opportunity must not be empty"
            });
        }
    }
    if (_field === "reference") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "reference",
                message: "Order.reference must not be empty"
            });
        }
    }
    if (_field === "leadSource") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "leadSource",
                message: "Order.leadSource must not be empty"
            });
        }
    }
    if (_field === "group") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "group",
                message: "Order.group must not be empty"
            });
        }
    }
    if (_field === "subgroup") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "subgroup",
                message: "Order.subgroup must not be empty"
            });
        }
    }
    if (_field === "actionItem") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "actionItem",
                message: "Order.actionItem must not be empty"
            });
        }
    }
    if (_field === "memo") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "memo",
                message: "Order.memo must not be empty"
            });
        }
    }
    return errors;
}
export function orderValidateFields(_partial: Partial<Order>): Array<{
    field: string;
    message: string;
}> {
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if ("opportunity" in _partial && _partial.opportunity !== undefined) {
        const __val = _partial.opportunity as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "opportunity",
                message: "Order.opportunity must not be empty"
            });
        }
    }
    if ("reference" in _partial && _partial.reference !== undefined) {
        const __val = _partial.reference as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "reference",
                message: "Order.reference must not be empty"
            });
        }
    }
    if ("leadSource" in _partial && _partial.leadSource !== undefined) {
        const __val = _partial.leadSource as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "leadSource",
                message: "Order.leadSource must not be empty"
            });
        }
    }
    if ("group" in _partial && _partial.group !== undefined) {
        const __val = _partial.group as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "group",
                message: "Order.group must not be empty"
            });
        }
    }
    if ("subgroup" in _partial && _partial.subgroup !== undefined) {
        const __val = _partial.subgroup as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "subgroup",
                message: "Order.subgroup must not be empty"
            });
        }
    }
    if ("actionItem" in _partial && _partial.actionItem !== undefined) {
        const __val = _partial.actionItem as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "actionItem",
                message: "Order.actionItem must not be empty"
            });
        }
    }
    if ("memo" in _partial && _partial.memo !== undefined) {
        const __val = _partial.memo as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "memo",
                message: "Order.memo must not be empty"
            });
        }
    }
    return errors;
}
export function orderHasShape(obj: unknown): boolean {
    if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
        return false;
    }
    const o = obj as Record<string, unknown>;
    return '"id" in o && "account" in o && "stage" in o && "number" in o && "payments" in o && "opportunity" in o && "reference" in o && "leadSource" in o && "salesRep" in o && "group" in o && "subgroup" in o && "isPosted" in o && "needsReview" in o && "actionItem" in o && "upsale" in o && "dateCreated" in o && "appointment" in o && "lastTechs" in o && "package" in o && "promotion" in o && "balance" in o && "due" in o && "total" in o && "site" in o && "billedItems" in o && "memo" in o && "discount" in o && "tip" in o && "commissions" in o';
}
export function orderIs(obj: unknown): obj is Order {
    if (!orderHasShape(obj)) {
        return false;
    }
    const result = orderDeserialize(obj);
    return result.success;
}

export type OrderErrors = {
    _errors: __gf_Option<Array<string>>;
    id: __gf_Option<Array<string>>;
    account: __gf_Option<Array<string>>;
    stage: __gf_Option<Array<string>>;
    number: __gf_Option<Array<string>>;
    payments: __gf_Option<Array<string>>;
    opportunity: __gf_Option<Array<string>>;
    reference: __gf_Option<Array<string>>;
    leadSource: __gf_Option<Array<string>>;
    salesRep: __gf_Option<Array<string>>;
    group: __gf_Option<Array<string>>;
    subgroup: __gf_Option<Array<string>>;
    isPosted: __gf_Option<Array<string>>;
    needsReview: __gf_Option<Array<string>>;
    actionItem: __gf_Option<Array<string>>;
    upsale: __gf_Option<Array<string>>;
    dateCreated: __gf_Option<Array<string>>;
    appointment: __gf_Option<Array<string>>;
    lastTechs: __gf_Option<Array<string>>;
    package: __gf_Option<Array<string>>;
    promotion: __gf_Option<Array<string>>;
    balance: __gf_Option<Array<string>>;
    due: __gf_Option<Array<string>>;
    total: __gf_Option<Array<string>>;
    site: __gf_Option<Array<string>>;
    billedItems: __gf_Option<Array<string>>;
    memo: __gf_Option<Array<string>>;
    discount: __gf_Option<Array<string>>;
    tip: __gf_Option<Array<string>>;
    commissions: __gf_Option<Array<string>>;
};
export type OrderTainted = {
    id: __gf_Option<boolean>;
    account: __gf_Option<boolean>;
    stage: __gf_Option<boolean>;
    number: __gf_Option<boolean>;
    payments: __gf_Option<boolean>;
    opportunity: __gf_Option<boolean>;
    reference: __gf_Option<boolean>;
    leadSource: __gf_Option<boolean>;
    salesRep: __gf_Option<boolean>;
    group: __gf_Option<boolean>;
    subgroup: __gf_Option<boolean>;
    isPosted: __gf_Option<boolean>;
    needsReview: __gf_Option<boolean>;
    actionItem: __gf_Option<boolean>;
    upsale: __gf_Option<boolean>;
    dateCreated: __gf_Option<boolean>;
    appointment: __gf_Option<boolean>;
    lastTechs: __gf_Option<boolean>;
    package: __gf_Option<boolean>;
    promotion: __gf_Option<boolean>;
    balance: __gf_Option<boolean>;
    due: __gf_Option<boolean>;
    total: __gf_Option<boolean>;
    site: __gf_Option<boolean>;
    billedItems: __gf_Option<boolean>;
    memo: __gf_Option<boolean>;
    discount: __gf_Option<boolean>;
    tip: __gf_Option<boolean>;
    commissions: __gf_Option<boolean>;
};
export interface OrderFieldControllers {
    readonly id: FieldController<string>;
    readonly account: FieldController<string | Account>;
    readonly stage: FieldController<OrderStage>;
    readonly number: FieldController<number>;
    readonly payments: ArrayFieldController<string | Payment>;
    readonly opportunity: FieldController<string>;
    readonly reference: FieldController<string>;
    readonly leadSource: FieldController<string>;
    readonly salesRep: FieldController<string | Employee>;
    readonly group: FieldController<string>;
    readonly subgroup: FieldController<string>;
    readonly isPosted: FieldController<boolean>;
    readonly needsReview: FieldController<boolean>;
    readonly actionItem: FieldController<string>;
    readonly upsale: FieldController<number>;
    readonly dateCreated: FieldController<string>;
    readonly appointment: FieldController<string | Appointment>;
    readonly lastTechs: ArrayFieldController<string | Employee>;
    readonly package: FieldController<Array<string | Package> | null>;
    readonly promotion: FieldController<Array<string | Promotion> | null>;
    readonly balance: FieldController<number>;
    readonly due: FieldController<string>;
    readonly total: FieldController<number>;
    readonly site: FieldController<string | Site>;
    readonly billedItems: ArrayFieldController<BilledItem>;
    readonly memo: FieldController<string>;
    readonly discount: FieldController<number>;
    readonly tip: FieldController<number>;
    readonly commissions: ArrayFieldController<number>;
}
export interface OrderGigaform {
    readonly data: Order;
    readonly errors: OrderErrors;
    readonly tainted: OrderTainted;
    readonly fields: OrderFieldControllers;
    validate(): Exit<Order, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<Order>): void;
}
export function orderCreateForm(overrides?: Partial<Order>): OrderGigaform {
    let data = $state({
        ...orderDefaultValue(),
        ...overrides
    });
    let errors = $state<OrderErrors>({
        _errors: optionNone(),
        id: optionNone(),
        account: optionNone(),
        stage: optionNone(),
        number: optionNone(),
        payments: optionNone(),
        opportunity: optionNone(),
        reference: optionNone(),
        leadSource: optionNone(),
        salesRep: optionNone(),
        group: optionNone(),
        subgroup: optionNone(),
        isPosted: optionNone(),
        needsReview: optionNone(),
        actionItem: optionNone(),
        upsale: optionNone(),
        dateCreated: optionNone(),
        appointment: optionNone(),
        lastTechs: optionNone(),
        package: optionNone(),
        promotion: optionNone(),
        balance: optionNone(),
        due: optionNone(),
        total: optionNone(),
        site: optionNone(),
        billedItems: optionNone(),
        memo: optionNone(),
        discount: optionNone(),
        tip: optionNone(),
        commissions: optionNone()
    } as OrderErrors);
    let tainted = $state<OrderTainted>({
        id: optionNone(),
        account: optionNone(),
        stage: optionNone(),
        number: optionNone(),
        payments: optionNone(),
        opportunity: optionNone(),
        reference: optionNone(),
        leadSource: optionNone(),
        salesRep: optionNone(),
        group: optionNone(),
        subgroup: optionNone(),
        isPosted: optionNone(),
        needsReview: optionNone(),
        actionItem: optionNone(),
        upsale: optionNone(),
        dateCreated: optionNone(),
        appointment: optionNone(),
        lastTechs: optionNone(),
        package: optionNone(),
        promotion: optionNone(),
        balance: optionNone(),
        due: optionNone(),
        total: optionNone(),
        site: optionNone(),
        billedItems: optionNone(),
        memo: optionNone(),
        discount: optionNone(),
        tip: optionNone(),
        commissions: optionNone()
    } as OrderTainted);
    const fields = {
        id: {
            path: [
                "id"
            ] as const,
            name: "id",
            constraints: {
                required: true
            },
            get: ()=>data.id,
            set: (value: string)=>{
                data.id = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.id,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.id = value;
            },
            getTainted: ()=>tainted.id,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.id = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = orderValidateField("id", data.id);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        account: {
            path: [
                "account"
            ] as const,
            name: "account",
            constraints: {
                required: true
            },
            label: "Account",
            get: ()=>data.account,
            set: (value: string | Account)=>{
                data.account = value;
            },
            transform: (value: string | Account): string | Account =>value,
            getError: ()=>errors.account,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.account = value;
            },
            getTainted: ()=>tainted.account,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.account = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = orderValidateField("account", data.account);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        stage: {
            path: [
                "stage"
            ] as const,
            name: "stage",
            constraints: {
                required: true
            },
            label: "Stage",
            get: ()=>data.stage,
            set: (value: OrderStage)=>{
                data.stage = value;
            },
            transform: (value: OrderStage): OrderStage =>value,
            getError: ()=>errors.stage,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.stage = value;
            },
            getTainted: ()=>tainted.stage,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.stage = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = orderValidateField("stage", data.stage);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        number: {
            path: [
                "number"
            ] as const,
            name: "number",
            constraints: {
                required: true
            },
            get: ()=>data.number,
            set: (value: number)=>{
                data.number = value;
            },
            transform: (value: number): number =>value,
            getError: ()=>errors.number,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.number = value;
            },
            getTainted: ()=>tainted.number,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.number = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = orderValidateField("number", data.number);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        payments: {
            path: [
                "payments"
            ] as const,
            name: "payments",
            constraints: {
                required: true
            },
            get: ()=>data.payments,
            set: (value: Array<string | Payment>)=>{
                data.payments = value;
            },
            transform: (value: Array<string | Payment>): Array<string | Payment> =>value,
            getError: ()=>errors.payments,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.payments = value;
            },
            getTainted: ()=>tainted.payments,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.payments = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = orderValidateField("payments", data.payments);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            },
            at: (index: number)=>({
                    path: [
                        "payments",
                        index
                    ] as const,
                    name: "'^payments.${index}^'",
                    constraints: {
                        required: true
                    },
                    get: ()=>data.payments[index]!,
                    set: (value: string | Payment)=>{
                        data.payments[index] = value;
                    },
                    transform: (value: string | Payment): string | Payment =>value,
                    getError: ()=>errors.payments,
                    setError: (value: __gf_Option<Array<string>>)=>{
                        errors.payments = value;
                    },
                    getTainted: ()=>tainted.payments,
                    setTainted: (value: __gf_Option<boolean>)=>{
                        tainted.payments = value;
                    },
                    validate: (): Array<string> =>[]
                }),
            push: (item: string | Payment)=>{
                data.payments.push(item);
            },
            remove: (index: number)=>{
                data.payments.splice(index, 1);
            },
            swap: (a: number, b: number)=>{
                const tmp = data.payments[a]!;
                data.payments[a] = data.payments[b]!;
                data.payments[b] = tmp;
            }
        },
        opportunity: {
            path: [
                "opportunity"
            ] as const,
            name: "opportunity",
            constraints: {
                required: true
            },
            label: "Opportunity",
            get: ()=>data.opportunity,
            set: (value: string)=>{
                data.opportunity = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.opportunity,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.opportunity = value;
            },
            getTainted: ()=>tainted.opportunity,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.opportunity = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = orderValidateField("opportunity", data.opportunity);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        reference: {
            path: [
                "reference"
            ] as const,
            name: "reference",
            constraints: {
                required: true
            },
            label: "Reference",
            get: ()=>data.reference,
            set: (value: string)=>{
                data.reference = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.reference,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.reference = value;
            },
            getTainted: ()=>tainted.reference,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.reference = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = orderValidateField("reference", data.reference);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        leadSource: {
            path: [
                "leadSource"
            ] as const,
            name: "leadSource",
            constraints: {
                required: true
            },
            label: "Lead Source",
            get: ()=>data.leadSource,
            set: (value: string)=>{
                data.leadSource = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.leadSource,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.leadSource = value;
            },
            getTainted: ()=>tainted.leadSource,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.leadSource = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = orderValidateField("leadSource", data.leadSource);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        salesRep: {
            path: [
                "salesRep"
            ] as const,
            name: "salesRep",
            constraints: {
                required: true
            },
            label: "Sales Rep",
            get: ()=>data.salesRep,
            set: (value: string | Employee)=>{
                data.salesRep = value;
            },
            transform: (value: string | Employee): string | Employee =>value,
            getError: ()=>errors.salesRep,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.salesRep = value;
            },
            getTainted: ()=>tainted.salesRep,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.salesRep = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = orderValidateField("salesRep", data.salesRep);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        group: {
            path: [
                "group"
            ] as const,
            name: "group",
            constraints: {
                required: true
            },
            label: "Group",
            get: ()=>data.group,
            set: (value: string)=>{
                data.group = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.group,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.group = value;
            },
            getTainted: ()=>tainted.group,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.group = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = orderValidateField("group", data.group);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        subgroup: {
            path: [
                "subgroup"
            ] as const,
            name: "subgroup",
            constraints: {
                required: true
            },
            label: "Subgroup",
            get: ()=>data.subgroup,
            set: (value: string)=>{
                data.subgroup = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.subgroup,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.subgroup = value;
            },
            getTainted: ()=>tainted.subgroup,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.subgroup = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = orderValidateField("subgroup", data.subgroup);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        isPosted: {
            path: [
                "isPosted"
            ] as const,
            name: "isPosted",
            constraints: {
                required: true
            },
            label: "Posted",
            get: ()=>data.isPosted,
            set: (value: boolean)=>{
                data.isPosted = value;
            },
            transform: (value: boolean): boolean =>value,
            getError: ()=>errors.isPosted,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.isPosted = value;
            },
            getTainted: ()=>tainted.isPosted,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.isPosted = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = orderValidateField("isPosted", data.isPosted);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        needsReview: {
            path: [
                "needsReview"
            ] as const,
            name: "needsReview",
            constraints: {
                required: true
            },
            label: "Needs Review",
            get: ()=>data.needsReview,
            set: (value: boolean)=>{
                data.needsReview = value;
            },
            transform: (value: boolean): boolean =>value,
            getError: ()=>errors.needsReview,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.needsReview = value;
            },
            getTainted: ()=>tainted.needsReview,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.needsReview = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = orderValidateField("needsReview", data.needsReview);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        actionItem: {
            path: [
                "actionItem"
            ] as const,
            name: "actionItem",
            constraints: {
                required: true
            },
            label: "Action Item",
            get: ()=>data.actionItem,
            set: (value: string)=>{
                data.actionItem = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.actionItem,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.actionItem = value;
            },
            getTainted: ()=>tainted.actionItem,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.actionItem = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = orderValidateField("actionItem", data.actionItem);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        upsale: {
            path: [
                "upsale"
            ] as const,
            name: "upsale",
            constraints: {
                required: true
            },
            get: ()=>data.upsale,
            set: (value: number)=>{
                data.upsale = value;
            },
            transform: (value: number): number =>value,
            getError: ()=>errors.upsale,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.upsale = value;
            },
            getTainted: ()=>tainted.upsale,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.upsale = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = orderValidateField("upsale", data.upsale);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        dateCreated: {
            path: [
                "dateCreated"
            ] as const,
            name: "dateCreated",
            constraints: {
                required: true
            },
            get: ()=>data.dateCreated,
            set: (value: string)=>{
                data.dateCreated = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.dateCreated,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.dateCreated = value;
            },
            getTainted: ()=>tainted.dateCreated,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.dateCreated = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = orderValidateField("dateCreated", data.dateCreated);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        appointment: {
            path: [
                "appointment"
            ] as const,
            name: "appointment",
            constraints: {
                required: true
            },
            label: "Appointment",
            get: ()=>data.appointment,
            set: (value: string | Appointment)=>{
                data.appointment = value;
            },
            transform: (value: string | Appointment): string | Appointment =>value,
            getError: ()=>errors.appointment,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.appointment = value;
            },
            getTainted: ()=>tainted.appointment,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.appointment = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = orderValidateField("appointment", data.appointment);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        lastTechs: {
            path: [
                "lastTechs"
            ] as const,
            name: "lastTechs",
            constraints: {
                required: true
            },
            label: "Technicians",
            get: ()=>data.lastTechs,
            set: (value: Array<string | Employee>)=>{
                data.lastTechs = value;
            },
            transform: (value: Array<string | Employee>): Array<string | Employee> =>value,
            getError: ()=>errors.lastTechs,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.lastTechs = value;
            },
            getTainted: ()=>tainted.lastTechs,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.lastTechs = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = orderValidateField("lastTechs", data.lastTechs);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            },
            at: (index: number)=>({
                    path: [
                        "lastTechs",
                        index
                    ] as const,
                    name: "'^lastTechs.${index}^'",
                    constraints: {
                        required: true
                    },
                    get: ()=>data.lastTechs[index]!,
                    set: (value: string | Employee)=>{
                        data.lastTechs[index] = value;
                    },
                    transform: (value: string | Employee): string | Employee =>value,
                    getError: ()=>errors.lastTechs,
                    setError: (value: __gf_Option<Array<string>>)=>{
                        errors.lastTechs = value;
                    },
                    getTainted: ()=>tainted.lastTechs,
                    setTainted: (value: __gf_Option<boolean>)=>{
                        tainted.lastTechs = value;
                    },
                    validate: (): Array<string> =>[]
                }),
            push: (item: string | Employee)=>{
                data.lastTechs.push(item);
            },
            remove: (index: number)=>{
                data.lastTechs.splice(index, 1);
            },
            swap: (a: number, b: number)=>{
                const tmp = data.lastTechs[a]!;
                data.lastTechs[a] = data.lastTechs[b]!;
                data.lastTechs[b] = tmp;
            }
        },
        package: {
            path: [
                "package"
            ] as const,
            name: "package",
            constraints: {
                required: true
            },
            get: ()=>data.package,
            set: (value: Array<string | Package> | null)=>{
                data.package = value;
            },
            transform: (value: Array<string | Package> | null): Array<string | Package> | null =>value,
            getError: ()=>errors.package,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.package = value;
            },
            getTainted: ()=>tainted.package,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.package = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = orderValidateField("package", data.package);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        promotion: {
            path: [
                "promotion"
            ] as const,
            name: "promotion",
            constraints: {
                required: true
            },
            get: ()=>data.promotion,
            set: (value: Array<string | Promotion> | null)=>{
                data.promotion = value;
            },
            transform: (value: Array<string | Promotion> | null): Array<string | Promotion> | null =>value,
            getError: ()=>errors.promotion,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.promotion = value;
            },
            getTainted: ()=>tainted.promotion,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.promotion = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = orderValidateField("promotion", data.promotion);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        balance: {
            path: [
                "balance"
            ] as const,
            name: "balance",
            constraints: {
                required: true
            },
            get: ()=>data.balance,
            set: (value: number)=>{
                data.balance = value;
            },
            transform: (value: number): number =>value,
            getError: ()=>errors.balance,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.balance = value;
            },
            getTainted: ()=>tainted.balance,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.balance = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = orderValidateField("balance", data.balance);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        due: {
            path: [
                "due"
            ] as const,
            name: "due",
            constraints: {
                required: true
            },
            label: "Due",
            get: ()=>data.due,
            set: (value: string)=>{
                data.due = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.due,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.due = value;
            },
            getTainted: ()=>tainted.due,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.due = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = orderValidateField("due", data.due);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        total: {
            path: [
                "total"
            ] as const,
            name: "total",
            constraints: {
                required: true
            },
            get: ()=>data.total,
            set: (value: number)=>{
                data.total = value;
            },
            transform: (value: number): number =>value,
            getError: ()=>errors.total,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.total = value;
            },
            getTainted: ()=>tainted.total,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.total = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = orderValidateField("total", data.total);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        site: {
            path: [
                "site"
            ] as const,
            name: "site",
            constraints: {
                required: true
            },
            label: "Site",
            get: ()=>data.site,
            set: (value: string | Site)=>{
                data.site = value;
            },
            transform: (value: string | Site): string | Site =>value,
            getError: ()=>errors.site,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.site = value;
            },
            getTainted: ()=>tainted.site,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.site = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = orderValidateField("site", data.site);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        billedItems: {
            path: [
                "billedItems"
            ] as const,
            name: "billedItems",
            constraints: {
                required: true
            },
            get: ()=>data.billedItems,
            set: (value: Array<BilledItem>)=>{
                data.billedItems = value;
            },
            transform: (value: Array<BilledItem>): Array<BilledItem> =>value,
            getError: ()=>errors.billedItems,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.billedItems = value;
            },
            getTainted: ()=>tainted.billedItems,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.billedItems = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = orderValidateField("billedItems", data.billedItems);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            },
            at: (index: number)=>({
                    path: [
                        "billedItems",
                        index
                    ] as const,
                    name: "'^billedItems.${index}^'",
                    constraints: {
                        required: true
                    },
                    get: ()=>data.billedItems[index]!,
                    set: (value: BilledItem)=>{
                        data.billedItems[index] = value;
                    },
                    transform: (value: BilledItem): BilledItem =>value,
                    getError: ()=>errors.billedItems,
                    setError: (value: __gf_Option<Array<string>>)=>{
                        errors.billedItems = value;
                    },
                    getTainted: ()=>tainted.billedItems,
                    setTainted: (value: __gf_Option<boolean>)=>{
                        tainted.billedItems = value;
                    },
                    validate: (): Array<string> =>[]
                }),
            push: (item: BilledItem)=>{
                data.billedItems.push(item);
            },
            remove: (index: number)=>{
                data.billedItems.splice(index, 1);
            },
            swap: (a: number, b: number)=>{
                const tmp = data.billedItems[a]!;
                data.billedItems[a] = data.billedItems[b]!;
                data.billedItems[b] = tmp;
            }
        },
        memo: {
            path: [
                "memo"
            ] as const,
            name: "memo",
            constraints: {
                required: true
            },
            label: "Memo",
            get: ()=>data.memo,
            set: (value: string)=>{
                data.memo = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.memo,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.memo = value;
            },
            getTainted: ()=>tainted.memo,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.memo = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = orderValidateField("memo", data.memo);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        discount: {
            path: [
                "discount"
            ] as const,
            name: "discount",
            constraints: {
                required: true
            },
            get: ()=>data.discount,
            set: (value: number)=>{
                data.discount = value;
            },
            transform: (value: number): number =>value,
            getError: ()=>errors.discount,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.discount = value;
            },
            getTainted: ()=>tainted.discount,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.discount = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = orderValidateField("discount", data.discount);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        tip: {
            path: [
                "tip"
            ] as const,
            name: "tip",
            constraints: {
                required: true
            },
            get: ()=>data.tip,
            set: (value: number)=>{
                data.tip = value;
            },
            transform: (value: number): number =>value,
            getError: ()=>errors.tip,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.tip = value;
            },
            getTainted: ()=>tainted.tip,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.tip = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = orderValidateField("tip", data.tip);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        commissions: {
            path: [
                "commissions"
            ] as const,
            name: "commissions",
            constraints: {
                required: true
            },
            get: ()=>data.commissions,
            set: (value: Array<number>)=>{
                data.commissions = value;
            },
            transform: (value: Array<number>): Array<number> =>value,
            getError: ()=>errors.commissions,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.commissions = value;
            },
            getTainted: ()=>tainted.commissions,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.commissions = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = orderValidateField("commissions", data.commissions);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            },
            at: (index: number)=>({
                    path: [
                        "commissions",
                        index
                    ] as const,
                    name: "'^commissions.${index}^'",
                    constraints: {
                        required: true
                    },
                    get: ()=>data.commissions[index]!,
                    set: (value: number)=>{
                        data.commissions[index] = value;
                    },
                    transform: (value: number): number =>value,
                    getError: ()=>errors.commissions,
                    setError: (value: __gf_Option<Array<string>>)=>{
                        errors.commissions = value;
                    },
                    getTainted: ()=>tainted.commissions,
                    setTainted: (value: __gf_Option<boolean>)=>{
                        tainted.commissions = value;
                    },
                    validate: (): Array<string> =>[]
                }),
            push: (item: number)=>{
                data.commissions.push(item);
            },
            remove: (index: number)=>{
                data.commissions.splice(index, 1);
            },
            swap: (a: number, b: number)=>{
                const tmp = data.commissions[a]!;
                data.commissions[a] = data.commissions[b]!;
                data.commissions[b] = tmp;
            }
        }
    } as OrderFieldControllers;
    const __gf_getter_hint = "get data() set data(v) get errors() set errors(v) get tainted() set tainted(v)";
    const __gf_validate_hint = ".map((e: { field: string; message: string }) => e.message)";
    function validate(): Exit<Order, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(orderDeserialize(data));
    }
    function reset(newOverrides?: Partial<Order>): void {
        data = {
            ...orderDefaultValue(),
            ...newOverrides
        };
        errors = {
            _errors: optionNone(),
            id: optionNone(),
            account: optionNone(),
            stage: optionNone(),
            number: optionNone(),
            payments: optionNone(),
            opportunity: optionNone(),
            reference: optionNone(),
            leadSource: optionNone(),
            salesRep: optionNone(),
            group: optionNone(),
            subgroup: optionNone(),
            isPosted: optionNone(),
            needsReview: optionNone(),
            actionItem: optionNone(),
            upsale: optionNone(),
            dateCreated: optionNone(),
            appointment: optionNone(),
            lastTechs: optionNone(),
            package: optionNone(),
            promotion: optionNone(),
            balance: optionNone(),
            due: optionNone(),
            total: optionNone(),
            site: optionNone(),
            billedItems: optionNone(),
            memo: optionNone(),
            discount: optionNone(),
            tip: optionNone(),
            commissions: optionNone()
        };
        tainted = {
            id: optionNone(),
            account: optionNone(),
            stage: optionNone(),
            number: optionNone(),
            payments: optionNone(),
            opportunity: optionNone(),
            reference: optionNone(),
            leadSource: optionNone(),
            salesRep: optionNone(),
            group: optionNone(),
            subgroup: optionNone(),
            isPosted: optionNone(),
            needsReview: optionNone(),
            actionItem: optionNone(),
            upsale: optionNone(),
            dateCreated: optionNone(),
            appointment: optionNone(),
            lastTechs: optionNone(),
            package: optionNone(),
            promotion: optionNone(),
            balance: optionNone(),
            due: optionNone(),
            total: optionNone(),
            site: optionNone(),
            billedItems: optionNone(),
            memo: optionNone(),
            discount: optionNone(),
            tip: optionNone(),
            commissions: optionNone()
        };
    }
    return {
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        fields,
        validate,
        reset
    };
}
export function orderFromFormData(formData: FormData): Exit<Order, Array<{
    field: string;
    message: string;
}>> {
    const obj: Record<string, unknown> = {};
    const __gf_exit_hint = "Exit<Order, Array<{ field: string; message: string }>>";
    obj.id = formData.get(`${"id"}`) ?? "";
    obj.account = formData.get(`${"account"}`) ?? "";
    {
        const stageObj: Record<string, unknown> = {};
        for (const [key, value] of Array.from(formData.entries())){
            if (key.startsWith(`${"stage"}.`)) {
                const fieldName = key.slice(`${"stage"}.`.length);
                const parts = fieldName.split(".");
                let current = stageObj;
                for(let i = 0; i < parts.length - 1; i++){
                    const part = parts[i]!;
                    if (!(part in current)) {
                        current[part] = {};
                    }
                    current = current[part] as Record<string, unknown>;
                }
                current[parts[parts.length - 1]!] = value;
            }
        }
        obj.stage = stageObj;
    }
    {
        const numberStr = formData.get(`${"number"}`);
        obj.number = numberStr ? parseFloat(numberStr as string) : $MfPh5;
        if (obj.number !== undefined && isNaN(obj.number as number)) obj.number = "0";
    }
    obj.payments = formData.getAll(`${"payments"}`) as Array<string>;
    obj.opportunity = formData.get(`${"opportunity"}`) ?? "";
    obj.reference = formData.get(`${"reference"}`) ?? "";
    obj.leadSource = formData.get(`${"leadSource"}`) ?? "";
    obj.salesRep = formData.get(`${"salesRep"}`) ?? "";
    obj.group = formData.get(`${"group"}`) ?? "";
    obj.subgroup = formData.get(`${"subgroup"}`) ?? "";
    {
        const isPostedVal = formData.get(`${"isPosted"}`);
        obj.isPosted = isPostedVal === "true" || isPostedVal === "on" || isPostedVal === "1";
    }
    {
        const needsReviewVal = formData.get(`${"needsReview"}`);
        obj.needsReview = needsReviewVal === "true" || needsReviewVal === "on" || needsReviewVal === "1";
    }
    obj.actionItem = formData.get(`${"actionItem"}`) ?? "";
    {
        const upsaleStr = formData.get(`${"upsale"}`);
        obj.upsale = upsaleStr ? parseFloat(upsaleStr as string) : $MfPh5;
        if (obj.upsale !== undefined && isNaN(obj.upsale as number)) obj.upsale = "0";
    }
    obj.dateCreated = formData.get(`${"dateCreated"}`) ?? "";
    obj.appointment = formData.get(`${"appointment"}`) ?? "";
    obj.lastTechs = formData.getAll(`${"lastTechs"}`) as Array<string>;
    obj.package = formData.get(`${"package"}`) ?? "";
    obj.promotion = formData.get(`${"promotion"}`) ?? "";
    {
        const balanceStr = formData.get(`${"balance"}`);
        obj.balance = balanceStr ? parseFloat(balanceStr as string) : $MfPh5;
        if (obj.balance !== undefined && isNaN(obj.balance as number)) obj.balance = "0";
    }
    obj.due = formData.get(`${"due"}`) ?? "";
    {
        const totalStr = formData.get(`${"total"}`);
        obj.total = totalStr ? parseFloat(totalStr as string) : $MfPh5;
        if (obj.total !== undefined && isNaN(obj.total as number)) obj.total = "0";
    }
    obj.site = formData.get(`${"site"}`) ?? "";
    {
        const billedItemsItems: Array<Record<string, unknown>> = [];
        let idx = 0;
        while(formData.has(`${"billedItems"}.` + idx + ".") || idx === 0){
            const hasAny = Array.from(formData.keys()).some((k)=>k.startsWith(`${"billedItems"}.` + idx + "."));
            if (!hasAny && idx > 0) break;
            if (hasAny) {
                const item: Record<string, unknown> = {};
                for (const [key, value] of Array.from(formData.entries())){
                    if (key.startsWith(`${"billedItems"}.` + idx + ".")) {
                        const fieldName = key.slice(`${"billedItems"}.`.length + String(idx).length + 1);
                        item[fieldName] = value;
                    }
                }
                billedItemsItems.push(item);
            }
            idx++;
            if (idx > 1000) break;
        }
        obj.billedItems = billedItemsItems;
    }
    obj.memo = formData.get(`${"memo"}`) ?? "";
    {
        const discountStr = formData.get(`${"discount"}`);
        obj.discount = discountStr ? parseFloat(discountStr as string) : $MfPh5;
        if (obj.discount !== undefined && isNaN(obj.discount as number)) obj.discount = "0";
    }
    {
        const tipStr = formData.get(`${"tip"}`);
        obj.tip = tipStr ? parseFloat(tipStr as string) : $MfPh5;
        if (obj.tip !== undefined && isNaN(obj.tip as number)) obj.tip = "0";
    }
    obj.commissions = formData.getAll(`${"commissions"}`).map((v)=>parseFloat(v as string)).filter((n)=>!isNaN(n));
    return toExit(orderDeserialize(obj));
}

export const Order = {
  defaultValue: orderDefaultValue,
  serialize: orderSerialize,
  serializeWithContext: orderSerializeWithContext,
  deserialize: orderDeserialize,
  deserializeWithContext: orderDeserializeWithContext,
  validateFields: orderValidateFields,
  hasShape: orderHasShape,
  is: orderIs,
  createForm: orderCreateForm,
  fromFormData: orderFromFormData
} as const;


export interface Commented {
    
    comment: string;
    replyTo: string | null;
}

export function commentedDefaultValue(): Commented {
    return {
        comment: "",
        replyTo: null
    } as Commented;
}

export function commentedSerialize(value: Commented): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(commentedSerializeWithContext(value, ctx));
}
export function commentedSerializeWithContext(value: Commented, ctx: __mf_SerializeContext): Record<string, unknown> {
    const existingId = ctx.getId(value);
    if (existingId !== undefined) {
        return {
            __ref: existingId
        };
    }
    const __id = ctx.register(value);
    const result: Record<string, unknown> = {
        __type: "Commented",
        __id
    };
    result.comment = value.comment;
    result.replyTo = value.replyTo;
    return result;
}

export function commentedDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: Commented } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = commentedDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "Commented.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function commentedDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Commented | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
        throw new __mf_DeserializeError([
            {
                field: "_root",
                message: `${"Commented"}.deserializeWithContext: expected an object`
            }
        ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (!("comment" in obj)) {
        errors.push({
            field: "comment",
            message: "missing required field"
        });
    }
    if (!("replyTo" in obj)) {
        errors.push({
            field: "replyTo",
            message: "missing required field"
        });
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
        ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
        const __raw_comment = obj["comment"] as string;
        if (__raw_comment.trim().length === 0) {
            errors.push({
                field: "comment",
                message: "Commented.comment must not be empty"
            });
        }
        instance.comment = __raw_comment;
    }
    {
        const __raw_replyTo = obj["replyTo"] as string | null;
        instance.replyTo = __raw_replyTo;
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    return instance as Commented;
}
export function commentedValidateField<K extends keyof Commented>(_field: K, _value: Commented[K]): Array<{
    field: string;
    message: string;
}> {
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (_field === "comment") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "comment",
                message: "Commented.comment must not be empty"
            });
        }
    }
    return errors;
}
export function commentedValidateFields(_partial: Partial<Commented>): Array<{
    field: string;
    message: string;
}> {
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if ("comment" in _partial && _partial.comment !== undefined) {
        const __val = _partial.comment as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "comment",
                message: "Commented.comment must not be empty"
            });
        }
    }
    return errors;
}
export function commentedHasShape(obj: unknown): boolean {
    if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
        return false;
    }
    const o = obj as Record<string, unknown>;
    return '"comment" in o && "replyTo" in o';
}
export function commentedIs(obj: unknown): obj is Commented {
    if (!commentedHasShape(obj)) {
        return false;
    }
    const result = commentedDeserialize(obj);
    return result.success;
}

export type CommentedErrors = {
    _errors: __gf_Option<Array<string>>;
    comment: __gf_Option<Array<string>>;
    replyTo: __gf_Option<Array<string>>;
};
export type CommentedTainted = {
    comment: __gf_Option<boolean>;
    replyTo: __gf_Option<boolean>;
};
export interface CommentedFieldControllers {
    readonly comment: FieldController<string>;
    readonly replyTo: FieldController<string | null>;
}
export interface CommentedGigaform {
    readonly data: Commented;
    readonly errors: CommentedErrors;
    readonly tainted: CommentedTainted;
    readonly fields: CommentedFieldControllers;
    validate(): Exit<Commented, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<Commented>): void;
}
export function commentedCreateForm(overrides?: Partial<Commented>): CommentedGigaform {
    let data = $state({
        ...commentedDefaultValue(),
        ...overrides
    });
    let errors = $state<CommentedErrors>({
        _errors: optionNone(),
        comment: optionNone(),
        replyTo: optionNone()
    } as CommentedErrors);
    let tainted = $state<CommentedTainted>({
        comment: optionNone(),
        replyTo: optionNone()
    } as CommentedTainted);
    const fields = {
        comment: {
            path: [
                "comment"
            ] as const,
            name: "comment",
            constraints: {
                required: true
            },
            get: ()=>data.comment,
            set: (value: string)=>{
                data.comment = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.comment,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.comment = value;
            },
            getTainted: ()=>tainted.comment,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.comment = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = commentedValidateField("comment", data.comment);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        replyTo: {
            path: [
                "replyTo"
            ] as const,
            name: "replyTo",
            constraints: {
                required: true
            },
            get: ()=>data.replyTo,
            set: (value: string | null)=>{
                data.replyTo = value;
            },
            transform: (value: string | null): string | null =>value,
            getError: ()=>errors.replyTo,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.replyTo = value;
            },
            getTainted: ()=>tainted.replyTo,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.replyTo = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = commentedValidateField("replyTo", data.replyTo);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        }
    } as CommentedFieldControllers;
    const __gf_getter_hint = "get data() set data(v) get errors() set errors(v) get tainted() set tainted(v)";
    const __gf_validate_hint = ".map((e: { field: string; message: string }) => e.message)";
    function validate(): Exit<Commented, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(commentedDeserialize(data));
    }
    function reset(newOverrides?: Partial<Commented>): void {
        data = {
            ...commentedDefaultValue(),
            ...newOverrides
        };
        errors = {
            _errors: optionNone(),
            comment: optionNone(),
            replyTo: optionNone()
        };
        tainted = {
            comment: optionNone(),
            replyTo: optionNone()
        };
    }
    return {
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        fields,
        validate,
        reset
    };
}
export function commentedFromFormData(formData: FormData): Exit<Commented, Array<{
    field: string;
    message: string;
}>> {
    const obj: Record<string, unknown> = {};
    const __gf_exit_hint = "Exit<Commented, Array<{ field: string; message: string }>>";
    obj.comment = formData.get(`${"comment"}`) ?? "";
    obj.replyTo = formData.get(`${"replyTo"}`) ?? "";
    return toExit(commentedDeserialize(obj));
}

export const Commented = {
  defaultValue: commentedDefaultValue,
  serialize: commentedSerialize,
  serializeWithContext: commentedSerializeWithContext,
  deserialize: commentedDeserialize,
  deserializeWithContext: commentedDeserializeWithContext,
  validateFields: commentedValidateFields,
  hasShape: commentedHasShape,
  is: commentedIs,
  createForm: commentedCreateForm,
  fromFormData: commentedFromFormData
} as const;


export interface Custom {
    mappings: Array<DirectionHue>;
}

export function customDefaultValue(): Custom {
    return {
        mappings: []
    } as Custom;
}

export function customSerialize(value: Custom): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(customSerializeWithContext(value, ctx));
}
export function customSerializeWithContext(value: Custom, ctx: __mf_SerializeContext): Record<string, unknown> {
    const existingId = ctx.getId(value);
    if (existingId !== undefined) {
        return {
            __ref: existingId
        };
    }
    const __id = ctx.register(value);
    const result: Record<string, unknown> = {
        __type: "Custom",
        __id
    };
    result.mappings = value.mappings.map((item)=>directionHueSerializeWithContext(item, ctx));
    return result;
}

export function customDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: Custom } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = customDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "Custom.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function customDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Custom | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
        throw new __mf_DeserializeError([
            {
                field: "_root",
                message: `${"Custom"}.deserializeWithContext: expected an object`
            }
        ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (!("mappings" in obj)) {
        errors.push({
            field: "mappings",
            message: "missing required field"
        });
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
        ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
        const __raw_mappings = obj["mappings"] as Array<DirectionHue>;
        if (Array.isArray(__raw_mappings)) {
            instance.mappings = __raw_mappings as DirectionHue[];
        }
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    return instance as Custom;
}
export function customValidateField<K extends keyof Custom>(_field: K, _value: Custom[K]): Array<{
    field: string;
    message: string;
}> {
    return [];
}
export function customValidateFields(_partial: Partial<Custom>): Array<{
    field: string;
    message: string;
}> {
    return [];
}
export function customHasShape(obj: unknown): boolean {
    if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
        return false;
    }
    const o = obj as Record<string, unknown>;
    return '"mappings" in o';
}
export function customIs(obj: unknown): obj is Custom {
    if (!customHasShape(obj)) {
        return false;
    }
    const result = customDeserialize(obj);
    return result.success;
}

export type CustomErrors = {
    _errors: __gf_Option<Array<string>>;
    mappings: __gf_Option<Array<string>>;
};
export type CustomTainted = {
    mappings: __gf_Option<boolean>;
};
export interface CustomFieldControllers {
    readonly mappings: ArrayFieldController<DirectionHue>;
}
export interface CustomGigaform {
    readonly data: Custom;
    readonly errors: CustomErrors;
    readonly tainted: CustomTainted;
    readonly fields: CustomFieldControllers;
    validate(): Exit<Custom, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<Custom>): void;
}
export function customCreateForm(overrides?: Partial<Custom>): CustomGigaform {
    let data = $state({
        ...customDefaultValue(),
        ...overrides
    });
    let errors = $state<CustomErrors>({
        _errors: optionNone(),
        mappings: optionNone()
    } as CustomErrors);
    let tainted = $state<CustomTainted>({
        mappings: optionNone()
    } as CustomTainted);
    const fields = {
        mappings: {
            path: [
                "mappings"
            ] as const,
            name: "mappings",
            constraints: {
                required: true
            },
            get: ()=>data.mappings,
            set: (value: Array<DirectionHue>)=>{
                data.mappings = value;
            },
            transform: (value: Array<DirectionHue>): Array<DirectionHue> =>value,
            getError: ()=>errors.mappings,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.mappings = value;
            },
            getTainted: ()=>tainted.mappings,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.mappings = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = customValidateField("mappings", data.mappings);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            },
            at: (index: number)=>({
                    path: [
                        "mappings",
                        index
                    ] as const,
                    name: "'^mappings.${index}^'",
                    constraints: {
                        required: true
                    },
                    get: ()=>data.mappings[index]!,
                    set: (value: DirectionHue)=>{
                        data.mappings[index] = value;
                    },
                    transform: (value: DirectionHue): DirectionHue =>value,
                    getError: ()=>errors.mappings,
                    setError: (value: __gf_Option<Array<string>>)=>{
                        errors.mappings = value;
                    },
                    getTainted: ()=>tainted.mappings,
                    setTainted: (value: __gf_Option<boolean>)=>{
                        tainted.mappings = value;
                    },
                    validate: (): Array<string> =>[]
                }),
            push: (item: DirectionHue)=>{
                data.mappings.push(item);
            },
            remove: (index: number)=>{
                data.mappings.splice(index, 1);
            },
            swap: (a: number, b: number)=>{
                const tmp = data.mappings[a]!;
                data.mappings[a] = data.mappings[b]!;
                data.mappings[b] = tmp;
            }
        }
    } as CustomFieldControllers;
    const __gf_getter_hint = "get data() set data(v) get errors() set errors(v) get tainted() set tainted(v)";
    const __gf_validate_hint = ".map((e: { field: string; message: string }) => e.message)";
    function validate(): Exit<Custom, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(customDeserialize(data));
    }
    function reset(newOverrides?: Partial<Custom>): void {
        data = {
            ...customDefaultValue(),
            ...newOverrides
        };
        errors = {
            _errors: optionNone(),
            mappings: optionNone()
        };
        tainted = {
            mappings: optionNone()
        };
    }
    return {
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        fields,
        validate,
        reset
    };
}
export function customFromFormData(formData: FormData): Exit<Custom, Array<{
    field: string;
    message: string;
}>> {
    const obj: Record<string, unknown> = {};
    const __gf_exit_hint = "Exit<Custom, Array<{ field: string; message: string }>>";
    {
        const mappingsItems: Array<Record<string, unknown>> = [];
        let idx = 0;
        while(formData.has(`${"mappings"}.` + idx + ".") || idx === 0){
            const hasAny = Array.from(formData.keys()).some((k)=>k.startsWith(`${"mappings"}.` + idx + "."));
            if (!hasAny && idx > 0) break;
            if (hasAny) {
                const item: Record<string, unknown> = {};
                for (const [key, value] of Array.from(formData.entries())){
                    if (key.startsWith(`${"mappings"}.` + idx + ".")) {
                        const fieldName = key.slice(`${"mappings"}.`.length + String(idx).length + 1);
                        item[fieldName] = value;
                    }
                }
                mappingsItems.push(item);
            }
            idx++;
            if (idx > 1000) break;
        }
        obj.mappings = mappingsItems;
    }
    return toExit(customDeserialize(obj));
}

export const Custom = {
  defaultValue: customDefaultValue,
  serialize: customSerialize,
  serializeWithContext: customSerializeWithContext,
  deserialize: customDeserialize,
  deserializeWithContext: customDeserializeWithContext,
  validateFields: customValidateFields,
  hasShape: customHasShape,
  is: customIs,
  createForm: customCreateForm,
  fromFormData: customFromFormData
} as const;


export interface Colors {
    
    main: string;
    
    hover: string;
    
    active: string;
}

export function colorsDefaultValue(): Colors {
    return {
        main: "",
        hover: "",
        active: ""
    } as Colors;
}

export function colorsSerialize(value: Colors): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(colorsSerializeWithContext(value, ctx));
}
export function colorsSerializeWithContext(value: Colors, ctx: __mf_SerializeContext): Record<string, unknown> {
    const existingId = ctx.getId(value);
    if (existingId !== undefined) {
        return {
            __ref: existingId
        };
    }
    const __id = ctx.register(value);
    const result: Record<string, unknown> = {
        __type: "Colors",
        __id
    };
    result.main = value.main;
    result.hover = value.hover;
    result.active = value.active;
    return result;
}

export function colorsDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: Colors } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = colorsDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "Colors.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function colorsDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Colors | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
        throw new __mf_DeserializeError([
            {
                field: "_root",
                message: `${"Colors"}.deserializeWithContext: expected an object`
            }
        ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (!("main" in obj)) {
        errors.push({
            field: "main",
            message: "missing required field"
        });
    }
    if (!("hover" in obj)) {
        errors.push({
            field: "hover",
            message: "missing required field"
        });
    }
    if (!("active" in obj)) {
        errors.push({
            field: "active",
            message: "missing required field"
        });
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
        ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
        const __raw_main = obj["main"] as string;
        if (__raw_main.trim().length === 0) {
            errors.push({
                field: "main",
                message: "Colors.main must not be empty"
            });
        }
        instance.main = __raw_main;
    }
    {
        const __raw_hover = obj["hover"] as string;
        if (__raw_hover.trim().length === 0) {
            errors.push({
                field: "hover",
                message: "Colors.hover must not be empty"
            });
        }
        instance.hover = __raw_hover;
    }
    {
        const __raw_active = obj["active"] as string;
        if (__raw_active.trim().length === 0) {
            errors.push({
                field: "active",
                message: "Colors.active must not be empty"
            });
        }
        instance.active = __raw_active;
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    return instance as Colors;
}
export function colorsValidateField<K extends keyof Colors>(_field: K, _value: Colors[K]): Array<{
    field: string;
    message: string;
}> {
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (_field === "main") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "main",
                message: "Colors.main must not be empty"
            });
        }
    }
    if (_field === "hover") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "hover",
                message: "Colors.hover must not be empty"
            });
        }
    }
    if (_field === "active") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "active",
                message: "Colors.active must not be empty"
            });
        }
    }
    return errors;
}
export function colorsValidateFields(_partial: Partial<Colors>): Array<{
    field: string;
    message: string;
}> {
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if ("main" in _partial && _partial.main !== undefined) {
        const __val = _partial.main as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "main",
                message: "Colors.main must not be empty"
            });
        }
    }
    if ("hover" in _partial && _partial.hover !== undefined) {
        const __val = _partial.hover as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "hover",
                message: "Colors.hover must not be empty"
            });
        }
    }
    if ("active" in _partial && _partial.active !== undefined) {
        const __val = _partial.active as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "active",
                message: "Colors.active must not be empty"
            });
        }
    }
    return errors;
}
export function colorsHasShape(obj: unknown): boolean {
    if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
        return false;
    }
    const o = obj as Record<string, unknown>;
    return '"main" in o && "hover" in o && "active" in o';
}
export function colorsIs(obj: unknown): obj is Colors {
    if (!colorsHasShape(obj)) {
        return false;
    }
    const result = colorsDeserialize(obj);
    return result.success;
}

export type ColorsErrors = {
    _errors: __gf_Option<Array<string>>;
    main: __gf_Option<Array<string>>;
    hover: __gf_Option<Array<string>>;
    active: __gf_Option<Array<string>>;
};
export type ColorsTainted = {
    main: __gf_Option<boolean>;
    hover: __gf_Option<boolean>;
    active: __gf_Option<boolean>;
};
export interface ColorsFieldControllers {
    readonly main: FieldController<string>;
    readonly hover: FieldController<string>;
    readonly active: FieldController<string>;
}
export interface ColorsGigaform {
    readonly data: Colors;
    readonly errors: ColorsErrors;
    readonly tainted: ColorsTainted;
    readonly fields: ColorsFieldControllers;
    validate(): Exit<Colors, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<Colors>): void;
}
export function colorsCreateForm(overrides?: Partial<Colors>): ColorsGigaform {
    let data = $state({
        ...colorsDefaultValue(),
        ...overrides
    });
    let errors = $state<ColorsErrors>({
        _errors: optionNone(),
        main: optionNone(),
        hover: optionNone(),
        active: optionNone()
    } as ColorsErrors);
    let tainted = $state<ColorsTainted>({
        main: optionNone(),
        hover: optionNone(),
        active: optionNone()
    } as ColorsTainted);
    const fields = {
        main: {
            path: [
                "main"
            ] as const,
            name: "main",
            constraints: {
                required: true
            },
            get: ()=>data.main,
            set: (value: string)=>{
                data.main = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.main,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.main = value;
            },
            getTainted: ()=>tainted.main,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.main = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = colorsValidateField("main", data.main);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        hover: {
            path: [
                "hover"
            ] as const,
            name: "hover",
            constraints: {
                required: true
            },
            get: ()=>data.hover,
            set: (value: string)=>{
                data.hover = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.hover,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.hover = value;
            },
            getTainted: ()=>tainted.hover,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.hover = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = colorsValidateField("hover", data.hover);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        active: {
            path: [
                "active"
            ] as const,
            name: "active",
            constraints: {
                required: true
            },
            get: ()=>data.active,
            set: (value: string)=>{
                data.active = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.active,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.active = value;
            },
            getTainted: ()=>tainted.active,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.active = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = colorsValidateField("active", data.active);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        }
    } as ColorsFieldControllers;
    const __gf_getter_hint = "get data() set data(v) get errors() set errors(v) get tainted() set tainted(v)";
    const __gf_validate_hint = ".map((e: { field: string; message: string }) => e.message)";
    function validate(): Exit<Colors, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(colorsDeserialize(data));
    }
    function reset(newOverrides?: Partial<Colors>): void {
        data = {
            ...colorsDefaultValue(),
            ...newOverrides
        };
        errors = {
            _errors: optionNone(),
            main: optionNone(),
            hover: optionNone(),
            active: optionNone()
        };
        tainted = {
            main: optionNone(),
            hover: optionNone(),
            active: optionNone()
        };
    }
    return {
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        fields,
        validate,
        reset
    };
}
export function colorsFromFormData(formData: FormData): Exit<Colors, Array<{
    field: string;
    message: string;
}>> {
    const obj: Record<string, unknown> = {};
    const __gf_exit_hint = "Exit<Colors, Array<{ field: string; message: string }>>";
    obj.main = formData.get(`${"main"}`) ?? "";
    obj.hover = formData.get(`${"hover"}`) ?? "";
    obj.active = formData.get(`${"active"}`) ?? "";
    return toExit(colorsDeserialize(obj));
}

export const Colors = {
  defaultValue: colorsDefaultValue,
  serialize: colorsSerialize,
  serializeWithContext: colorsSerializeWithContext,
  deserialize: colorsDeserialize,
  deserializeWithContext: colorsDeserializeWithContext,
  validateFields: colorsValidateFields,
  hasShape: colorsHasShape,
  is: colorsIs,
  createForm: colorsCreateForm,
  fromFormData: colorsFromFormData
} as const;


export interface ProductDefaults {
    
    price: number;
    
    
    description: string;
}

export function productDefaultsDefaultValue(): ProductDefaults {
    return {
        price: 0,
        description: ""
    } as ProductDefaults;
}

export function productDefaultsSerialize(value: ProductDefaults): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(productDefaultsSerializeWithContext(value, ctx));
}
export function productDefaultsSerializeWithContext(value: ProductDefaults, ctx: __mf_SerializeContext): Record<string, unknown> {
    const existingId = ctx.getId(value);
    if (existingId !== undefined) {
        return {
            __ref: existingId
        };
    }
    const __id = ctx.register(value);
    const result: Record<string, unknown> = {
        __type: "ProductDefaults",
        __id
    };
    result.price = value.price;
    result.description = value.description;
    return result;
}

export function productDefaultsDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: ProductDefaults } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = productDefaultsDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "ProductDefaults.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function productDefaultsDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): ProductDefaults | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
        throw new __mf_DeserializeError([
            {
                field: "_root",
                message: `${"ProductDefaults"}.deserializeWithContext: expected an object`
            }
        ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (!("price" in obj)) {
        errors.push({
            field: "price",
            message: "missing required field"
        });
    }
    if (!("description" in obj)) {
        errors.push({
            field: "description",
            message: "missing required field"
        });
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
        ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
        const __raw_price = obj["price"] as number;
        instance.price = __raw_price;
    }
    {
        const __raw_description = obj["description"] as string;
        if (__raw_description.trim().length === 0) {
            errors.push({
                field: "description",
                message: "ProductDefaults.description must not be empty"
            });
        }
        instance.description = __raw_description;
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    return instance as ProductDefaults;
}
export function productDefaultsValidateField<K extends keyof ProductDefaults>(_field: K, _value: ProductDefaults[K]): Array<{
    field: string;
    message: string;
}> {
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (_field === "description") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "description",
                message: "ProductDefaults.description must not be empty"
            });
        }
    }
    return errors;
}
export function productDefaultsValidateFields(_partial: Partial<ProductDefaults>): Array<{
    field: string;
    message: string;
}> {
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if ("description" in _partial && _partial.description !== undefined) {
        const __val = _partial.description as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "description",
                message: "ProductDefaults.description must not be empty"
            });
        }
    }
    return errors;
}
export function productDefaultsHasShape(obj: unknown): boolean {
    if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
        return false;
    }
    const o = obj as Record<string, unknown>;
    return '"price" in o && "description" in o';
}
export function productDefaultsIs(obj: unknown): obj is ProductDefaults {
    if (!productDefaultsHasShape(obj)) {
        return false;
    }
    const result = productDefaultsDeserialize(obj);
    return result.success;
}

export type ProductDefaultsErrors = {
    _errors: __gf_Option<Array<string>>;
    price: __gf_Option<Array<string>>;
    description: __gf_Option<Array<string>>;
};
export type ProductDefaultsTainted = {
    price: __gf_Option<boolean>;
    description: __gf_Option<boolean>;
};
export interface ProductDefaultsFieldControllers {
    readonly price: FieldController<number>;
    readonly description: FieldController<string>;
}
export interface ProductDefaultsGigaform {
    readonly data: ProductDefaults;
    readonly errors: ProductDefaultsErrors;
    readonly tainted: ProductDefaultsTainted;
    readonly fields: ProductDefaultsFieldControllers;
    validate(): Exit<ProductDefaults, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<ProductDefaults>): void;
}
export function productDefaultsCreateForm(overrides?: Partial<ProductDefaults>): ProductDefaultsGigaform {
    let data = $state({
        ...productDefaultsDefaultValue(),
        ...overrides
    });
    let errors = $state<ProductDefaultsErrors>({
        _errors: optionNone(),
        price: optionNone(),
        description: optionNone()
    } as ProductDefaultsErrors);
    let tainted = $state<ProductDefaultsTainted>({
        price: optionNone(),
        description: optionNone()
    } as ProductDefaultsTainted);
    const fields = {
        price: {
            path: [
                "price"
            ] as const,
            name: "price",
            constraints: {
                required: true
            },
            label: "Price",
            get: ()=>data.price,
            set: (value: number)=>{
                data.price = value;
            },
            transform: (value: number): number =>value,
            getError: ()=>errors.price,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.price = value;
            },
            getTainted: ()=>tainted.price,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.price = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = productDefaultsValidateField("price", data.price);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        description: {
            path: [
                "description"
            ] as const,
            name: "description",
            constraints: {
                required: true
            },
            label: "Description",
            get: ()=>data.description,
            set: (value: string)=>{
                data.description = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.description,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.description = value;
            },
            getTainted: ()=>tainted.description,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.description = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = productDefaultsValidateField("description", data.description);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        }
    } as ProductDefaultsFieldControllers;
    const __gf_getter_hint = "get data() set data(v) get errors() set errors(v) get tainted() set tainted(v)";
    const __gf_validate_hint = ".map((e: { field: string; message: string }) => e.message)";
    function validate(): Exit<ProductDefaults, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(productDefaultsDeserialize(data));
    }
    function reset(newOverrides?: Partial<ProductDefaults>): void {
        data = {
            ...productDefaultsDefaultValue(),
            ...newOverrides
        };
        errors = {
            _errors: optionNone(),
            price: optionNone(),
            description: optionNone()
        };
        tainted = {
            price: optionNone(),
            description: optionNone()
        };
    }
    return {
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        fields,
        validate,
        reset
    };
}
export function productDefaultsFromFormData(formData: FormData): Exit<ProductDefaults, Array<{
    field: string;
    message: string;
}>> {
    const obj: Record<string, unknown> = {};
    const __gf_exit_hint = "Exit<ProductDefaults, Array<{ field: string; message: string }>>";
    {
        const priceStr = formData.get(`${"price"}`);
        obj.price = priceStr ? parseFloat(priceStr as string) : $MfPh5;
        if (obj.price !== undefined && isNaN(obj.price as number)) obj.price = "0";
    }
    obj.description = formData.get(`${"description"}`) ?? "";
    return toExit(productDefaultsDeserialize(obj));
}

export const ProductDefaults = {
  defaultValue: productDefaultsDefaultValue,
  serialize: productDefaultsSerialize,
  serializeWithContext: productDefaultsSerializeWithContext,
  deserialize: productDefaultsDeserialize,
  deserializeWithContext: productDefaultsDeserializeWithContext,
  validateFields: productDefaultsValidateFields,
  hasShape: productDefaultsHasShape,
  is: productDefaultsIs,
  createForm: productDefaultsCreateForm,
  fromFormData: productDefaultsFromFormData
} as const;


export interface Viewed {
    durationSeconds: number | null;
    source: string | null;
}

export function viewedDefaultValue(): Viewed {
    return {
        durationSeconds: null,
        source: null
    } as Viewed;
}

export function viewedSerialize(value: Viewed): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(viewedSerializeWithContext(value, ctx));
}
export function viewedSerializeWithContext(value: Viewed, ctx: __mf_SerializeContext): Record<string, unknown> {
    const existingId = ctx.getId(value);
    if (existingId !== undefined) {
        return {
            __ref: existingId
        };
    }
    const __id = ctx.register(value);
    const result: Record<string, unknown> = {
        __type: "Viewed",
        __id
    };
    result.durationSeconds = value.durationSeconds;
    result.source = value.source;
    return result;
}

export function viewedDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: Viewed } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = viewedDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "Viewed.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function viewedDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Viewed | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
        throw new __mf_DeserializeError([
            {
                field: "_root",
                message: `${"Viewed"}.deserializeWithContext: expected an object`
            }
        ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (!("durationSeconds" in obj)) {
        errors.push({
            field: "durationSeconds",
            message: "missing required field"
        });
    }
    if (!("source" in obj)) {
        errors.push({
            field: "source",
            message: "missing required field"
        });
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
        ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
        const __raw_durationSeconds = obj["durationSeconds"] as number | null;
        instance.durationSeconds = __raw_durationSeconds;
    }
    {
        const __raw_source = obj["source"] as string | null;
        instance.source = __raw_source;
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    return instance as Viewed;
}
export function viewedValidateField<K extends keyof Viewed>(_field: K, _value: Viewed[K]): Array<{
    field: string;
    message: string;
}> {
    return [];
}
export function viewedValidateFields(_partial: Partial<Viewed>): Array<{
    field: string;
    message: string;
}> {
    return [];
}
export function viewedHasShape(obj: unknown): boolean {
    if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
        return false;
    }
    const o = obj as Record<string, unknown>;
    return '"durationSeconds" in o && "source" in o';
}
export function viewedIs(obj: unknown): obj is Viewed {
    if (!viewedHasShape(obj)) {
        return false;
    }
    const result = viewedDeserialize(obj);
    return result.success;
}

export type ViewedErrors = {
    _errors: __gf_Option<Array<string>>;
    durationSeconds: __gf_Option<Array<string>>;
    source: __gf_Option<Array<string>>;
};
export type ViewedTainted = {
    durationSeconds: __gf_Option<boolean>;
    source: __gf_Option<boolean>;
};
export interface ViewedFieldControllers {
    readonly durationSeconds: FieldController<number | null>;
    readonly source: FieldController<string | null>;
}
export interface ViewedGigaform {
    readonly data: Viewed;
    readonly errors: ViewedErrors;
    readonly tainted: ViewedTainted;
    readonly fields: ViewedFieldControllers;
    validate(): Exit<Viewed, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<Viewed>): void;
}
export function viewedCreateForm(overrides?: Partial<Viewed>): ViewedGigaform {
    let data = $state({
        ...viewedDefaultValue(),
        ...overrides
    });
    let errors = $state<ViewedErrors>({
        _errors: optionNone(),
        durationSeconds: optionNone(),
        source: optionNone()
    } as ViewedErrors);
    let tainted = $state<ViewedTainted>({
        durationSeconds: optionNone(),
        source: optionNone()
    } as ViewedTainted);
    const fields = {
        durationSeconds: {
            path: [
                "durationSeconds"
            ] as const,
            name: "durationSeconds",
            constraints: {
                required: true
            },
            get: ()=>data.durationSeconds,
            set: (value: number | null)=>{
                data.durationSeconds = value;
            },
            transform: (value: number | null): number | null =>value,
            getError: ()=>errors.durationSeconds,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.durationSeconds = value;
            },
            getTainted: ()=>tainted.durationSeconds,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.durationSeconds = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = viewedValidateField("durationSeconds", data.durationSeconds);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        source: {
            path: [
                "source"
            ] as const,
            name: "source",
            constraints: {
                required: true
            },
            get: ()=>data.source,
            set: (value: string | null)=>{
                data.source = value;
            },
            transform: (value: string | null): string | null =>value,
            getError: ()=>errors.source,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.source = value;
            },
            getTainted: ()=>tainted.source,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.source = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = viewedValidateField("source", data.source);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        }
    } as ViewedFieldControllers;
    const __gf_getter_hint = "get data() set data(v) get errors() set errors(v) get tainted() set tainted(v)";
    const __gf_validate_hint = ".map((e: { field: string; message: string }) => e.message)";
    function validate(): Exit<Viewed, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(viewedDeserialize(data));
    }
    function reset(newOverrides?: Partial<Viewed>): void {
        data = {
            ...viewedDefaultValue(),
            ...newOverrides
        };
        errors = {
            _errors: optionNone(),
            durationSeconds: optionNone(),
            source: optionNone()
        };
        tainted = {
            durationSeconds: optionNone(),
            source: optionNone()
        };
    }
    return {
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        fields,
        validate,
        reset
    };
}
export function viewedFromFormData(formData: FormData): Exit<Viewed, Array<{
    field: string;
    message: string;
}>> {
    const obj: Record<string, unknown> = {};
    const __gf_exit_hint = "Exit<Viewed, Array<{ field: string; message: string }>>";
    {
        const durationSecondsStr = formData.get(`${"durationSeconds"}`);
        obj.durationSeconds = durationSecondsStr ? parseFloat(durationSecondsStr as string) : $MfPh5;
        if (obj.durationSeconds !== undefined && isNaN(obj.durationSeconds as number)) obj.durationSeconds = "0";
    }
    obj.source = formData.get(`${"source"}`) ?? "";
    return toExit(viewedDeserialize(obj));
}

export const Viewed = {
  defaultValue: viewedDefaultValue,
  serialize: viewedSerialize,
  serializeWithContext: viewedSerializeWithContext,
  deserialize: viewedDeserialize,
  deserializeWithContext: viewedDeserializeWithContext,
  validateFields: viewedValidateFields,
  hasShape: viewedHasShape,
  is: viewedIs,
  createForm: viewedCreateForm,
  fromFormData: viewedFromFormData
} as const;


export interface WeeklyRecurrenceRule {
    quantityOfWeeks: number;
    weekdays: Array<Weekday>;
}

export function weeklyRecurrenceRuleDefaultValue(): WeeklyRecurrenceRule {
    return {
        quantityOfWeeks: 0,
        weekdays: []
    } as WeeklyRecurrenceRule;
}

export function weeklyRecurrenceRuleSerialize(value: WeeklyRecurrenceRule): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(weeklyRecurrenceRuleSerializeWithContext(value, ctx));
}
export function weeklyRecurrenceRuleSerializeWithContext(value: WeeklyRecurrenceRule, ctx: __mf_SerializeContext): Record<string, unknown> {
    const existingId = ctx.getId(value);
    if (existingId !== undefined) {
        return {
            __ref: existingId
        };
    }
    const __id = ctx.register(value);
    const result: Record<string, unknown> = {
        __type: "WeeklyRecurrenceRule",
        __id
    };
    result.quantityOfWeeks = value.quantityOfWeeks;
    result.weekdays = value.weekdays.map((item)=>weekdaySerializeWithContext(item, ctx));
    return result;
}

export function weeklyRecurrenceRuleDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: WeeklyRecurrenceRule } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = weeklyRecurrenceRuleDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "WeeklyRecurrenceRule.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function weeklyRecurrenceRuleDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): WeeklyRecurrenceRule | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
        throw new __mf_DeserializeError([
            {
                field: "_root",
                message: `${"WeeklyRecurrenceRule"}.deserializeWithContext: expected an object`
            }
        ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (!("quantityOfWeeks" in obj)) {
        errors.push({
            field: "quantityOfWeeks",
            message: "missing required field"
        });
    }
    if (!("weekdays" in obj)) {
        errors.push({
            field: "weekdays",
            message: "missing required field"
        });
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
        ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
        const __raw_quantityOfWeeks = obj["quantityOfWeeks"] as number;
        instance.quantityOfWeeks = __raw_quantityOfWeeks;
    }
    {
        const __raw_weekdays = obj["weekdays"] as Array<Weekday>;
        if (Array.isArray(__raw_weekdays)) {
            instance.weekdays = __raw_weekdays as Weekday[];
        }
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    return instance as WeeklyRecurrenceRule;
}
export function weeklyRecurrenceRuleValidateField<K extends keyof WeeklyRecurrenceRule>(_field: K, _value: WeeklyRecurrenceRule[K]): Array<{
    field: string;
    message: string;
}> {
    return [];
}
export function weeklyRecurrenceRuleValidateFields(_partial: Partial<WeeklyRecurrenceRule>): Array<{
    field: string;
    message: string;
}> {
    return [];
}
export function weeklyRecurrenceRuleHasShape(obj: unknown): boolean {
    if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
        return false;
    }
    const o = obj as Record<string, unknown>;
    return '"quantityOfWeeks" in o && "weekdays" in o';
}
export function weeklyRecurrenceRuleIs(obj: unknown): obj is WeeklyRecurrenceRule {
    if (!weeklyRecurrenceRuleHasShape(obj)) {
        return false;
    }
    const result = weeklyRecurrenceRuleDeserialize(obj);
    return result.success;
}

export type WeeklyRecurrenceRuleErrors = {
    _errors: __gf_Option<Array<string>>;
    quantityOfWeeks: __gf_Option<Array<string>>;
    weekdays: __gf_Option<Array<string>>;
};
export type WeeklyRecurrenceRuleTainted = {
    quantityOfWeeks: __gf_Option<boolean>;
    weekdays: __gf_Option<boolean>;
};
export interface WeeklyRecurrenceRuleFieldControllers {
    readonly quantityOfWeeks: FieldController<number>;
    readonly weekdays: ArrayFieldController<Weekday>;
}
export interface WeeklyRecurrenceRuleGigaform {
    readonly data: WeeklyRecurrenceRule;
    readonly errors: WeeklyRecurrenceRuleErrors;
    readonly tainted: WeeklyRecurrenceRuleTainted;
    readonly fields: WeeklyRecurrenceRuleFieldControllers;
    validate(): Exit<WeeklyRecurrenceRule, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<WeeklyRecurrenceRule>): void;
}
export function weeklyRecurrenceRuleCreateForm(overrides?: Partial<WeeklyRecurrenceRule>): WeeklyRecurrenceRuleGigaform {
    let data = $state({
        ...weeklyRecurrenceRuleDefaultValue(),
        ...overrides
    });
    let errors = $state<WeeklyRecurrenceRuleErrors>({
        _errors: optionNone(),
        quantityOfWeeks: optionNone(),
        weekdays: optionNone()
    } as WeeklyRecurrenceRuleErrors);
    let tainted = $state<WeeklyRecurrenceRuleTainted>({
        quantityOfWeeks: optionNone(),
        weekdays: optionNone()
    } as WeeklyRecurrenceRuleTainted);
    const fields = {
        quantityOfWeeks: {
            path: [
                "quantityOfWeeks"
            ] as const,
            name: "quantityOfWeeks",
            constraints: {
                required: true
            },
            get: ()=>data.quantityOfWeeks,
            set: (value: number)=>{
                data.quantityOfWeeks = value;
            },
            transform: (value: number): number =>value,
            getError: ()=>errors.quantityOfWeeks,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.quantityOfWeeks = value;
            },
            getTainted: ()=>tainted.quantityOfWeeks,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.quantityOfWeeks = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = weeklyRecurrenceRuleValidateField("quantityOfWeeks", data.quantityOfWeeks);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        weekdays: {
            path: [
                "weekdays"
            ] as const,
            name: "weekdays",
            constraints: {
                required: true
            },
            get: ()=>data.weekdays,
            set: (value: Array<Weekday>)=>{
                data.weekdays = value;
            },
            transform: (value: Array<Weekday>): Array<Weekday> =>value,
            getError: ()=>errors.weekdays,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.weekdays = value;
            },
            getTainted: ()=>tainted.weekdays,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.weekdays = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = weeklyRecurrenceRuleValidateField("weekdays", data.weekdays);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            },
            at: (index: number)=>({
                    path: [
                        "weekdays",
                        index
                    ] as const,
                    name: "'^weekdays.${index}^'",
                    constraints: {
                        required: true
                    },
                    get: ()=>data.weekdays[index]!,
                    set: (value: Weekday)=>{
                        data.weekdays[index] = value;
                    },
                    transform: (value: Weekday): Weekday =>value,
                    getError: ()=>errors.weekdays,
                    setError: (value: __gf_Option<Array<string>>)=>{
                        errors.weekdays = value;
                    },
                    getTainted: ()=>tainted.weekdays,
                    setTainted: (value: __gf_Option<boolean>)=>{
                        tainted.weekdays = value;
                    },
                    validate: (): Array<string> =>[]
                }),
            push: (item: Weekday)=>{
                data.weekdays.push(item);
            },
            remove: (index: number)=>{
                data.weekdays.splice(index, 1);
            },
            swap: (a: number, b: number)=>{
                const tmp = data.weekdays[a]!;
                data.weekdays[a] = data.weekdays[b]!;
                data.weekdays[b] = tmp;
            }
        }
    } as WeeklyRecurrenceRuleFieldControllers;
    const __gf_getter_hint = "get data() set data(v) get errors() set errors(v) get tainted() set tainted(v)";
    const __gf_validate_hint = ".map((e: { field: string; message: string }) => e.message)";
    function validate(): Exit<WeeklyRecurrenceRule, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(weeklyRecurrenceRuleDeserialize(data));
    }
    function reset(newOverrides?: Partial<WeeklyRecurrenceRule>): void {
        data = {
            ...weeklyRecurrenceRuleDefaultValue(),
            ...newOverrides
        };
        errors = {
            _errors: optionNone(),
            quantityOfWeeks: optionNone(),
            weekdays: optionNone()
        };
        tainted = {
            quantityOfWeeks: optionNone(),
            weekdays: optionNone()
        };
    }
    return {
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        fields,
        validate,
        reset
    };
}
export function weeklyRecurrenceRuleFromFormData(formData: FormData): Exit<WeeklyRecurrenceRule, Array<{
    field: string;
    message: string;
}>> {
    const obj: Record<string, unknown> = {};
    const __gf_exit_hint = "Exit<WeeklyRecurrenceRule, Array<{ field: string; message: string }>>";
    {
        const quantityOfWeeksStr = formData.get(`${"quantityOfWeeks"}`);
        obj.quantityOfWeeks = quantityOfWeeksStr ? parseFloat(quantityOfWeeksStr as string) : $MfPh5;
        if (obj.quantityOfWeeks !== undefined && isNaN(obj.quantityOfWeeks as number)) obj.quantityOfWeeks = "0";
    }
    {
        const weekdaysItems: Array<Record<string, unknown>> = [];
        let idx = 0;
        while(formData.has(`${"weekdays"}.` + idx + ".") || idx === 0){
            const hasAny = Array.from(formData.keys()).some((k)=>k.startsWith(`${"weekdays"}.` + idx + "."));
            if (!hasAny && idx > 0) break;
            if (hasAny) {
                const item: Record<string, unknown> = {};
                for (const [key, value] of Array.from(formData.entries())){
                    if (key.startsWith(`${"weekdays"}.` + idx + ".")) {
                        const fieldName = key.slice(`${"weekdays"}.`.length + String(idx).length + 1);
                        item[fieldName] = value;
                    }
                }
                weekdaysItems.push(item);
            }
            idx++;
            if (idx > 1000) break;
        }
        obj.weekdays = weekdaysItems;
    }
    return toExit(weeklyRecurrenceRuleDeserialize(obj));
}

export const WeeklyRecurrenceRule = {
  defaultValue: weeklyRecurrenceRuleDefaultValue,
  serialize: weeklyRecurrenceRuleSerialize,
  serializeWithContext: weeklyRecurrenceRuleSerializeWithContext,
  deserialize: weeklyRecurrenceRuleDeserialize,
  deserializeWithContext: weeklyRecurrenceRuleDeserializeWithContext,
  validateFields: weeklyRecurrenceRuleValidateFields,
  hasShape: weeklyRecurrenceRuleHasShape,
  is: weeklyRecurrenceRuleIs,
  createForm: weeklyRecurrenceRuleCreateForm,
  fromFormData: weeklyRecurrenceRuleFromFormData
} as const;


export interface Paid {
    amount: number | null;
    currency: string | null;
    paymentMethod: string | null;
}

export function paidDefaultValue(): Paid {
    return {
        amount: null,
        currency: null,
        paymentMethod: null
    } as Paid;
}

export function paidSerialize(value: Paid): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(paidSerializeWithContext(value, ctx));
}
export function paidSerializeWithContext(value: Paid, ctx: __mf_SerializeContext): Record<string, unknown> {
    const existingId = ctx.getId(value);
    if (existingId !== undefined) {
        return {
            __ref: existingId
        };
    }
    const __id = ctx.register(value);
    const result: Record<string, unknown> = {
        __type: "Paid",
        __id
    };
    result.amount = value.amount;
    result.currency = value.currency;
    result.paymentMethod = value.paymentMethod;
    return result;
}

export function paidDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: Paid } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = paidDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "Paid.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function paidDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Paid | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
        throw new __mf_DeserializeError([
            {
                field: "_root",
                message: `${"Paid"}.deserializeWithContext: expected an object`
            }
        ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (!("amount" in obj)) {
        errors.push({
            field: "amount",
            message: "missing required field"
        });
    }
    if (!("currency" in obj)) {
        errors.push({
            field: "currency",
            message: "missing required field"
        });
    }
    if (!("paymentMethod" in obj)) {
        errors.push({
            field: "paymentMethod",
            message: "missing required field"
        });
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
        ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
        const __raw_amount = obj["amount"] as number | null;
        instance.amount = __raw_amount;
    }
    {
        const __raw_currency = obj["currency"] as string | null;
        instance.currency = __raw_currency;
    }
    {
        const __raw_paymentMethod = obj["paymentMethod"] as string | null;
        instance.paymentMethod = __raw_paymentMethod;
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    return instance as Paid;
}
export function paidValidateField<K extends keyof Paid>(_field: K, _value: Paid[K]): Array<{
    field: string;
    message: string;
}> {
    return [];
}
export function paidValidateFields(_partial: Partial<Paid>): Array<{
    field: string;
    message: string;
}> {
    return [];
}
export function paidHasShape(obj: unknown): boolean {
    if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
        return false;
    }
    const o = obj as Record<string, unknown>;
    return '"amount" in o && "currency" in o && "paymentMethod" in o';
}
export function paidIs(obj: unknown): obj is Paid {
    if (!paidHasShape(obj)) {
        return false;
    }
    const result = paidDeserialize(obj);
    return result.success;
}

export type PaidErrors = {
    _errors: __gf_Option<Array<string>>;
    amount: __gf_Option<Array<string>>;
    currency: __gf_Option<Array<string>>;
    paymentMethod: __gf_Option<Array<string>>;
};
export type PaidTainted = {
    amount: __gf_Option<boolean>;
    currency: __gf_Option<boolean>;
    paymentMethod: __gf_Option<boolean>;
};
export interface PaidFieldControllers {
    readonly amount: FieldController<number | null>;
    readonly currency: FieldController<string | null>;
    readonly paymentMethod: FieldController<string | null>;
}
export interface PaidGigaform {
    readonly data: Paid;
    readonly errors: PaidErrors;
    readonly tainted: PaidTainted;
    readonly fields: PaidFieldControllers;
    validate(): Exit<Paid, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<Paid>): void;
}
export function paidCreateForm(overrides?: Partial<Paid>): PaidGigaform {
    let data = $state({
        ...paidDefaultValue(),
        ...overrides
    });
    let errors = $state<PaidErrors>({
        _errors: optionNone(),
        amount: optionNone(),
        currency: optionNone(),
        paymentMethod: optionNone()
    } as PaidErrors);
    let tainted = $state<PaidTainted>({
        amount: optionNone(),
        currency: optionNone(),
        paymentMethod: optionNone()
    } as PaidTainted);
    const fields = {
        amount: {
            path: [
                "amount"
            ] as const,
            name: "amount",
            constraints: {
                required: true
            },
            get: ()=>data.amount,
            set: (value: number | null)=>{
                data.amount = value;
            },
            transform: (value: number | null): number | null =>value,
            getError: ()=>errors.amount,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.amount = value;
            },
            getTainted: ()=>tainted.amount,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.amount = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = paidValidateField("amount", data.amount);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        currency: {
            path: [
                "currency"
            ] as const,
            name: "currency",
            constraints: {
                required: true
            },
            get: ()=>data.currency,
            set: (value: string | null)=>{
                data.currency = value;
            },
            transform: (value: string | null): string | null =>value,
            getError: ()=>errors.currency,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.currency = value;
            },
            getTainted: ()=>tainted.currency,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.currency = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = paidValidateField("currency", data.currency);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        paymentMethod: {
            path: [
                "paymentMethod"
            ] as const,
            name: "paymentMethod",
            constraints: {
                required: true
            },
            get: ()=>data.paymentMethod,
            set: (value: string | null)=>{
                data.paymentMethod = value;
            },
            transform: (value: string | null): string | null =>value,
            getError: ()=>errors.paymentMethod,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.paymentMethod = value;
            },
            getTainted: ()=>tainted.paymentMethod,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.paymentMethod = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = paidValidateField("paymentMethod", data.paymentMethod);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        }
    } as PaidFieldControllers;
    const __gf_getter_hint = "get data() set data(v) get errors() set errors(v) get tainted() set tainted(v)";
    const __gf_validate_hint = ".map((e: { field: string; message: string }) => e.message)";
    function validate(): Exit<Paid, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(paidDeserialize(data));
    }
    function reset(newOverrides?: Partial<Paid>): void {
        data = {
            ...paidDefaultValue(),
            ...newOverrides
        };
        errors = {
            _errors: optionNone(),
            amount: optionNone(),
            currency: optionNone(),
            paymentMethod: optionNone()
        };
        tainted = {
            amount: optionNone(),
            currency: optionNone(),
            paymentMethod: optionNone()
        };
    }
    return {
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        fields,
        validate,
        reset
    };
}
export function paidFromFormData(formData: FormData): Exit<Paid, Array<{
    field: string;
    message: string;
}>> {
    const obj: Record<string, unknown> = {};
    const __gf_exit_hint = "Exit<Paid, Array<{ field: string; message: string }>>";
    {
        const amountStr = formData.get(`${"amount"}`);
        obj.amount = amountStr ? parseFloat(amountStr as string) : $MfPh5;
        if (obj.amount !== undefined && isNaN(obj.amount as number)) obj.amount = "0";
    }
    obj.currency = formData.get(`${"currency"}`) ?? "";
    obj.paymentMethod = formData.get(`${"paymentMethod"}`) ?? "";
    return toExit(paidDeserialize(obj));
}

export const Paid = {
  defaultValue: paidDefaultValue,
  serialize: paidSerialize,
  serializeWithContext: paidSerializeWithContext,
  deserialize: paidDeserialize,
  deserializeWithContext: paidDeserializeWithContext,
  validateFields: paidValidateFields,
  hasShape: paidHasShape,
  is: paidIs,
  createForm: paidCreateForm,
  fromFormData: paidFromFormData
} as const;


export interface TaxRate {
    
    id: string;
    
    
    name: string;
    
    
    taxAgency: string;
    
    zip: number;
    
    
    city: string;
    
    
    county: string;
    
    
    state: string;
    
    isActive: boolean;
    
    
    description: string;
    
    
    taxComponents: { [key: string]: number };
}

export function taxRateDefaultValue(): TaxRate {
    return {
        id: "",
        name: "",
        taxAgency: "",
        zip: 0,
        city: "",
        county: "",
        state: "",
        isActive: false,
        description: "",
        taxComponents: {}
    } as TaxRate;
}

export function taxRateSerialize(value: TaxRate): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(taxRateSerializeWithContext(value, ctx));
}
export function taxRateSerializeWithContext(value: TaxRate, ctx: __mf_SerializeContext): Record<string, unknown> {
    const existingId = ctx.getId(value);
    if (existingId !== undefined) {
        return {
            __ref: existingId
        };
    }
    const __id = ctx.register(value);
    const result: Record<string, unknown> = {
        __type: "TaxRate",
        __id
    };
    result.id = value.id;
    result.name = value.name;
    result.taxAgency = value.taxAgency;
    result.zip = value.zip;
    result.city = value.city;
    result.county = value.county;
    result.state = value.state;
    result.isActive = value.isActive;
    result.description = value.description;
    result.taxComponents = value.taxComponents;
    return result;
}

export function taxRateDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: TaxRate } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = taxRateDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "TaxRate.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function taxRateDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): TaxRate | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
        throw new __mf_DeserializeError([
            {
                field: "_root",
                message: `${"TaxRate"}.deserializeWithContext: expected an object`
            }
        ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (!("id" in obj)) {
        errors.push({
            field: "id",
            message: "missing required field"
        });
    }
    if (!("name" in obj)) {
        errors.push({
            field: "name",
            message: "missing required field"
        });
    }
    if (!("taxAgency" in obj)) {
        errors.push({
            field: "taxAgency",
            message: "missing required field"
        });
    }
    if (!("zip" in obj)) {
        errors.push({
            field: "zip",
            message: "missing required field"
        });
    }
    if (!("city" in obj)) {
        errors.push({
            field: "city",
            message: "missing required field"
        });
    }
    if (!("county" in obj)) {
        errors.push({
            field: "county",
            message: "missing required field"
        });
    }
    if (!("state" in obj)) {
        errors.push({
            field: "state",
            message: "missing required field"
        });
    }
    if (!("isActive" in obj)) {
        errors.push({
            field: "isActive",
            message: "missing required field"
        });
    }
    if (!("description" in obj)) {
        errors.push({
            field: "description",
            message: "missing required field"
        });
    }
    if (!("taxComponents" in obj)) {
        errors.push({
            field: "taxComponents",
            message: "missing required field"
        });
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
        ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
        const __raw_id = obj["id"] as string;
        instance.id = __raw_id;
    }
    {
        const __raw_name = obj["name"] as string;
        if (__raw_name.trim().length === 0) {
            errors.push({
                field: "name",
                message: "TaxRate.name must not be empty"
            });
        }
        instance.name = __raw_name;
    }
    {
        const __raw_taxAgency = obj["taxAgency"] as string;
        if (__raw_taxAgency.trim().length === 0) {
            errors.push({
                field: "taxAgency",
                message: "TaxRate.taxAgency must not be empty"
            });
        }
        instance.taxAgency = __raw_taxAgency;
    }
    {
        const __raw_zip = obj["zip"] as number;
        instance.zip = __raw_zip;
    }
    {
        const __raw_city = obj["city"] as string;
        if (__raw_city.trim().length === 0) {
            errors.push({
                field: "city",
                message: "TaxRate.city must not be empty"
            });
        }
        instance.city = __raw_city;
    }
    {
        const __raw_county = obj["county"] as string;
        if (__raw_county.trim().length === 0) {
            errors.push({
                field: "county",
                message: "TaxRate.county must not be empty"
            });
        }
        instance.county = __raw_county;
    }
    {
        const __raw_state = obj["state"] as string;
        if (__raw_state.trim().length === 0) {
            errors.push({
                field: "state",
                message: "TaxRate.state must not be empty"
            });
        }
        instance.state = __raw_state;
    }
    {
        const __raw_isActive = obj["isActive"] as boolean;
        instance.isActive = __raw_isActive;
    }
    {
        const __raw_description = obj["description"] as string;
        if (__raw_description.trim().length === 0) {
            errors.push({
                field: "description",
                message: "TaxRate.description must not be empty"
            });
        }
        instance.description = __raw_description;
    }
    {
        const __raw_taxComponents = obj["taxComponents"] as { [key: string]: number };
        instance.taxComponents = __raw_taxComponents;
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    return instance as TaxRate;
}
export function taxRateValidateField<K extends keyof TaxRate>(_field: K, _value: TaxRate[K]): Array<{
    field: string;
    message: string;
}> {
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (_field === "name") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "name",
                message: "TaxRate.name must not be empty"
            });
        }
    }
    if (_field === "taxAgency") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "taxAgency",
                message: "TaxRate.taxAgency must not be empty"
            });
        }
    }
    if (_field === "city") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "city",
                message: "TaxRate.city must not be empty"
            });
        }
    }
    if (_field === "county") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "county",
                message: "TaxRate.county must not be empty"
            });
        }
    }
    if (_field === "state") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "state",
                message: "TaxRate.state must not be empty"
            });
        }
    }
    if (_field === "description") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "description",
                message: "TaxRate.description must not be empty"
            });
        }
    }
    return errors;
}
export function taxRateValidateFields(_partial: Partial<TaxRate>): Array<{
    field: string;
    message: string;
}> {
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if ("name" in _partial && _partial.name !== undefined) {
        const __val = _partial.name as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "name",
                message: "TaxRate.name must not be empty"
            });
        }
    }
    if ("taxAgency" in _partial && _partial.taxAgency !== undefined) {
        const __val = _partial.taxAgency as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "taxAgency",
                message: "TaxRate.taxAgency must not be empty"
            });
        }
    }
    if ("city" in _partial && _partial.city !== undefined) {
        const __val = _partial.city as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "city",
                message: "TaxRate.city must not be empty"
            });
        }
    }
    if ("county" in _partial && _partial.county !== undefined) {
        const __val = _partial.county as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "county",
                message: "TaxRate.county must not be empty"
            });
        }
    }
    if ("state" in _partial && _partial.state !== undefined) {
        const __val = _partial.state as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "state",
                message: "TaxRate.state must not be empty"
            });
        }
    }
    if ("description" in _partial && _partial.description !== undefined) {
        const __val = _partial.description as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "description",
                message: "TaxRate.description must not be empty"
            });
        }
    }
    return errors;
}
export function taxRateHasShape(obj: unknown): boolean {
    if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
        return false;
    }
    const o = obj as Record<string, unknown>;
    return '"id" in o && "name" in o && "taxAgency" in o && "zip" in o && "city" in o && "county" in o && "state" in o && "isActive" in o && "description" in o && "taxComponents" in o';
}
export function taxRateIs(obj: unknown): obj is TaxRate {
    if (!taxRateHasShape(obj)) {
        return false;
    }
    const result = taxRateDeserialize(obj);
    return result.success;
}

export type TaxRateErrors = {
    _errors: __gf_Option<Array<string>>;
    id: __gf_Option<Array<string>>;
    name: __gf_Option<Array<string>>;
    taxAgency: __gf_Option<Array<string>>;
    zip: __gf_Option<Array<string>>;
    city: __gf_Option<Array<string>>;
    county: __gf_Option<Array<string>>;
    state: __gf_Option<Array<string>>;
    isActive: __gf_Option<Array<string>>;
    description: __gf_Option<Array<string>>;
    taxComponents: __gf_Option<Array<string>>;
};
export type TaxRateTainted = {
    id: __gf_Option<boolean>;
    name: __gf_Option<boolean>;
    taxAgency: __gf_Option<boolean>;
    zip: __gf_Option<boolean>;
    city: __gf_Option<boolean>;
    county: __gf_Option<boolean>;
    state: __gf_Option<boolean>;
    isActive: __gf_Option<boolean>;
    description: __gf_Option<boolean>;
    taxComponents: __gf_Option<boolean>;
};
export interface TaxRateFieldControllers {
    readonly id: FieldController<string>;
    readonly name: FieldController<string>;
    readonly taxAgency: FieldController<string>;
    readonly zip: FieldController<number>;
    readonly city: FieldController<string>;
    readonly county: FieldController<string>;
    readonly state: FieldController<string>;
    readonly isActive: FieldController<boolean>;
    readonly description: FieldController<string>;
    readonly taxComponents: FieldController<{
        [key: string]: number;
    }>;
}
export interface TaxRateGigaform {
    readonly data: TaxRate;
    readonly errors: TaxRateErrors;
    readonly tainted: TaxRateTainted;
    readonly fields: TaxRateFieldControllers;
    validate(): Exit<TaxRate, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<TaxRate>): void;
}
export function taxRateCreateForm(overrides?: Partial<TaxRate>): TaxRateGigaform {
    let data = $state({
        ...taxRateDefaultValue(),
        ...overrides
    });
    let errors = $state<TaxRateErrors>({
        _errors: optionNone(),
        id: optionNone(),
        name: optionNone(),
        taxAgency: optionNone(),
        zip: optionNone(),
        city: optionNone(),
        county: optionNone(),
        state: optionNone(),
        isActive: optionNone(),
        description: optionNone(),
        taxComponents: optionNone()
    } as TaxRateErrors);
    let tainted = $state<TaxRateTainted>({
        id: optionNone(),
        name: optionNone(),
        taxAgency: optionNone(),
        zip: optionNone(),
        city: optionNone(),
        county: optionNone(),
        state: optionNone(),
        isActive: optionNone(),
        description: optionNone(),
        taxComponents: optionNone()
    } as TaxRateTainted);
    const fields = {
        id: {
            path: [
                "id"
            ] as const,
            name: "id",
            constraints: {
                required: true
            },
            get: ()=>data.id,
            set: (value: string)=>{
                data.id = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.id,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.id = value;
            },
            getTainted: ()=>tainted.id,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.id = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = taxRateValidateField("id", data.id);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        name: {
            path: [
                "name"
            ] as const,
            name: "name",
            constraints: {
                required: true
            },
            label: "Name",
            get: ()=>data.name,
            set: (value: string)=>{
                data.name = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.name,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.name = value;
            },
            getTainted: ()=>tainted.name,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.name = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = taxRateValidateField("name", data.name);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        taxAgency: {
            path: [
                "taxAgency"
            ] as const,
            name: "taxAgency",
            constraints: {
                required: true
            },
            label: "Tax Agency",
            get: ()=>data.taxAgency,
            set: (value: string)=>{
                data.taxAgency = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.taxAgency,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.taxAgency = value;
            },
            getTainted: ()=>tainted.taxAgency,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.taxAgency = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = taxRateValidateField("taxAgency", data.taxAgency);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        zip: {
            path: [
                "zip"
            ] as const,
            name: "zip",
            constraints: {
                required: true
            },
            label: "Zip",
            get: ()=>data.zip,
            set: (value: number)=>{
                data.zip = value;
            },
            transform: (value: number): number =>value,
            getError: ()=>errors.zip,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.zip = value;
            },
            getTainted: ()=>tainted.zip,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.zip = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = taxRateValidateField("zip", data.zip);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        city: {
            path: [
                "city"
            ] as const,
            name: "city",
            constraints: {
                required: true
            },
            label: "City",
            get: ()=>data.city,
            set: (value: string)=>{
                data.city = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.city,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.city = value;
            },
            getTainted: ()=>tainted.city,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.city = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = taxRateValidateField("city", data.city);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        county: {
            path: [
                "county"
            ] as const,
            name: "county",
            constraints: {
                required: true
            },
            label: "County",
            get: ()=>data.county,
            set: (value: string)=>{
                data.county = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.county,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.county = value;
            },
            getTainted: ()=>tainted.county,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.county = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = taxRateValidateField("county", data.county);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        state: {
            path: [
                "state"
            ] as const,
            name: "state",
            constraints: {
                required: true
            },
            label: "State",
            get: ()=>data.state,
            set: (value: string)=>{
                data.state = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.state,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.state = value;
            },
            getTainted: ()=>tainted.state,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.state = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = taxRateValidateField("state", data.state);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        isActive: {
            path: [
                "isActive"
            ] as const,
            name: "isActive",
            constraints: {
                required: true
            },
            label: "Active",
            get: ()=>data.isActive,
            set: (value: boolean)=>{
                data.isActive = value;
            },
            transform: (value: boolean): boolean =>value,
            getError: ()=>errors.isActive,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.isActive = value;
            },
            getTainted: ()=>tainted.isActive,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.isActive = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = taxRateValidateField("isActive", data.isActive);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        description: {
            path: [
                "description"
            ] as const,
            name: "description",
            constraints: {
                required: true
            },
            label: "Description",
            get: ()=>data.description,
            set: (value: string)=>{
                data.description = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.description,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.description = value;
            },
            getTainted: ()=>tainted.description,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.description = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = taxRateValidateField("description", data.description);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        taxComponents: {
            path: [
                "taxComponents"
            ] as const,
            name: "taxComponents",
            constraints: {
                required: true
            },
            get: ()=>data.taxComponents,
            set: (value: {
                [key: string]: number;
            })=>{
                data.taxComponents = value;
            },
            transform: (value: {
                [key: string]: number;
            }): {
                [key: string]: number;
            } =>value,
            getError: ()=>errors.taxComponents,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.taxComponents = value;
            },
            getTainted: ()=>tainted.taxComponents,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.taxComponents = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = taxRateValidateField("taxComponents", data.taxComponents);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        }
    } as TaxRateFieldControllers;
    const __gf_getter_hint = "get data() set data(v) get errors() set errors(v) get tainted() set tainted(v)";
    const __gf_validate_hint = ".map((e: { field: string; message: string }) => e.message)";
    function validate(): Exit<TaxRate, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(taxRateDeserialize(data));
    }
    function reset(newOverrides?: Partial<TaxRate>): void {
        data = {
            ...taxRateDefaultValue(),
            ...newOverrides
        };
        errors = {
            _errors: optionNone(),
            id: optionNone(),
            name: optionNone(),
            taxAgency: optionNone(),
            zip: optionNone(),
            city: optionNone(),
            county: optionNone(),
            state: optionNone(),
            isActive: optionNone(),
            description: optionNone(),
            taxComponents: optionNone()
        };
        tainted = {
            id: optionNone(),
            name: optionNone(),
            taxAgency: optionNone(),
            zip: optionNone(),
            city: optionNone(),
            county: optionNone(),
            state: optionNone(),
            isActive: optionNone(),
            description: optionNone(),
            taxComponents: optionNone()
        };
    }
    return {
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        fields,
        validate,
        reset
    };
}
export function taxRateFromFormData(formData: FormData): Exit<TaxRate, Array<{
    field: string;
    message: string;
}>> {
    const obj: Record<string, unknown> = {};
    const __gf_exit_hint = "Exit<TaxRate, Array<{ field: string; message: string }>>";
    obj.id = formData.get(`${"id"}`) ?? "";
    obj.name = formData.get(`${"name"}`) ?? "";
    obj.taxAgency = formData.get(`${"taxAgency"}`) ?? "";
    {
        const zipStr = formData.get(`${"zip"}`);
        obj.zip = zipStr ? parseFloat(zipStr as string) : $MfPh5;
        if (obj.zip !== undefined && isNaN(obj.zip as number)) obj.zip = "0";
    }
    obj.city = formData.get(`${"city"}`) ?? "";
    obj.county = formData.get(`${"county"}`) ?? "";
    obj.state = formData.get(`${"state"}`) ?? "";
    {
        const isActiveVal = formData.get(`${"isActive"}`);
        obj.isActive = isActiveVal === "true" || isActiveVal === "on" || isActiveVal === "1";
    }
    obj.description = formData.get(`${"description"}`) ?? "";
    obj.taxComponents = formData.get(`${"taxComponents"}`) ?? "";
    return toExit(taxRateDeserialize(obj));
}

export const TaxRate = {
  defaultValue: taxRateDefaultValue,
  serialize: taxRateSerialize,
  serializeWithContext: taxRateSerializeWithContext,
  deserialize: taxRateDeserialize,
  deserializeWithContext: taxRateDeserializeWithContext,
  validateFields: taxRateValidateFields,
  hasShape: taxRateHasShape,
  is: taxRateIs,
  createForm: taxRateCreateForm,
  fromFormData: taxRateFromFormData
} as const;


export interface Address {
    
    street: string;
    
    city: string;
    
    state: string;
    
    zipcode: string;
}

export function addressDefaultValue(): Address {
    return {
        street: "",
        city: "",
        state: "",
        zipcode: ""
    } as Address;
}

export function addressSerialize(value: Address): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(addressSerializeWithContext(value, ctx));
}
export function addressSerializeWithContext(value: Address, ctx: __mf_SerializeContext): Record<string, unknown> {
    const existingId = ctx.getId(value);
    if (existingId !== undefined) {
        return {
            __ref: existingId
        };
    }
    const __id = ctx.register(value);
    const result: Record<string, unknown> = {
        __type: "Address",
        __id
    };
    result.street = value.street;
    result.city = value.city;
    result.state = value.state;
    result.zipcode = value.zipcode;
    return result;
}

export function addressDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: Address } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = addressDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "Address.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function addressDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Address | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
        throw new __mf_DeserializeError([
            {
                field: "_root",
                message: `${"Address"}.deserializeWithContext: expected an object`
            }
        ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (!("street" in obj)) {
        errors.push({
            field: "street",
            message: "missing required field"
        });
    }
    if (!("city" in obj)) {
        errors.push({
            field: "city",
            message: "missing required field"
        });
    }
    if (!("state" in obj)) {
        errors.push({
            field: "state",
            message: "missing required field"
        });
    }
    if (!("zipcode" in obj)) {
        errors.push({
            field: "zipcode",
            message: "missing required field"
        });
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
        ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
        const __raw_street = obj["street"] as string;
        if (__raw_street.trim().length === 0) {
            errors.push({
                field: "street",
                message: "Address.street must not be empty"
            });
        }
        instance.street = __raw_street;
    }
    {
        const __raw_city = obj["city"] as string;
        if (__raw_city.trim().length === 0) {
            errors.push({
                field: "city",
                message: "Address.city must not be empty"
            });
        }
        instance.city = __raw_city;
    }
    {
        const __raw_state = obj["state"] as string;
        if (__raw_state.trim().length === 0) {
            errors.push({
                field: "state",
                message: "Address.state must not be empty"
            });
        }
        instance.state = __raw_state;
    }
    {
        const __raw_zipcode = obj["zipcode"] as string;
        if (__raw_zipcode.trim().length === 0) {
            errors.push({
                field: "zipcode",
                message: "Address.zipcode must not be empty"
            });
        }
        instance.zipcode = __raw_zipcode;
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    return instance as Address;
}
export function addressValidateField<K extends keyof Address>(_field: K, _value: Address[K]): Array<{
    field: string;
    message: string;
}> {
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (_field === "street") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "street",
                message: "Address.street must not be empty"
            });
        }
    }
    if (_field === "city") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "city",
                message: "Address.city must not be empty"
            });
        }
    }
    if (_field === "state") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "state",
                message: "Address.state must not be empty"
            });
        }
    }
    if (_field === "zipcode") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "zipcode",
                message: "Address.zipcode must not be empty"
            });
        }
    }
    return errors;
}
export function addressValidateFields(_partial: Partial<Address>): Array<{
    field: string;
    message: string;
}> {
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if ("street" in _partial && _partial.street !== undefined) {
        const __val = _partial.street as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "street",
                message: "Address.street must not be empty"
            });
        }
    }
    if ("city" in _partial && _partial.city !== undefined) {
        const __val = _partial.city as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "city",
                message: "Address.city must not be empty"
            });
        }
    }
    if ("state" in _partial && _partial.state !== undefined) {
        const __val = _partial.state as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "state",
                message: "Address.state must not be empty"
            });
        }
    }
    if ("zipcode" in _partial && _partial.zipcode !== undefined) {
        const __val = _partial.zipcode as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "zipcode",
                message: "Address.zipcode must not be empty"
            });
        }
    }
    return errors;
}
export function addressHasShape(obj: unknown): boolean {
    if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
        return false;
    }
    const o = obj as Record<string, unknown>;
    return '"street" in o && "city" in o && "state" in o && "zipcode" in o';
}
export function addressIs(obj: unknown): obj is Address {
    if (!addressHasShape(obj)) {
        return false;
    }
    const result = addressDeserialize(obj);
    return result.success;
}

export type AddressErrors = {
    _errors: __gf_Option<Array<string>>;
    street: __gf_Option<Array<string>>;
    city: __gf_Option<Array<string>>;
    state: __gf_Option<Array<string>>;
    zipcode: __gf_Option<Array<string>>;
};
export type AddressTainted = {
    street: __gf_Option<boolean>;
    city: __gf_Option<boolean>;
    state: __gf_Option<boolean>;
    zipcode: __gf_Option<boolean>;
};
export interface AddressFieldControllers {
    readonly street: FieldController<string>;
    readonly city: FieldController<string>;
    readonly state: FieldController<string>;
    readonly zipcode: FieldController<string>;
}
export interface AddressGigaform {
    readonly data: Address;
    readonly errors: AddressErrors;
    readonly tainted: AddressTainted;
    readonly fields: AddressFieldControllers;
    validate(): Exit<Address, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<Address>): void;
}
export function addressCreateForm(overrides?: Partial<Address>): AddressGigaform {
    let data = $state({
        ...addressDefaultValue(),
        ...overrides
    });
    let errors = $state<AddressErrors>({
        _errors: optionNone(),
        street: optionNone(),
        city: optionNone(),
        state: optionNone(),
        zipcode: optionNone()
    } as AddressErrors);
    let tainted = $state<AddressTainted>({
        street: optionNone(),
        city: optionNone(),
        state: optionNone(),
        zipcode: optionNone()
    } as AddressTainted);
    const fields = {
        street: {
            path: [
                "street"
            ] as const,
            name: "street",
            constraints: {
                required: true
            },
            get: ()=>data.street,
            set: (value: string)=>{
                data.street = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.street,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.street = value;
            },
            getTainted: ()=>tainted.street,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.street = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = addressValidateField("street", data.street);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        city: {
            path: [
                "city"
            ] as const,
            name: "city",
            constraints: {
                required: true
            },
            get: ()=>data.city,
            set: (value: string)=>{
                data.city = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.city,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.city = value;
            },
            getTainted: ()=>tainted.city,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.city = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = addressValidateField("city", data.city);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        state: {
            path: [
                "state"
            ] as const,
            name: "state",
            constraints: {
                required: true
            },
            get: ()=>data.state,
            set: (value: string)=>{
                data.state = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.state,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.state = value;
            },
            getTainted: ()=>tainted.state,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.state = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = addressValidateField("state", data.state);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        zipcode: {
            path: [
                "zipcode"
            ] as const,
            name: "zipcode",
            constraints: {
                required: true
            },
            get: ()=>data.zipcode,
            set: (value: string)=>{
                data.zipcode = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.zipcode,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.zipcode = value;
            },
            getTainted: ()=>tainted.zipcode,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.zipcode = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = addressValidateField("zipcode", data.zipcode);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        }
    } as AddressFieldControllers;
    const __gf_getter_hint = "get data() set data(v) get errors() set errors(v) get tainted() set tainted(v)";
    const __gf_validate_hint = ".map((e: { field: string; message: string }) => e.message)";
    function validate(): Exit<Address, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(addressDeserialize(data));
    }
    function reset(newOverrides?: Partial<Address>): void {
        data = {
            ...addressDefaultValue(),
            ...newOverrides
        };
        errors = {
            _errors: optionNone(),
            street: optionNone(),
            city: optionNone(),
            state: optionNone(),
            zipcode: optionNone()
        };
        tainted = {
            street: optionNone(),
            city: optionNone(),
            state: optionNone(),
            zipcode: optionNone()
        };
    }
    return {
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        fields,
        validate,
        reset
    };
}
export function addressFromFormData(formData: FormData): Exit<Address, Array<{
    field: string;
    message: string;
}>> {
    const obj: Record<string, unknown> = {};
    const __gf_exit_hint = "Exit<Address, Array<{ field: string; message: string }>>";
    obj.street = formData.get(`${"street"}`) ?? "";
    obj.city = formData.get(`${"city"}`) ?? "";
    obj.state = formData.get(`${"state"}`) ?? "";
    obj.zipcode = formData.get(`${"zipcode"}`) ?? "";
    return toExit(addressDeserialize(obj));
}

export const Address = {
  defaultValue: addressDefaultValue,
  serialize: addressSerialize,
  serializeWithContext: addressSerializeWithContext,
  deserialize: addressDeserialize,
  deserializeWithContext: addressDeserializeWithContext,
  validateFields: addressValidateFields,
  hasShape: addressHasShape,
  is: addressIs,
  createForm: addressCreateForm,
  fromFormData: addressFromFormData
} as const;


export interface Lead {
    
    id: string;
    
    number: number | null;
    
    accepted: boolean;
    
    probability: number;
    
    
    priority: Priority;
    
    dueDate: string | null;
    
    closeDate: string | null;
    
    value: number;
    
    
    stage: LeadStage;
    
    
    status: string;
    
    description: string | null;
    
    
    nextStep: NextStep;
    
    favorite: boolean;
    
    dateAdded: string | null;
    
    taxRate: (string | TaxRate) | null;
    
    
    sector: Sector;
    
    leadName: AccountName;
    
    phones: Array<PhoneNumber>;
    
    email: Email;
    
    leadSource: string | null;
    
    
    site: string | Site;
    
    
    memo: string;
    
    needsReview: boolean;
    
    hasAlert: boolean;
    
    salesRep: Array<Represents> | null;
    
    color: string | null;
    
    
    accountType: string;
    
    
    subtype: string;
    
    isTaxExempt: boolean;
    
    
    paymentTerms: string;
    
    tags: Array<string>;
    
    customFields: Array<[string, string]>;
}

export function leadDefaultValue(): Lead {
    return {
        id: "",
        number: null,
        accepted: false,
        probability: 0,
        priority: "Medium",
        dueDate: null,
        closeDate: null,
        value: 0,
        stage: "Open",
        status: "",
        description: null,
        nextStep: "InitialContact",
        favorite: false,
        dateAdded: null,
        taxRate: null,
        sector: "Residential",
        leadName: accountNameDefaultValue(),
        phones: [],
        email: emailDefaultValue(),
        leadSource: null,
        site: "",
        memo: "",
        needsReview: false,
        hasAlert: false,
        salesRep: null,
        color: null,
        accountType: "",
        subtype: "",
        isTaxExempt: false,
        paymentTerms: "",
        tags: [],
        customFields: []
    } as Lead;
}

export function leadSerialize(value: Lead): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(leadSerializeWithContext(value, ctx));
}
export function leadSerializeWithContext(value: Lead, ctx: __mf_SerializeContext): Record<string, unknown> {
    const existingId = ctx.getId(value);
    if (existingId !== undefined) {
        return {
            __ref: existingId
        };
    }
    const __id = ctx.register(value);
    const result: Record<string, unknown> = {
        __type: "Lead",
        __id
    };
    result.id = value.id;
    result.number = value.number;
    result.accepted = value.accepted;
    result.probability = value.probability;
    result.priority = prioritySerializeWithContext(value.priority, ctx);
    result.dueDate = value.dueDate;
    result.closeDate = value.closeDate;
    result.value = value.value;
    result.stage = leadStageSerializeWithContext(value.stage, ctx);
    result.status = value.status;
    result.description = value.description;
    result.nextStep = nextStepSerializeWithContext(value.nextStep, ctx);
    result.favorite = value.favorite;
    result.dateAdded = value.dateAdded;
    if (value.taxRate !== null) {
        result.taxRate = value.taxRate;
    }
    result.sector = sectorSerializeWithContext(value.sector, ctx);
    result.leadName = accountNameSerializeWithContext(value.leadName, ctx);
    result.phones = value.phones.map((item)=>phoneNumberSerializeWithContext(item, ctx));
    result.email = emailSerializeWithContext(value.email, ctx);
    result.leadSource = value.leadSource;
    result.site = value.site;
    result.memo = value.memo;
    result.needsReview = value.needsReview;
    result.hasAlert = value.hasAlert;
    if (value.salesRep !== null) {
        result.salesRep = value.salesRep;
    }
    result.color = value.color;
    result.accountType = value.accountType;
    result.subtype = value.subtype;
    result.isTaxExempt = value.isTaxExempt;
    result.paymentTerms = value.paymentTerms;
    result.tags = value.tags;
    result.customFields = value.customFields;
    return result;
}

export function leadDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: Lead } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = leadDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "Lead.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function leadDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Lead | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
        throw new __mf_DeserializeError([
            {
                field: "_root",
                message: `${"Lead"}.deserializeWithContext: expected an object`
            }
        ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (!("id" in obj)) {
        errors.push({
            field: "id",
            message: "missing required field"
        });
    }
    if (!("number" in obj)) {
        errors.push({
            field: "number",
            message: "missing required field"
        });
    }
    if (!("accepted" in obj)) {
        errors.push({
            field: "accepted",
            message: "missing required field"
        });
    }
    if (!("probability" in obj)) {
        errors.push({
            field: "probability",
            message: "missing required field"
        });
    }
    if (!("priority" in obj)) {
        errors.push({
            field: "priority",
            message: "missing required field"
        });
    }
    if (!("dueDate" in obj)) {
        errors.push({
            field: "dueDate",
            message: "missing required field"
        });
    }
    if (!("closeDate" in obj)) {
        errors.push({
            field: "closeDate",
            message: "missing required field"
        });
    }
    if (!("value" in obj)) {
        errors.push({
            field: "value",
            message: "missing required field"
        });
    }
    if (!("stage" in obj)) {
        errors.push({
            field: "stage",
            message: "missing required field"
        });
    }
    if (!("status" in obj)) {
        errors.push({
            field: "status",
            message: "missing required field"
        });
    }
    if (!("description" in obj)) {
        errors.push({
            field: "description",
            message: "missing required field"
        });
    }
    if (!("nextStep" in obj)) {
        errors.push({
            field: "nextStep",
            message: "missing required field"
        });
    }
    if (!("favorite" in obj)) {
        errors.push({
            field: "favorite",
            message: "missing required field"
        });
    }
    if (!("dateAdded" in obj)) {
        errors.push({
            field: "dateAdded",
            message: "missing required field"
        });
    }
    if (!("taxRate" in obj)) {
        errors.push({
            field: "taxRate",
            message: "missing required field"
        });
    }
    if (!("sector" in obj)) {
        errors.push({
            field: "sector",
            message: "missing required field"
        });
    }
    if (!("leadName" in obj)) {
        errors.push({
            field: "leadName",
            message: "missing required field"
        });
    }
    if (!("phones" in obj)) {
        errors.push({
            field: "phones",
            message: "missing required field"
        });
    }
    if (!("email" in obj)) {
        errors.push({
            field: "email",
            message: "missing required field"
        });
    }
    if (!("leadSource" in obj)) {
        errors.push({
            field: "leadSource",
            message: "missing required field"
        });
    }
    if (!("site" in obj)) {
        errors.push({
            field: "site",
            message: "missing required field"
        });
    }
    if (!("memo" in obj)) {
        errors.push({
            field: "memo",
            message: "missing required field"
        });
    }
    if (!("needsReview" in obj)) {
        errors.push({
            field: "needsReview",
            message: "missing required field"
        });
    }
    if (!("hasAlert" in obj)) {
        errors.push({
            field: "hasAlert",
            message: "missing required field"
        });
    }
    if (!("salesRep" in obj)) {
        errors.push({
            field: "salesRep",
            message: "missing required field"
        });
    }
    if (!("color" in obj)) {
        errors.push({
            field: "color",
            message: "missing required field"
        });
    }
    if (!("accountType" in obj)) {
        errors.push({
            field: "accountType",
            message: "missing required field"
        });
    }
    if (!("subtype" in obj)) {
        errors.push({
            field: "subtype",
            message: "missing required field"
        });
    }
    if (!("isTaxExempt" in obj)) {
        errors.push({
            field: "isTaxExempt",
            message: "missing required field"
        });
    }
    if (!("paymentTerms" in obj)) {
        errors.push({
            field: "paymentTerms",
            message: "missing required field"
        });
    }
    if (!("tags" in obj)) {
        errors.push({
            field: "tags",
            message: "missing required field"
        });
    }
    if (!("customFields" in obj)) {
        errors.push({
            field: "customFields",
            message: "missing required field"
        });
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
        ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
        const __raw_id = obj["id"] as string;
        instance.id = __raw_id;
    }
    {
        const __raw_number = obj["number"] as number | null;
        instance.number = __raw_number;
    }
    {
        const __raw_accepted = obj["accepted"] as boolean;
        instance.accepted = __raw_accepted;
    }
    {
        const __raw_probability = obj["probability"] as number;
        instance.probability = __raw_probability;
    }
    {
        const __raw_priority = obj["priority"] as Priority;
        {
            const __result = priorityDeserializeWithContext(__raw_priority, ctx);
            ctx.assignOrDefer(instance, "priority", __result);
        }
    }
    {
        const __raw_dueDate = obj["dueDate"] as string | null;
        instance.dueDate = __raw_dueDate;
    }
    {
        const __raw_closeDate = obj["closeDate"] as string | null;
        instance.closeDate = __raw_closeDate;
    }
    {
        const __raw_value = obj["value"] as number;
        instance.value = __raw_value;
    }
    {
        const __raw_stage = obj["stage"] as LeadStage;
        {
            const __result = leadStageDeserializeWithContext(__raw_stage, ctx);
            ctx.assignOrDefer(instance, "stage", __result);
        }
    }
    {
        const __raw_status = obj["status"] as string;
        if (__raw_status.trim().length === 0) {
            errors.push({
                field: "status",
                message: "Lead.status must not be empty"
            });
        }
        instance.status = __raw_status;
    }
    {
        const __raw_description = obj["description"] as string | null;
        instance.description = __raw_description;
    }
    {
        const __raw_nextStep = obj["nextStep"] as NextStep;
        {
            const __result = nextStepDeserializeWithContext(__raw_nextStep, ctx);
            ctx.assignOrDefer(instance, "nextStep", __result);
        }
    }
    {
        const __raw_favorite = obj["favorite"] as boolean;
        instance.favorite = __raw_favorite;
    }
    {
        const __raw_dateAdded = obj["dateAdded"] as string | null;
        instance.dateAdded = __raw_dateAdded;
    }
    {
        const __raw_taxRate = obj["taxRate"] as (string | TaxRate) | null;
        if (__raw_taxRate === null) {
            instance.taxRate = null;
        } else {
            instance.taxRate = __raw_taxRate;
        }
    }
    {
        const __raw_sector = obj["sector"] as Sector;
        {
            const __result = sectorDeserializeWithContext(__raw_sector, ctx);
            ctx.assignOrDefer(instance, "sector", __result);
        }
    }
    {
        const __raw_leadName = obj["leadName"] as AccountName;
        {
            const __result = accountNameDeserializeWithContext(__raw_leadName, ctx);
            ctx.assignOrDefer(instance, "leadName", __result);
        }
    }
    {
        const __raw_phones = obj["phones"] as Array<PhoneNumber>;
        if (Array.isArray(__raw_phones)) {
            instance.phones = __raw_phones as PhoneNumber[];
        }
    }
    {
        const __raw_email = obj["email"] as Email;
        {
            const __result = emailDeserializeWithContext(__raw_email, ctx);
            ctx.assignOrDefer(instance, "email", __result);
        }
    }
    {
        const __raw_leadSource = obj["leadSource"] as string | null;
        instance.leadSource = __raw_leadSource;
    }
    {
        const __raw_site = obj["site"] as string | Site;
        instance.site = __raw_site;
    }
    {
        const __raw_memo = obj["memo"] as string;
        if (__raw_memo.trim().length === 0) {
            errors.push({
                field: "memo",
                message: "Lead.memo must not be empty"
            });
        }
        instance.memo = __raw_memo;
    }
    {
        const __raw_needsReview = obj["needsReview"] as boolean;
        instance.needsReview = __raw_needsReview;
    }
    {
        const __raw_hasAlert = obj["hasAlert"] as boolean;
        instance.hasAlert = __raw_hasAlert;
    }
    {
        const __raw_salesRep = obj["salesRep"] as Array<Represents> | null;
        if (__raw_salesRep === null) {
            instance.salesRep = null;
        } else {
            instance.salesRep = __raw_salesRep;
        }
    }
    {
        const __raw_color = obj["color"] as string | null;
        instance.color = __raw_color;
    }
    {
        const __raw_accountType = obj["accountType"] as string;
        if (__raw_accountType.trim().length === 0) {
            errors.push({
                field: "accountType",
                message: "Lead.accountType must not be empty"
            });
        }
        instance.accountType = __raw_accountType;
    }
    {
        const __raw_subtype = obj["subtype"] as string;
        if (__raw_subtype.trim().length === 0) {
            errors.push({
                field: "subtype",
                message: "Lead.subtype must not be empty"
            });
        }
        instance.subtype = __raw_subtype;
    }
    {
        const __raw_isTaxExempt = obj["isTaxExempt"] as boolean;
        instance.isTaxExempt = __raw_isTaxExempt;
    }
    {
        const __raw_paymentTerms = obj["paymentTerms"] as string;
        if (__raw_paymentTerms.trim().length === 0) {
            errors.push({
                field: "paymentTerms",
                message: "Lead.paymentTerms must not be empty"
            });
        }
        instance.paymentTerms = __raw_paymentTerms;
    }
    {
        const __raw_tags = obj["tags"] as Array<string>;
        if (Array.isArray(__raw_tags)) {
            instance.tags = __raw_tags as string[];
        }
    }
    {
        const __raw_customFields = obj["customFields"] as Array<[string, string]>;
        if (Array.isArray(__raw_customFields)) {
            instance.customFields = __raw_customFields as [string, string][];
        }
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    return instance as Lead;
}
export function leadValidateField<K extends keyof Lead>(_field: K, _value: Lead[K]): Array<{
    field: string;
    message: string;
}> {
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (_field === "status") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "status",
                message: "Lead.status must not be empty"
            });
        }
    }
    if (_field === "memo") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "memo",
                message: "Lead.memo must not be empty"
            });
        }
    }
    if (_field === "accountType") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "accountType",
                message: "Lead.accountType must not be empty"
            });
        }
    }
    if (_field === "subtype") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "subtype",
                message: "Lead.subtype must not be empty"
            });
        }
    }
    if (_field === "paymentTerms") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "paymentTerms",
                message: "Lead.paymentTerms must not be empty"
            });
        }
    }
    return errors;
}
export function leadValidateFields(_partial: Partial<Lead>): Array<{
    field: string;
    message: string;
}> {
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if ("status" in _partial && _partial.status !== undefined) {
        const __val = _partial.status as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "status",
                message: "Lead.status must not be empty"
            });
        }
    }
    if ("memo" in _partial && _partial.memo !== undefined) {
        const __val = _partial.memo as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "memo",
                message: "Lead.memo must not be empty"
            });
        }
    }
    if ("accountType" in _partial && _partial.accountType !== undefined) {
        const __val = _partial.accountType as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "accountType",
                message: "Lead.accountType must not be empty"
            });
        }
    }
    if ("subtype" in _partial && _partial.subtype !== undefined) {
        const __val = _partial.subtype as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "subtype",
                message: "Lead.subtype must not be empty"
            });
        }
    }
    if ("paymentTerms" in _partial && _partial.paymentTerms !== undefined) {
        const __val = _partial.paymentTerms as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "paymentTerms",
                message: "Lead.paymentTerms must not be empty"
            });
        }
    }
    return errors;
}
export function leadHasShape(obj: unknown): boolean {
    if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
        return false;
    }
    const o = obj as Record<string, unknown>;
    return '"id" in o && "number" in o && "accepted" in o && "probability" in o && "priority" in o && "dueDate" in o && "closeDate" in o && "value" in o && "stage" in o && "status" in o && "description" in o && "nextStep" in o && "favorite" in o && "dateAdded" in o && "taxRate" in o && "sector" in o && "leadName" in o && "phones" in o && "email" in o && "leadSource" in o && "site" in o && "memo" in o && "needsReview" in o && "hasAlert" in o && "salesRep" in o && "color" in o && "accountType" in o && "subtype" in o && "isTaxExempt" in o && "paymentTerms" in o && "tags" in o && "customFields" in o';
}
export function leadIs(obj: unknown): obj is Lead {
    if (!leadHasShape(obj)) {
        return false;
    }
    const result = leadDeserialize(obj);
    return result.success;
}

export type LeadErrors = {
    _errors: __gf_Option<Array<string>>;
    id: __gf_Option<Array<string>>;
    number: __gf_Option<Array<string>>;
    accepted: __gf_Option<Array<string>>;
    probability: __gf_Option<Array<string>>;
    priority: __gf_Option<Array<string>>;
    dueDate: __gf_Option<Array<string>>;
    closeDate: __gf_Option<Array<string>>;
    value: __gf_Option<Array<string>>;
    stage: __gf_Option<Array<string>>;
    status: __gf_Option<Array<string>>;
    description: __gf_Option<Array<string>>;
    nextStep: __gf_Option<Array<string>>;
    favorite: __gf_Option<Array<string>>;
    dateAdded: __gf_Option<Array<string>>;
    taxRate: __gf_Option<Array<string>>;
    sector: __gf_Option<Array<string>>;
    leadName: __gf_Option<Array<string>>;
    phones: __gf_Option<Array<string>>;
    email: __gf_Option<Array<string>>;
    leadSource: __gf_Option<Array<string>>;
    site: __gf_Option<Array<string>>;
    memo: __gf_Option<Array<string>>;
    needsReview: __gf_Option<Array<string>>;
    hasAlert: __gf_Option<Array<string>>;
    salesRep: __gf_Option<Array<string>>;
    color: __gf_Option<Array<string>>;
    accountType: __gf_Option<Array<string>>;
    subtype: __gf_Option<Array<string>>;
    isTaxExempt: __gf_Option<Array<string>>;
    paymentTerms: __gf_Option<Array<string>>;
    tags: __gf_Option<Array<string>>;
    customFields: __gf_Option<Array<string>>;
};
export type LeadTainted = {
    id: __gf_Option<boolean>;
    number: __gf_Option<boolean>;
    accepted: __gf_Option<boolean>;
    probability: __gf_Option<boolean>;
    priority: __gf_Option<boolean>;
    dueDate: __gf_Option<boolean>;
    closeDate: __gf_Option<boolean>;
    value: __gf_Option<boolean>;
    stage: __gf_Option<boolean>;
    status: __gf_Option<boolean>;
    description: __gf_Option<boolean>;
    nextStep: __gf_Option<boolean>;
    favorite: __gf_Option<boolean>;
    dateAdded: __gf_Option<boolean>;
    taxRate: __gf_Option<boolean>;
    sector: __gf_Option<boolean>;
    leadName: __gf_Option<boolean>;
    phones: __gf_Option<boolean>;
    email: __gf_Option<boolean>;
    leadSource: __gf_Option<boolean>;
    site: __gf_Option<boolean>;
    memo: __gf_Option<boolean>;
    needsReview: __gf_Option<boolean>;
    hasAlert: __gf_Option<boolean>;
    salesRep: __gf_Option<boolean>;
    color: __gf_Option<boolean>;
    accountType: __gf_Option<boolean>;
    subtype: __gf_Option<boolean>;
    isTaxExempt: __gf_Option<boolean>;
    paymentTerms: __gf_Option<boolean>;
    tags: __gf_Option<boolean>;
    customFields: __gf_Option<boolean>;
};
export interface LeadFieldControllers {
    readonly id: FieldController<string>;
    readonly number: FieldController<number | null>;
    readonly accepted: FieldController<boolean>;
    readonly probability: FieldController<number>;
    readonly priority: FieldController<Priority>;
    readonly dueDate: FieldController<string | null>;
    readonly closeDate: FieldController<string | null>;
    readonly value: FieldController<number>;
    readonly stage: FieldController<LeadStage>;
    readonly status: FieldController<string>;
    readonly description: FieldController<string | null>;
    readonly nextStep: FieldController<NextStep>;
    readonly favorite: FieldController<boolean>;
    readonly dateAdded: FieldController<string | null>;
    readonly taxRate: FieldController<(string | TaxRate) | null>;
    readonly sector: FieldController<Sector>;
    readonly leadName: FieldController<AccountName>;
    readonly phones: ArrayFieldController<PhoneNumber>;
    readonly email: FieldController<Email>;
    readonly leadSource: FieldController<string | null>;
    readonly site: FieldController<string | Site>;
    readonly memo: FieldController<string>;
    readonly needsReview: FieldController<boolean>;
    readonly hasAlert: FieldController<boolean>;
    readonly salesRep: FieldController<Array<Represents> | null>;
    readonly color: FieldController<string | null>;
    readonly accountType: FieldController<string>;
    readonly subtype: FieldController<string>;
    readonly isTaxExempt: FieldController<boolean>;
    readonly paymentTerms: FieldController<string>;
    readonly tags: ArrayFieldController<string>;
    readonly customFields: ArrayFieldController<[string, string]>;
}
export interface LeadGigaform {
    readonly data: Lead;
    readonly errors: LeadErrors;
    readonly tainted: LeadTainted;
    readonly fields: LeadFieldControllers;
    validate(): Exit<Lead, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<Lead>): void;
}
export function leadCreateForm(overrides?: Partial<Lead>): LeadGigaform {
    let data = $state({
        ...leadDefaultValue(),
        ...overrides
    });
    let errors = $state<LeadErrors>({
        _errors: optionNone(),
        id: optionNone(),
        number: optionNone(),
        accepted: optionNone(),
        probability: optionNone(),
        priority: optionNone(),
        dueDate: optionNone(),
        closeDate: optionNone(),
        value: optionNone(),
        stage: optionNone(),
        status: optionNone(),
        description: optionNone(),
        nextStep: optionNone(),
        favorite: optionNone(),
        dateAdded: optionNone(),
        taxRate: optionNone(),
        sector: optionNone(),
        leadName: optionNone(),
        phones: optionNone(),
        email: optionNone(),
        leadSource: optionNone(),
        site: optionNone(),
        memo: optionNone(),
        needsReview: optionNone(),
        hasAlert: optionNone(),
        salesRep: optionNone(),
        color: optionNone(),
        accountType: optionNone(),
        subtype: optionNone(),
        isTaxExempt: optionNone(),
        paymentTerms: optionNone(),
        tags: optionNone(),
        customFields: optionNone()
    } as LeadErrors);
    let tainted = $state<LeadTainted>({
        id: optionNone(),
        number: optionNone(),
        accepted: optionNone(),
        probability: optionNone(),
        priority: optionNone(),
        dueDate: optionNone(),
        closeDate: optionNone(),
        value: optionNone(),
        stage: optionNone(),
        status: optionNone(),
        description: optionNone(),
        nextStep: optionNone(),
        favorite: optionNone(),
        dateAdded: optionNone(),
        taxRate: optionNone(),
        sector: optionNone(),
        leadName: optionNone(),
        phones: optionNone(),
        email: optionNone(),
        leadSource: optionNone(),
        site: optionNone(),
        memo: optionNone(),
        needsReview: optionNone(),
        hasAlert: optionNone(),
        salesRep: optionNone(),
        color: optionNone(),
        accountType: optionNone(),
        subtype: optionNone(),
        isTaxExempt: optionNone(),
        paymentTerms: optionNone(),
        tags: optionNone(),
        customFields: optionNone()
    } as LeadTainted);
    const fields = {
        id: {
            path: [
                "id"
            ] as const,
            name: "id",
            constraints: {
                required: true
            },
            get: ()=>data.id,
            set: (value: string)=>{
                data.id = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.id,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.id = value;
            },
            getTainted: ()=>tainted.id,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.id = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = leadValidateField("id", data.id);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        number: {
            path: [
                "number"
            ] as const,
            name: "number",
            constraints: {
                required: true
            },
            get: ()=>data.number,
            set: (value: number | null)=>{
                data.number = value;
            },
            transform: (value: number | null): number | null =>value,
            getError: ()=>errors.number,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.number = value;
            },
            getTainted: ()=>tainted.number,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.number = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = leadValidateField("number", data.number);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        accepted: {
            path: [
                "accepted"
            ] as const,
            name: "accepted",
            constraints: {
                required: true
            },
            get: ()=>data.accepted,
            set: (value: boolean)=>{
                data.accepted = value;
            },
            transform: (value: boolean): boolean =>value,
            getError: ()=>errors.accepted,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.accepted = value;
            },
            getTainted: ()=>tainted.accepted,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.accepted = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = leadValidateField("accepted", data.accepted);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        probability: {
            path: [
                "probability"
            ] as const,
            name: "probability",
            constraints: {
                required: true
            },
            label: "Probability",
            get: ()=>data.probability,
            set: (value: number)=>{
                data.probability = value;
            },
            transform: (value: number): number =>value,
            getError: ()=>errors.probability,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.probability = value;
            },
            getTainted: ()=>tainted.probability,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.probability = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = leadValidateField("probability", data.probability);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        priority: {
            path: [
                "priority"
            ] as const,
            name: "priority",
            constraints: {
                required: true
            },
            label: "Priority",
            get: ()=>data.priority,
            set: (value: Priority)=>{
                data.priority = value;
            },
            transform: (value: Priority): Priority =>value,
            getError: ()=>errors.priority,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.priority = value;
            },
            getTainted: ()=>tainted.priority,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.priority = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = leadValidateField("priority", data.priority);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        dueDate: {
            path: [
                "dueDate"
            ] as const,
            name: "dueDate",
            constraints: {
                required: true
            },
            label: "Due Date",
            get: ()=>data.dueDate,
            set: (value: string | null)=>{
                data.dueDate = value;
            },
            transform: (value: string | null): string | null =>value,
            getError: ()=>errors.dueDate,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.dueDate = value;
            },
            getTainted: ()=>tainted.dueDate,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.dueDate = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = leadValidateField("dueDate", data.dueDate);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        closeDate: {
            path: [
                "closeDate"
            ] as const,
            name: "closeDate",
            constraints: {
                required: true
            },
            label: "Close Date",
            get: ()=>data.closeDate,
            set: (value: string | null)=>{
                data.closeDate = value;
            },
            transform: (value: string | null): string | null =>value,
            getError: ()=>errors.closeDate,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.closeDate = value;
            },
            getTainted: ()=>tainted.closeDate,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.closeDate = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = leadValidateField("closeDate", data.closeDate);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        value: {
            path: [
                "value"
            ] as const,
            name: "value",
            constraints: {
                required: true
            },
            label: "Value",
            get: ()=>data.value,
            set: (value: number)=>{
                data.value = value;
            },
            transform: (value: number): number =>value,
            getError: ()=>errors.value,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.value = value;
            },
            getTainted: ()=>tainted.value,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.value = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = leadValidateField("value", data.value);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        stage: {
            path: [
                "stage"
            ] as const,
            name: "stage",
            constraints: {
                required: true
            },
            label: "Stage",
            get: ()=>data.stage,
            set: (value: LeadStage)=>{
                data.stage = value;
            },
            transform: (value: LeadStage): LeadStage =>value,
            getError: ()=>errors.stage,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.stage = value;
            },
            getTainted: ()=>tainted.stage,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.stage = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = leadValidateField("stage", data.stage);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        status: {
            path: [
                "status"
            ] as const,
            name: "status",
            constraints: {
                required: true
            },
            label: "Status",
            get: ()=>data.status,
            set: (value: string)=>{
                data.status = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.status,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.status = value;
            },
            getTainted: ()=>tainted.status,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.status = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = leadValidateField("status", data.status);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        description: {
            path: [
                "description"
            ] as const,
            name: "description",
            constraints: {
                required: true
            },
            label: "Description",
            get: ()=>data.description,
            set: (value: string | null)=>{
                data.description = value;
            },
            transform: (value: string | null): string | null =>value,
            getError: ()=>errors.description,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.description = value;
            },
            getTainted: ()=>tainted.description,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.description = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = leadValidateField("description", data.description);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        nextStep: {
            path: [
                "nextStep"
            ] as const,
            name: "nextStep",
            constraints: {
                required: true
            },
            get: ()=>data.nextStep,
            set: (value: NextStep)=>{
                data.nextStep = value;
            },
            transform: (value: NextStep): NextStep =>value,
            getError: ()=>errors.nextStep,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.nextStep = value;
            },
            getTainted: ()=>tainted.nextStep,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.nextStep = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = leadValidateField("nextStep", data.nextStep);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        favorite: {
            path: [
                "favorite"
            ] as const,
            name: "favorite",
            constraints: {
                required: true
            },
            label: "Favorite",
            get: ()=>data.favorite,
            set: (value: boolean)=>{
                data.favorite = value;
            },
            transform: (value: boolean): boolean =>value,
            getError: ()=>errors.favorite,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.favorite = value;
            },
            getTainted: ()=>tainted.favorite,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.favorite = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = leadValidateField("favorite", data.favorite);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        dateAdded: {
            path: [
                "dateAdded"
            ] as const,
            name: "dateAdded",
            constraints: {
                required: true
            },
            get: ()=>data.dateAdded,
            set: (value: string | null)=>{
                data.dateAdded = value;
            },
            transform: (value: string | null): string | null =>value,
            getError: ()=>errors.dateAdded,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.dateAdded = value;
            },
            getTainted: ()=>tainted.dateAdded,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.dateAdded = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = leadValidateField("dateAdded", data.dateAdded);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        taxRate: {
            path: [
                "taxRate"
            ] as const,
            name: "taxRate",
            constraints: {
                required: true
            },
            label: "Tax Rate",
            get: ()=>data.taxRate,
            set: (value: (string | TaxRate) | null)=>{
                data.taxRate = value;
            },
            transform: (value: (string | TaxRate) | null): (string | TaxRate) | null =>value,
            getError: ()=>errors.taxRate,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.taxRate = value;
            },
            getTainted: ()=>tainted.taxRate,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.taxRate = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = leadValidateField("taxRate", data.taxRate);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        sector: {
            path: [
                "sector"
            ] as const,
            name: "sector",
            constraints: {
                required: true
            },
            label: "Sector",
            get: ()=>data.sector,
            set: (value: Sector)=>{
                data.sector = value;
            },
            transform: (value: Sector): Sector =>value,
            getError: ()=>errors.sector,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.sector = value;
            },
            getTainted: ()=>tainted.sector,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.sector = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = leadValidateField("sector", data.sector);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        leadName: {
            path: [
                "leadName"
            ] as const,
            name: "leadName",
            constraints: {
                required: true
            },
            get: ()=>data.leadName,
            set: (value: AccountName)=>{
                data.leadName = value;
            },
            transform: (value: AccountName): AccountName =>value,
            getError: ()=>errors.leadName,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.leadName = value;
            },
            getTainted: ()=>tainted.leadName,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.leadName = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = leadValidateField("leadName", data.leadName);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        phones: {
            path: [
                "phones"
            ] as const,
            name: "phones",
            constraints: {
                required: true
            },
            get: ()=>data.phones,
            set: (value: Array<PhoneNumber>)=>{
                data.phones = value;
            },
            transform: (value: Array<PhoneNumber>): Array<PhoneNumber> =>value,
            getError: ()=>errors.phones,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.phones = value;
            },
            getTainted: ()=>tainted.phones,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.phones = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = leadValidateField("phones", data.phones);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            },
            at: (index: number)=>({
                    path: [
                        "phones",
                        index
                    ] as const,
                    name: "'^phones.${index}^'",
                    constraints: {
                        required: true
                    },
                    get: ()=>data.phones[index]!,
                    set: (value: PhoneNumber)=>{
                        data.phones[index] = value;
                    },
                    transform: (value: PhoneNumber): PhoneNumber =>value,
                    getError: ()=>errors.phones,
                    setError: (value: __gf_Option<Array<string>>)=>{
                        errors.phones = value;
                    },
                    getTainted: ()=>tainted.phones,
                    setTainted: (value: __gf_Option<boolean>)=>{
                        tainted.phones = value;
                    },
                    validate: (): Array<string> =>[]
                }),
            push: (item: PhoneNumber)=>{
                data.phones.push(item);
            },
            remove: (index: number)=>{
                data.phones.splice(index, 1);
            },
            swap: (a: number, b: number)=>{
                const tmp = data.phones[a]!;
                data.phones[a] = data.phones[b]!;
                data.phones[b] = tmp;
            }
        },
        email: {
            path: [
                "email"
            ] as const,
            name: "email",
            constraints: {
                required: true
            },
            label: "Email",
            get: ()=>data.email,
            set: (value: Email)=>{
                data.email = value;
            },
            transform: (value: Email): Email =>value,
            getError: ()=>errors.email,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.email = value;
            },
            getTainted: ()=>tainted.email,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.email = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = leadValidateField("email", data.email);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        leadSource: {
            path: [
                "leadSource"
            ] as const,
            name: "leadSource",
            constraints: {
                required: true
            },
            label: "Lead Source",
            get: ()=>data.leadSource,
            set: (value: string | null)=>{
                data.leadSource = value;
            },
            transform: (value: string | null): string | null =>value,
            getError: ()=>errors.leadSource,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.leadSource = value;
            },
            getTainted: ()=>tainted.leadSource,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.leadSource = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = leadValidateField("leadSource", data.leadSource);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        site: {
            path: [
                "site"
            ] as const,
            name: "site",
            constraints: {
                required: true
            },
            label: "Site",
            get: ()=>data.site,
            set: (value: string | Site)=>{
                data.site = value;
            },
            transform: (value: string | Site): string | Site =>value,
            getError: ()=>errors.site,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.site = value;
            },
            getTainted: ()=>tainted.site,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.site = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = leadValidateField("site", data.site);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        memo: {
            path: [
                "memo"
            ] as const,
            name: "memo",
            constraints: {
                required: true
            },
            label: "Memo",
            get: ()=>data.memo,
            set: (value: string)=>{
                data.memo = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.memo,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.memo = value;
            },
            getTainted: ()=>tainted.memo,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.memo = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = leadValidateField("memo", data.memo);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        needsReview: {
            path: [
                "needsReview"
            ] as const,
            name: "needsReview",
            constraints: {
                required: true
            },
            label: "Needs Review",
            get: ()=>data.needsReview,
            set: (value: boolean)=>{
                data.needsReview = value;
            },
            transform: (value: boolean): boolean =>value,
            getError: ()=>errors.needsReview,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.needsReview = value;
            },
            getTainted: ()=>tainted.needsReview,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.needsReview = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = leadValidateField("needsReview", data.needsReview);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        hasAlert: {
            path: [
                "hasAlert"
            ] as const,
            name: "hasAlert",
            constraints: {
                required: true
            },
            label: "Has Alert",
            get: ()=>data.hasAlert,
            set: (value: boolean)=>{
                data.hasAlert = value;
            },
            transform: (value: boolean): boolean =>value,
            getError: ()=>errors.hasAlert,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.hasAlert = value;
            },
            getTainted: ()=>tainted.hasAlert,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.hasAlert = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = leadValidateField("hasAlert", data.hasAlert);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        salesRep: {
            path: [
                "salesRep"
            ] as const,
            name: "salesRep",
            constraints: {
                required: true
            },
            label: "Sales Rep",
            get: ()=>data.salesRep,
            set: (value: Array<Represents> | null)=>{
                data.salesRep = value;
            },
            transform: (value: Array<Represents> | null): Array<Represents> | null =>value,
            getError: ()=>errors.salesRep,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.salesRep = value;
            },
            getTainted: ()=>tainted.salesRep,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.salesRep = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = leadValidateField("salesRep", data.salesRep);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        color: {
            path: [
                "color"
            ] as const,
            name: "color",
            constraints: {
                required: true
            },
            get: ()=>data.color,
            set: (value: string | null)=>{
                data.color = value;
            },
            transform: (value: string | null): string | null =>value,
            getError: ()=>errors.color,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.color = value;
            },
            getTainted: ()=>tainted.color,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.color = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = leadValidateField("color", data.color);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        accountType: {
            path: [
                "accountType"
            ] as const,
            name: "accountType",
            constraints: {
                required: true
            },
            label: "Account Type",
            get: ()=>data.accountType,
            set: (value: string)=>{
                data.accountType = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.accountType,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.accountType = value;
            },
            getTainted: ()=>tainted.accountType,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.accountType = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = leadValidateField("accountType", data.accountType);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        subtype: {
            path: [
                "subtype"
            ] as const,
            name: "subtype",
            constraints: {
                required: true
            },
            label: "Subtype",
            get: ()=>data.subtype,
            set: (value: string)=>{
                data.subtype = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.subtype,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.subtype = value;
            },
            getTainted: ()=>tainted.subtype,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.subtype = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = leadValidateField("subtype", data.subtype);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        isTaxExempt: {
            path: [
                "isTaxExempt"
            ] as const,
            name: "isTaxExempt",
            constraints: {
                required: true
            },
            label: "Tax Exempt",
            get: ()=>data.isTaxExempt,
            set: (value: boolean)=>{
                data.isTaxExempt = value;
            },
            transform: (value: boolean): boolean =>value,
            getError: ()=>errors.isTaxExempt,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.isTaxExempt = value;
            },
            getTainted: ()=>tainted.isTaxExempt,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.isTaxExempt = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = leadValidateField("isTaxExempt", data.isTaxExempt);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        paymentTerms: {
            path: [
                "paymentTerms"
            ] as const,
            name: "paymentTerms",
            constraints: {
                required: true
            },
            label: "Payment Terms",
            get: ()=>data.paymentTerms,
            set: (value: string)=>{
                data.paymentTerms = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.paymentTerms,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.paymentTerms = value;
            },
            getTainted: ()=>tainted.paymentTerms,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.paymentTerms = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = leadValidateField("paymentTerms", data.paymentTerms);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        tags: {
            path: [
                "tags"
            ] as const,
            name: "tags",
            constraints: {
                required: true
            },
            label: "Tags",
            get: ()=>data.tags,
            set: (value: Array<string>)=>{
                data.tags = value;
            },
            transform: (value: Array<string>): Array<string> =>value,
            getError: ()=>errors.tags,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.tags = value;
            },
            getTainted: ()=>tainted.tags,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.tags = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = leadValidateField("tags", data.tags);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            },
            at: (index: number)=>({
                    path: [
                        "tags",
                        index
                    ] as const,
                    name: "'^tags.${index}^'",
                    constraints: {
                        required: true
                    },
                    get: ()=>data.tags[index]!,
                    set: (value: string)=>{
                        data.tags[index] = value;
                    },
                    transform: (value: string): string =>value,
                    getError: ()=>errors.tags,
                    setError: (value: __gf_Option<Array<string>>)=>{
                        errors.tags = value;
                    },
                    getTainted: ()=>tainted.tags,
                    setTainted: (value: __gf_Option<boolean>)=>{
                        tainted.tags = value;
                    },
                    validate: (): Array<string> =>[]
                }),
            push: (item: string)=>{
                data.tags.push(item);
            },
            remove: (index: number)=>{
                data.tags.splice(index, 1);
            },
            swap: (a: number, b: number)=>{
                const tmp = data.tags[a]!;
                data.tags[a] = data.tags[b]!;
                data.tags[b] = tmp;
            }
        },
        customFields: {
            path: [
                "customFields"
            ] as const,
            name: "customFields",
            constraints: {
                required: true
            },
            get: ()=>data.customFields,
            set: (value: Array<[string, string]>)=>{
                data.customFields = value;
            },
            transform: (value: Array<[string, string]>): Array<[string, string]> =>value,
            getError: ()=>errors.customFields,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.customFields = value;
            },
            getTainted: ()=>tainted.customFields,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.customFields = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = leadValidateField("customFields", data.customFields);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            },
            at: (index: number)=>({
                    path: [
                        "customFields",
                        index
                    ] as const,
                    name: "'^customFields.${index}^'",
                    constraints: {
                        required: true
                    },
                    get: ()=>data.customFields[index]!,
                    set: (value: [string, string])=>{
                        data.customFields[index] = value;
                    },
                    transform: (value: [string, string]): [string, string] =>value,
                    getError: ()=>errors.customFields,
                    setError: (value: __gf_Option<Array<string>>)=>{
                        errors.customFields = value;
                    },
                    getTainted: ()=>tainted.customFields,
                    setTainted: (value: __gf_Option<boolean>)=>{
                        tainted.customFields = value;
                    },
                    validate: (): Array<string> =>[]
                }),
            push: (item: [string, string])=>{
                data.customFields.push(item);
            },
            remove: (index: number)=>{
                data.customFields.splice(index, 1);
            },
            swap: (a: number, b: number)=>{
                const tmp = data.customFields[a]!;
                data.customFields[a] = data.customFields[b]!;
                data.customFields[b] = tmp;
            }
        }
    } as LeadFieldControllers;
    const __gf_getter_hint = "get data() set data(v) get errors() set errors(v) get tainted() set tainted(v)";
    const __gf_validate_hint = ".map((e: { field: string; message: string }) => e.message)";
    function validate(): Exit<Lead, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(leadDeserialize(data));
    }
    function reset(newOverrides?: Partial<Lead>): void {
        data = {
            ...leadDefaultValue(),
            ...newOverrides
        };
        errors = {
            _errors: optionNone(),
            id: optionNone(),
            number: optionNone(),
            accepted: optionNone(),
            probability: optionNone(),
            priority: optionNone(),
            dueDate: optionNone(),
            closeDate: optionNone(),
            value: optionNone(),
            stage: optionNone(),
            status: optionNone(),
            description: optionNone(),
            nextStep: optionNone(),
            favorite: optionNone(),
            dateAdded: optionNone(),
            taxRate: optionNone(),
            sector: optionNone(),
            leadName: optionNone(),
            phones: optionNone(),
            email: optionNone(),
            leadSource: optionNone(),
            site: optionNone(),
            memo: optionNone(),
            needsReview: optionNone(),
            hasAlert: optionNone(),
            salesRep: optionNone(),
            color: optionNone(),
            accountType: optionNone(),
            subtype: optionNone(),
            isTaxExempt: optionNone(),
            paymentTerms: optionNone(),
            tags: optionNone(),
            customFields: optionNone()
        };
        tainted = {
            id: optionNone(),
            number: optionNone(),
            accepted: optionNone(),
            probability: optionNone(),
            priority: optionNone(),
            dueDate: optionNone(),
            closeDate: optionNone(),
            value: optionNone(),
            stage: optionNone(),
            status: optionNone(),
            description: optionNone(),
            nextStep: optionNone(),
            favorite: optionNone(),
            dateAdded: optionNone(),
            taxRate: optionNone(),
            sector: optionNone(),
            leadName: optionNone(),
            phones: optionNone(),
            email: optionNone(),
            leadSource: optionNone(),
            site: optionNone(),
            memo: optionNone(),
            needsReview: optionNone(),
            hasAlert: optionNone(),
            salesRep: optionNone(),
            color: optionNone(),
            accountType: optionNone(),
            subtype: optionNone(),
            isTaxExempt: optionNone(),
            paymentTerms: optionNone(),
            tags: optionNone(),
            customFields: optionNone()
        };
    }
    return {
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        fields,
        validate,
        reset
    };
}
export function leadFromFormData(formData: FormData): Exit<Lead, Array<{
    field: string;
    message: string;
}>> {
    const obj: Record<string, unknown> = {};
    const __gf_exit_hint = "Exit<Lead, Array<{ field: string; message: string }>>";
    obj.id = formData.get(`${"id"}`) ?? "";
    {
        const numberStr = formData.get(`${"number"}`);
        obj.number = numberStr ? parseFloat(numberStr as string) : $MfPh5;
        if (obj.number !== undefined && isNaN(obj.number as number)) obj.number = "0";
    }
    {
        const acceptedVal = formData.get(`${"accepted"}`);
        obj.accepted = acceptedVal === "true" || acceptedVal === "on" || acceptedVal === "1";
    }
    {
        const probabilityStr = formData.get(`${"probability"}`);
        obj.probability = probabilityStr ? parseFloat(probabilityStr as string) : $MfPh5;
        if (obj.probability !== undefined && isNaN(obj.probability as number)) obj.probability = "0";
    }
    {
        const priorityObj: Record<string, unknown> = {};
        for (const [key, value] of Array.from(formData.entries())){
            if (key.startsWith(`${"priority"}.`)) {
                const fieldName = key.slice(`${"priority"}.`.length);
                const parts = fieldName.split(".");
                let current = priorityObj;
                for(let i = 0; i < parts.length - 1; i++){
                    const part = parts[i]!;
                    if (!(part in current)) {
                        current[part] = {};
                    }
                    current = current[part] as Record<string, unknown>;
                }
                current[parts[parts.length - 1]!] = value;
            }
        }
        obj.priority = priorityObj;
    }
    obj.dueDate = formData.get(`${"dueDate"}`) ?? "";
    obj.closeDate = formData.get(`${"closeDate"}`) ?? "";
    {
        const valueStr = formData.get(`${"value"}`);
        obj.value = valueStr ? parseFloat(valueStr as string) : $MfPh5;
        if (obj.value !== undefined && isNaN(obj.value as number)) obj.value = "0";
    }
    {
        const stageObj: Record<string, unknown> = {};
        for (const [key, value] of Array.from(formData.entries())){
            if (key.startsWith(`${"stage"}.`)) {
                const fieldName = key.slice(`${"stage"}.`.length);
                const parts = fieldName.split(".");
                let current = stageObj;
                for(let i = 0; i < parts.length - 1; i++){
                    const part = parts[i]!;
                    if (!(part in current)) {
                        current[part] = {};
                    }
                    current = current[part] as Record<string, unknown>;
                }
                current[parts[parts.length - 1]!] = value;
            }
        }
        obj.stage = stageObj;
    }
    obj.status = formData.get(`${"status"}`) ?? "";
    obj.description = formData.get(`${"description"}`) ?? "";
    {
        const nextStepObj: Record<string, unknown> = {};
        for (const [key, value] of Array.from(formData.entries())){
            if (key.startsWith(`${"nextStep"}.`)) {
                const fieldName = key.slice(`${"nextStep"}.`.length);
                const parts = fieldName.split(".");
                let current = nextStepObj;
                for(let i = 0; i < parts.length - 1; i++){
                    const part = parts[i]!;
                    if (!(part in current)) {
                        current[part] = {};
                    }
                    current = current[part] as Record<string, unknown>;
                }
                current[parts[parts.length - 1]!] = value;
            }
        }
        obj.nextStep = nextStepObj;
    }
    {
        const favoriteVal = formData.get(`${"favorite"}`);
        obj.favorite = favoriteVal === "true" || favoriteVal === "on" || favoriteVal === "1";
    }
    obj.dateAdded = formData.get(`${"dateAdded"}`) ?? "";
    obj.taxRate = formData.get(`${"taxRate"}`) ?? "";
    {
        const sectorObj: Record<string, unknown> = {};
        for (const [key, value] of Array.from(formData.entries())){
            if (key.startsWith(`${"sector"}.`)) {
                const fieldName = key.slice(`${"sector"}.`.length);
                const parts = fieldName.split(".");
                let current = sectorObj;
                for(let i = 0; i < parts.length - 1; i++){
                    const part = parts[i]!;
                    if (!(part in current)) {
                        current[part] = {};
                    }
                    current = current[part] as Record<string, unknown>;
                }
                current[parts[parts.length - 1]!] = value;
            }
        }
        obj.sector = sectorObj;
    }
    {
        const leadNameObj: Record<string, unknown> = {};
        for (const [key, value] of Array.from(formData.entries())){
            if (key.startsWith(`${"leadName"}.`)) {
                const fieldName = key.slice(`${"leadName"}.`.length);
                const parts = fieldName.split(".");
                let current = leadNameObj;
                for(let i = 0; i < parts.length - 1; i++){
                    const part = parts[i]!;
                    if (!(part in current)) {
                        current[part] = {};
                    }
                    current = current[part] as Record<string, unknown>;
                }
                current[parts[parts.length - 1]!] = value;
            }
        }
        obj.leadName = leadNameObj;
    }
    {
        const phonesItems: Array<Record<string, unknown>> = [];
        let idx = 0;
        while(formData.has(`${"phones"}.` + idx + ".") || idx === 0){
            const hasAny = Array.from(formData.keys()).some((k)=>k.startsWith(`${"phones"}.` + idx + "."));
            if (!hasAny && idx > 0) break;
            if (hasAny) {
                const item: Record<string, unknown> = {};
                for (const [key, value] of Array.from(formData.entries())){
                    if (key.startsWith(`${"phones"}.` + idx + ".")) {
                        const fieldName = key.slice(`${"phones"}.`.length + String(idx).length + 1);
                        item[fieldName] = value;
                    }
                }
                phonesItems.push(item);
            }
            idx++;
            if (idx > 1000) break;
        }
        obj.phones = phonesItems;
    }
    {
        const emailObj: Record<string, unknown> = {};
        for (const [key, value] of Array.from(formData.entries())){
            if (key.startsWith(`${"email"}.`)) {
                const fieldName = key.slice(`${"email"}.`.length);
                const parts = fieldName.split(".");
                let current = emailObj;
                for(let i = 0; i < parts.length - 1; i++){
                    const part = parts[i]!;
                    if (!(part in current)) {
                        current[part] = {};
                    }
                    current = current[part] as Record<string, unknown>;
                }
                current[parts[parts.length - 1]!] = value;
            }
        }
        obj.email = emailObj;
    }
    obj.leadSource = formData.get(`${"leadSource"}`) ?? "";
    obj.site = formData.get(`${"site"}`) ?? "";
    obj.memo = formData.get(`${"memo"}`) ?? "";
    {
        const needsReviewVal = formData.get(`${"needsReview"}`);
        obj.needsReview = needsReviewVal === "true" || needsReviewVal === "on" || needsReviewVal === "1";
    }
    {
        const hasAlertVal = formData.get(`${"hasAlert"}`);
        obj.hasAlert = hasAlertVal === "true" || hasAlertVal === "on" || hasAlertVal === "1";
    }
    obj.salesRep = formData.get(`${"salesRep"}`) ?? "";
    obj.color = formData.get(`${"color"}`) ?? "";
    obj.accountType = formData.get(`${"accountType"}`) ?? "";
    obj.subtype = formData.get(`${"subtype"}`) ?? "";
    {
        const isTaxExemptVal = formData.get(`${"isTaxExempt"}`);
        obj.isTaxExempt = isTaxExemptVal === "true" || isTaxExemptVal === "on" || isTaxExemptVal === "1";
    }
    obj.paymentTerms = formData.get(`${"paymentTerms"}`) ?? "";
    obj.tags = formData.getAll(`${"tags"}`) as Array<string>;
    {
        const customFieldsItems: Array<Record<string, unknown>> = [];
        let idx = 0;
        while(formData.has(`${"customFields"}.` + idx + ".") || idx === 0){
            const hasAny = Array.from(formData.keys()).some((k)=>k.startsWith(`${"customFields"}.` + idx + "."));
            if (!hasAny && idx > 0) break;
            if (hasAny) {
                const item: Record<string, unknown> = {};
                for (const [key, value] of Array.from(formData.entries())){
                    if (key.startsWith(`${"customFields"}.` + idx + ".")) {
                        const fieldName = key.slice(`${"customFields"}.`.length + String(idx).length + 1);
                        item[fieldName] = value;
                    }
                }
                customFieldsItems.push(item);
            }
            idx++;
            if (idx > 1000) break;
        }
        obj.customFields = customFieldsItems;
    }
    return toExit(leadDeserialize(obj));
}

export const Lead = {
  defaultValue: leadDefaultValue,
  serialize: leadSerialize,
  serializeWithContext: leadSerializeWithContext,
  deserialize: leadDeserialize,
  deserializeWithContext: leadDeserializeWithContext,
  validateFields: leadValidateFields,
  hasShape: leadHasShape,
  is: leadIs,
  createForm: leadCreateForm,
  fromFormData: leadFromFormData
} as const;


export interface AppPermissions {
    applications: Array<Applications>;
    pages: Array<Page>;
    data: Array<Table>;
}

export function appPermissionsDefaultValue(): AppPermissions {
    return {
        applications: [],
        pages: [],
        data: []
    } as AppPermissions;
}

export function appPermissionsSerialize(value: AppPermissions): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(appPermissionsSerializeWithContext(value, ctx));
}
export function appPermissionsSerializeWithContext(value: AppPermissions, ctx: __mf_SerializeContext): Record<string, unknown> {
    const existingId = ctx.getId(value);
    if (existingId !== undefined) {
        return {
            __ref: existingId
        };
    }
    const __id = ctx.register(value);
    const result: Record<string, unknown> = {
        __type: "AppPermissions",
        __id
    };
    result.applications = value.applications.map((item)=>applicationsSerializeWithContext(item, ctx));
    result.pages = value.pages.map((item)=>pageSerializeWithContext(item, ctx));
    result.data = value.data.map((item)=>tableSerializeWithContext(item, ctx));
    return result;
}

export function appPermissionsDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: AppPermissions } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = appPermissionsDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "AppPermissions.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function appPermissionsDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): AppPermissions | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
        throw new __mf_DeserializeError([
            {
                field: "_root",
                message: `${"AppPermissions"}.deserializeWithContext: expected an object`
            }
        ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (!("applications" in obj)) {
        errors.push({
            field: "applications",
            message: "missing required field"
        });
    }
    if (!("pages" in obj)) {
        errors.push({
            field: "pages",
            message: "missing required field"
        });
    }
    if (!("data" in obj)) {
        errors.push({
            field: "data",
            message: "missing required field"
        });
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
        ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
        const __raw_applications = obj["applications"] as Array<Applications>;
        if (Array.isArray(__raw_applications)) {
            instance.applications = __raw_applications as Applications[];
        }
    }
    {
        const __raw_pages = obj["pages"] as Array<Page>;
        if (Array.isArray(__raw_pages)) {
            instance.pages = __raw_pages as Page[];
        }
    }
    {
        const __raw_data = obj["data"] as Array<Table>;
        if (Array.isArray(__raw_data)) {
            instance.data = __raw_data as Table[];
        }
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    return instance as AppPermissions;
}
export function appPermissionsValidateField<K extends keyof AppPermissions>(_field: K, _value: AppPermissions[K]): Array<{
    field: string;
    message: string;
}> {
    return [];
}
export function appPermissionsValidateFields(_partial: Partial<AppPermissions>): Array<{
    field: string;
    message: string;
}> {
    return [];
}
export function appPermissionsHasShape(obj: unknown): boolean {
    if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
        return false;
    }
    const o = obj as Record<string, unknown>;
    return '"applications" in o && "pages" in o && "data" in o';
}
export function appPermissionsIs(obj: unknown): obj is AppPermissions {
    if (!appPermissionsHasShape(obj)) {
        return false;
    }
    const result = appPermissionsDeserialize(obj);
    return result.success;
}

export type AppPermissionsErrors = {
    _errors: __gf_Option<Array<string>>;
    applications: __gf_Option<Array<string>>;
    pages: __gf_Option<Array<string>>;
    data: __gf_Option<Array<string>>;
};
export type AppPermissionsTainted = {
    applications: __gf_Option<boolean>;
    pages: __gf_Option<boolean>;
    data: __gf_Option<boolean>;
};
export interface AppPermissionsFieldControllers {
    readonly applications: ArrayFieldController<Applications>;
    readonly pages: ArrayFieldController<Page>;
    readonly data: ArrayFieldController<Table>;
}
export interface AppPermissionsGigaform {
    readonly data: AppPermissions;
    readonly errors: AppPermissionsErrors;
    readonly tainted: AppPermissionsTainted;
    readonly fields: AppPermissionsFieldControllers;
    validate(): Exit<AppPermissions, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<AppPermissions>): void;
}
export function appPermissionsCreateForm(overrides?: Partial<AppPermissions>): AppPermissionsGigaform {
    let data = $state({
        ...appPermissionsDefaultValue(),
        ...overrides
    });
    let errors = $state<AppPermissionsErrors>({
        _errors: optionNone(),
        applications: optionNone(),
        pages: optionNone(),
        data: optionNone()
    } as AppPermissionsErrors);
    let tainted = $state<AppPermissionsTainted>({
        applications: optionNone(),
        pages: optionNone(),
        data: optionNone()
    } as AppPermissionsTainted);
    const fields = {
        applications: {
            path: [
                "applications"
            ] as const,
            name: "applications",
            constraints: {
                required: true
            },
            get: ()=>data.applications,
            set: (value: Array<Applications>)=>{
                data.applications = value;
            },
            transform: (value: Array<Applications>): Array<Applications> =>value,
            getError: ()=>errors.applications,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.applications = value;
            },
            getTainted: ()=>tainted.applications,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.applications = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = appPermissionsValidateField("applications", data.applications);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            },
            at: (index: number)=>({
                    path: [
                        "applications",
                        index
                    ] as const,
                    name: "'^applications.${index}^'",
                    constraints: {
                        required: true
                    },
                    get: ()=>data.applications[index]!,
                    set: (value: Applications)=>{
                        data.applications[index] = value;
                    },
                    transform: (value: Applications): Applications =>value,
                    getError: ()=>errors.applications,
                    setError: (value: __gf_Option<Array<string>>)=>{
                        errors.applications = value;
                    },
                    getTainted: ()=>tainted.applications,
                    setTainted: (value: __gf_Option<boolean>)=>{
                        tainted.applications = value;
                    },
                    validate: (): Array<string> =>[]
                }),
            push: (item: Applications)=>{
                data.applications.push(item);
            },
            remove: (index: number)=>{
                data.applications.splice(index, 1);
            },
            swap: (a: number, b: number)=>{
                const tmp = data.applications[a]!;
                data.applications[a] = data.applications[b]!;
                data.applications[b] = tmp;
            }
        },
        pages: {
            path: [
                "pages"
            ] as const,
            name: "pages",
            constraints: {
                required: true
            },
            get: ()=>data.pages,
            set: (value: Array<Page>)=>{
                data.pages = value;
            },
            transform: (value: Array<Page>): Array<Page> =>value,
            getError: ()=>errors.pages,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.pages = value;
            },
            getTainted: ()=>tainted.pages,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.pages = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = appPermissionsValidateField("pages", data.pages);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            },
            at: (index: number)=>({
                    path: [
                        "pages",
                        index
                    ] as const,
                    name: "'^pages.${index}^'",
                    constraints: {
                        required: true
                    },
                    get: ()=>data.pages[index]!,
                    set: (value: Page)=>{
                        data.pages[index] = value;
                    },
                    transform: (value: Page): Page =>value,
                    getError: ()=>errors.pages,
                    setError: (value: __gf_Option<Array<string>>)=>{
                        errors.pages = value;
                    },
                    getTainted: ()=>tainted.pages,
                    setTainted: (value: __gf_Option<boolean>)=>{
                        tainted.pages = value;
                    },
                    validate: (): Array<string> =>[]
                }),
            push: (item: Page)=>{
                data.pages.push(item);
            },
            remove: (index: number)=>{
                data.pages.splice(index, 1);
            },
            swap: (a: number, b: number)=>{
                const tmp = data.pages[a]!;
                data.pages[a] = data.pages[b]!;
                data.pages[b] = tmp;
            }
        },
        data: {
            path: [
                "data"
            ] as const,
            name: "data",
            constraints: {
                required: true
            },
            get: ()=>data.data,
            set: (value: Array<Table>)=>{
                data.data = value;
            },
            transform: (value: Array<Table>): Array<Table> =>value,
            getError: ()=>errors.data,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.data = value;
            },
            getTainted: ()=>tainted.data,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.data = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = appPermissionsValidateField("data", data.data);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            },
            at: (index: number)=>({
                    path: [
                        "data",
                        index
                    ] as const,
                    name: "'^data.${index}^'",
                    constraints: {
                        required: true
                    },
                    get: ()=>data.data[index]!,
                    set: (value: Table)=>{
                        data.data[index] = value;
                    },
                    transform: (value: Table): Table =>value,
                    getError: ()=>errors.data,
                    setError: (value: __gf_Option<Array<string>>)=>{
                        errors.data = value;
                    },
                    getTainted: ()=>tainted.data,
                    setTainted: (value: __gf_Option<boolean>)=>{
                        tainted.data = value;
                    },
                    validate: (): Array<string> =>[]
                }),
            push: (item: Table)=>{
                data.data.push(item);
            },
            remove: (index: number)=>{
                data.data.splice(index, 1);
            },
            swap: (a: number, b: number)=>{
                const tmp = data.data[a]!;
                data.data[a] = data.data[b]!;
                data.data[b] = tmp;
            }
        }
    } as AppPermissionsFieldControllers;
    const __gf_getter_hint = "get data() set data(v) get errors() set errors(v) get tainted() set tainted(v)";
    const __gf_validate_hint = ".map((e: { field: string; message: string }) => e.message)";
    function validate(): Exit<AppPermissions, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(appPermissionsDeserialize(data));
    }
    function reset(newOverrides?: Partial<AppPermissions>): void {
        data = {
            ...appPermissionsDefaultValue(),
            ...newOverrides
        };
        errors = {
            _errors: optionNone(),
            applications: optionNone(),
            pages: optionNone(),
            data: optionNone()
        };
        tainted = {
            applications: optionNone(),
            pages: optionNone(),
            data: optionNone()
        };
    }
    return {
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        fields,
        validate,
        reset
    };
}
export function appPermissionsFromFormData(formData: FormData): Exit<AppPermissions, Array<{
    field: string;
    message: string;
}>> {
    const obj: Record<string, unknown> = {};
    const __gf_exit_hint = "Exit<AppPermissions, Array<{ field: string; message: string }>>";
    {
        const applicationsItems: Array<Record<string, unknown>> = [];
        let idx = 0;
        while(formData.has(`${"applications"}.` + idx + ".") || idx === 0){
            const hasAny = Array.from(formData.keys()).some((k)=>k.startsWith(`${"applications"}.` + idx + "."));
            if (!hasAny && idx > 0) break;
            if (hasAny) {
                const item: Record<string, unknown> = {};
                for (const [key, value] of Array.from(formData.entries())){
                    if (key.startsWith(`${"applications"}.` + idx + ".")) {
                        const fieldName = key.slice(`${"applications"}.`.length + String(idx).length + 1);
                        item[fieldName] = value;
                    }
                }
                applicationsItems.push(item);
            }
            idx++;
            if (idx > 1000) break;
        }
        obj.applications = applicationsItems;
    }
    {
        const pagesItems: Array<Record<string, unknown>> = [];
        let idx = 0;
        while(formData.has(`${"pages"}.` + idx + ".") || idx === 0){
            const hasAny = Array.from(formData.keys()).some((k)=>k.startsWith(`${"pages"}.` + idx + "."));
            if (!hasAny && idx > 0) break;
            if (hasAny) {
                const item: Record<string, unknown> = {};
                for (const [key, value] of Array.from(formData.entries())){
                    if (key.startsWith(`${"pages"}.` + idx + ".")) {
                        const fieldName = key.slice(`${"pages"}.`.length + String(idx).length + 1);
                        item[fieldName] = value;
                    }
                }
                pagesItems.push(item);
            }
            idx++;
            if (idx > 1000) break;
        }
        obj.pages = pagesItems;
    }
    {
        const dataItems: Array<Record<string, unknown>> = [];
        let idx = 0;
        while(formData.has(`${"data"}.` + idx + ".") || idx === 0){
            const hasAny = Array.from(formData.keys()).some((k)=>k.startsWith(`${"data"}.` + idx + "."));
            if (!hasAny && idx > 0) break;
            if (hasAny) {
                const item: Record<string, unknown> = {};
                for (const [key, value] of Array.from(formData.entries())){
                    if (key.startsWith(`${"data"}.` + idx + ".")) {
                        const fieldName = key.slice(`${"data"}.`.length + String(idx).length + 1);
                        item[fieldName] = value;
                    }
                }
                dataItems.push(item);
            }
            idx++;
            if (idx > 1000) break;
        }
        obj.data = dataItems;
    }
    return toExit(appPermissionsDeserialize(obj));
}

export const AppPermissions = {
  defaultValue: appPermissionsDefaultValue,
  serialize: appPermissionsSerialize,
  serializeWithContext: appPermissionsSerializeWithContext,
  deserialize: appPermissionsDeserialize,
  deserializeWithContext: appPermissionsDeserializeWithContext,
  validateFields: appPermissionsValidateFields,
  hasShape: appPermissionsHasShape,
  is: appPermissionsIs,
  createForm: appPermissionsCreateForm,
  fromFormData: appPermissionsFromFormData
} as const;


export interface Company {
    id: string;
    
    legalName: string;
    
    headquarters: string | Site;
    phones: Array<PhoneNumber>;
    
    fax: string;
    
    email: string;
    
    website: string;
    
    taxId: string;
    referenceNumber: number;
    
    postalCodeLookup: string;
    timeZone: string;
    
    defaultTax: string | TaxRate;
    
    defaultTaxLocation: string;
    defaultAreaCode: number;
    
    defaultAccountType: string;
    
    lookupFormatting: string;
    
    accountNameFormat: string;
    merchantServiceProvider: string | null;
    
    dateDisplayStyle: string;
    hasAutoCommission: boolean;
    hasAutoDaylightSavings: boolean;
    hasAutoFmsTracking: boolean;
    hasNotifications: boolean;
    hasRequiredLeadSource: boolean;
    hasRequiredEmail: boolean;
    hasSortServiceItemsAlphabetically: boolean;
    hasAttachOrderToAppointmentEmails: boolean;
    scheduleInterval: number;
    colorsConfig: ColorsConfig;
}

export function companyDefaultValue(): Company {
    return {
        id: "",
        legalName: "",
        headquarters: "",
        phones: [],
        fax: "",
        email: "",
        website: "",
        taxId: "",
        referenceNumber: 0,
        postalCodeLookup: "",
        timeZone: "",
        defaultTax: "",
        defaultTaxLocation: "",
        defaultAreaCode: 0,
        defaultAccountType: "",
        lookupFormatting: "",
        accountNameFormat: "",
        merchantServiceProvider: null,
        dateDisplayStyle: "",
        hasAutoCommission: false,
        hasAutoDaylightSavings: false,
        hasAutoFmsTracking: false,
        hasNotifications: false,
        hasRequiredLeadSource: false,
        hasRequiredEmail: false,
        hasSortServiceItemsAlphabetically: false,
        hasAttachOrderToAppointmentEmails: false,
        scheduleInterval: 0,
        colorsConfig: colorsConfigDefaultValue()
    } as Company;
}

export function companySerialize(value: Company): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(companySerializeWithContext(value, ctx));
}
export function companySerializeWithContext(value: Company, ctx: __mf_SerializeContext): Record<string, unknown> {
    const existingId = ctx.getId(value);
    if (existingId !== undefined) {
        return {
            __ref: existingId
        };
    }
    const __id = ctx.register(value);
    const result: Record<string, unknown> = {
        __type: "Company",
        __id
    };
    result.id = value.id;
    result.legalName = value.legalName;
    result.headquarters = value.headquarters;
    result.phones = value.phones.map((item)=>phoneNumberSerializeWithContext(item, ctx));
    result.fax = value.fax;
    result.email = value.email;
    result.website = value.website;
    result.taxId = value.taxId;
    result.referenceNumber = value.referenceNumber;
    result.postalCodeLookup = value.postalCodeLookup;
    result.timeZone = value.timeZone;
    result.defaultTax = value.defaultTax;
    result.defaultTaxLocation = value.defaultTaxLocation;
    result.defaultAreaCode = value.defaultAreaCode;
    result.defaultAccountType = value.defaultAccountType;
    result.lookupFormatting = value.lookupFormatting;
    result.accountNameFormat = value.accountNameFormat;
    result.merchantServiceProvider = value.merchantServiceProvider;
    result.dateDisplayStyle = value.dateDisplayStyle;
    result.hasAutoCommission = value.hasAutoCommission;
    result.hasAutoDaylightSavings = value.hasAutoDaylightSavings;
    result.hasAutoFmsTracking = value.hasAutoFmsTracking;
    result.hasNotifications = value.hasNotifications;
    result.hasRequiredLeadSource = value.hasRequiredLeadSource;
    result.hasRequiredEmail = value.hasRequiredEmail;
    result.hasSortServiceItemsAlphabetically = value.hasSortServiceItemsAlphabetically;
    result.hasAttachOrderToAppointmentEmails = value.hasAttachOrderToAppointmentEmails;
    result.scheduleInterval = value.scheduleInterval;
    result.colorsConfig = colorsConfigSerializeWithContext(value.colorsConfig, ctx);
    return result;
}

export function companyDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: Company } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = companyDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "Company.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function companyDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Company | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
        throw new __mf_DeserializeError([
            {
                field: "_root",
                message: `${"Company"}.deserializeWithContext: expected an object`
            }
        ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (!("id" in obj)) {
        errors.push({
            field: "id",
            message: "missing required field"
        });
    }
    if (!("legalName" in obj)) {
        errors.push({
            field: "legalName",
            message: "missing required field"
        });
    }
    if (!("headquarters" in obj)) {
        errors.push({
            field: "headquarters",
            message: "missing required field"
        });
    }
    if (!("phones" in obj)) {
        errors.push({
            field: "phones",
            message: "missing required field"
        });
    }
    if (!("fax" in obj)) {
        errors.push({
            field: "fax",
            message: "missing required field"
        });
    }
    if (!("email" in obj)) {
        errors.push({
            field: "email",
            message: "missing required field"
        });
    }
    if (!("website" in obj)) {
        errors.push({
            field: "website",
            message: "missing required field"
        });
    }
    if (!("taxId" in obj)) {
        errors.push({
            field: "taxId",
            message: "missing required field"
        });
    }
    if (!("referenceNumber" in obj)) {
        errors.push({
            field: "referenceNumber",
            message: "missing required field"
        });
    }
    if (!("postalCodeLookup" in obj)) {
        errors.push({
            field: "postalCodeLookup",
            message: "missing required field"
        });
    }
    if (!("timeZone" in obj)) {
        errors.push({
            field: "timeZone",
            message: "missing required field"
        });
    }
    if (!("defaultTax" in obj)) {
        errors.push({
            field: "defaultTax",
            message: "missing required field"
        });
    }
    if (!("defaultTaxLocation" in obj)) {
        errors.push({
            field: "defaultTaxLocation",
            message: "missing required field"
        });
    }
    if (!("defaultAreaCode" in obj)) {
        errors.push({
            field: "defaultAreaCode",
            message: "missing required field"
        });
    }
    if (!("defaultAccountType" in obj)) {
        errors.push({
            field: "defaultAccountType",
            message: "missing required field"
        });
    }
    if (!("lookupFormatting" in obj)) {
        errors.push({
            field: "lookupFormatting",
            message: "missing required field"
        });
    }
    if (!("accountNameFormat" in obj)) {
        errors.push({
            field: "accountNameFormat",
            message: "missing required field"
        });
    }
    if (!("merchantServiceProvider" in obj)) {
        errors.push({
            field: "merchantServiceProvider",
            message: "missing required field"
        });
    }
    if (!("dateDisplayStyle" in obj)) {
        errors.push({
            field: "dateDisplayStyle",
            message: "missing required field"
        });
    }
    if (!("hasAutoCommission" in obj)) {
        errors.push({
            field: "hasAutoCommission",
            message: "missing required field"
        });
    }
    if (!("hasAutoDaylightSavings" in obj)) {
        errors.push({
            field: "hasAutoDaylightSavings",
            message: "missing required field"
        });
    }
    if (!("hasAutoFmsTracking" in obj)) {
        errors.push({
            field: "hasAutoFmsTracking",
            message: "missing required field"
        });
    }
    if (!("hasNotifications" in obj)) {
        errors.push({
            field: "hasNotifications",
            message: "missing required field"
        });
    }
    if (!("hasRequiredLeadSource" in obj)) {
        errors.push({
            field: "hasRequiredLeadSource",
            message: "missing required field"
        });
    }
    if (!("hasRequiredEmail" in obj)) {
        errors.push({
            field: "hasRequiredEmail",
            message: "missing required field"
        });
    }
    if (!("hasSortServiceItemsAlphabetically" in obj)) {
        errors.push({
            field: "hasSortServiceItemsAlphabetically",
            message: "missing required field"
        });
    }
    if (!("hasAttachOrderToAppointmentEmails" in obj)) {
        errors.push({
            field: "hasAttachOrderToAppointmentEmails",
            message: "missing required field"
        });
    }
    if (!("scheduleInterval" in obj)) {
        errors.push({
            field: "scheduleInterval",
            message: "missing required field"
        });
    }
    if (!("colorsConfig" in obj)) {
        errors.push({
            field: "colorsConfig",
            message: "missing required field"
        });
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
        ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
        const __raw_id = obj["id"] as string;
        instance.id = __raw_id;
    }
    {
        const __raw_legalName = obj["legalName"] as string;
        if (__raw_legalName.trim().length === 0) {
            errors.push({
                field: "legalName",
                message: "Company.legalName must not be empty"
            });
        }
        instance.legalName = __raw_legalName;
    }
    {
        const __raw_headquarters = obj["headquarters"] as string | Site;
        instance.headquarters = __raw_headquarters;
    }
    {
        const __raw_phones = obj["phones"] as Array<PhoneNumber>;
        if (Array.isArray(__raw_phones)) {
            instance.phones = __raw_phones as PhoneNumber[];
        }
    }
    {
        const __raw_fax = obj["fax"] as string;
        if (__raw_fax.trim().length === 0) {
            errors.push({
                field: "fax",
                message: "Company.fax must not be empty"
            });
        }
        instance.fax = __raw_fax;
    }
    {
        const __raw_email = obj["email"] as string;
        if (__raw_email.trim().length === 0) {
            errors.push({
                field: "email",
                message: "Company.email must not be empty"
            });
        }
        instance.email = __raw_email;
    }
    {
        const __raw_website = obj["website"] as string;
        if (__raw_website.trim().length === 0) {
            errors.push({
                field: "website",
                message: "Company.website must not be empty"
            });
        }
        instance.website = __raw_website;
    }
    {
        const __raw_taxId = obj["taxId"] as string;
        if (__raw_taxId.trim().length === 0) {
            errors.push({
                field: "taxId",
                message: "Company.taxId must not be empty"
            });
        }
        instance.taxId = __raw_taxId;
    }
    {
        const __raw_referenceNumber = obj["referenceNumber"] as number;
        instance.referenceNumber = __raw_referenceNumber;
    }
    {
        const __raw_postalCodeLookup = obj["postalCodeLookup"] as string;
        if (__raw_postalCodeLookup.trim().length === 0) {
            errors.push({
                field: "postalCodeLookup",
                message: "Company.postalCodeLookup must not be empty"
            });
        }
        instance.postalCodeLookup = __raw_postalCodeLookup;
    }
    {
        const __raw_timeZone = obj["timeZone"] as string;
        instance.timeZone = __raw_timeZone;
    }
    {
        const __raw_defaultTax = obj["defaultTax"] as string | TaxRate;
        instance.defaultTax = __raw_defaultTax;
    }
    {
        const __raw_defaultTaxLocation = obj["defaultTaxLocation"] as string;
        if (__raw_defaultTaxLocation.trim().length === 0) {
            errors.push({
                field: "defaultTaxLocation",
                message: "Company.defaultTaxLocation must not be empty"
            });
        }
        instance.defaultTaxLocation = __raw_defaultTaxLocation;
    }
    {
        const __raw_defaultAreaCode = obj["defaultAreaCode"] as number;
        instance.defaultAreaCode = __raw_defaultAreaCode;
    }
    {
        const __raw_defaultAccountType = obj["defaultAccountType"] as string;
        if (__raw_defaultAccountType.trim().length === 0) {
            errors.push({
                field: "defaultAccountType",
                message: "Company.defaultAccountType must not be empty"
            });
        }
        instance.defaultAccountType = __raw_defaultAccountType;
    }
    {
        const __raw_lookupFormatting = obj["lookupFormatting"] as string;
        if (__raw_lookupFormatting.trim().length === 0) {
            errors.push({
                field: "lookupFormatting",
                message: "Company.lookupFormatting must not be empty"
            });
        }
        instance.lookupFormatting = __raw_lookupFormatting;
    }
    {
        const __raw_accountNameFormat = obj["accountNameFormat"] as string;
        if (__raw_accountNameFormat.trim().length === 0) {
            errors.push({
                field: "accountNameFormat",
                message: "Company.accountNameFormat must not be empty"
            });
        }
        instance.accountNameFormat = __raw_accountNameFormat;
    }
    {
        const __raw_merchantServiceProvider = obj["merchantServiceProvider"] as string | null;
        instance.merchantServiceProvider = __raw_merchantServiceProvider;
    }
    {
        const __raw_dateDisplayStyle = obj["dateDisplayStyle"] as string;
        if (__raw_dateDisplayStyle.trim().length === 0) {
            errors.push({
                field: "dateDisplayStyle",
                message: "Company.dateDisplayStyle must not be empty"
            });
        }
        instance.dateDisplayStyle = __raw_dateDisplayStyle;
    }
    {
        const __raw_hasAutoCommission = obj["hasAutoCommission"] as boolean;
        instance.hasAutoCommission = __raw_hasAutoCommission;
    }
    {
        const __raw_hasAutoDaylightSavings = obj["hasAutoDaylightSavings"] as boolean;
        instance.hasAutoDaylightSavings = __raw_hasAutoDaylightSavings;
    }
    {
        const __raw_hasAutoFmsTracking = obj["hasAutoFmsTracking"] as boolean;
        instance.hasAutoFmsTracking = __raw_hasAutoFmsTracking;
    }
    {
        const __raw_hasNotifications = obj["hasNotifications"] as boolean;
        instance.hasNotifications = __raw_hasNotifications;
    }
    {
        const __raw_hasRequiredLeadSource = obj["hasRequiredLeadSource"] as boolean;
        instance.hasRequiredLeadSource = __raw_hasRequiredLeadSource;
    }
    {
        const __raw_hasRequiredEmail = obj["hasRequiredEmail"] as boolean;
        instance.hasRequiredEmail = __raw_hasRequiredEmail;
    }
    {
        const __raw_hasSortServiceItemsAlphabetically = obj["hasSortServiceItemsAlphabetically"] as boolean;
        instance.hasSortServiceItemsAlphabetically = __raw_hasSortServiceItemsAlphabetically;
    }
    {
        const __raw_hasAttachOrderToAppointmentEmails = obj["hasAttachOrderToAppointmentEmails"] as boolean;
        instance.hasAttachOrderToAppointmentEmails = __raw_hasAttachOrderToAppointmentEmails;
    }
    {
        const __raw_scheduleInterval = obj["scheduleInterval"] as number;
        instance.scheduleInterval = __raw_scheduleInterval;
    }
    {
        const __raw_colorsConfig = obj["colorsConfig"] as ColorsConfig;
        {
            const __result = colorsConfigDeserializeWithContext(__raw_colorsConfig, ctx);
            ctx.assignOrDefer(instance, "colorsConfig", __result);
        }
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    return instance as Company;
}
export function companyValidateField<K extends keyof Company>(_field: K, _value: Company[K]): Array<{
    field: string;
    message: string;
}> {
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (_field === "legalName") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "legalName",
                message: "Company.legalName must not be empty"
            });
        }
    }
    if (_field === "fax") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "fax",
                message: "Company.fax must not be empty"
            });
        }
    }
    if (_field === "email") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "email",
                message: "Company.email must not be empty"
            });
        }
    }
    if (_field === "website") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "website",
                message: "Company.website must not be empty"
            });
        }
    }
    if (_field === "taxId") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "taxId",
                message: "Company.taxId must not be empty"
            });
        }
    }
    if (_field === "postalCodeLookup") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "postalCodeLookup",
                message: "Company.postalCodeLookup must not be empty"
            });
        }
    }
    if (_field === "defaultTaxLocation") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "defaultTaxLocation",
                message: "Company.defaultTaxLocation must not be empty"
            });
        }
    }
    if (_field === "defaultAccountType") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "defaultAccountType",
                message: "Company.defaultAccountType must not be empty"
            });
        }
    }
    if (_field === "lookupFormatting") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "lookupFormatting",
                message: "Company.lookupFormatting must not be empty"
            });
        }
    }
    if (_field === "accountNameFormat") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "accountNameFormat",
                message: "Company.accountNameFormat must not be empty"
            });
        }
    }
    if (_field === "dateDisplayStyle") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "dateDisplayStyle",
                message: "Company.dateDisplayStyle must not be empty"
            });
        }
    }
    return errors;
}
export function companyValidateFields(_partial: Partial<Company>): Array<{
    field: string;
    message: string;
}> {
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if ("legalName" in _partial && _partial.legalName !== undefined) {
        const __val = _partial.legalName as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "legalName",
                message: "Company.legalName must not be empty"
            });
        }
    }
    if ("fax" in _partial && _partial.fax !== undefined) {
        const __val = _partial.fax as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "fax",
                message: "Company.fax must not be empty"
            });
        }
    }
    if ("email" in _partial && _partial.email !== undefined) {
        const __val = _partial.email as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "email",
                message: "Company.email must not be empty"
            });
        }
    }
    if ("website" in _partial && _partial.website !== undefined) {
        const __val = _partial.website as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "website",
                message: "Company.website must not be empty"
            });
        }
    }
    if ("taxId" in _partial && _partial.taxId !== undefined) {
        const __val = _partial.taxId as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "taxId",
                message: "Company.taxId must not be empty"
            });
        }
    }
    if ("postalCodeLookup" in _partial && _partial.postalCodeLookup !== undefined) {
        const __val = _partial.postalCodeLookup as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "postalCodeLookup",
                message: "Company.postalCodeLookup must not be empty"
            });
        }
    }
    if ("defaultTaxLocation" in _partial && _partial.defaultTaxLocation !== undefined) {
        const __val = _partial.defaultTaxLocation as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "defaultTaxLocation",
                message: "Company.defaultTaxLocation must not be empty"
            });
        }
    }
    if ("defaultAccountType" in _partial && _partial.defaultAccountType !== undefined) {
        const __val = _partial.defaultAccountType as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "defaultAccountType",
                message: "Company.defaultAccountType must not be empty"
            });
        }
    }
    if ("lookupFormatting" in _partial && _partial.lookupFormatting !== undefined) {
        const __val = _partial.lookupFormatting as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "lookupFormatting",
                message: "Company.lookupFormatting must not be empty"
            });
        }
    }
    if ("accountNameFormat" in _partial && _partial.accountNameFormat !== undefined) {
        const __val = _partial.accountNameFormat as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "accountNameFormat",
                message: "Company.accountNameFormat must not be empty"
            });
        }
    }
    if ("dateDisplayStyle" in _partial && _partial.dateDisplayStyle !== undefined) {
        const __val = _partial.dateDisplayStyle as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "dateDisplayStyle",
                message: "Company.dateDisplayStyle must not be empty"
            });
        }
    }
    return errors;
}
export function companyHasShape(obj: unknown): boolean {
    if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
        return false;
    }
    const o = obj as Record<string, unknown>;
    return '"id" in o && "legalName" in o && "headquarters" in o && "phones" in o && "fax" in o && "email" in o && "website" in o && "taxId" in o && "referenceNumber" in o && "postalCodeLookup" in o && "timeZone" in o && "defaultTax" in o && "defaultTaxLocation" in o && "defaultAreaCode" in o && "defaultAccountType" in o && "lookupFormatting" in o && "accountNameFormat" in o && "merchantServiceProvider" in o && "dateDisplayStyle" in o && "hasAutoCommission" in o && "hasAutoDaylightSavings" in o && "hasAutoFmsTracking" in o && "hasNotifications" in o && "hasRequiredLeadSource" in o && "hasRequiredEmail" in o && "hasSortServiceItemsAlphabetically" in o && "hasAttachOrderToAppointmentEmails" in o && "scheduleInterval" in o && "colorsConfig" in o';
}
export function companyIs(obj: unknown): obj is Company {
    if (!companyHasShape(obj)) {
        return false;
    }
    const result = companyDeserialize(obj);
    return result.success;
}

export type CompanyErrors = {
    _errors: __gf_Option<Array<string>>;
    id: __gf_Option<Array<string>>;
    legalName: __gf_Option<Array<string>>;
    headquarters: __gf_Option<Array<string>>;
    phones: __gf_Option<Array<string>>;
    fax: __gf_Option<Array<string>>;
    email: __gf_Option<Array<string>>;
    website: __gf_Option<Array<string>>;
    taxId: __gf_Option<Array<string>>;
    referenceNumber: __gf_Option<Array<string>>;
    postalCodeLookup: __gf_Option<Array<string>>;
    timeZone: __gf_Option<Array<string>>;
    defaultTax: __gf_Option<Array<string>>;
    defaultTaxLocation: __gf_Option<Array<string>>;
    defaultAreaCode: __gf_Option<Array<string>>;
    defaultAccountType: __gf_Option<Array<string>>;
    lookupFormatting: __gf_Option<Array<string>>;
    accountNameFormat: __gf_Option<Array<string>>;
    merchantServiceProvider: __gf_Option<Array<string>>;
    dateDisplayStyle: __gf_Option<Array<string>>;
    hasAutoCommission: __gf_Option<Array<string>>;
    hasAutoDaylightSavings: __gf_Option<Array<string>>;
    hasAutoFmsTracking: __gf_Option<Array<string>>;
    hasNotifications: __gf_Option<Array<string>>;
    hasRequiredLeadSource: __gf_Option<Array<string>>;
    hasRequiredEmail: __gf_Option<Array<string>>;
    hasSortServiceItemsAlphabetically: __gf_Option<Array<string>>;
    hasAttachOrderToAppointmentEmails: __gf_Option<Array<string>>;
    scheduleInterval: __gf_Option<Array<string>>;
    colorsConfig: __gf_Option<Array<string>>;
};
export type CompanyTainted = {
    id: __gf_Option<boolean>;
    legalName: __gf_Option<boolean>;
    headquarters: __gf_Option<boolean>;
    phones: __gf_Option<boolean>;
    fax: __gf_Option<boolean>;
    email: __gf_Option<boolean>;
    website: __gf_Option<boolean>;
    taxId: __gf_Option<boolean>;
    referenceNumber: __gf_Option<boolean>;
    postalCodeLookup: __gf_Option<boolean>;
    timeZone: __gf_Option<boolean>;
    defaultTax: __gf_Option<boolean>;
    defaultTaxLocation: __gf_Option<boolean>;
    defaultAreaCode: __gf_Option<boolean>;
    defaultAccountType: __gf_Option<boolean>;
    lookupFormatting: __gf_Option<boolean>;
    accountNameFormat: __gf_Option<boolean>;
    merchantServiceProvider: __gf_Option<boolean>;
    dateDisplayStyle: __gf_Option<boolean>;
    hasAutoCommission: __gf_Option<boolean>;
    hasAutoDaylightSavings: __gf_Option<boolean>;
    hasAutoFmsTracking: __gf_Option<boolean>;
    hasNotifications: __gf_Option<boolean>;
    hasRequiredLeadSource: __gf_Option<boolean>;
    hasRequiredEmail: __gf_Option<boolean>;
    hasSortServiceItemsAlphabetically: __gf_Option<boolean>;
    hasAttachOrderToAppointmentEmails: __gf_Option<boolean>;
    scheduleInterval: __gf_Option<boolean>;
    colorsConfig: __gf_Option<boolean>;
};
export interface CompanyFieldControllers {
    readonly id: FieldController<string>;
    readonly legalName: FieldController<string>;
    readonly headquarters: FieldController<string | Site>;
    readonly phones: ArrayFieldController<PhoneNumber>;
    readonly fax: FieldController<string>;
    readonly email: FieldController<string>;
    readonly website: FieldController<string>;
    readonly taxId: FieldController<string>;
    readonly referenceNumber: FieldController<number>;
    readonly postalCodeLookup: FieldController<string>;
    readonly timeZone: FieldController<string>;
    readonly defaultTax: FieldController<string | TaxRate>;
    readonly defaultTaxLocation: FieldController<string>;
    readonly defaultAreaCode: FieldController<number>;
    readonly defaultAccountType: FieldController<string>;
    readonly lookupFormatting: FieldController<string>;
    readonly accountNameFormat: FieldController<string>;
    readonly merchantServiceProvider: FieldController<string | null>;
    readonly dateDisplayStyle: FieldController<string>;
    readonly hasAutoCommission: FieldController<boolean>;
    readonly hasAutoDaylightSavings: FieldController<boolean>;
    readonly hasAutoFmsTracking: FieldController<boolean>;
    readonly hasNotifications: FieldController<boolean>;
    readonly hasRequiredLeadSource: FieldController<boolean>;
    readonly hasRequiredEmail: FieldController<boolean>;
    readonly hasSortServiceItemsAlphabetically: FieldController<boolean>;
    readonly hasAttachOrderToAppointmentEmails: FieldController<boolean>;
    readonly scheduleInterval: FieldController<number>;
    readonly colorsConfig: FieldController<ColorsConfig>;
}
export interface CompanyGigaform {
    readonly data: Company;
    readonly errors: CompanyErrors;
    readonly tainted: CompanyTainted;
    readonly fields: CompanyFieldControllers;
    validate(): Exit<Company, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<Company>): void;
}
export function companyCreateForm(overrides?: Partial<Company>): CompanyGigaform {
    let data = $state({
        ...companyDefaultValue(),
        ...overrides
    });
    let errors = $state<CompanyErrors>({
        _errors: optionNone(),
        id: optionNone(),
        legalName: optionNone(),
        headquarters: optionNone(),
        phones: optionNone(),
        fax: optionNone(),
        email: optionNone(),
        website: optionNone(),
        taxId: optionNone(),
        referenceNumber: optionNone(),
        postalCodeLookup: optionNone(),
        timeZone: optionNone(),
        defaultTax: optionNone(),
        defaultTaxLocation: optionNone(),
        defaultAreaCode: optionNone(),
        defaultAccountType: optionNone(),
        lookupFormatting: optionNone(),
        accountNameFormat: optionNone(),
        merchantServiceProvider: optionNone(),
        dateDisplayStyle: optionNone(),
        hasAutoCommission: optionNone(),
        hasAutoDaylightSavings: optionNone(),
        hasAutoFmsTracking: optionNone(),
        hasNotifications: optionNone(),
        hasRequiredLeadSource: optionNone(),
        hasRequiredEmail: optionNone(),
        hasSortServiceItemsAlphabetically: optionNone(),
        hasAttachOrderToAppointmentEmails: optionNone(),
        scheduleInterval: optionNone(),
        colorsConfig: optionNone()
    } as CompanyErrors);
    let tainted = $state<CompanyTainted>({
        id: optionNone(),
        legalName: optionNone(),
        headquarters: optionNone(),
        phones: optionNone(),
        fax: optionNone(),
        email: optionNone(),
        website: optionNone(),
        taxId: optionNone(),
        referenceNumber: optionNone(),
        postalCodeLookup: optionNone(),
        timeZone: optionNone(),
        defaultTax: optionNone(),
        defaultTaxLocation: optionNone(),
        defaultAreaCode: optionNone(),
        defaultAccountType: optionNone(),
        lookupFormatting: optionNone(),
        accountNameFormat: optionNone(),
        merchantServiceProvider: optionNone(),
        dateDisplayStyle: optionNone(),
        hasAutoCommission: optionNone(),
        hasAutoDaylightSavings: optionNone(),
        hasAutoFmsTracking: optionNone(),
        hasNotifications: optionNone(),
        hasRequiredLeadSource: optionNone(),
        hasRequiredEmail: optionNone(),
        hasSortServiceItemsAlphabetically: optionNone(),
        hasAttachOrderToAppointmentEmails: optionNone(),
        scheduleInterval: optionNone(),
        colorsConfig: optionNone()
    } as CompanyTainted);
    const fields = {
        id: {
            path: [
                "id"
            ] as const,
            name: "id",
            constraints: {
                required: true
            },
            get: ()=>data.id,
            set: (value: string)=>{
                data.id = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.id,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.id = value;
            },
            getTainted: ()=>tainted.id,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.id = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = companyValidateField("id", data.id);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        legalName: {
            path: [
                "legalName"
            ] as const,
            name: "legalName",
            constraints: {
                required: true
            },
            get: ()=>data.legalName,
            set: (value: string)=>{
                data.legalName = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.legalName,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.legalName = value;
            },
            getTainted: ()=>tainted.legalName,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.legalName = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = companyValidateField("legalName", data.legalName);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        headquarters: {
            path: [
                "headquarters"
            ] as const,
            name: "headquarters",
            constraints: {
                required: true
            },
            get: ()=>data.headquarters,
            set: (value: string | Site)=>{
                data.headquarters = value;
            },
            transform: (value: string | Site): string | Site =>value,
            getError: ()=>errors.headquarters,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.headquarters = value;
            },
            getTainted: ()=>tainted.headquarters,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.headquarters = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = companyValidateField("headquarters", data.headquarters);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        phones: {
            path: [
                "phones"
            ] as const,
            name: "phones",
            constraints: {
                required: true
            },
            get: ()=>data.phones,
            set: (value: Array<PhoneNumber>)=>{
                data.phones = value;
            },
            transform: (value: Array<PhoneNumber>): Array<PhoneNumber> =>value,
            getError: ()=>errors.phones,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.phones = value;
            },
            getTainted: ()=>tainted.phones,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.phones = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = companyValidateField("phones", data.phones);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            },
            at: (index: number)=>({
                    path: [
                        "phones",
                        index
                    ] as const,
                    name: "'^phones.${index}^'",
                    constraints: {
                        required: true
                    },
                    get: ()=>data.phones[index]!,
                    set: (value: PhoneNumber)=>{
                        data.phones[index] = value;
                    },
                    transform: (value: PhoneNumber): PhoneNumber =>value,
                    getError: ()=>errors.phones,
                    setError: (value: __gf_Option<Array<string>>)=>{
                        errors.phones = value;
                    },
                    getTainted: ()=>tainted.phones,
                    setTainted: (value: __gf_Option<boolean>)=>{
                        tainted.phones = value;
                    },
                    validate: (): Array<string> =>[]
                }),
            push: (item: PhoneNumber)=>{
                data.phones.push(item);
            },
            remove: (index: number)=>{
                data.phones.splice(index, 1);
            },
            swap: (a: number, b: number)=>{
                const tmp = data.phones[a]!;
                data.phones[a] = data.phones[b]!;
                data.phones[b] = tmp;
            }
        },
        fax: {
            path: [
                "fax"
            ] as const,
            name: "fax",
            constraints: {
                required: true
            },
            get: ()=>data.fax,
            set: (value: string)=>{
                data.fax = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.fax,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.fax = value;
            },
            getTainted: ()=>tainted.fax,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.fax = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = companyValidateField("fax", data.fax);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        email: {
            path: [
                "email"
            ] as const,
            name: "email",
            constraints: {
                required: true
            },
            get: ()=>data.email,
            set: (value: string)=>{
                data.email = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.email,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.email = value;
            },
            getTainted: ()=>tainted.email,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.email = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = companyValidateField("email", data.email);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        website: {
            path: [
                "website"
            ] as const,
            name: "website",
            constraints: {
                required: true
            },
            get: ()=>data.website,
            set: (value: string)=>{
                data.website = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.website,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.website = value;
            },
            getTainted: ()=>tainted.website,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.website = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = companyValidateField("website", data.website);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        taxId: {
            path: [
                "taxId"
            ] as const,
            name: "taxId",
            constraints: {
                required: true
            },
            get: ()=>data.taxId,
            set: (value: string)=>{
                data.taxId = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.taxId,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.taxId = value;
            },
            getTainted: ()=>tainted.taxId,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.taxId = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = companyValidateField("taxId", data.taxId);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        referenceNumber: {
            path: [
                "referenceNumber"
            ] as const,
            name: "referenceNumber",
            constraints: {
                required: true
            },
            get: ()=>data.referenceNumber,
            set: (value: number)=>{
                data.referenceNumber = value;
            },
            transform: (value: number): number =>value,
            getError: ()=>errors.referenceNumber,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.referenceNumber = value;
            },
            getTainted: ()=>tainted.referenceNumber,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.referenceNumber = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = companyValidateField("referenceNumber", data.referenceNumber);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        postalCodeLookup: {
            path: [
                "postalCodeLookup"
            ] as const,
            name: "postalCodeLookup",
            constraints: {
                required: true
            },
            get: ()=>data.postalCodeLookup,
            set: (value: string)=>{
                data.postalCodeLookup = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.postalCodeLookup,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.postalCodeLookup = value;
            },
            getTainted: ()=>tainted.postalCodeLookup,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.postalCodeLookup = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = companyValidateField("postalCodeLookup", data.postalCodeLookup);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        timeZone: {
            path: [
                "timeZone"
            ] as const,
            name: "timeZone",
            constraints: {
                required: true
            },
            get: ()=>data.timeZone,
            set: (value: string)=>{
                data.timeZone = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.timeZone,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.timeZone = value;
            },
            getTainted: ()=>tainted.timeZone,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.timeZone = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = companyValidateField("timeZone", data.timeZone);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        defaultTax: {
            path: [
                "defaultTax"
            ] as const,
            name: "defaultTax",
            constraints: {
                required: true
            },
            get: ()=>data.defaultTax,
            set: (value: string | TaxRate)=>{
                data.defaultTax = value;
            },
            transform: (value: string | TaxRate): string | TaxRate =>value,
            getError: ()=>errors.defaultTax,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.defaultTax = value;
            },
            getTainted: ()=>tainted.defaultTax,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.defaultTax = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = companyValidateField("defaultTax", data.defaultTax);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        defaultTaxLocation: {
            path: [
                "defaultTaxLocation"
            ] as const,
            name: "defaultTaxLocation",
            constraints: {
                required: true
            },
            get: ()=>data.defaultTaxLocation,
            set: (value: string)=>{
                data.defaultTaxLocation = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.defaultTaxLocation,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.defaultTaxLocation = value;
            },
            getTainted: ()=>tainted.defaultTaxLocation,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.defaultTaxLocation = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = companyValidateField("defaultTaxLocation", data.defaultTaxLocation);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        defaultAreaCode: {
            path: [
                "defaultAreaCode"
            ] as const,
            name: "defaultAreaCode",
            constraints: {
                required: true
            },
            get: ()=>data.defaultAreaCode,
            set: (value: number)=>{
                data.defaultAreaCode = value;
            },
            transform: (value: number): number =>value,
            getError: ()=>errors.defaultAreaCode,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.defaultAreaCode = value;
            },
            getTainted: ()=>tainted.defaultAreaCode,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.defaultAreaCode = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = companyValidateField("defaultAreaCode", data.defaultAreaCode);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        defaultAccountType: {
            path: [
                "defaultAccountType"
            ] as const,
            name: "defaultAccountType",
            constraints: {
                required: true
            },
            get: ()=>data.defaultAccountType,
            set: (value: string)=>{
                data.defaultAccountType = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.defaultAccountType,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.defaultAccountType = value;
            },
            getTainted: ()=>tainted.defaultAccountType,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.defaultAccountType = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = companyValidateField("defaultAccountType", data.defaultAccountType);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        lookupFormatting: {
            path: [
                "lookupFormatting"
            ] as const,
            name: "lookupFormatting",
            constraints: {
                required: true
            },
            get: ()=>data.lookupFormatting,
            set: (value: string)=>{
                data.lookupFormatting = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.lookupFormatting,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.lookupFormatting = value;
            },
            getTainted: ()=>tainted.lookupFormatting,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.lookupFormatting = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = companyValidateField("lookupFormatting", data.lookupFormatting);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        accountNameFormat: {
            path: [
                "accountNameFormat"
            ] as const,
            name: "accountNameFormat",
            constraints: {
                required: true
            },
            get: ()=>data.accountNameFormat,
            set: (value: string)=>{
                data.accountNameFormat = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.accountNameFormat,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.accountNameFormat = value;
            },
            getTainted: ()=>tainted.accountNameFormat,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.accountNameFormat = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = companyValidateField("accountNameFormat", data.accountNameFormat);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        merchantServiceProvider: {
            path: [
                "merchantServiceProvider"
            ] as const,
            name: "merchantServiceProvider",
            constraints: {
                required: true
            },
            get: ()=>data.merchantServiceProvider,
            set: (value: string | null)=>{
                data.merchantServiceProvider = value;
            },
            transform: (value: string | null): string | null =>value,
            getError: ()=>errors.merchantServiceProvider,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.merchantServiceProvider = value;
            },
            getTainted: ()=>tainted.merchantServiceProvider,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.merchantServiceProvider = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = companyValidateField("merchantServiceProvider", data.merchantServiceProvider);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        dateDisplayStyle: {
            path: [
                "dateDisplayStyle"
            ] as const,
            name: "dateDisplayStyle",
            constraints: {
                required: true
            },
            get: ()=>data.dateDisplayStyle,
            set: (value: string)=>{
                data.dateDisplayStyle = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.dateDisplayStyle,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.dateDisplayStyle = value;
            },
            getTainted: ()=>tainted.dateDisplayStyle,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.dateDisplayStyle = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = companyValidateField("dateDisplayStyle", data.dateDisplayStyle);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        hasAutoCommission: {
            path: [
                "hasAutoCommission"
            ] as const,
            name: "hasAutoCommission",
            constraints: {
                required: true
            },
            get: ()=>data.hasAutoCommission,
            set: (value: boolean)=>{
                data.hasAutoCommission = value;
            },
            transform: (value: boolean): boolean =>value,
            getError: ()=>errors.hasAutoCommission,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.hasAutoCommission = value;
            },
            getTainted: ()=>tainted.hasAutoCommission,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.hasAutoCommission = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = companyValidateField("hasAutoCommission", data.hasAutoCommission);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        hasAutoDaylightSavings: {
            path: [
                "hasAutoDaylightSavings"
            ] as const,
            name: "hasAutoDaylightSavings",
            constraints: {
                required: true
            },
            get: ()=>data.hasAutoDaylightSavings,
            set: (value: boolean)=>{
                data.hasAutoDaylightSavings = value;
            },
            transform: (value: boolean): boolean =>value,
            getError: ()=>errors.hasAutoDaylightSavings,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.hasAutoDaylightSavings = value;
            },
            getTainted: ()=>tainted.hasAutoDaylightSavings,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.hasAutoDaylightSavings = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = companyValidateField("hasAutoDaylightSavings", data.hasAutoDaylightSavings);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        hasAutoFmsTracking: {
            path: [
                "hasAutoFmsTracking"
            ] as const,
            name: "hasAutoFmsTracking",
            constraints: {
                required: true
            },
            get: ()=>data.hasAutoFmsTracking,
            set: (value: boolean)=>{
                data.hasAutoFmsTracking = value;
            },
            transform: (value: boolean): boolean =>value,
            getError: ()=>errors.hasAutoFmsTracking,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.hasAutoFmsTracking = value;
            },
            getTainted: ()=>tainted.hasAutoFmsTracking,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.hasAutoFmsTracking = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = companyValidateField("hasAutoFmsTracking", data.hasAutoFmsTracking);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        hasNotifications: {
            path: [
                "hasNotifications"
            ] as const,
            name: "hasNotifications",
            constraints: {
                required: true
            },
            get: ()=>data.hasNotifications,
            set: (value: boolean)=>{
                data.hasNotifications = value;
            },
            transform: (value: boolean): boolean =>value,
            getError: ()=>errors.hasNotifications,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.hasNotifications = value;
            },
            getTainted: ()=>tainted.hasNotifications,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.hasNotifications = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = companyValidateField("hasNotifications", data.hasNotifications);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        hasRequiredLeadSource: {
            path: [
                "hasRequiredLeadSource"
            ] as const,
            name: "hasRequiredLeadSource",
            constraints: {
                required: true
            },
            get: ()=>data.hasRequiredLeadSource,
            set: (value: boolean)=>{
                data.hasRequiredLeadSource = value;
            },
            transform: (value: boolean): boolean =>value,
            getError: ()=>errors.hasRequiredLeadSource,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.hasRequiredLeadSource = value;
            },
            getTainted: ()=>tainted.hasRequiredLeadSource,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.hasRequiredLeadSource = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = companyValidateField("hasRequiredLeadSource", data.hasRequiredLeadSource);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        hasRequiredEmail: {
            path: [
                "hasRequiredEmail"
            ] as const,
            name: "hasRequiredEmail",
            constraints: {
                required: true
            },
            get: ()=>data.hasRequiredEmail,
            set: (value: boolean)=>{
                data.hasRequiredEmail = value;
            },
            transform: (value: boolean): boolean =>value,
            getError: ()=>errors.hasRequiredEmail,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.hasRequiredEmail = value;
            },
            getTainted: ()=>tainted.hasRequiredEmail,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.hasRequiredEmail = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = companyValidateField("hasRequiredEmail", data.hasRequiredEmail);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        hasSortServiceItemsAlphabetically: {
            path: [
                "hasSortServiceItemsAlphabetically"
            ] as const,
            name: "hasSortServiceItemsAlphabetically",
            constraints: {
                required: true
            },
            get: ()=>data.hasSortServiceItemsAlphabetically,
            set: (value: boolean)=>{
                data.hasSortServiceItemsAlphabetically = value;
            },
            transform: (value: boolean): boolean =>value,
            getError: ()=>errors.hasSortServiceItemsAlphabetically,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.hasSortServiceItemsAlphabetically = value;
            },
            getTainted: ()=>tainted.hasSortServiceItemsAlphabetically,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.hasSortServiceItemsAlphabetically = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = companyValidateField("hasSortServiceItemsAlphabetically", data.hasSortServiceItemsAlphabetically);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        hasAttachOrderToAppointmentEmails: {
            path: [
                "hasAttachOrderToAppointmentEmails"
            ] as const,
            name: "hasAttachOrderToAppointmentEmails",
            constraints: {
                required: true
            },
            get: ()=>data.hasAttachOrderToAppointmentEmails,
            set: (value: boolean)=>{
                data.hasAttachOrderToAppointmentEmails = value;
            },
            transform: (value: boolean): boolean =>value,
            getError: ()=>errors.hasAttachOrderToAppointmentEmails,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.hasAttachOrderToAppointmentEmails = value;
            },
            getTainted: ()=>tainted.hasAttachOrderToAppointmentEmails,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.hasAttachOrderToAppointmentEmails = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = companyValidateField("hasAttachOrderToAppointmentEmails", data.hasAttachOrderToAppointmentEmails);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        scheduleInterval: {
            path: [
                "scheduleInterval"
            ] as const,
            name: "scheduleInterval",
            constraints: {
                required: true
            },
            get: ()=>data.scheduleInterval,
            set: (value: number)=>{
                data.scheduleInterval = value;
            },
            transform: (value: number): number =>value,
            getError: ()=>errors.scheduleInterval,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.scheduleInterval = value;
            },
            getTainted: ()=>tainted.scheduleInterval,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.scheduleInterval = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = companyValidateField("scheduleInterval", data.scheduleInterval);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        colorsConfig: {
            path: [
                "colorsConfig"
            ] as const,
            name: "colorsConfig",
            constraints: {
                required: true
            },
            get: ()=>data.colorsConfig,
            set: (value: ColorsConfig)=>{
                data.colorsConfig = value;
            },
            transform: (value: ColorsConfig): ColorsConfig =>value,
            getError: ()=>errors.colorsConfig,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.colorsConfig = value;
            },
            getTainted: ()=>tainted.colorsConfig,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.colorsConfig = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = companyValidateField("colorsConfig", data.colorsConfig);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        }
    } as CompanyFieldControllers;
    const __gf_getter_hint = "get data() set data(v) get errors() set errors(v) get tainted() set tainted(v)";
    const __gf_validate_hint = ".map((e: { field: string; message: string }) => e.message)";
    function validate(): Exit<Company, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(companyDeserialize(data));
    }
    function reset(newOverrides?: Partial<Company>): void {
        data = {
            ...companyDefaultValue(),
            ...newOverrides
        };
        errors = {
            _errors: optionNone(),
            id: optionNone(),
            legalName: optionNone(),
            headquarters: optionNone(),
            phones: optionNone(),
            fax: optionNone(),
            email: optionNone(),
            website: optionNone(),
            taxId: optionNone(),
            referenceNumber: optionNone(),
            postalCodeLookup: optionNone(),
            timeZone: optionNone(),
            defaultTax: optionNone(),
            defaultTaxLocation: optionNone(),
            defaultAreaCode: optionNone(),
            defaultAccountType: optionNone(),
            lookupFormatting: optionNone(),
            accountNameFormat: optionNone(),
            merchantServiceProvider: optionNone(),
            dateDisplayStyle: optionNone(),
            hasAutoCommission: optionNone(),
            hasAutoDaylightSavings: optionNone(),
            hasAutoFmsTracking: optionNone(),
            hasNotifications: optionNone(),
            hasRequiredLeadSource: optionNone(),
            hasRequiredEmail: optionNone(),
            hasSortServiceItemsAlphabetically: optionNone(),
            hasAttachOrderToAppointmentEmails: optionNone(),
            scheduleInterval: optionNone(),
            colorsConfig: optionNone()
        };
        tainted = {
            id: optionNone(),
            legalName: optionNone(),
            headquarters: optionNone(),
            phones: optionNone(),
            fax: optionNone(),
            email: optionNone(),
            website: optionNone(),
            taxId: optionNone(),
            referenceNumber: optionNone(),
            postalCodeLookup: optionNone(),
            timeZone: optionNone(),
            defaultTax: optionNone(),
            defaultTaxLocation: optionNone(),
            defaultAreaCode: optionNone(),
            defaultAccountType: optionNone(),
            lookupFormatting: optionNone(),
            accountNameFormat: optionNone(),
            merchantServiceProvider: optionNone(),
            dateDisplayStyle: optionNone(),
            hasAutoCommission: optionNone(),
            hasAutoDaylightSavings: optionNone(),
            hasAutoFmsTracking: optionNone(),
            hasNotifications: optionNone(),
            hasRequiredLeadSource: optionNone(),
            hasRequiredEmail: optionNone(),
            hasSortServiceItemsAlphabetically: optionNone(),
            hasAttachOrderToAppointmentEmails: optionNone(),
            scheduleInterval: optionNone(),
            colorsConfig: optionNone()
        };
    }
    return {
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        fields,
        validate,
        reset
    };
}
export function companyFromFormData(formData: FormData): Exit<Company, Array<{
    field: string;
    message: string;
}>> {
    const obj: Record<string, unknown> = {};
    const __gf_exit_hint = "Exit<Company, Array<{ field: string; message: string }>>";
    obj.id = formData.get(`${"id"}`) ?? "";
    obj.legalName = formData.get(`${"legalName"}`) ?? "";
    obj.headquarters = formData.get(`${"headquarters"}`) ?? "";
    {
        const phonesItems: Array<Record<string, unknown>> = [];
        let idx = 0;
        while(formData.has(`${"phones"}.` + idx + ".") || idx === 0){
            const hasAny = Array.from(formData.keys()).some((k)=>k.startsWith(`${"phones"}.` + idx + "."));
            if (!hasAny && idx > 0) break;
            if (hasAny) {
                const item: Record<string, unknown> = {};
                for (const [key, value] of Array.from(formData.entries())){
                    if (key.startsWith(`${"phones"}.` + idx + ".")) {
                        const fieldName = key.slice(`${"phones"}.`.length + String(idx).length + 1);
                        item[fieldName] = value;
                    }
                }
                phonesItems.push(item);
            }
            idx++;
            if (idx > 1000) break;
        }
        obj.phones = phonesItems;
    }
    obj.fax = formData.get(`${"fax"}`) ?? "";
    obj.email = formData.get(`${"email"}`) ?? "";
    obj.website = formData.get(`${"website"}`) ?? "";
    obj.taxId = formData.get(`${"taxId"}`) ?? "";
    {
        const referenceNumberStr = formData.get(`${"referenceNumber"}`);
        obj.referenceNumber = referenceNumberStr ? parseFloat(referenceNumberStr as string) : $MfPh5;
        if (obj.referenceNumber !== undefined && isNaN(obj.referenceNumber as number)) obj.referenceNumber = "0";
    }
    obj.postalCodeLookup = formData.get(`${"postalCodeLookup"}`) ?? "";
    obj.timeZone = formData.get(`${"timeZone"}`) ?? "";
    obj.defaultTax = formData.get(`${"defaultTax"}`) ?? "";
    obj.defaultTaxLocation = formData.get(`${"defaultTaxLocation"}`) ?? "";
    {
        const defaultAreaCodeStr = formData.get(`${"defaultAreaCode"}`);
        obj.defaultAreaCode = defaultAreaCodeStr ? parseFloat(defaultAreaCodeStr as string) : $MfPh5;
        if (obj.defaultAreaCode !== undefined && isNaN(obj.defaultAreaCode as number)) obj.defaultAreaCode = "0";
    }
    obj.defaultAccountType = formData.get(`${"defaultAccountType"}`) ?? "";
    obj.lookupFormatting = formData.get(`${"lookupFormatting"}`) ?? "";
    obj.accountNameFormat = formData.get(`${"accountNameFormat"}`) ?? "";
    obj.merchantServiceProvider = formData.get(`${"merchantServiceProvider"}`) ?? "";
    obj.dateDisplayStyle = formData.get(`${"dateDisplayStyle"}`) ?? "";
    {
        const hasAutoCommissionVal = formData.get(`${"hasAutoCommission"}`);
        obj.hasAutoCommission = hasAutoCommissionVal === "true" || hasAutoCommissionVal === "on" || hasAutoCommissionVal === "1";
    }
    {
        const hasAutoDaylightSavingsVal = formData.get(`${"hasAutoDaylightSavings"}`);
        obj.hasAutoDaylightSavings = hasAutoDaylightSavingsVal === "true" || hasAutoDaylightSavingsVal === "on" || hasAutoDaylightSavingsVal === "1";
    }
    {
        const hasAutoFmsTrackingVal = formData.get(`${"hasAutoFmsTracking"}`);
        obj.hasAutoFmsTracking = hasAutoFmsTrackingVal === "true" || hasAutoFmsTrackingVal === "on" || hasAutoFmsTrackingVal === "1";
    }
    {
        const hasNotificationsVal = formData.get(`${"hasNotifications"}`);
        obj.hasNotifications = hasNotificationsVal === "true" || hasNotificationsVal === "on" || hasNotificationsVal === "1";
    }
    {
        const hasRequiredLeadSourceVal = formData.get(`${"hasRequiredLeadSource"}`);
        obj.hasRequiredLeadSource = hasRequiredLeadSourceVal === "true" || hasRequiredLeadSourceVal === "on" || hasRequiredLeadSourceVal === "1";
    }
    {
        const hasRequiredEmailVal = formData.get(`${"hasRequiredEmail"}`);
        obj.hasRequiredEmail = hasRequiredEmailVal === "true" || hasRequiredEmailVal === "on" || hasRequiredEmailVal === "1";
    }
    {
        const hasSortServiceItemsAlphabeticallyVal = formData.get(`${"hasSortServiceItemsAlphabetically"}`);
        obj.hasSortServiceItemsAlphabetically = hasSortServiceItemsAlphabeticallyVal === "true" || hasSortServiceItemsAlphabeticallyVal === "on" || hasSortServiceItemsAlphabeticallyVal === "1";
    }
    {
        const hasAttachOrderToAppointmentEmailsVal = formData.get(`${"hasAttachOrderToAppointmentEmails"}`);
        obj.hasAttachOrderToAppointmentEmails = hasAttachOrderToAppointmentEmailsVal === "true" || hasAttachOrderToAppointmentEmailsVal === "on" || hasAttachOrderToAppointmentEmailsVal === "1";
    }
    {
        const scheduleIntervalStr = formData.get(`${"scheduleInterval"}`);
        obj.scheduleInterval = scheduleIntervalStr ? parseFloat(scheduleIntervalStr as string) : $MfPh5;
        if (obj.scheduleInterval !== undefined && isNaN(obj.scheduleInterval as number)) obj.scheduleInterval = "0";
    }
    {
        const colorsConfigObj: Record<string, unknown> = {};
        for (const [key, value] of Array.from(formData.entries())){
            if (key.startsWith(`${"colorsConfig"}.`)) {
                const fieldName = key.slice(`${"colorsConfig"}.`.length);
                const parts = fieldName.split(".");
                let current = colorsConfigObj;
                for(let i = 0; i < parts.length - 1; i++){
                    const part = parts[i]!;
                    if (!(part in current)) {
                        current[part] = {};
                    }
                    current = current[part] as Record<string, unknown>;
                }
                current[parts[parts.length - 1]!] = value;
            }
        }
        obj.colorsConfig = colorsConfigObj;
    }
    return toExit(companyDeserialize(obj));
}

export const Company = {
  defaultValue: companyDefaultValue,
  serialize: companySerialize,
  serializeWithContext: companySerializeWithContext,
  deserialize: companyDeserialize,
  deserializeWithContext: companyDeserializeWithContext,
  validateFields: companyValidateFields,
  hasShape: companyHasShape,
  is: companyIs,
  createForm: companyCreateForm,
  fromFormData: companyFromFormData
} as const;


export interface Ordinal {
    north: number;
    northeast: number;
    east: number;
    southeast: number;
    south: number;
    southwest: number;
    west: number;
    northwest: number;
}

export function ordinalDefaultValue(): Ordinal {
    return {
        north: 0,
        northeast: 0,
        east: 0,
        southeast: 0,
        south: 0,
        southwest: 0,
        west: 0,
        northwest: 0
    } as Ordinal;
}

export function ordinalSerialize(value: Ordinal): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(ordinalSerializeWithContext(value, ctx));
}
export function ordinalSerializeWithContext(value: Ordinal, ctx: __mf_SerializeContext): Record<string, unknown> {
    const existingId = ctx.getId(value);
    if (existingId !== undefined) {
        return {
            __ref: existingId
        };
    }
    const __id = ctx.register(value);
    const result: Record<string, unknown> = {
        __type: "Ordinal",
        __id
    };
    result.north = value.north;
    result.northeast = value.northeast;
    result.east = value.east;
    result.southeast = value.southeast;
    result.south = value.south;
    result.southwest = value.southwest;
    result.west = value.west;
    result.northwest = value.northwest;
    return result;
}

export function ordinalDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: Ordinal } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = ordinalDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "Ordinal.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function ordinalDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Ordinal | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
        throw new __mf_DeserializeError([
            {
                field: "_root",
                message: `${"Ordinal"}.deserializeWithContext: expected an object`
            }
        ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (!("north" in obj)) {
        errors.push({
            field: "north",
            message: "missing required field"
        });
    }
    if (!("northeast" in obj)) {
        errors.push({
            field: "northeast",
            message: "missing required field"
        });
    }
    if (!("east" in obj)) {
        errors.push({
            field: "east",
            message: "missing required field"
        });
    }
    if (!("southeast" in obj)) {
        errors.push({
            field: "southeast",
            message: "missing required field"
        });
    }
    if (!("south" in obj)) {
        errors.push({
            field: "south",
            message: "missing required field"
        });
    }
    if (!("southwest" in obj)) {
        errors.push({
            field: "southwest",
            message: "missing required field"
        });
    }
    if (!("west" in obj)) {
        errors.push({
            field: "west",
            message: "missing required field"
        });
    }
    if (!("northwest" in obj)) {
        errors.push({
            field: "northwest",
            message: "missing required field"
        });
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
        ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
        const __raw_north = obj["north"] as number;
        instance.north = __raw_north;
    }
    {
        const __raw_northeast = obj["northeast"] as number;
        instance.northeast = __raw_northeast;
    }
    {
        const __raw_east = obj["east"] as number;
        instance.east = __raw_east;
    }
    {
        const __raw_southeast = obj["southeast"] as number;
        instance.southeast = __raw_southeast;
    }
    {
        const __raw_south = obj["south"] as number;
        instance.south = __raw_south;
    }
    {
        const __raw_southwest = obj["southwest"] as number;
        instance.southwest = __raw_southwest;
    }
    {
        const __raw_west = obj["west"] as number;
        instance.west = __raw_west;
    }
    {
        const __raw_northwest = obj["northwest"] as number;
        instance.northwest = __raw_northwest;
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    return instance as Ordinal;
}
export function ordinalValidateField<K extends keyof Ordinal>(_field: K, _value: Ordinal[K]): Array<{
    field: string;
    message: string;
}> {
    return [];
}
export function ordinalValidateFields(_partial: Partial<Ordinal>): Array<{
    field: string;
    message: string;
}> {
    return [];
}
export function ordinalHasShape(obj: unknown): boolean {
    if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
        return false;
    }
    const o = obj as Record<string, unknown>;
    return '"north" in o && "northeast" in o && "east" in o && "southeast" in o && "south" in o && "southwest" in o && "west" in o && "northwest" in o';
}
export function ordinalIs(obj: unknown): obj is Ordinal {
    if (!ordinalHasShape(obj)) {
        return false;
    }
    const result = ordinalDeserialize(obj);
    return result.success;
}

export type OrdinalErrors = {
    _errors: __gf_Option<Array<string>>;
    north: __gf_Option<Array<string>>;
    northeast: __gf_Option<Array<string>>;
    east: __gf_Option<Array<string>>;
    southeast: __gf_Option<Array<string>>;
    south: __gf_Option<Array<string>>;
    southwest: __gf_Option<Array<string>>;
    west: __gf_Option<Array<string>>;
    northwest: __gf_Option<Array<string>>;
};
export type OrdinalTainted = {
    north: __gf_Option<boolean>;
    northeast: __gf_Option<boolean>;
    east: __gf_Option<boolean>;
    southeast: __gf_Option<boolean>;
    south: __gf_Option<boolean>;
    southwest: __gf_Option<boolean>;
    west: __gf_Option<boolean>;
    northwest: __gf_Option<boolean>;
};
export interface OrdinalFieldControllers {
    readonly north: FieldController<number>;
    readonly northeast: FieldController<number>;
    readonly east: FieldController<number>;
    readonly southeast: FieldController<number>;
    readonly south: FieldController<number>;
    readonly southwest: FieldController<number>;
    readonly west: FieldController<number>;
    readonly northwest: FieldController<number>;
}
export interface OrdinalGigaform {
    readonly data: Ordinal;
    readonly errors: OrdinalErrors;
    readonly tainted: OrdinalTainted;
    readonly fields: OrdinalFieldControllers;
    validate(): Exit<Ordinal, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<Ordinal>): void;
}
export function ordinalCreateForm(overrides?: Partial<Ordinal>): OrdinalGigaform {
    let data = $state({
        ...ordinalDefaultValue(),
        ...overrides
    });
    let errors = $state<OrdinalErrors>({
        _errors: optionNone(),
        north: optionNone(),
        northeast: optionNone(),
        east: optionNone(),
        southeast: optionNone(),
        south: optionNone(),
        southwest: optionNone(),
        west: optionNone(),
        northwest: optionNone()
    } as OrdinalErrors);
    let tainted = $state<OrdinalTainted>({
        north: optionNone(),
        northeast: optionNone(),
        east: optionNone(),
        southeast: optionNone(),
        south: optionNone(),
        southwest: optionNone(),
        west: optionNone(),
        northwest: optionNone()
    } as OrdinalTainted);
    const fields = {
        north: {
            path: [
                "north"
            ] as const,
            name: "north",
            constraints: {
                required: true
            },
            get: ()=>data.north,
            set: (value: number)=>{
                data.north = value;
            },
            transform: (value: number): number =>value,
            getError: ()=>errors.north,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.north = value;
            },
            getTainted: ()=>tainted.north,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.north = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = ordinalValidateField("north", data.north);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        northeast: {
            path: [
                "northeast"
            ] as const,
            name: "northeast",
            constraints: {
                required: true
            },
            get: ()=>data.northeast,
            set: (value: number)=>{
                data.northeast = value;
            },
            transform: (value: number): number =>value,
            getError: ()=>errors.northeast,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.northeast = value;
            },
            getTainted: ()=>tainted.northeast,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.northeast = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = ordinalValidateField("northeast", data.northeast);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        east: {
            path: [
                "east"
            ] as const,
            name: "east",
            constraints: {
                required: true
            },
            get: ()=>data.east,
            set: (value: number)=>{
                data.east = value;
            },
            transform: (value: number): number =>value,
            getError: ()=>errors.east,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.east = value;
            },
            getTainted: ()=>tainted.east,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.east = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = ordinalValidateField("east", data.east);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        southeast: {
            path: [
                "southeast"
            ] as const,
            name: "southeast",
            constraints: {
                required: true
            },
            get: ()=>data.southeast,
            set: (value: number)=>{
                data.southeast = value;
            },
            transform: (value: number): number =>value,
            getError: ()=>errors.southeast,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.southeast = value;
            },
            getTainted: ()=>tainted.southeast,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.southeast = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = ordinalValidateField("southeast", data.southeast);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        south: {
            path: [
                "south"
            ] as const,
            name: "south",
            constraints: {
                required: true
            },
            get: ()=>data.south,
            set: (value: number)=>{
                data.south = value;
            },
            transform: (value: number): number =>value,
            getError: ()=>errors.south,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.south = value;
            },
            getTainted: ()=>tainted.south,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.south = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = ordinalValidateField("south", data.south);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        southwest: {
            path: [
                "southwest"
            ] as const,
            name: "southwest",
            constraints: {
                required: true
            },
            get: ()=>data.southwest,
            set: (value: number)=>{
                data.southwest = value;
            },
            transform: (value: number): number =>value,
            getError: ()=>errors.southwest,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.southwest = value;
            },
            getTainted: ()=>tainted.southwest,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.southwest = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = ordinalValidateField("southwest", data.southwest);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        west: {
            path: [
                "west"
            ] as const,
            name: "west",
            constraints: {
                required: true
            },
            get: ()=>data.west,
            set: (value: number)=>{
                data.west = value;
            },
            transform: (value: number): number =>value,
            getError: ()=>errors.west,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.west = value;
            },
            getTainted: ()=>tainted.west,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.west = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = ordinalValidateField("west", data.west);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        northwest: {
            path: [
                "northwest"
            ] as const,
            name: "northwest",
            constraints: {
                required: true
            },
            get: ()=>data.northwest,
            set: (value: number)=>{
                data.northwest = value;
            },
            transform: (value: number): number =>value,
            getError: ()=>errors.northwest,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.northwest = value;
            },
            getTainted: ()=>tainted.northwest,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.northwest = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = ordinalValidateField("northwest", data.northwest);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        }
    } as OrdinalFieldControllers;
    const __gf_getter_hint = "get data() set data(v) get errors() set errors(v) get tainted() set tainted(v)";
    const __gf_validate_hint = ".map((e: { field: string; message: string }) => e.message)";
    function validate(): Exit<Ordinal, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(ordinalDeserialize(data));
    }
    function reset(newOverrides?: Partial<Ordinal>): void {
        data = {
            ...ordinalDefaultValue(),
            ...newOverrides
        };
        errors = {
            _errors: optionNone(),
            north: optionNone(),
            northeast: optionNone(),
            east: optionNone(),
            southeast: optionNone(),
            south: optionNone(),
            southwest: optionNone(),
            west: optionNone(),
            northwest: optionNone()
        };
        tainted = {
            north: optionNone(),
            northeast: optionNone(),
            east: optionNone(),
            southeast: optionNone(),
            south: optionNone(),
            southwest: optionNone(),
            west: optionNone(),
            northwest: optionNone()
        };
    }
    return {
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        fields,
        validate,
        reset
    };
}
export function ordinalFromFormData(formData: FormData): Exit<Ordinal, Array<{
    field: string;
    message: string;
}>> {
    const obj: Record<string, unknown> = {};
    const __gf_exit_hint = "Exit<Ordinal, Array<{ field: string; message: string }>>";
    {
        const northStr = formData.get(`${"north"}`);
        obj.north = northStr ? parseFloat(northStr as string) : $MfPh5;
        if (obj.north !== undefined && isNaN(obj.north as number)) obj.north = "0";
    }
    {
        const northeastStr = formData.get(`${"northeast"}`);
        obj.northeast = northeastStr ? parseFloat(northeastStr as string) : $MfPh5;
        if (obj.northeast !== undefined && isNaN(obj.northeast as number)) obj.northeast = "0";
    }
    {
        const eastStr = formData.get(`${"east"}`);
        obj.east = eastStr ? parseFloat(eastStr as string) : $MfPh5;
        if (obj.east !== undefined && isNaN(obj.east as number)) obj.east = "0";
    }
    {
        const southeastStr = formData.get(`${"southeast"}`);
        obj.southeast = southeastStr ? parseFloat(southeastStr as string) : $MfPh5;
        if (obj.southeast !== undefined && isNaN(obj.southeast as number)) obj.southeast = "0";
    }
    {
        const southStr = formData.get(`${"south"}`);
        obj.south = southStr ? parseFloat(southStr as string) : $MfPh5;
        if (obj.south !== undefined && isNaN(obj.south as number)) obj.south = "0";
    }
    {
        const southwestStr = formData.get(`${"southwest"}`);
        obj.southwest = southwestStr ? parseFloat(southwestStr as string) : $MfPh5;
        if (obj.southwest !== undefined && isNaN(obj.southwest as number)) obj.southwest = "0";
    }
    {
        const westStr = formData.get(`${"west"}`);
        obj.west = westStr ? parseFloat(westStr as string) : $MfPh5;
        if (obj.west !== undefined && isNaN(obj.west as number)) obj.west = "0";
    }
    {
        const northwestStr = formData.get(`${"northwest"}`);
        obj.northwest = northwestStr ? parseFloat(northwestStr as string) : $MfPh5;
        if (obj.northwest !== undefined && isNaN(obj.northwest as number)) obj.northwest = "0";
    }
    return toExit(ordinalDeserialize(obj));
}

export const Ordinal = {
  defaultValue: ordinalDefaultValue,
  serialize: ordinalSerialize,
  serializeWithContext: ordinalSerializeWithContext,
  deserialize: ordinalDeserialize,
  deserializeWithContext: ordinalDeserializeWithContext,
  validateFields: ordinalValidateFields,
  hasShape: ordinalHasShape,
  is: ordinalIs,
  createForm: ordinalCreateForm,
  fromFormData: ordinalFromFormData
} as const;


export interface Password {
    
    password: string;
}

export function passwordDefaultValue(): Password {
    return {
        password: ""
    } as Password;
}

export function passwordSerialize(value: Password): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(passwordSerializeWithContext(value, ctx));
}
export function passwordSerializeWithContext(value: Password, ctx: __mf_SerializeContext): Record<string, unknown> {
    const existingId = ctx.getId(value);
    if (existingId !== undefined) {
        return {
            __ref: existingId
        };
    }
    const __id = ctx.register(value);
    const result: Record<string, unknown> = {
        __type: "Password",
        __id
    };
    result.password = value.password;
    return result;
}

export function passwordDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: Password } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = passwordDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "Password.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function passwordDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Password | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
        throw new __mf_DeserializeError([
            {
                field: "_root",
                message: `${"Password"}.deserializeWithContext: expected an object`
            }
        ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (!("password" in obj)) {
        errors.push({
            field: "password",
            message: "missing required field"
        });
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
        ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
        const __raw_password = obj["password"] as string;
        if (__raw_password.trim().length === 0) {
            errors.push({
                field: "password",
                message: "Password.password must not be empty"
            });
        }
        instance.password = __raw_password;
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    return instance as Password;
}
export function passwordValidateField<K extends keyof Password>(_field: K, _value: Password[K]): Array<{
    field: string;
    message: string;
}> {
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (_field === "password") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "password",
                message: "Password.password must not be empty"
            });
        }
    }
    return errors;
}
export function passwordValidateFields(_partial: Partial<Password>): Array<{
    field: string;
    message: string;
}> {
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if ("password" in _partial && _partial.password !== undefined) {
        const __val = _partial.password as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "password",
                message: "Password.password must not be empty"
            });
        }
    }
    return errors;
}
export function passwordHasShape(obj: unknown): boolean {
    if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
        return false;
    }
    const o = obj as Record<string, unknown>;
    return '"password" in o';
}
export function passwordIs(obj: unknown): obj is Password {
    if (!passwordHasShape(obj)) {
        return false;
    }
    const result = passwordDeserialize(obj);
    return result.success;
}

export type PasswordErrors = {
    _errors: __gf_Option<Array<string>>;
    password: __gf_Option<Array<string>>;
};
export type PasswordTainted = {
    password: __gf_Option<boolean>;
};
export interface PasswordFieldControllers {
    readonly password: FieldController<string>;
}
export interface PasswordGigaform {
    readonly data: Password;
    readonly errors: PasswordErrors;
    readonly tainted: PasswordTainted;
    readonly fields: PasswordFieldControllers;
    validate(): Exit<Password, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<Password>): void;
}
export function passwordCreateForm(overrides?: Partial<Password>): PasswordGigaform {
    let data = $state({
        ...passwordDefaultValue(),
        ...overrides
    });
    let errors = $state<PasswordErrors>({
        _errors: optionNone(),
        password: optionNone()
    } as PasswordErrors);
    let tainted = $state<PasswordTainted>({
        password: optionNone()
    } as PasswordTainted);
    const fields = {
        password: {
            path: [
                "password"
            ] as const,
            name: "password",
            constraints: {
                required: true
            },
            get: ()=>data.password,
            set: (value: string)=>{
                data.password = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.password,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.password = value;
            },
            getTainted: ()=>tainted.password,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.password = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = passwordValidateField("password", data.password);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        }
    } as PasswordFieldControllers;
    const __gf_getter_hint = "get data() set data(v) get errors() set errors(v) get tainted() set tainted(v)";
    const __gf_validate_hint = ".map((e: { field: string; message: string }) => e.message)";
    function validate(): Exit<Password, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(passwordDeserialize(data));
    }
    function reset(newOverrides?: Partial<Password>): void {
        data = {
            ...passwordDefaultValue(),
            ...newOverrides
        };
        errors = {
            _errors: optionNone(),
            password: optionNone()
        };
        tainted = {
            password: optionNone()
        };
    }
    return {
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        fields,
        validate,
        reset
    };
}
export function passwordFromFormData(formData: FormData): Exit<Password, Array<{
    field: string;
    message: string;
}>> {
    const obj: Record<string, unknown> = {};
    const __gf_exit_hint = "Exit<Password, Array<{ field: string; message: string }>>";
    obj.password = formData.get(`${"password"}`) ?? "";
    return toExit(passwordDeserialize(obj));
}

export const Password = {
  defaultValue: passwordDefaultValue,
  serialize: passwordSerialize,
  serializeWithContext: passwordSerializeWithContext,
  deserialize: passwordDeserialize,
  deserializeWithContext: passwordDeserializeWithContext,
  validateFields: passwordValidateFields,
  hasShape: passwordHasShape,
  is: passwordIs,
  createForm: passwordCreateForm,
  fromFormData: passwordFromFormData
} as const;


export interface Created {
    initialData: string | null;
}

export function createdDefaultValue(): Created {
    return {
        initialData: null
    } as Created;
}

export function createdSerialize(value: Created): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(createdSerializeWithContext(value, ctx));
}
export function createdSerializeWithContext(value: Created, ctx: __mf_SerializeContext): Record<string, unknown> {
    const existingId = ctx.getId(value);
    if (existingId !== undefined) {
        return {
            __ref: existingId
        };
    }
    const __id = ctx.register(value);
    const result: Record<string, unknown> = {
        __type: "Created",
        __id
    };
    result.initialData = value.initialData;
    return result;
}

export function createdDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: Created } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = createdDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "Created.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function createdDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Created | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
        throw new __mf_DeserializeError([
            {
                field: "_root",
                message: `${"Created"}.deserializeWithContext: expected an object`
            }
        ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (!("initialData" in obj)) {
        errors.push({
            field: "initialData",
            message: "missing required field"
        });
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
        ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
        const __raw_initialData = obj["initialData"] as string | null;
        instance.initialData = __raw_initialData;
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    return instance as Created;
}
export function createdValidateField<K extends keyof Created>(_field: K, _value: Created[K]): Array<{
    field: string;
    message: string;
}> {
    return [];
}
export function createdValidateFields(_partial: Partial<Created>): Array<{
    field: string;
    message: string;
}> {
    return [];
}
export function createdHasShape(obj: unknown): boolean {
    if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
        return false;
    }
    const o = obj as Record<string, unknown>;
    return '"initialData" in o';
}
export function createdIs(obj: unknown): obj is Created {
    if (!createdHasShape(obj)) {
        return false;
    }
    const result = createdDeserialize(obj);
    return result.success;
}

export type CreatedErrors = {
    _errors: __gf_Option<Array<string>>;
    initialData: __gf_Option<Array<string>>;
};
export type CreatedTainted = {
    initialData: __gf_Option<boolean>;
};
export interface CreatedFieldControllers {
    readonly initialData: FieldController<string | null>;
}
export interface CreatedGigaform {
    readonly data: Created;
    readonly errors: CreatedErrors;
    readonly tainted: CreatedTainted;
    readonly fields: CreatedFieldControllers;
    validate(): Exit<Created, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<Created>): void;
}
export function createdCreateForm(overrides?: Partial<Created>): CreatedGigaform {
    let data = $state({
        ...createdDefaultValue(),
        ...overrides
    });
    let errors = $state<CreatedErrors>({
        _errors: optionNone(),
        initialData: optionNone()
    } as CreatedErrors);
    let tainted = $state<CreatedTainted>({
        initialData: optionNone()
    } as CreatedTainted);
    const fields = {
        initialData: {
            path: [
                "initialData"
            ] as const,
            name: "initialData",
            constraints: {
                required: true
            },
            get: ()=>data.initialData,
            set: (value: string | null)=>{
                data.initialData = value;
            },
            transform: (value: string | null): string | null =>value,
            getError: ()=>errors.initialData,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.initialData = value;
            },
            getTainted: ()=>tainted.initialData,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.initialData = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = createdValidateField("initialData", data.initialData);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        }
    } as CreatedFieldControllers;
    const __gf_getter_hint = "get data() set data(v) get errors() set errors(v) get tainted() set tainted(v)";
    const __gf_validate_hint = ".map((e: { field: string; message: string }) => e.message)";
    function validate(): Exit<Created, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(createdDeserialize(data));
    }
    function reset(newOverrides?: Partial<Created>): void {
        data = {
            ...createdDefaultValue(),
            ...newOverrides
        };
        errors = {
            _errors: optionNone(),
            initialData: optionNone()
        };
        tainted = {
            initialData: optionNone()
        };
    }
    return {
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        fields,
        validate,
        reset
    };
}
export function createdFromFormData(formData: FormData): Exit<Created, Array<{
    field: string;
    message: string;
}>> {
    const obj: Record<string, unknown> = {};
    const __gf_exit_hint = "Exit<Created, Array<{ field: string; message: string }>>";
    obj.initialData = formData.get(`${"initialData"}`) ?? "";
    return toExit(createdDeserialize(obj));
}

export const Created = {
  defaultValue: createdDefaultValue,
  serialize: createdSerialize,
  serializeWithContext: createdSerializeWithContext,
  deserialize: createdDeserialize,
  deserializeWithContext: createdDeserializeWithContext,
  validateFields: createdValidateFields,
  hasShape: createdHasShape,
  is: createdIs,
  createForm: createdCreateForm,
  fromFormData: createdFromFormData
} as const;


export interface Employee {
    id: string;
    imageUrl: string | null;
    
    name: string;
    phones: Array<PhoneNumber>;
    
    role: string;
    
    title: JobTitle;
    email: Email;
    
    address: string;
    
    username: string;
    
    route: string | Route;
    ratePerHour: number;
    active: boolean;
    isTechnician: boolean;
    isSalesRep: boolean;
    description: string | null;
    linkedinUrl: string | null;
    attendance: Array<string>;
    settings: Settings;
}

export function employeeDefaultValue(): Employee {
    return {
        id: "",
        imageUrl: null,
        name: "",
        phones: [],
        role: "",
        title: "Technician",
        email: emailDefaultValue(),
        address: "",
        username: "",
        route: "",
        ratePerHour: 0,
        active: false,
        isTechnician: false,
        isSalesRep: false,
        description: null,
        linkedinUrl: null,
        attendance: [],
        settings: settingsDefaultValue()
    } as Employee;
}

export function employeeSerialize(value: Employee): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(employeeSerializeWithContext(value, ctx));
}
export function employeeSerializeWithContext(value: Employee, ctx: __mf_SerializeContext): Record<string, unknown> {
    const existingId = ctx.getId(value);
    if (existingId !== undefined) {
        return {
            __ref: existingId
        };
    }
    const __id = ctx.register(value);
    const result: Record<string, unknown> = {
        __type: "Employee",
        __id
    };
    result.id = value.id;
    result.imageUrl = value.imageUrl;
    result.name = value.name;
    result.phones = value.phones.map((item)=>phoneNumberSerializeWithContext(item, ctx));
    result.role = value.role;
    result.title = jobTitleSerializeWithContext(value.title, ctx);
    result.email = emailSerializeWithContext(value.email, ctx);
    result.address = value.address;
    result.username = value.username;
    result.route = value.route;
    result.ratePerHour = value.ratePerHour;
    result.active = value.active;
    result.isTechnician = value.isTechnician;
    result.isSalesRep = value.isSalesRep;
    result.description = value.description;
    result.linkedinUrl = value.linkedinUrl;
    result.attendance = value.attendance;
    result.settings = settingsSerializeWithContext(value.settings, ctx);
    return result;
}

export function employeeDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: Employee } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = employeeDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "Employee.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function employeeDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Employee | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
        throw new __mf_DeserializeError([
            {
                field: "_root",
                message: `${"Employee"}.deserializeWithContext: expected an object`
            }
        ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (!("id" in obj)) {
        errors.push({
            field: "id",
            message: "missing required field"
        });
    }
    if (!("imageUrl" in obj)) {
        errors.push({
            field: "imageUrl",
            message: "missing required field"
        });
    }
    if (!("name" in obj)) {
        errors.push({
            field: "name",
            message: "missing required field"
        });
    }
    if (!("phones" in obj)) {
        errors.push({
            field: "phones",
            message: "missing required field"
        });
    }
    if (!("role" in obj)) {
        errors.push({
            field: "role",
            message: "missing required field"
        });
    }
    if (!("title" in obj)) {
        errors.push({
            field: "title",
            message: "missing required field"
        });
    }
    if (!("email" in obj)) {
        errors.push({
            field: "email",
            message: "missing required field"
        });
    }
    if (!("address" in obj)) {
        errors.push({
            field: "address",
            message: "missing required field"
        });
    }
    if (!("username" in obj)) {
        errors.push({
            field: "username",
            message: "missing required field"
        });
    }
    if (!("route" in obj)) {
        errors.push({
            field: "route",
            message: "missing required field"
        });
    }
    if (!("ratePerHour" in obj)) {
        errors.push({
            field: "ratePerHour",
            message: "missing required field"
        });
    }
    if (!("active" in obj)) {
        errors.push({
            field: "active",
            message: "missing required field"
        });
    }
    if (!("isTechnician" in obj)) {
        errors.push({
            field: "isTechnician",
            message: "missing required field"
        });
    }
    if (!("isSalesRep" in obj)) {
        errors.push({
            field: "isSalesRep",
            message: "missing required field"
        });
    }
    if (!("description" in obj)) {
        errors.push({
            field: "description",
            message: "missing required field"
        });
    }
    if (!("linkedinUrl" in obj)) {
        errors.push({
            field: "linkedinUrl",
            message: "missing required field"
        });
    }
    if (!("attendance" in obj)) {
        errors.push({
            field: "attendance",
            message: "missing required field"
        });
    }
    if (!("settings" in obj)) {
        errors.push({
            field: "settings",
            message: "missing required field"
        });
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
        ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
        const __raw_id = obj["id"] as string;
        instance.id = __raw_id;
    }
    {
        const __raw_imageUrl = obj["imageUrl"] as string | null;
        instance.imageUrl = __raw_imageUrl;
    }
    {
        const __raw_name = obj["name"] as string;
        if (__raw_name.trim().length === 0) {
            errors.push({
                field: "name",
                message: "Employee.name must not be empty"
            });
        }
        instance.name = __raw_name;
    }
    {
        const __raw_phones = obj["phones"] as Array<PhoneNumber>;
        if (Array.isArray(__raw_phones)) {
            instance.phones = __raw_phones as PhoneNumber[];
        }
    }
    {
        const __raw_role = obj["role"] as string;
        if (__raw_role.trim().length === 0) {
            errors.push({
                field: "role",
                message: "Employee.role must not be empty"
            });
        }
        instance.role = __raw_role;
    }
    {
        const __raw_title = obj["title"] as JobTitle;
        {
            const __result = jobTitleDeserializeWithContext(__raw_title, ctx);
            ctx.assignOrDefer(instance, "title", __result);
        }
    }
    {
        const __raw_email = obj["email"] as Email;
        {
            const __result = emailDeserializeWithContext(__raw_email, ctx);
            ctx.assignOrDefer(instance, "email", __result);
        }
    }
    {
        const __raw_address = obj["address"] as string;
        if (__raw_address.trim().length === 0) {
            errors.push({
                field: "address",
                message: "Employee.address must not be empty"
            });
        }
        instance.address = __raw_address;
    }
    {
        const __raw_username = obj["username"] as string;
        if (__raw_username.trim().length === 0) {
            errors.push({
                field: "username",
                message: "Employee.username must not be empty"
            });
        }
        instance.username = __raw_username;
    }
    {
        const __raw_route = obj["route"] as string | Route;
        instance.route = __raw_route;
    }
    {
        const __raw_ratePerHour = obj["ratePerHour"] as number;
        instance.ratePerHour = __raw_ratePerHour;
    }
    {
        const __raw_active = obj["active"] as boolean;
        instance.active = __raw_active;
    }
    {
        const __raw_isTechnician = obj["isTechnician"] as boolean;
        instance.isTechnician = __raw_isTechnician;
    }
    {
        const __raw_isSalesRep = obj["isSalesRep"] as boolean;
        instance.isSalesRep = __raw_isSalesRep;
    }
    {
        const __raw_description = obj["description"] as string | null;
        instance.description = __raw_description;
    }
    {
        const __raw_linkedinUrl = obj["linkedinUrl"] as string | null;
        instance.linkedinUrl = __raw_linkedinUrl;
    }
    {
        const __raw_attendance = obj["attendance"] as Array<string>;
        if (Array.isArray(__raw_attendance)) {
            instance.attendance = __raw_attendance as string[];
        }
    }
    {
        const __raw_settings = obj["settings"] as Settings;
        {
            const __result = settingsDeserializeWithContext(__raw_settings, ctx);
            ctx.assignOrDefer(instance, "settings", __result);
        }
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    return instance as Employee;
}
export function employeeValidateField<K extends keyof Employee>(_field: K, _value: Employee[K]): Array<{
    field: string;
    message: string;
}> {
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (_field === "name") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "name",
                message: "Employee.name must not be empty"
            });
        }
    }
    if (_field === "role") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "role",
                message: "Employee.role must not be empty"
            });
        }
    }
    if (_field === "address") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "address",
                message: "Employee.address must not be empty"
            });
        }
    }
    if (_field === "username") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "username",
                message: "Employee.username must not be empty"
            });
        }
    }
    return errors;
}
export function employeeValidateFields(_partial: Partial<Employee>): Array<{
    field: string;
    message: string;
}> {
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if ("name" in _partial && _partial.name !== undefined) {
        const __val = _partial.name as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "name",
                message: "Employee.name must not be empty"
            });
        }
    }
    if ("role" in _partial && _partial.role !== undefined) {
        const __val = _partial.role as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "role",
                message: "Employee.role must not be empty"
            });
        }
    }
    if ("address" in _partial && _partial.address !== undefined) {
        const __val = _partial.address as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "address",
                message: "Employee.address must not be empty"
            });
        }
    }
    if ("username" in _partial && _partial.username !== undefined) {
        const __val = _partial.username as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "username",
                message: "Employee.username must not be empty"
            });
        }
    }
    return errors;
}
export function employeeHasShape(obj: unknown): boolean {
    if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
        return false;
    }
    const o = obj as Record<string, unknown>;
    return '"id" in o && "imageUrl" in o && "name" in o && "phones" in o && "role" in o && "title" in o && "email" in o && "address" in o && "username" in o && "route" in o && "ratePerHour" in o && "active" in o && "isTechnician" in o && "isSalesRep" in o && "description" in o && "linkedinUrl" in o && "attendance" in o && "settings" in o';
}
export function employeeIs(obj: unknown): obj is Employee {
    if (!employeeHasShape(obj)) {
        return false;
    }
    const result = employeeDeserialize(obj);
    return result.success;
}

export type EmployeeErrors = {
    _errors: __gf_Option<Array<string>>;
    id: __gf_Option<Array<string>>;
    imageUrl: __gf_Option<Array<string>>;
    name: __gf_Option<Array<string>>;
    phones: __gf_Option<Array<string>>;
    role: __gf_Option<Array<string>>;
    title: __gf_Option<Array<string>>;
    email: __gf_Option<Array<string>>;
    address: __gf_Option<Array<string>>;
    username: __gf_Option<Array<string>>;
    route: __gf_Option<Array<string>>;
    ratePerHour: __gf_Option<Array<string>>;
    active: __gf_Option<Array<string>>;
    isTechnician: __gf_Option<Array<string>>;
    isSalesRep: __gf_Option<Array<string>>;
    description: __gf_Option<Array<string>>;
    linkedinUrl: __gf_Option<Array<string>>;
    attendance: __gf_Option<Array<string>>;
    settings: __gf_Option<Array<string>>;
};
export type EmployeeTainted = {
    id: __gf_Option<boolean>;
    imageUrl: __gf_Option<boolean>;
    name: __gf_Option<boolean>;
    phones: __gf_Option<boolean>;
    role: __gf_Option<boolean>;
    title: __gf_Option<boolean>;
    email: __gf_Option<boolean>;
    address: __gf_Option<boolean>;
    username: __gf_Option<boolean>;
    route: __gf_Option<boolean>;
    ratePerHour: __gf_Option<boolean>;
    active: __gf_Option<boolean>;
    isTechnician: __gf_Option<boolean>;
    isSalesRep: __gf_Option<boolean>;
    description: __gf_Option<boolean>;
    linkedinUrl: __gf_Option<boolean>;
    attendance: __gf_Option<boolean>;
    settings: __gf_Option<boolean>;
};
export interface EmployeeFieldControllers {
    readonly id: FieldController<string>;
    readonly imageUrl: FieldController<string | null>;
    readonly name: FieldController<string>;
    readonly phones: ArrayFieldController<PhoneNumber>;
    readonly role: FieldController<string>;
    readonly title: FieldController<JobTitle>;
    readonly email: FieldController<Email>;
    readonly address: FieldController<string>;
    readonly username: FieldController<string>;
    readonly route: FieldController<string | Route>;
    readonly ratePerHour: FieldController<number>;
    readonly active: FieldController<boolean>;
    readonly isTechnician: FieldController<boolean>;
    readonly isSalesRep: FieldController<boolean>;
    readonly description: FieldController<string | null>;
    readonly linkedinUrl: FieldController<string | null>;
    readonly attendance: ArrayFieldController<string>;
    readonly settings: FieldController<Settings>;
}
export interface EmployeeGigaform {
    readonly data: Employee;
    readonly errors: EmployeeErrors;
    readonly tainted: EmployeeTainted;
    readonly fields: EmployeeFieldControllers;
    validate(): Exit<Employee, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<Employee>): void;
}
export function employeeCreateForm(overrides?: Partial<Employee>): EmployeeGigaform {
    let data = $state({
        ...employeeDefaultValue(),
        ...overrides
    });
    let errors = $state<EmployeeErrors>({
        _errors: optionNone(),
        id: optionNone(),
        imageUrl: optionNone(),
        name: optionNone(),
        phones: optionNone(),
        role: optionNone(),
        title: optionNone(),
        email: optionNone(),
        address: optionNone(),
        username: optionNone(),
        route: optionNone(),
        ratePerHour: optionNone(),
        active: optionNone(),
        isTechnician: optionNone(),
        isSalesRep: optionNone(),
        description: optionNone(),
        linkedinUrl: optionNone(),
        attendance: optionNone(),
        settings: optionNone()
    } as EmployeeErrors);
    let tainted = $state<EmployeeTainted>({
        id: optionNone(),
        imageUrl: optionNone(),
        name: optionNone(),
        phones: optionNone(),
        role: optionNone(),
        title: optionNone(),
        email: optionNone(),
        address: optionNone(),
        username: optionNone(),
        route: optionNone(),
        ratePerHour: optionNone(),
        active: optionNone(),
        isTechnician: optionNone(),
        isSalesRep: optionNone(),
        description: optionNone(),
        linkedinUrl: optionNone(),
        attendance: optionNone(),
        settings: optionNone()
    } as EmployeeTainted);
    const fields = {
        id: {
            path: [
                "id"
            ] as const,
            name: "id",
            constraints: {
                required: true
            },
            get: ()=>data.id,
            set: (value: string)=>{
                data.id = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.id,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.id = value;
            },
            getTainted: ()=>tainted.id,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.id = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = employeeValidateField("id", data.id);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        imageUrl: {
            path: [
                "imageUrl"
            ] as const,
            name: "imageUrl",
            constraints: {
                required: true
            },
            get: ()=>data.imageUrl,
            set: (value: string | null)=>{
                data.imageUrl = value;
            },
            transform: (value: string | null): string | null =>value,
            getError: ()=>errors.imageUrl,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.imageUrl = value;
            },
            getTainted: ()=>tainted.imageUrl,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.imageUrl = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = employeeValidateField("imageUrl", data.imageUrl);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        name: {
            path: [
                "name"
            ] as const,
            name: "name",
            constraints: {
                required: true
            },
            get: ()=>data.name,
            set: (value: string)=>{
                data.name = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.name,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.name = value;
            },
            getTainted: ()=>tainted.name,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.name = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = employeeValidateField("name", data.name);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        phones: {
            path: [
                "phones"
            ] as const,
            name: "phones",
            constraints: {
                required: true
            },
            get: ()=>data.phones,
            set: (value: Array<PhoneNumber>)=>{
                data.phones = value;
            },
            transform: (value: Array<PhoneNumber>): Array<PhoneNumber> =>value,
            getError: ()=>errors.phones,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.phones = value;
            },
            getTainted: ()=>tainted.phones,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.phones = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = employeeValidateField("phones", data.phones);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            },
            at: (index: number)=>({
                    path: [
                        "phones",
                        index
                    ] as const,
                    name: "'^phones.${index}^'",
                    constraints: {
                        required: true
                    },
                    get: ()=>data.phones[index]!,
                    set: (value: PhoneNumber)=>{
                        data.phones[index] = value;
                    },
                    transform: (value: PhoneNumber): PhoneNumber =>value,
                    getError: ()=>errors.phones,
                    setError: (value: __gf_Option<Array<string>>)=>{
                        errors.phones = value;
                    },
                    getTainted: ()=>tainted.phones,
                    setTainted: (value: __gf_Option<boolean>)=>{
                        tainted.phones = value;
                    },
                    validate: (): Array<string> =>[]
                }),
            push: (item: PhoneNumber)=>{
                data.phones.push(item);
            },
            remove: (index: number)=>{
                data.phones.splice(index, 1);
            },
            swap: (a: number, b: number)=>{
                const tmp = data.phones[a]!;
                data.phones[a] = data.phones[b]!;
                data.phones[b] = tmp;
            }
        },
        role: {
            path: [
                "role"
            ] as const,
            name: "role",
            constraints: {
                required: true
            },
            get: ()=>data.role,
            set: (value: string)=>{
                data.role = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.role,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.role = value;
            },
            getTainted: ()=>tainted.role,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.role = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = employeeValidateField("role", data.role);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        title: {
            path: [
                "title"
            ] as const,
            name: "title",
            constraints: {
                required: true
            },
            get: ()=>data.title,
            set: (value: JobTitle)=>{
                data.title = value;
            },
            transform: (value: JobTitle): JobTitle =>value,
            getError: ()=>errors.title,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.title = value;
            },
            getTainted: ()=>tainted.title,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.title = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = employeeValidateField("title", data.title);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        email: {
            path: [
                "email"
            ] as const,
            name: "email",
            constraints: {
                required: true
            },
            get: ()=>data.email,
            set: (value: Email)=>{
                data.email = value;
            },
            transform: (value: Email): Email =>value,
            getError: ()=>errors.email,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.email = value;
            },
            getTainted: ()=>tainted.email,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.email = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = employeeValidateField("email", data.email);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        address: {
            path: [
                "address"
            ] as const,
            name: "address",
            constraints: {
                required: true
            },
            get: ()=>data.address,
            set: (value: string)=>{
                data.address = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.address,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.address = value;
            },
            getTainted: ()=>tainted.address,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.address = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = employeeValidateField("address", data.address);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        username: {
            path: [
                "username"
            ] as const,
            name: "username",
            constraints: {
                required: true
            },
            get: ()=>data.username,
            set: (value: string)=>{
                data.username = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.username,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.username = value;
            },
            getTainted: ()=>tainted.username,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.username = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = employeeValidateField("username", data.username);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        route: {
            path: [
                "route"
            ] as const,
            name: "route",
            constraints: {
                required: true
            },
            get: ()=>data.route,
            set: (value: string | Route)=>{
                data.route = value;
            },
            transform: (value: string | Route): string | Route =>value,
            getError: ()=>errors.route,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.route = value;
            },
            getTainted: ()=>tainted.route,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.route = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = employeeValidateField("route", data.route);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        ratePerHour: {
            path: [
                "ratePerHour"
            ] as const,
            name: "ratePerHour",
            constraints: {
                required: true
            },
            get: ()=>data.ratePerHour,
            set: (value: number)=>{
                data.ratePerHour = value;
            },
            transform: (value: number): number =>value,
            getError: ()=>errors.ratePerHour,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.ratePerHour = value;
            },
            getTainted: ()=>tainted.ratePerHour,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.ratePerHour = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = employeeValidateField("ratePerHour", data.ratePerHour);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        active: {
            path: [
                "active"
            ] as const,
            name: "active",
            constraints: {
                required: true
            },
            get: ()=>data.active,
            set: (value: boolean)=>{
                data.active = value;
            },
            transform: (value: boolean): boolean =>value,
            getError: ()=>errors.active,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.active = value;
            },
            getTainted: ()=>tainted.active,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.active = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = employeeValidateField("active", data.active);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        isTechnician: {
            path: [
                "isTechnician"
            ] as const,
            name: "isTechnician",
            constraints: {
                required: true
            },
            get: ()=>data.isTechnician,
            set: (value: boolean)=>{
                data.isTechnician = value;
            },
            transform: (value: boolean): boolean =>value,
            getError: ()=>errors.isTechnician,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.isTechnician = value;
            },
            getTainted: ()=>tainted.isTechnician,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.isTechnician = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = employeeValidateField("isTechnician", data.isTechnician);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        isSalesRep: {
            path: [
                "isSalesRep"
            ] as const,
            name: "isSalesRep",
            constraints: {
                required: true
            },
            get: ()=>data.isSalesRep,
            set: (value: boolean)=>{
                data.isSalesRep = value;
            },
            transform: (value: boolean): boolean =>value,
            getError: ()=>errors.isSalesRep,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.isSalesRep = value;
            },
            getTainted: ()=>tainted.isSalesRep,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.isSalesRep = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = employeeValidateField("isSalesRep", data.isSalesRep);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        description: {
            path: [
                "description"
            ] as const,
            name: "description",
            constraints: {
                required: true
            },
            get: ()=>data.description,
            set: (value: string | null)=>{
                data.description = value;
            },
            transform: (value: string | null): string | null =>value,
            getError: ()=>errors.description,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.description = value;
            },
            getTainted: ()=>tainted.description,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.description = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = employeeValidateField("description", data.description);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        linkedinUrl: {
            path: [
                "linkedinUrl"
            ] as const,
            name: "linkedinUrl",
            constraints: {
                required: true
            },
            get: ()=>data.linkedinUrl,
            set: (value: string | null)=>{
                data.linkedinUrl = value;
            },
            transform: (value: string | null): string | null =>value,
            getError: ()=>errors.linkedinUrl,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.linkedinUrl = value;
            },
            getTainted: ()=>tainted.linkedinUrl,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.linkedinUrl = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = employeeValidateField("linkedinUrl", data.linkedinUrl);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        attendance: {
            path: [
                "attendance"
            ] as const,
            name: "attendance",
            constraints: {
                required: true
            },
            get: ()=>data.attendance,
            set: (value: Array<string>)=>{
                data.attendance = value;
            },
            transform: (value: Array<string>): Array<string> =>value,
            getError: ()=>errors.attendance,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.attendance = value;
            },
            getTainted: ()=>tainted.attendance,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.attendance = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = employeeValidateField("attendance", data.attendance);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            },
            at: (index: number)=>({
                    path: [
                        "attendance",
                        index
                    ] as const,
                    name: "'^attendance.${index}^'",
                    constraints: {
                        required: true
                    },
                    get: ()=>data.attendance[index]!,
                    set: (value: string)=>{
                        data.attendance[index] = value;
                    },
                    transform: (value: string): string =>value,
                    getError: ()=>errors.attendance,
                    setError: (value: __gf_Option<Array<string>>)=>{
                        errors.attendance = value;
                    },
                    getTainted: ()=>tainted.attendance,
                    setTainted: (value: __gf_Option<boolean>)=>{
                        tainted.attendance = value;
                    },
                    validate: (): Array<string> =>[]
                }),
            push: (item: string)=>{
                data.attendance.push(item);
            },
            remove: (index: number)=>{
                data.attendance.splice(index, 1);
            },
            swap: (a: number, b: number)=>{
                const tmp = data.attendance[a]!;
                data.attendance[a] = data.attendance[b]!;
                data.attendance[b] = tmp;
            }
        },
        settings: {
            path: [
                "settings"
            ] as const,
            name: "settings",
            constraints: {
                required: true
            },
            get: ()=>data.settings,
            set: (value: Settings)=>{
                data.settings = value;
            },
            transform: (value: Settings): Settings =>value,
            getError: ()=>errors.settings,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.settings = value;
            },
            getTainted: ()=>tainted.settings,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.settings = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = employeeValidateField("settings", data.settings);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        }
    } as EmployeeFieldControllers;
    const __gf_getter_hint = "get data() set data(v) get errors() set errors(v) get tainted() set tainted(v)";
    const __gf_validate_hint = ".map((e: { field: string; message: string }) => e.message)";
    function validate(): Exit<Employee, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(employeeDeserialize(data));
    }
    function reset(newOverrides?: Partial<Employee>): void {
        data = {
            ...employeeDefaultValue(),
            ...newOverrides
        };
        errors = {
            _errors: optionNone(),
            id: optionNone(),
            imageUrl: optionNone(),
            name: optionNone(),
            phones: optionNone(),
            role: optionNone(),
            title: optionNone(),
            email: optionNone(),
            address: optionNone(),
            username: optionNone(),
            route: optionNone(),
            ratePerHour: optionNone(),
            active: optionNone(),
            isTechnician: optionNone(),
            isSalesRep: optionNone(),
            description: optionNone(),
            linkedinUrl: optionNone(),
            attendance: optionNone(),
            settings: optionNone()
        };
        tainted = {
            id: optionNone(),
            imageUrl: optionNone(),
            name: optionNone(),
            phones: optionNone(),
            role: optionNone(),
            title: optionNone(),
            email: optionNone(),
            address: optionNone(),
            username: optionNone(),
            route: optionNone(),
            ratePerHour: optionNone(),
            active: optionNone(),
            isTechnician: optionNone(),
            isSalesRep: optionNone(),
            description: optionNone(),
            linkedinUrl: optionNone(),
            attendance: optionNone(),
            settings: optionNone()
        };
    }
    return {
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        fields,
        validate,
        reset
    };
}
export function employeeFromFormData(formData: FormData): Exit<Employee, Array<{
    field: string;
    message: string;
}>> {
    const obj: Record<string, unknown> = {};
    const __gf_exit_hint = "Exit<Employee, Array<{ field: string; message: string }>>";
    obj.id = formData.get(`${"id"}`) ?? "";
    obj.imageUrl = formData.get(`${"imageUrl"}`) ?? "";
    obj.name = formData.get(`${"name"}`) ?? "";
    {
        const phonesItems: Array<Record<string, unknown>> = [];
        let idx = 0;
        while(formData.has(`${"phones"}.` + idx + ".") || idx === 0){
            const hasAny = Array.from(formData.keys()).some((k)=>k.startsWith(`${"phones"}.` + idx + "."));
            if (!hasAny && idx > 0) break;
            if (hasAny) {
                const item: Record<string, unknown> = {};
                for (const [key, value] of Array.from(formData.entries())){
                    if (key.startsWith(`${"phones"}.` + idx + ".")) {
                        const fieldName = key.slice(`${"phones"}.`.length + String(idx).length + 1);
                        item[fieldName] = value;
                    }
                }
                phonesItems.push(item);
            }
            idx++;
            if (idx > 1000) break;
        }
        obj.phones = phonesItems;
    }
    obj.role = formData.get(`${"role"}`) ?? "";
    {
        const titleObj: Record<string, unknown> = {};
        for (const [key, value] of Array.from(formData.entries())){
            if (key.startsWith(`${"title"}.`)) {
                const fieldName = key.slice(`${"title"}.`.length);
                const parts = fieldName.split(".");
                let current = titleObj;
                for(let i = 0; i < parts.length - 1; i++){
                    const part = parts[i]!;
                    if (!(part in current)) {
                        current[part] = {};
                    }
                    current = current[part] as Record<string, unknown>;
                }
                current[parts[parts.length - 1]!] = value;
            }
        }
        obj.title = titleObj;
    }
    {
        const emailObj: Record<string, unknown> = {};
        for (const [key, value] of Array.from(formData.entries())){
            if (key.startsWith(`${"email"}.`)) {
                const fieldName = key.slice(`${"email"}.`.length);
                const parts = fieldName.split(".");
                let current = emailObj;
                for(let i = 0; i < parts.length - 1; i++){
                    const part = parts[i]!;
                    if (!(part in current)) {
                        current[part] = {};
                    }
                    current = current[part] as Record<string, unknown>;
                }
                current[parts[parts.length - 1]!] = value;
            }
        }
        obj.email = emailObj;
    }
    obj.address = formData.get(`${"address"}`) ?? "";
    obj.username = formData.get(`${"username"}`) ?? "";
    obj.route = formData.get(`${"route"}`) ?? "";
    {
        const ratePerHourStr = formData.get(`${"ratePerHour"}`);
        obj.ratePerHour = ratePerHourStr ? parseFloat(ratePerHourStr as string) : $MfPh5;
        if (obj.ratePerHour !== undefined && isNaN(obj.ratePerHour as number)) obj.ratePerHour = "0";
    }
    {
        const activeVal = formData.get(`${"active"}`);
        obj.active = activeVal === "true" || activeVal === "on" || activeVal === "1";
    }
    {
        const isTechnicianVal = formData.get(`${"isTechnician"}`);
        obj.isTechnician = isTechnicianVal === "true" || isTechnicianVal === "on" || isTechnicianVal === "1";
    }
    {
        const isSalesRepVal = formData.get(`${"isSalesRep"}`);
        obj.isSalesRep = isSalesRepVal === "true" || isSalesRepVal === "on" || isSalesRepVal === "1";
    }
    obj.description = formData.get(`${"description"}`) ?? "";
    obj.linkedinUrl = formData.get(`${"linkedinUrl"}`) ?? "";
    obj.attendance = formData.getAll(`${"attendance"}`) as Array<string>;
    {
        const settingsObj: Record<string, unknown> = {};
        for (const [key, value] of Array.from(formData.entries())){
            if (key.startsWith(`${"settings"}.`)) {
                const fieldName = key.slice(`${"settings"}.`.length);
                const parts = fieldName.split(".");
                let current = settingsObj;
                for(let i = 0; i < parts.length - 1; i++){
                    const part = parts[i]!;
                    if (!(part in current)) {
                        current[part] = {};
                    }
                    current = current[part] as Record<string, unknown>;
                }
                current[parts[parts.length - 1]!] = value;
            }
        }
        obj.settings = settingsObj;
    }
    return toExit(employeeDeserialize(obj));
}

export const Employee = {
  defaultValue: employeeDefaultValue,
  serialize: employeeSerialize,
  serializeWithContext: employeeSerializeWithContext,
  deserialize: employeeDeserialize,
  deserializeWithContext: employeeDeserializeWithContext,
  validateFields: employeeValidateFields,
  hasShape: employeeHasShape,
  is: employeeIs,
  createForm: employeeCreateForm,
  fromFormData: employeeFromFormData
} as const;


export interface Commissions {
    
    technician: string;
    
    salesRep: string;
}

export function commissionsDefaultValue(): Commissions {
    return {
        technician: "",
        salesRep: ""
    } as Commissions;
}

export function commissionsSerialize(value: Commissions): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(commissionsSerializeWithContext(value, ctx));
}
export function commissionsSerializeWithContext(value: Commissions, ctx: __mf_SerializeContext): Record<string, unknown> {
    const existingId = ctx.getId(value);
    if (existingId !== undefined) {
        return {
            __ref: existingId
        };
    }
    const __id = ctx.register(value);
    const result: Record<string, unknown> = {
        __type: "Commissions",
        __id
    };
    result.technician = value.technician;
    result.salesRep = value.salesRep;
    return result;
}

export function commissionsDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: Commissions } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = commissionsDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "Commissions.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function commissionsDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Commissions | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
        throw new __mf_DeserializeError([
            {
                field: "_root",
                message: `${"Commissions"}.deserializeWithContext: expected an object`
            }
        ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (!("technician" in obj)) {
        errors.push({
            field: "technician",
            message: "missing required field"
        });
    }
    if (!("salesRep" in obj)) {
        errors.push({
            field: "salesRep",
            message: "missing required field"
        });
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
        ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
        const __raw_technician = obj["technician"] as string;
        if (__raw_technician.trim().length === 0) {
            errors.push({
                field: "technician",
                message: "Commissions.technician must not be empty"
            });
        }
        instance.technician = __raw_technician;
    }
    {
        const __raw_salesRep = obj["salesRep"] as string;
        if (__raw_salesRep.trim().length === 0) {
            errors.push({
                field: "salesRep",
                message: "Commissions.salesRep must not be empty"
            });
        }
        instance.salesRep = __raw_salesRep;
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    return instance as Commissions;
}
export function commissionsValidateField<K extends keyof Commissions>(_field: K, _value: Commissions[K]): Array<{
    field: string;
    message: string;
}> {
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (_field === "technician") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "technician",
                message: "Commissions.technician must not be empty"
            });
        }
    }
    if (_field === "salesRep") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "salesRep",
                message: "Commissions.salesRep must not be empty"
            });
        }
    }
    return errors;
}
export function commissionsValidateFields(_partial: Partial<Commissions>): Array<{
    field: string;
    message: string;
}> {
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if ("technician" in _partial && _partial.technician !== undefined) {
        const __val = _partial.technician as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "technician",
                message: "Commissions.technician must not be empty"
            });
        }
    }
    if ("salesRep" in _partial && _partial.salesRep !== undefined) {
        const __val = _partial.salesRep as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "salesRep",
                message: "Commissions.salesRep must not be empty"
            });
        }
    }
    return errors;
}
export function commissionsHasShape(obj: unknown): boolean {
    if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
        return false;
    }
    const o = obj as Record<string, unknown>;
    return '"technician" in o && "salesRep" in o';
}
export function commissionsIs(obj: unknown): obj is Commissions {
    if (!commissionsHasShape(obj)) {
        return false;
    }
    const result = commissionsDeserialize(obj);
    return result.success;
}

export type CommissionsErrors = {
    _errors: __gf_Option<Array<string>>;
    technician: __gf_Option<Array<string>>;
    salesRep: __gf_Option<Array<string>>;
};
export type CommissionsTainted = {
    technician: __gf_Option<boolean>;
    salesRep: __gf_Option<boolean>;
};
export interface CommissionsFieldControllers {
    readonly technician: FieldController<string>;
    readonly salesRep: FieldController<string>;
}
export interface CommissionsGigaform {
    readonly data: Commissions;
    readonly errors: CommissionsErrors;
    readonly tainted: CommissionsTainted;
    readonly fields: CommissionsFieldControllers;
    validate(): Exit<Commissions, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<Commissions>): void;
}
export function commissionsCreateForm(overrides?: Partial<Commissions>): CommissionsGigaform {
    let data = $state({
        ...commissionsDefaultValue(),
        ...overrides
    });
    let errors = $state<CommissionsErrors>({
        _errors: optionNone(),
        technician: optionNone(),
        salesRep: optionNone()
    } as CommissionsErrors);
    let tainted = $state<CommissionsTainted>({
        technician: optionNone(),
        salesRep: optionNone()
    } as CommissionsTainted);
    const fields = {
        technician: {
            path: [
                "technician"
            ] as const,
            name: "technician",
            constraints: {
                required: true
            },
            get: ()=>data.technician,
            set: (value: string)=>{
                data.technician = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.technician,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.technician = value;
            },
            getTainted: ()=>tainted.technician,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.technician = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = commissionsValidateField("technician", data.technician);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        salesRep: {
            path: [
                "salesRep"
            ] as const,
            name: "salesRep",
            constraints: {
                required: true
            },
            get: ()=>data.salesRep,
            set: (value: string)=>{
                data.salesRep = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.salesRep,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.salesRep = value;
            },
            getTainted: ()=>tainted.salesRep,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.salesRep = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = commissionsValidateField("salesRep", data.salesRep);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        }
    } as CommissionsFieldControllers;
    const __gf_getter_hint = "get data() set data(v) get errors() set errors(v) get tainted() set tainted(v)";
    const __gf_validate_hint = ".map((e: { field: string; message: string }) => e.message)";
    function validate(): Exit<Commissions, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(commissionsDeserialize(data));
    }
    function reset(newOverrides?: Partial<Commissions>): void {
        data = {
            ...commissionsDefaultValue(),
            ...newOverrides
        };
        errors = {
            _errors: optionNone(),
            technician: optionNone(),
            salesRep: optionNone()
        };
        tainted = {
            technician: optionNone(),
            salesRep: optionNone()
        };
    }
    return {
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        fields,
        validate,
        reset
    };
}
export function commissionsFromFormData(formData: FormData): Exit<Commissions, Array<{
    field: string;
    message: string;
}>> {
    const obj: Record<string, unknown> = {};
    const __gf_exit_hint = "Exit<Commissions, Array<{ field: string; message: string }>>";
    obj.technician = formData.get(`${"technician"}`) ?? "";
    obj.salesRep = formData.get(`${"salesRep"}`) ?? "";
    return toExit(commissionsDeserialize(obj));
}

export const Commissions = {
  defaultValue: commissionsDefaultValue,
  serialize: commissionsSerialize,
  serializeWithContext: commissionsSerializeWithContext,
  deserialize: commissionsDeserialize,
  deserializeWithContext: commissionsDeserializeWithContext,
  validateFields: commissionsValidateFields,
  hasShape: commissionsHasShape,
  is: commissionsIs,
  createForm: commissionsCreateForm,
  fromFormData: commissionsFromFormData
} as const;


export interface Number {
    
    countryCode: string;
    
    areaCode: string;
    
    localNumber: string;
}

export function numberDefaultValue(): Number {
    return {
        countryCode: "",
        areaCode: "",
        localNumber: ""
    } as Number;
}

export function numberSerialize(value: Number): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(numberSerializeWithContext(value, ctx));
}
export function numberSerializeWithContext(value: Number, ctx: __mf_SerializeContext): Record<string, unknown> {
    const existingId = ctx.getId(value);
    if (existingId !== undefined) {
        return {
            __ref: existingId
        };
    }
    const __id = ctx.register(value);
    const result: Record<string, unknown> = {
        __type: "Number",
        __id
    };
    result.countryCode = value.countryCode;
    result.areaCode = value.areaCode;
    result.localNumber = value.localNumber;
    return result;
}

export function numberDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: Number } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = numberDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "Number.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function numberDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Number | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
        throw new __mf_DeserializeError([
            {
                field: "_root",
                message: `${"Number"}.deserializeWithContext: expected an object`
            }
        ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (!("countryCode" in obj)) {
        errors.push({
            field: "countryCode",
            message: "missing required field"
        });
    }
    if (!("areaCode" in obj)) {
        errors.push({
            field: "areaCode",
            message: "missing required field"
        });
    }
    if (!("localNumber" in obj)) {
        errors.push({
            field: "localNumber",
            message: "missing required field"
        });
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
        ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
        const __raw_countryCode = obj["countryCode"] as string;
        if (__raw_countryCode.trim().length === 0) {
            errors.push({
                field: "countryCode",
                message: "Number.countryCode must not be empty"
            });
        }
        instance.countryCode = __raw_countryCode;
    }
    {
        const __raw_areaCode = obj["areaCode"] as string;
        if (__raw_areaCode.trim().length === 0) {
            errors.push({
                field: "areaCode",
                message: "Number.areaCode must not be empty"
            });
        }
        instance.areaCode = __raw_areaCode;
    }
    {
        const __raw_localNumber = obj["localNumber"] as string;
        if (__raw_localNumber.trim().length === 0) {
            errors.push({
                field: "localNumber",
                message: "Number.localNumber must not be empty"
            });
        }
        instance.localNumber = __raw_localNumber;
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    return instance as Number;
}
export function numberValidateField<K extends keyof Number>(_field: K, _value: Number[K]): Array<{
    field: string;
    message: string;
}> {
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (_field === "countryCode") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "countryCode",
                message: "Number.countryCode must not be empty"
            });
        }
    }
    if (_field === "areaCode") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "areaCode",
                message: "Number.areaCode must not be empty"
            });
        }
    }
    if (_field === "localNumber") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "localNumber",
                message: "Number.localNumber must not be empty"
            });
        }
    }
    return errors;
}
export function numberValidateFields(_partial: Partial<Number>): Array<{
    field: string;
    message: string;
}> {
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if ("countryCode" in _partial && _partial.countryCode !== undefined) {
        const __val = _partial.countryCode as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "countryCode",
                message: "Number.countryCode must not be empty"
            });
        }
    }
    if ("areaCode" in _partial && _partial.areaCode !== undefined) {
        const __val = _partial.areaCode as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "areaCode",
                message: "Number.areaCode must not be empty"
            });
        }
    }
    if ("localNumber" in _partial && _partial.localNumber !== undefined) {
        const __val = _partial.localNumber as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "localNumber",
                message: "Number.localNumber must not be empty"
            });
        }
    }
    return errors;
}
export function numberHasShape(obj: unknown): boolean {
    if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
        return false;
    }
    const o = obj as Record<string, unknown>;
    return '"countryCode" in o && "areaCode" in o && "localNumber" in o';
}
export function numberIs(obj: unknown): obj is Number {
    if (!numberHasShape(obj)) {
        return false;
    }
    const result = numberDeserialize(obj);
    return result.success;
}

export type NumberErrors = {
    _errors: __gf_Option<Array<string>>;
    countryCode: __gf_Option<Array<string>>;
    areaCode: __gf_Option<Array<string>>;
    localNumber: __gf_Option<Array<string>>;
};
export type NumberTainted = {
    countryCode: __gf_Option<boolean>;
    areaCode: __gf_Option<boolean>;
    localNumber: __gf_Option<boolean>;
};
export interface NumberFieldControllers {
    readonly countryCode: FieldController<string>;
    readonly areaCode: FieldController<string>;
    readonly localNumber: FieldController<string>;
}
export interface NumberGigaform {
    readonly data: Number;
    readonly errors: NumberErrors;
    readonly tainted: NumberTainted;
    readonly fields: NumberFieldControllers;
    validate(): Exit<Number, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<Number>): void;
}
export function numberCreateForm(overrides?: Partial<Number>): NumberGigaform {
    let data = $state({
        ...numberDefaultValue(),
        ...overrides
    });
    let errors = $state<NumberErrors>({
        _errors: optionNone(),
        countryCode: optionNone(),
        areaCode: optionNone(),
        localNumber: optionNone()
    } as NumberErrors);
    let tainted = $state<NumberTainted>({
        countryCode: optionNone(),
        areaCode: optionNone(),
        localNumber: optionNone()
    } as NumberTainted);
    const fields = {
        countryCode: {
            path: [
                "countryCode"
            ] as const,
            name: "countryCode",
            constraints: {
                required: true
            },
            get: ()=>data.countryCode,
            set: (value: string)=>{
                data.countryCode = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.countryCode,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.countryCode = value;
            },
            getTainted: ()=>tainted.countryCode,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.countryCode = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = numberValidateField("countryCode", data.countryCode);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        areaCode: {
            path: [
                "areaCode"
            ] as const,
            name: "areaCode",
            constraints: {
                required: true
            },
            get: ()=>data.areaCode,
            set: (value: string)=>{
                data.areaCode = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.areaCode,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.areaCode = value;
            },
            getTainted: ()=>tainted.areaCode,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.areaCode = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = numberValidateField("areaCode", data.areaCode);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        localNumber: {
            path: [
                "localNumber"
            ] as const,
            name: "localNumber",
            constraints: {
                required: true
            },
            get: ()=>data.localNumber,
            set: (value: string)=>{
                data.localNumber = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.localNumber,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.localNumber = value;
            },
            getTainted: ()=>tainted.localNumber,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.localNumber = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = numberValidateField("localNumber", data.localNumber);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        }
    } as NumberFieldControllers;
    const __gf_getter_hint = "get data() set data(v) get errors() set errors(v) get tainted() set tainted(v)";
    const __gf_validate_hint = ".map((e: { field: string; message: string }) => e.message)";
    function validate(): Exit<Number, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(numberDeserialize(data));
    }
    function reset(newOverrides?: Partial<Number>): void {
        data = {
            ...numberDefaultValue(),
            ...newOverrides
        };
        errors = {
            _errors: optionNone(),
            countryCode: optionNone(),
            areaCode: optionNone(),
            localNumber: optionNone()
        };
        tainted = {
            countryCode: optionNone(),
            areaCode: optionNone(),
            localNumber: optionNone()
        };
    }
    return {
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        fields,
        validate,
        reset
    };
}
export function numberFromFormData(formData: FormData): Exit<Number, Array<{
    field: string;
    message: string;
}>> {
    const obj: Record<string, unknown> = {};
    const __gf_exit_hint = "Exit<Number, Array<{ field: string; message: string }>>";
    obj.countryCode = formData.get(`${"countryCode"}`) ?? "";
    obj.areaCode = formData.get(`${"areaCode"}`) ?? "";
    obj.localNumber = formData.get(`${"localNumber"}`) ?? "";
    return toExit(numberDeserialize(obj));
}

export const Number = {
  defaultValue: numberDefaultValue,
  serialize: numberSerialize,
  serializeWithContext: numberSerializeWithContext,
  deserialize: numberDeserialize,
  deserializeWithContext: numberDeserializeWithContext,
  validateFields: numberValidateFields,
  hasShape: numberHasShape,
  is: numberIs,
  createForm: numberCreateForm,
  fromFormData: numberFromFormData
} as const;


export interface DataPath {
    path: Array<string>;
    formatter: string | null;
}

export function dataPathDefaultValue(): DataPath {
    return {
        path: [],
        formatter: null
    } as DataPath;
}

export function dataPathSerialize(value: DataPath): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(dataPathSerializeWithContext(value, ctx));
}
export function dataPathSerializeWithContext(value: DataPath, ctx: __mf_SerializeContext): Record<string, unknown> {
    const existingId = ctx.getId(value);
    if (existingId !== undefined) {
        return {
            __ref: existingId
        };
    }
    const __id = ctx.register(value);
    const result: Record<string, unknown> = {
        __type: "DataPath",
        __id
    };
    result.path = value.path;
    result.formatter = value.formatter;
    return result;
}

export function dataPathDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: DataPath } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = dataPathDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "DataPath.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function dataPathDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): DataPath | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
        throw new __mf_DeserializeError([
            {
                field: "_root",
                message: `${"DataPath"}.deserializeWithContext: expected an object`
            }
        ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (!("path" in obj)) {
        errors.push({
            field: "path",
            message: "missing required field"
        });
    }
    if (!("formatter" in obj)) {
        errors.push({
            field: "formatter",
            message: "missing required field"
        });
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
        ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
        const __raw_path = obj["path"] as Array<string>;
        if (Array.isArray(__raw_path)) {
            instance.path = __raw_path as string[];
        }
    }
    {
        const __raw_formatter = obj["formatter"] as string | null;
        instance.formatter = __raw_formatter;
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    return instance as DataPath;
}
export function dataPathValidateField<K extends keyof DataPath>(_field: K, _value: DataPath[K]): Array<{
    field: string;
    message: string;
}> {
    return [];
}
export function dataPathValidateFields(_partial: Partial<DataPath>): Array<{
    field: string;
    message: string;
}> {
    return [];
}
export function dataPathHasShape(obj: unknown): boolean {
    if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
        return false;
    }
    const o = obj as Record<string, unknown>;
    return '"path" in o && "formatter" in o';
}
export function dataPathIs(obj: unknown): obj is DataPath {
    if (!dataPathHasShape(obj)) {
        return false;
    }
    const result = dataPathDeserialize(obj);
    return result.success;
}

export type DataPathErrors = {
    _errors: __gf_Option<Array<string>>;
    path: __gf_Option<Array<string>>;
    formatter: __gf_Option<Array<string>>;
};
export type DataPathTainted = {
    path: __gf_Option<boolean>;
    formatter: __gf_Option<boolean>;
};
export interface DataPathFieldControllers {
    readonly path: ArrayFieldController<string>;
    readonly formatter: FieldController<string | null>;
}
export interface DataPathGigaform {
    readonly data: DataPath;
    readonly errors: DataPathErrors;
    readonly tainted: DataPathTainted;
    readonly fields: DataPathFieldControllers;
    validate(): Exit<DataPath, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<DataPath>): void;
}
export function dataPathCreateForm(overrides?: Partial<DataPath>): DataPathGigaform {
    let data = $state({
        ...dataPathDefaultValue(),
        ...overrides
    });
    let errors = $state<DataPathErrors>({
        _errors: optionNone(),
        path: optionNone(),
        formatter: optionNone()
    } as DataPathErrors);
    let tainted = $state<DataPathTainted>({
        path: optionNone(),
        formatter: optionNone()
    } as DataPathTainted);
    const fields = {
        path: {
            path: [
                "path"
            ] as const,
            name: "path",
            constraints: {
                required: true
            },
            get: ()=>data.path,
            set: (value: Array<string>)=>{
                data.path = value;
            },
            transform: (value: Array<string>): Array<string> =>value,
            getError: ()=>errors.path,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.path = value;
            },
            getTainted: ()=>tainted.path,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.path = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = dataPathValidateField("path", data.path);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            },
            at: (index: number)=>({
                    path: [
                        "path",
                        index
                    ] as const,
                    name: "'^path.${index}^'",
                    constraints: {
                        required: true
                    },
                    get: ()=>data.path[index]!,
                    set: (value: string)=>{
                        data.path[index] = value;
                    },
                    transform: (value: string): string =>value,
                    getError: ()=>errors.path,
                    setError: (value: __gf_Option<Array<string>>)=>{
                        errors.path = value;
                    },
                    getTainted: ()=>tainted.path,
                    setTainted: (value: __gf_Option<boolean>)=>{
                        tainted.path = value;
                    },
                    validate: (): Array<string> =>[]
                }),
            push: (item: string)=>{
                data.path.push(item);
            },
            remove: (index: number)=>{
                data.path.splice(index, 1);
            },
            swap: (a: number, b: number)=>{
                const tmp = data.path[a]!;
                data.path[a] = data.path[b]!;
                data.path[b] = tmp;
            }
        },
        formatter: {
            path: [
                "formatter"
            ] as const,
            name: "formatter",
            constraints: {
                required: true
            },
            get: ()=>data.formatter,
            set: (value: string | null)=>{
                data.formatter = value;
            },
            transform: (value: string | null): string | null =>value,
            getError: ()=>errors.formatter,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.formatter = value;
            },
            getTainted: ()=>tainted.formatter,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.formatter = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = dataPathValidateField("formatter", data.formatter);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        }
    } as DataPathFieldControllers;
    const __gf_getter_hint = "get data() set data(v) get errors() set errors(v) get tainted() set tainted(v)";
    const __gf_validate_hint = ".map((e: { field: string; message: string }) => e.message)";
    function validate(): Exit<DataPath, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(dataPathDeserialize(data));
    }
    function reset(newOverrides?: Partial<DataPath>): void {
        data = {
            ...dataPathDefaultValue(),
            ...newOverrides
        };
        errors = {
            _errors: optionNone(),
            path: optionNone(),
            formatter: optionNone()
        };
        tainted = {
            path: optionNone(),
            formatter: optionNone()
        };
    }
    return {
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        fields,
        validate,
        reset
    };
}
export function dataPathFromFormData(formData: FormData): Exit<DataPath, Array<{
    field: string;
    message: string;
}>> {
    const obj: Record<string, unknown> = {};
    const __gf_exit_hint = "Exit<DataPath, Array<{ field: string; message: string }>>";
    obj.path = formData.getAll(`${"path"}`) as Array<string>;
    obj.formatter = formData.get(`${"formatter"}`) ?? "";
    return toExit(dataPathDeserialize(obj));
}

export const DataPath = {
  defaultValue: dataPathDefaultValue,
  serialize: dataPathSerialize,
  serializeWithContext: dataPathSerializeWithContext,
  deserialize: dataPathDeserialize,
  deserializeWithContext: dataPathDeserializeWithContext,
  validateFields: dataPathValidateFields,
  hasShape: dataPathHasShape,
  is: dataPathIs,
  createForm: dataPathCreateForm,
  fromFormData: dataPathFromFormData
} as const;


export interface Route {
    id: string;
    techs: Array<string | Employee> | null;
    active: boolean;
    
    name: string;
    
    phone: string;
    
    position: string;
    serviceRoute: boolean;
    defaultDurationHours: number;
    tags: Array<string>;
    icon: string | null;
    color: string | null;
}

export function routeDefaultValue(): Route {
    return {
        id: "",
        techs: null,
        active: false,
        name: "",
        phone: "",
        position: "",
        serviceRoute: false,
        defaultDurationHours: 0,
        tags: [],
        icon: null,
        color: null
    } as Route;
}

export function routeSerialize(value: Route): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(routeSerializeWithContext(value, ctx));
}
export function routeSerializeWithContext(value: Route, ctx: __mf_SerializeContext): Record<string, unknown> {
    const existingId = ctx.getId(value);
    if (existingId !== undefined) {
        return {
            __ref: existingId
        };
    }
    const __id = ctx.register(value);
    const result: Record<string, unknown> = {
        __type: "Route",
        __id
    };
    result.id = value.id;
    if (value.techs !== null) {
        result.techs = value.techs;
    }
    result.active = value.active;
    result.name = value.name;
    result.phone = value.phone;
    result.position = value.position;
    result.serviceRoute = value.serviceRoute;
    result.defaultDurationHours = value.defaultDurationHours;
    result.tags = value.tags;
    result.icon = value.icon;
    result.color = value.color;
    return result;
}

export function routeDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: Route } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = routeDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "Route.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function routeDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Route | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
        throw new __mf_DeserializeError([
            {
                field: "_root",
                message: `${"Route"}.deserializeWithContext: expected an object`
            }
        ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (!("id" in obj)) {
        errors.push({
            field: "id",
            message: "missing required field"
        });
    }
    if (!("techs" in obj)) {
        errors.push({
            field: "techs",
            message: "missing required field"
        });
    }
    if (!("active" in obj)) {
        errors.push({
            field: "active",
            message: "missing required field"
        });
    }
    if (!("name" in obj)) {
        errors.push({
            field: "name",
            message: "missing required field"
        });
    }
    if (!("phone" in obj)) {
        errors.push({
            field: "phone",
            message: "missing required field"
        });
    }
    if (!("position" in obj)) {
        errors.push({
            field: "position",
            message: "missing required field"
        });
    }
    if (!("serviceRoute" in obj)) {
        errors.push({
            field: "serviceRoute",
            message: "missing required field"
        });
    }
    if (!("defaultDurationHours" in obj)) {
        errors.push({
            field: "defaultDurationHours",
            message: "missing required field"
        });
    }
    if (!("tags" in obj)) {
        errors.push({
            field: "tags",
            message: "missing required field"
        });
    }
    if (!("icon" in obj)) {
        errors.push({
            field: "icon",
            message: "missing required field"
        });
    }
    if (!("color" in obj)) {
        errors.push({
            field: "color",
            message: "missing required field"
        });
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
        ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
        const __raw_id = obj["id"] as string;
        instance.id = __raw_id;
    }
    {
        const __raw_techs = obj["techs"] as Array<string | Employee> | null;
        if (__raw_techs === null) {
            instance.techs = null;
        } else {
            instance.techs = __raw_techs;
        }
    }
    {
        const __raw_active = obj["active"] as boolean;
        instance.active = __raw_active;
    }
    {
        const __raw_name = obj["name"] as string;
        if (__raw_name.trim().length === 0) {
            errors.push({
                field: "name",
                message: "Route.name must not be empty"
            });
        }
        instance.name = __raw_name;
    }
    {
        const __raw_phone = obj["phone"] as string;
        if (__raw_phone.trim().length === 0) {
            errors.push({
                field: "phone",
                message: "Route.phone must not be empty"
            });
        }
        instance.phone = __raw_phone;
    }
    {
        const __raw_position = obj["position"] as string;
        if (__raw_position.trim().length === 0) {
            errors.push({
                field: "position",
                message: "Route.position must not be empty"
            });
        }
        instance.position = __raw_position;
    }
    {
        const __raw_serviceRoute = obj["serviceRoute"] as boolean;
        instance.serviceRoute = __raw_serviceRoute;
    }
    {
        const __raw_defaultDurationHours = obj["defaultDurationHours"] as number;
        instance.defaultDurationHours = __raw_defaultDurationHours;
    }
    {
        const __raw_tags = obj["tags"] as Array<string>;
        if (Array.isArray(__raw_tags)) {
            instance.tags = __raw_tags as string[];
        }
    }
    {
        const __raw_icon = obj["icon"] as string | null;
        instance.icon = __raw_icon;
    }
    {
        const __raw_color = obj["color"] as string | null;
        instance.color = __raw_color;
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    return instance as Route;
}
export function routeValidateField<K extends keyof Route>(_field: K, _value: Route[K]): Array<{
    field: string;
    message: string;
}> {
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (_field === "name") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "name",
                message: "Route.name must not be empty"
            });
        }
    }
    if (_field === "phone") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "phone",
                message: "Route.phone must not be empty"
            });
        }
    }
    if (_field === "position") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "position",
                message: "Route.position must not be empty"
            });
        }
    }
    return errors;
}
export function routeValidateFields(_partial: Partial<Route>): Array<{
    field: string;
    message: string;
}> {
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if ("name" in _partial && _partial.name !== undefined) {
        const __val = _partial.name as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "name",
                message: "Route.name must not be empty"
            });
        }
    }
    if ("phone" in _partial && _partial.phone !== undefined) {
        const __val = _partial.phone as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "phone",
                message: "Route.phone must not be empty"
            });
        }
    }
    if ("position" in _partial && _partial.position !== undefined) {
        const __val = _partial.position as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "position",
                message: "Route.position must not be empty"
            });
        }
    }
    return errors;
}
export function routeHasShape(obj: unknown): boolean {
    if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
        return false;
    }
    const o = obj as Record<string, unknown>;
    return '"id" in o && "techs" in o && "active" in o && "name" in o && "phone" in o && "position" in o && "serviceRoute" in o && "defaultDurationHours" in o && "tags" in o && "icon" in o && "color" in o';
}
export function routeIs(obj: unknown): obj is Route {
    if (!routeHasShape(obj)) {
        return false;
    }
    const result = routeDeserialize(obj);
    return result.success;
}

export type RouteErrors = {
    _errors: __gf_Option<Array<string>>;
    id: __gf_Option<Array<string>>;
    techs: __gf_Option<Array<string>>;
    active: __gf_Option<Array<string>>;
    name: __gf_Option<Array<string>>;
    phone: __gf_Option<Array<string>>;
    position: __gf_Option<Array<string>>;
    serviceRoute: __gf_Option<Array<string>>;
    defaultDurationHours: __gf_Option<Array<string>>;
    tags: __gf_Option<Array<string>>;
    icon: __gf_Option<Array<string>>;
    color: __gf_Option<Array<string>>;
};
export type RouteTainted = {
    id: __gf_Option<boolean>;
    techs: __gf_Option<boolean>;
    active: __gf_Option<boolean>;
    name: __gf_Option<boolean>;
    phone: __gf_Option<boolean>;
    position: __gf_Option<boolean>;
    serviceRoute: __gf_Option<boolean>;
    defaultDurationHours: __gf_Option<boolean>;
    tags: __gf_Option<boolean>;
    icon: __gf_Option<boolean>;
    color: __gf_Option<boolean>;
};
export interface RouteFieldControllers {
    readonly id: FieldController<string>;
    readonly techs: FieldController<Array<string | Employee> | null>;
    readonly active: FieldController<boolean>;
    readonly name: FieldController<string>;
    readonly phone: FieldController<string>;
    readonly position: FieldController<string>;
    readonly serviceRoute: FieldController<boolean>;
    readonly defaultDurationHours: FieldController<number>;
    readonly tags: ArrayFieldController<string>;
    readonly icon: FieldController<string | null>;
    readonly color: FieldController<string | null>;
}
export interface RouteGigaform {
    readonly data: Route;
    readonly errors: RouteErrors;
    readonly tainted: RouteTainted;
    readonly fields: RouteFieldControllers;
    validate(): Exit<Route, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<Route>): void;
}
export function routeCreateForm(overrides?: Partial<Route>): RouteGigaform {
    let data = $state({
        ...routeDefaultValue(),
        ...overrides
    });
    let errors = $state<RouteErrors>({
        _errors: optionNone(),
        id: optionNone(),
        techs: optionNone(),
        active: optionNone(),
        name: optionNone(),
        phone: optionNone(),
        position: optionNone(),
        serviceRoute: optionNone(),
        defaultDurationHours: optionNone(),
        tags: optionNone(),
        icon: optionNone(),
        color: optionNone()
    } as RouteErrors);
    let tainted = $state<RouteTainted>({
        id: optionNone(),
        techs: optionNone(),
        active: optionNone(),
        name: optionNone(),
        phone: optionNone(),
        position: optionNone(),
        serviceRoute: optionNone(),
        defaultDurationHours: optionNone(),
        tags: optionNone(),
        icon: optionNone(),
        color: optionNone()
    } as RouteTainted);
    const fields = {
        id: {
            path: [
                "id"
            ] as const,
            name: "id",
            constraints: {
                required: true
            },
            get: ()=>data.id,
            set: (value: string)=>{
                data.id = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.id,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.id = value;
            },
            getTainted: ()=>tainted.id,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.id = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = routeValidateField("id", data.id);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        techs: {
            path: [
                "techs"
            ] as const,
            name: "techs",
            constraints: {
                required: true
            },
            get: ()=>data.techs,
            set: (value: Array<string | Employee> | null)=>{
                data.techs = value;
            },
            transform: (value: Array<string | Employee> | null): Array<string | Employee> | null =>value,
            getError: ()=>errors.techs,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.techs = value;
            },
            getTainted: ()=>tainted.techs,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.techs = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = routeValidateField("techs", data.techs);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        active: {
            path: [
                "active"
            ] as const,
            name: "active",
            constraints: {
                required: true
            },
            get: ()=>data.active,
            set: (value: boolean)=>{
                data.active = value;
            },
            transform: (value: boolean): boolean =>value,
            getError: ()=>errors.active,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.active = value;
            },
            getTainted: ()=>tainted.active,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.active = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = routeValidateField("active", data.active);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        name: {
            path: [
                "name"
            ] as const,
            name: "name",
            constraints: {
                required: true
            },
            get: ()=>data.name,
            set: (value: string)=>{
                data.name = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.name,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.name = value;
            },
            getTainted: ()=>tainted.name,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.name = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = routeValidateField("name", data.name);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        phone: {
            path: [
                "phone"
            ] as const,
            name: "phone",
            constraints: {
                required: true
            },
            get: ()=>data.phone,
            set: (value: string)=>{
                data.phone = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.phone,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.phone = value;
            },
            getTainted: ()=>tainted.phone,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.phone = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = routeValidateField("phone", data.phone);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        position: {
            path: [
                "position"
            ] as const,
            name: "position",
            constraints: {
                required: true
            },
            get: ()=>data.position,
            set: (value: string)=>{
                data.position = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.position,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.position = value;
            },
            getTainted: ()=>tainted.position,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.position = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = routeValidateField("position", data.position);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        serviceRoute: {
            path: [
                "serviceRoute"
            ] as const,
            name: "serviceRoute",
            constraints: {
                required: true
            },
            get: ()=>data.serviceRoute,
            set: (value: boolean)=>{
                data.serviceRoute = value;
            },
            transform: (value: boolean): boolean =>value,
            getError: ()=>errors.serviceRoute,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.serviceRoute = value;
            },
            getTainted: ()=>tainted.serviceRoute,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.serviceRoute = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = routeValidateField("serviceRoute", data.serviceRoute);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        defaultDurationHours: {
            path: [
                "defaultDurationHours"
            ] as const,
            name: "defaultDurationHours",
            constraints: {
                required: true
            },
            get: ()=>data.defaultDurationHours,
            set: (value: number)=>{
                data.defaultDurationHours = value;
            },
            transform: (value: number): number =>value,
            getError: ()=>errors.defaultDurationHours,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.defaultDurationHours = value;
            },
            getTainted: ()=>tainted.defaultDurationHours,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.defaultDurationHours = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = routeValidateField("defaultDurationHours", data.defaultDurationHours);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        tags: {
            path: [
                "tags"
            ] as const,
            name: "tags",
            constraints: {
                required: true
            },
            get: ()=>data.tags,
            set: (value: Array<string>)=>{
                data.tags = value;
            },
            transform: (value: Array<string>): Array<string> =>value,
            getError: ()=>errors.tags,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.tags = value;
            },
            getTainted: ()=>tainted.tags,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.tags = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = routeValidateField("tags", data.tags);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            },
            at: (index: number)=>({
                    path: [
                        "tags",
                        index
                    ] as const,
                    name: "'^tags.${index}^'",
                    constraints: {
                        required: true
                    },
                    get: ()=>data.tags[index]!,
                    set: (value: string)=>{
                        data.tags[index] = value;
                    },
                    transform: (value: string): string =>value,
                    getError: ()=>errors.tags,
                    setError: (value: __gf_Option<Array<string>>)=>{
                        errors.tags = value;
                    },
                    getTainted: ()=>tainted.tags,
                    setTainted: (value: __gf_Option<boolean>)=>{
                        tainted.tags = value;
                    },
                    validate: (): Array<string> =>[]
                }),
            push: (item: string)=>{
                data.tags.push(item);
            },
            remove: (index: number)=>{
                data.tags.splice(index, 1);
            },
            swap: (a: number, b: number)=>{
                const tmp = data.tags[a]!;
                data.tags[a] = data.tags[b]!;
                data.tags[b] = tmp;
            }
        },
        icon: {
            path: [
                "icon"
            ] as const,
            name: "icon",
            constraints: {
                required: true
            },
            get: ()=>data.icon,
            set: (value: string | null)=>{
                data.icon = value;
            },
            transform: (value: string | null): string | null =>value,
            getError: ()=>errors.icon,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.icon = value;
            },
            getTainted: ()=>tainted.icon,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.icon = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = routeValidateField("icon", data.icon);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        color: {
            path: [
                "color"
            ] as const,
            name: "color",
            constraints: {
                required: true
            },
            get: ()=>data.color,
            set: (value: string | null)=>{
                data.color = value;
            },
            transform: (value: string | null): string | null =>value,
            getError: ()=>errors.color,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.color = value;
            },
            getTainted: ()=>tainted.color,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.color = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = routeValidateField("color", data.color);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        }
    } as RouteFieldControllers;
    const __gf_getter_hint = "get data() set data(v) get errors() set errors(v) get tainted() set tainted(v)";
    const __gf_validate_hint = ".map((e: { field: string; message: string }) => e.message)";
    function validate(): Exit<Route, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(routeDeserialize(data));
    }
    function reset(newOverrides?: Partial<Route>): void {
        data = {
            ...routeDefaultValue(),
            ...newOverrides
        };
        errors = {
            _errors: optionNone(),
            id: optionNone(),
            techs: optionNone(),
            active: optionNone(),
            name: optionNone(),
            phone: optionNone(),
            position: optionNone(),
            serviceRoute: optionNone(),
            defaultDurationHours: optionNone(),
            tags: optionNone(),
            icon: optionNone(),
            color: optionNone()
        };
        tainted = {
            id: optionNone(),
            techs: optionNone(),
            active: optionNone(),
            name: optionNone(),
            phone: optionNone(),
            position: optionNone(),
            serviceRoute: optionNone(),
            defaultDurationHours: optionNone(),
            tags: optionNone(),
            icon: optionNone(),
            color: optionNone()
        };
    }
    return {
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        fields,
        validate,
        reset
    };
}
export function routeFromFormData(formData: FormData): Exit<Route, Array<{
    field: string;
    message: string;
}>> {
    const obj: Record<string, unknown> = {};
    const __gf_exit_hint = "Exit<Route, Array<{ field: string; message: string }>>";
    obj.id = formData.get(`${"id"}`) ?? "";
    obj.techs = formData.get(`${"techs"}`) ?? "";
    {
        const activeVal = formData.get(`${"active"}`);
        obj.active = activeVal === "true" || activeVal === "on" || activeVal === "1";
    }
    obj.name = formData.get(`${"name"}`) ?? "";
    obj.phone = formData.get(`${"phone"}`) ?? "";
    obj.position = formData.get(`${"position"}`) ?? "";
    {
        const serviceRouteVal = formData.get(`${"serviceRoute"}`);
        obj.serviceRoute = serviceRouteVal === "true" || serviceRouteVal === "on" || serviceRouteVal === "1";
    }
    {
        const defaultDurationHoursStr = formData.get(`${"defaultDurationHours"}`);
        obj.defaultDurationHours = defaultDurationHoursStr ? parseFloat(defaultDurationHoursStr as string) : $MfPh5;
        if (obj.defaultDurationHours !== undefined && isNaN(obj.defaultDurationHours as number)) obj.defaultDurationHours = "0";
    }
    obj.tags = formData.getAll(`${"tags"}`) as Array<string>;
    obj.icon = formData.get(`${"icon"}`) ?? "";
    obj.color = formData.get(`${"color"}`) ?? "";
    return toExit(routeDeserialize(obj));
}

export const Route = {
  defaultValue: routeDefaultValue,
  serialize: routeSerialize,
  serializeWithContext: routeSerializeWithContext,
  deserialize: routeDeserialize,
  deserializeWithContext: routeDeserializeWithContext,
  validateFields: routeValidateFields,
  hasShape: routeHasShape,
  is: routeIs,
  createForm: routeCreateForm,
  fromFormData: routeFromFormData
} as const;


export interface EmailParts {
    
    local: string;
    
    domainName: string;
    
    topLevelDomain: string;
}

export function emailPartsDefaultValue(): EmailParts {
    return {
        local: "",
        domainName: "",
        topLevelDomain: ""
    } as EmailParts;
}

export function emailPartsSerialize(value: EmailParts): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(emailPartsSerializeWithContext(value, ctx));
}
export function emailPartsSerializeWithContext(value: EmailParts, ctx: __mf_SerializeContext): Record<string, unknown> {
    const existingId = ctx.getId(value);
    if (existingId !== undefined) {
        return {
            __ref: existingId
        };
    }
    const __id = ctx.register(value);
    const result: Record<string, unknown> = {
        __type: "EmailParts",
        __id
    };
    result.local = value.local;
    result.domainName = value.domainName;
    result.topLevelDomain = value.topLevelDomain;
    return result;
}

export function emailPartsDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: EmailParts } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = emailPartsDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "EmailParts.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function emailPartsDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): EmailParts | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
        throw new __mf_DeserializeError([
            {
                field: "_root",
                message: `${"EmailParts"}.deserializeWithContext: expected an object`
            }
        ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (!("local" in obj)) {
        errors.push({
            field: "local",
            message: "missing required field"
        });
    }
    if (!("domainName" in obj)) {
        errors.push({
            field: "domainName",
            message: "missing required field"
        });
    }
    if (!("topLevelDomain" in obj)) {
        errors.push({
            field: "topLevelDomain",
            message: "missing required field"
        });
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
        ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
        const __raw_local = obj["local"] as string;
        if (__raw_local.trim().length === 0) {
            errors.push({
                field: "local",
                message: "EmailParts.local must not be empty"
            });
        }
        instance.local = __raw_local;
    }
    {
        const __raw_domainName = obj["domainName"] as string;
        if (__raw_domainName.trim().length === 0) {
            errors.push({
                field: "domainName",
                message: "EmailParts.domainName must not be empty"
            });
        }
        instance.domainName = __raw_domainName;
    }
    {
        const __raw_topLevelDomain = obj["topLevelDomain"] as string;
        if (__raw_topLevelDomain.trim().length === 0) {
            errors.push({
                field: "topLevelDomain",
                message: "EmailParts.topLevelDomain must not be empty"
            });
        }
        instance.topLevelDomain = __raw_topLevelDomain;
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    return instance as EmailParts;
}
export function emailPartsValidateField<K extends keyof EmailParts>(_field: K, _value: EmailParts[K]): Array<{
    field: string;
    message: string;
}> {
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (_field === "local") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "local",
                message: "EmailParts.local must not be empty"
            });
        }
    }
    if (_field === "domainName") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "domainName",
                message: "EmailParts.domainName must not be empty"
            });
        }
    }
    if (_field === "topLevelDomain") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "topLevelDomain",
                message: "EmailParts.topLevelDomain must not be empty"
            });
        }
    }
    return errors;
}
export function emailPartsValidateFields(_partial: Partial<EmailParts>): Array<{
    field: string;
    message: string;
}> {
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if ("local" in _partial && _partial.local !== undefined) {
        const __val = _partial.local as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "local",
                message: "EmailParts.local must not be empty"
            });
        }
    }
    if ("domainName" in _partial && _partial.domainName !== undefined) {
        const __val = _partial.domainName as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "domainName",
                message: "EmailParts.domainName must not be empty"
            });
        }
    }
    if ("topLevelDomain" in _partial && _partial.topLevelDomain !== undefined) {
        const __val = _partial.topLevelDomain as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "topLevelDomain",
                message: "EmailParts.topLevelDomain must not be empty"
            });
        }
    }
    return errors;
}
export function emailPartsHasShape(obj: unknown): boolean {
    if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
        return false;
    }
    const o = obj as Record<string, unknown>;
    return '"local" in o && "domainName" in o && "topLevelDomain" in o';
}
export function emailPartsIs(obj: unknown): obj is EmailParts {
    if (!emailPartsHasShape(obj)) {
        return false;
    }
    const result = emailPartsDeserialize(obj);
    return result.success;
}

export type EmailPartsErrors = {
    _errors: __gf_Option<Array<string>>;
    local: __gf_Option<Array<string>>;
    domainName: __gf_Option<Array<string>>;
    topLevelDomain: __gf_Option<Array<string>>;
};
export type EmailPartsTainted = {
    local: __gf_Option<boolean>;
    domainName: __gf_Option<boolean>;
    topLevelDomain: __gf_Option<boolean>;
};
export interface EmailPartsFieldControllers {
    readonly local: FieldController<string>;
    readonly domainName: FieldController<string>;
    readonly topLevelDomain: FieldController<string>;
}
export interface EmailPartsGigaform {
    readonly data: EmailParts;
    readonly errors: EmailPartsErrors;
    readonly tainted: EmailPartsTainted;
    readonly fields: EmailPartsFieldControllers;
    validate(): Exit<EmailParts, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<EmailParts>): void;
}
export function emailPartsCreateForm(overrides?: Partial<EmailParts>): EmailPartsGigaform {
    let data = $state({
        ...emailPartsDefaultValue(),
        ...overrides
    });
    let errors = $state<EmailPartsErrors>({
        _errors: optionNone(),
        local: optionNone(),
        domainName: optionNone(),
        topLevelDomain: optionNone()
    } as EmailPartsErrors);
    let tainted = $state<EmailPartsTainted>({
        local: optionNone(),
        domainName: optionNone(),
        topLevelDomain: optionNone()
    } as EmailPartsTainted);
    const fields = {
        local: {
            path: [
                "local"
            ] as const,
            name: "local",
            constraints: {
                required: true
            },
            get: ()=>data.local,
            set: (value: string)=>{
                data.local = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.local,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.local = value;
            },
            getTainted: ()=>tainted.local,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.local = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = emailPartsValidateField("local", data.local);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        domainName: {
            path: [
                "domainName"
            ] as const,
            name: "domainName",
            constraints: {
                required: true
            },
            get: ()=>data.domainName,
            set: (value: string)=>{
                data.domainName = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.domainName,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.domainName = value;
            },
            getTainted: ()=>tainted.domainName,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.domainName = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = emailPartsValidateField("domainName", data.domainName);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        topLevelDomain: {
            path: [
                "topLevelDomain"
            ] as const,
            name: "topLevelDomain",
            constraints: {
                required: true
            },
            get: ()=>data.topLevelDomain,
            set: (value: string)=>{
                data.topLevelDomain = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.topLevelDomain,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.topLevelDomain = value;
            },
            getTainted: ()=>tainted.topLevelDomain,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.topLevelDomain = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = emailPartsValidateField("topLevelDomain", data.topLevelDomain);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        }
    } as EmailPartsFieldControllers;
    const __gf_getter_hint = "get data() set data(v) get errors() set errors(v) get tainted() set tainted(v)";
    const __gf_validate_hint = ".map((e: { field: string; message: string }) => e.message)";
    function validate(): Exit<EmailParts, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(emailPartsDeserialize(data));
    }
    function reset(newOverrides?: Partial<EmailParts>): void {
        data = {
            ...emailPartsDefaultValue(),
            ...newOverrides
        };
        errors = {
            _errors: optionNone(),
            local: optionNone(),
            domainName: optionNone(),
            topLevelDomain: optionNone()
        };
        tainted = {
            local: optionNone(),
            domainName: optionNone(),
            topLevelDomain: optionNone()
        };
    }
    return {
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        fields,
        validate,
        reset
    };
}
export function emailPartsFromFormData(formData: FormData): Exit<EmailParts, Array<{
    field: string;
    message: string;
}>> {
    const obj: Record<string, unknown> = {};
    const __gf_exit_hint = "Exit<EmailParts, Array<{ field: string; message: string }>>";
    obj.local = formData.get(`${"local"}`) ?? "";
    obj.domainName = formData.get(`${"domainName"}`) ?? "";
    obj.topLevelDomain = formData.get(`${"topLevelDomain"}`) ?? "";
    return toExit(emailPartsDeserialize(obj));
}

export const EmailParts = {
  defaultValue: emailPartsDefaultValue,
  serialize: emailPartsSerialize,
  serializeWithContext: emailPartsSerializeWithContext,
  deserialize: emailPartsDeserialize,
  deserializeWithContext: emailPartsDeserializeWithContext,
  validateFields: emailPartsValidateFields,
  hasShape: emailPartsHasShape,
  is: emailPartsIs,
  createForm: emailPartsCreateForm,
  fromFormData: emailPartsFromFormData
} as const;


export interface Sent {
    recipient: string | null;
    method: string | null;
}

export function sentDefaultValue(): Sent {
    return {
        recipient: null,
        method: null
    } as Sent;
}

export function sentSerialize(value: Sent): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(sentSerializeWithContext(value, ctx));
}
export function sentSerializeWithContext(value: Sent, ctx: __mf_SerializeContext): Record<string, unknown> {
    const existingId = ctx.getId(value);
    if (existingId !== undefined) {
        return {
            __ref: existingId
        };
    }
    const __id = ctx.register(value);
    const result: Record<string, unknown> = {
        __type: "Sent",
        __id
    };
    result.recipient = value.recipient;
    result.method = value.method;
    return result;
}

export function sentDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: Sent } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = sentDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "Sent.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function sentDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Sent | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
        throw new __mf_DeserializeError([
            {
                field: "_root",
                message: `${"Sent"}.deserializeWithContext: expected an object`
            }
        ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (!("recipient" in obj)) {
        errors.push({
            field: "recipient",
            message: "missing required field"
        });
    }
    if (!("method" in obj)) {
        errors.push({
            field: "method",
            message: "missing required field"
        });
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
        ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
        const __raw_recipient = obj["recipient"] as string | null;
        instance.recipient = __raw_recipient;
    }
    {
        const __raw_method = obj["method"] as string | null;
        instance.method = __raw_method;
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    return instance as Sent;
}
export function sentValidateField<K extends keyof Sent>(_field: K, _value: Sent[K]): Array<{
    field: string;
    message: string;
}> {
    return [];
}
export function sentValidateFields(_partial: Partial<Sent>): Array<{
    field: string;
    message: string;
}> {
    return [];
}
export function sentHasShape(obj: unknown): boolean {
    if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
        return false;
    }
    const o = obj as Record<string, unknown>;
    return '"recipient" in o && "method" in o';
}
export function sentIs(obj: unknown): obj is Sent {
    if (!sentHasShape(obj)) {
        return false;
    }
    const result = sentDeserialize(obj);
    return result.success;
}

export type SentErrors = {
    _errors: __gf_Option<Array<string>>;
    recipient: __gf_Option<Array<string>>;
    method: __gf_Option<Array<string>>;
};
export type SentTainted = {
    recipient: __gf_Option<boolean>;
    method: __gf_Option<boolean>;
};
export interface SentFieldControllers {
    readonly recipient: FieldController<string | null>;
    readonly method: FieldController<string | null>;
}
export interface SentGigaform {
    readonly data: Sent;
    readonly errors: SentErrors;
    readonly tainted: SentTainted;
    readonly fields: SentFieldControllers;
    validate(): Exit<Sent, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<Sent>): void;
}
export function sentCreateForm(overrides?: Partial<Sent>): SentGigaform {
    let data = $state({
        ...sentDefaultValue(),
        ...overrides
    });
    let errors = $state<SentErrors>({
        _errors: optionNone(),
        recipient: optionNone(),
        method: optionNone()
    } as SentErrors);
    let tainted = $state<SentTainted>({
        recipient: optionNone(),
        method: optionNone()
    } as SentTainted);
    const fields = {
        recipient: {
            path: [
                "recipient"
            ] as const,
            name: "recipient",
            constraints: {
                required: true
            },
            get: ()=>data.recipient,
            set: (value: string | null)=>{
                data.recipient = value;
            },
            transform: (value: string | null): string | null =>value,
            getError: ()=>errors.recipient,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.recipient = value;
            },
            getTainted: ()=>tainted.recipient,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.recipient = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = sentValidateField("recipient", data.recipient);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        method: {
            path: [
                "method"
            ] as const,
            name: "method",
            constraints: {
                required: true
            },
            get: ()=>data.method,
            set: (value: string | null)=>{
                data.method = value;
            },
            transform: (value: string | null): string | null =>value,
            getError: ()=>errors.method,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.method = value;
            },
            getTainted: ()=>tainted.method,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.method = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = sentValidateField("method", data.method);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        }
    } as SentFieldControllers;
    const __gf_getter_hint = "get data() set data(v) get errors() set errors(v) get tainted() set tainted(v)";
    const __gf_validate_hint = ".map((e: { field: string; message: string }) => e.message)";
    function validate(): Exit<Sent, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(sentDeserialize(data));
    }
    function reset(newOverrides?: Partial<Sent>): void {
        data = {
            ...sentDefaultValue(),
            ...newOverrides
        };
        errors = {
            _errors: optionNone(),
            recipient: optionNone(),
            method: optionNone()
        };
        tainted = {
            recipient: optionNone(),
            method: optionNone()
        };
    }
    return {
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        fields,
        validate,
        reset
    };
}
export function sentFromFormData(formData: FormData): Exit<Sent, Array<{
    field: string;
    message: string;
}>> {
    const obj: Record<string, unknown> = {};
    const __gf_exit_hint = "Exit<Sent, Array<{ field: string; message: string }>>";
    obj.recipient = formData.get(`${"recipient"}`) ?? "";
    obj.method = formData.get(`${"method"}`) ?? "";
    return toExit(sentDeserialize(obj));
}

export const Sent = {
  defaultValue: sentDefaultValue,
  serialize: sentSerialize,
  serializeWithContext: sentSerializeWithContext,
  deserialize: sentDeserialize,
  deserializeWithContext: sentDeserializeWithContext,
  validateFields: sentValidateFields,
  hasShape: sentHasShape,
  is: sentIs,
  createForm: sentCreateForm,
  fromFormData: sentFromFormData
} as const;


export interface BilledItem {
    
    
    item: Item;
    
    quantity: number;
    
    taxed: boolean;
    
    upsale: boolean;
}

export function billedItemDefaultValue(): BilledItem {
    return {
        item: "",
        quantity: 0,
        taxed: false,
        upsale: false
    } as BilledItem;
}

export function billedItemSerialize(value: BilledItem): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(billedItemSerializeWithContext(value, ctx));
}
export function billedItemSerializeWithContext(value: BilledItem, ctx: __mf_SerializeContext): Record<string, unknown> {
    const existingId = ctx.getId(value);
    if (existingId !== undefined) {
        return {
            __ref: existingId
        };
    }
    const __id = ctx.register(value);
    const result: Record<string, unknown> = {
        __type: "BilledItem",
        __id
    };
    result.item = itemSerializeWithContext(value.item, ctx);
    result.quantity = value.quantity;
    result.taxed = value.taxed;
    result.upsale = value.upsale;
    return result;
}

export function billedItemDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: BilledItem } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = billedItemDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "BilledItem.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function billedItemDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): BilledItem | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
        throw new __mf_DeserializeError([
            {
                field: "_root",
                message: `${"BilledItem"}.deserializeWithContext: expected an object`
            }
        ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (!("item" in obj)) {
        errors.push({
            field: "item",
            message: "missing required field"
        });
    }
    if (!("quantity" in obj)) {
        errors.push({
            field: "quantity",
            message: "missing required field"
        });
    }
    if (!("taxed" in obj)) {
        errors.push({
            field: "taxed",
            message: "missing required field"
        });
    }
    if (!("upsale" in obj)) {
        errors.push({
            field: "upsale",
            message: "missing required field"
        });
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
        ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
        const __raw_item = obj["item"] as Item;
        {
            const __result = itemDeserializeWithContext(__raw_item, ctx);
            ctx.assignOrDefer(instance, "item", __result);
        }
    }
    {
        const __raw_quantity = obj["quantity"] as number;
        instance.quantity = __raw_quantity;
    }
    {
        const __raw_taxed = obj["taxed"] as boolean;
        instance.taxed = __raw_taxed;
    }
    {
        const __raw_upsale = obj["upsale"] as boolean;
        instance.upsale = __raw_upsale;
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    return instance as BilledItem;
}
export function billedItemValidateField<K extends keyof BilledItem>(_field: K, _value: BilledItem[K]): Array<{
    field: string;
    message: string;
}> {
    return [];
}
export function billedItemValidateFields(_partial: Partial<BilledItem>): Array<{
    field: string;
    message: string;
}> {
    return [];
}
export function billedItemHasShape(obj: unknown): boolean {
    if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
        return false;
    }
    const o = obj as Record<string, unknown>;
    return '"item" in o && "quantity" in o && "taxed" in o && "upsale" in o';
}
export function billedItemIs(obj: unknown): obj is BilledItem {
    if (!billedItemHasShape(obj)) {
        return false;
    }
    const result = billedItemDeserialize(obj);
    return result.success;
}

export type BilledItemErrors = {
    _errors: __gf_Option<Array<string>>;
    item: __gf_Option<Array<string>>;
    quantity: __gf_Option<Array<string>>;
    taxed: __gf_Option<Array<string>>;
    upsale: __gf_Option<Array<string>>;
};
export type BilledItemTainted = {
    item: __gf_Option<boolean>;
    quantity: __gf_Option<boolean>;
    taxed: __gf_Option<boolean>;
    upsale: __gf_Option<boolean>;
};
export interface BilledItemFieldControllers {
    readonly item: FieldController<Item>;
    readonly quantity: FieldController<number>;
    readonly taxed: FieldController<boolean>;
    readonly upsale: FieldController<boolean>;
}
export interface BilledItemGigaform {
    readonly data: BilledItem;
    readonly errors: BilledItemErrors;
    readonly tainted: BilledItemTainted;
    readonly fields: BilledItemFieldControllers;
    validate(): Exit<BilledItem, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<BilledItem>): void;
}
export function billedItemCreateForm(overrides?: Partial<BilledItem>): BilledItemGigaform {
    let data = $state({
        ...billedItemDefaultValue(),
        ...overrides
    });
    let errors = $state<BilledItemErrors>({
        _errors: optionNone(),
        item: optionNone(),
        quantity: optionNone(),
        taxed: optionNone(),
        upsale: optionNone()
    } as BilledItemErrors);
    let tainted = $state<BilledItemTainted>({
        item: optionNone(),
        quantity: optionNone(),
        taxed: optionNone(),
        upsale: optionNone()
    } as BilledItemTainted);
    const fields = {
        item: {
            path: [
                "item"
            ] as const,
            name: "item",
            constraints: {
                required: true
            },
            label: "Item",
            get: ()=>data.item,
            set: (value: Item)=>{
                data.item = value;
            },
            transform: (value: Item): Item =>value,
            getError: ()=>errors.item,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.item = value;
            },
            getTainted: ()=>tainted.item,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.item = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = billedItemValidateField("item", data.item);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        quantity: {
            path: [
                "quantity"
            ] as const,
            name: "quantity",
            constraints: {
                required: true
            },
            label: "Quantity",
            get: ()=>data.quantity,
            set: (value: number)=>{
                data.quantity = value;
            },
            transform: (value: number): number =>value,
            getError: ()=>errors.quantity,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.quantity = value;
            },
            getTainted: ()=>tainted.quantity,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.quantity = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = billedItemValidateField("quantity", data.quantity);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        taxed: {
            path: [
                "taxed"
            ] as const,
            name: "taxed",
            constraints: {
                required: true
            },
            label: "Taxed",
            get: ()=>data.taxed,
            set: (value: boolean)=>{
                data.taxed = value;
            },
            transform: (value: boolean): boolean =>value,
            getError: ()=>errors.taxed,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.taxed = value;
            },
            getTainted: ()=>tainted.taxed,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.taxed = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = billedItemValidateField("taxed", data.taxed);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        upsale: {
            path: [
                "upsale"
            ] as const,
            name: "upsale",
            constraints: {
                required: true
            },
            label: "Upsale",
            get: ()=>data.upsale,
            set: (value: boolean)=>{
                data.upsale = value;
            },
            transform: (value: boolean): boolean =>value,
            getError: ()=>errors.upsale,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.upsale = value;
            },
            getTainted: ()=>tainted.upsale,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.upsale = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = billedItemValidateField("upsale", data.upsale);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        }
    } as BilledItemFieldControllers;
    const __gf_getter_hint = "get data() set data(v) get errors() set errors(v) get tainted() set tainted(v)";
    const __gf_validate_hint = ".map((e: { field: string; message: string }) => e.message)";
    function validate(): Exit<BilledItem, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(billedItemDeserialize(data));
    }
    function reset(newOverrides?: Partial<BilledItem>): void {
        data = {
            ...billedItemDefaultValue(),
            ...newOverrides
        };
        errors = {
            _errors: optionNone(),
            item: optionNone(),
            quantity: optionNone(),
            taxed: optionNone(),
            upsale: optionNone()
        };
        tainted = {
            item: optionNone(),
            quantity: optionNone(),
            taxed: optionNone(),
            upsale: optionNone()
        };
    }
    return {
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        fields,
        validate,
        reset
    };
}
export function billedItemFromFormData(formData: FormData): Exit<BilledItem, Array<{
    field: string;
    message: string;
}>> {
    const obj: Record<string, unknown> = {};
    const __gf_exit_hint = "Exit<BilledItem, Array<{ field: string; message: string }>>";
    {
        const itemObj: Record<string, unknown> = {};
        for (const [key, value] of Array.from(formData.entries())){
            if (key.startsWith(`${"item"}.`)) {
                const fieldName = key.slice(`${"item"}.`.length);
                const parts = fieldName.split(".");
                let current = itemObj;
                for(let i = 0; i < parts.length - 1; i++){
                    const part = parts[i]!;
                    if (!(part in current)) {
                        current[part] = {};
                    }
                    current = current[part] as Record<string, unknown>;
                }
                current[parts[parts.length - 1]!] = value;
            }
        }
        obj.item = itemObj;
    }
    {
        const quantityStr = formData.get(`${"quantity"}`);
        obj.quantity = quantityStr ? parseFloat(quantityStr as string) : $MfPh5;
        if (obj.quantity !== undefined && isNaN(obj.quantity as number)) obj.quantity = "0";
    }
    {
        const taxedVal = formData.get(`${"taxed"}`);
        obj.taxed = taxedVal === "true" || taxedVal === "on" || taxedVal === "1";
    }
    {
        const upsaleVal = formData.get(`${"upsale"}`);
        obj.upsale = upsaleVal === "true" || upsaleVal === "on" || upsaleVal === "1";
    }
    return toExit(billedItemDeserialize(obj));
}

export const BilledItem = {
  defaultValue: billedItemDefaultValue,
  serialize: billedItemSerialize,
  serializeWithContext: billedItemSerializeWithContext,
  deserialize: billedItemDeserialize,
  deserializeWithContext: billedItemDeserializeWithContext,
  validateFields: billedItemValidateFields,
  hasShape: billedItemHasShape,
  is: billedItemIs,
  createForm: billedItemCreateForm,
  fromFormData: billedItemFromFormData
} as const;


export interface Coordinates {
    lat: number;
    lng: number;
}

export function coordinatesDefaultValue(): Coordinates {
    return {
        lat: 0,
        lng: 0
    } as Coordinates;
}

export function coordinatesSerialize(value: Coordinates): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(coordinatesSerializeWithContext(value, ctx));
}
export function coordinatesSerializeWithContext(value: Coordinates, ctx: __mf_SerializeContext): Record<string, unknown> {
    const existingId = ctx.getId(value);
    if (existingId !== undefined) {
        return {
            __ref: existingId
        };
    }
    const __id = ctx.register(value);
    const result: Record<string, unknown> = {
        __type: "Coordinates",
        __id
    };
    result.lat = value.lat;
    result.lng = value.lng;
    return result;
}

export function coordinatesDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: Coordinates } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = coordinatesDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "Coordinates.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function coordinatesDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Coordinates | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
        throw new __mf_DeserializeError([
            {
                field: "_root",
                message: `${"Coordinates"}.deserializeWithContext: expected an object`
            }
        ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (!("lat" in obj)) {
        errors.push({
            field: "lat",
            message: "missing required field"
        });
    }
    if (!("lng" in obj)) {
        errors.push({
            field: "lng",
            message: "missing required field"
        });
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
        ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
        const __raw_lat = obj["lat"] as number;
        instance.lat = __raw_lat;
    }
    {
        const __raw_lng = obj["lng"] as number;
        instance.lng = __raw_lng;
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    return instance as Coordinates;
}
export function coordinatesValidateField<K extends keyof Coordinates>(_field: K, _value: Coordinates[K]): Array<{
    field: string;
    message: string;
}> {
    return [];
}
export function coordinatesValidateFields(_partial: Partial<Coordinates>): Array<{
    field: string;
    message: string;
}> {
    return [];
}
export function coordinatesHasShape(obj: unknown): boolean {
    if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
        return false;
    }
    const o = obj as Record<string, unknown>;
    return '"lat" in o && "lng" in o';
}
export function coordinatesIs(obj: unknown): obj is Coordinates {
    if (!coordinatesHasShape(obj)) {
        return false;
    }
    const result = coordinatesDeserialize(obj);
    return result.success;
}

export type CoordinatesErrors = {
    _errors: __gf_Option<Array<string>>;
    lat: __gf_Option<Array<string>>;
    lng: __gf_Option<Array<string>>;
};
export type CoordinatesTainted = {
    lat: __gf_Option<boolean>;
    lng: __gf_Option<boolean>;
};
export interface CoordinatesFieldControllers {
    readonly lat: FieldController<number>;
    readonly lng: FieldController<number>;
}
export interface CoordinatesGigaform {
    readonly data: Coordinates;
    readonly errors: CoordinatesErrors;
    readonly tainted: CoordinatesTainted;
    readonly fields: CoordinatesFieldControllers;
    validate(): Exit<Coordinates, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<Coordinates>): void;
}
export function coordinatesCreateForm(overrides?: Partial<Coordinates>): CoordinatesGigaform {
    let data = $state({
        ...coordinatesDefaultValue(),
        ...overrides
    });
    let errors = $state<CoordinatesErrors>({
        _errors: optionNone(),
        lat: optionNone(),
        lng: optionNone()
    } as CoordinatesErrors);
    let tainted = $state<CoordinatesTainted>({
        lat: optionNone(),
        lng: optionNone()
    } as CoordinatesTainted);
    const fields = {
        lat: {
            path: [
                "lat"
            ] as const,
            name: "lat",
            constraints: {
                required: true
            },
            get: ()=>data.lat,
            set: (value: number)=>{
                data.lat = value;
            },
            transform: (value: number): number =>value,
            getError: ()=>errors.lat,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.lat = value;
            },
            getTainted: ()=>tainted.lat,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.lat = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = coordinatesValidateField("lat", data.lat);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        lng: {
            path: [
                "lng"
            ] as const,
            name: "lng",
            constraints: {
                required: true
            },
            get: ()=>data.lng,
            set: (value: number)=>{
                data.lng = value;
            },
            transform: (value: number): number =>value,
            getError: ()=>errors.lng,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.lng = value;
            },
            getTainted: ()=>tainted.lng,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.lng = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = coordinatesValidateField("lng", data.lng);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        }
    } as CoordinatesFieldControllers;
    const __gf_getter_hint = "get data() set data(v) get errors() set errors(v) get tainted() set tainted(v)";
    const __gf_validate_hint = ".map((e: { field: string; message: string }) => e.message)";
    function validate(): Exit<Coordinates, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(coordinatesDeserialize(data));
    }
    function reset(newOverrides?: Partial<Coordinates>): void {
        data = {
            ...coordinatesDefaultValue(),
            ...newOverrides
        };
        errors = {
            _errors: optionNone(),
            lat: optionNone(),
            lng: optionNone()
        };
        tainted = {
            lat: optionNone(),
            lng: optionNone()
        };
    }
    return {
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        fields,
        validate,
        reset
    };
}
export function coordinatesFromFormData(formData: FormData): Exit<Coordinates, Array<{
    field: string;
    message: string;
}>> {
    const obj: Record<string, unknown> = {};
    const __gf_exit_hint = "Exit<Coordinates, Array<{ field: string; message: string }>>";
    {
        const latStr = formData.get(`${"lat"}`);
        obj.lat = latStr ? parseFloat(latStr as string) : $MfPh5;
        if (obj.lat !== undefined && isNaN(obj.lat as number)) obj.lat = "0";
    }
    {
        const lngStr = formData.get(`${"lng"}`);
        obj.lng = lngStr ? parseFloat(lngStr as string) : $MfPh5;
        if (obj.lng !== undefined && isNaN(obj.lng as number)) obj.lng = "0";
    }
    return toExit(coordinatesDeserialize(obj));
}

export const Coordinates = {
  defaultValue: coordinatesDefaultValue,
  serialize: coordinatesSerialize,
  serializeWithContext: coordinatesSerializeWithContext,
  deserialize: coordinatesDeserialize,
  deserializeWithContext: coordinatesDeserializeWithContext,
  validateFields: coordinatesValidateFields,
  hasShape: coordinatesHasShape,
  is: coordinatesIs,
  createForm: coordinatesCreateForm,
  fromFormData: coordinatesFromFormData
} as const;


export interface Ordered {
    id: string;
    
    in: string | Account;
    
    out: string | Order;
    date: string;
}

export function orderedDefaultValue(): Ordered {
    return {
        id: "",
        in: "",
        out: "",
        date: ""
    } as Ordered;
}

export function orderedSerialize(value: Ordered): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(orderedSerializeWithContext(value, ctx));
}
export function orderedSerializeWithContext(value: Ordered, ctx: __mf_SerializeContext): Record<string, unknown> {
    const existingId = ctx.getId(value);
    if (existingId !== undefined) {
        return {
            __ref: existingId
        };
    }
    const __id = ctx.register(value);
    const result: Record<string, unknown> = {
        __type: "Ordered",
        __id
    };
    result.id = value.id;
    result.in = value.in;
    result.out = value.out;
    result.date = value.date;
    return result;
}

export function orderedDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: Ordered } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = orderedDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "Ordered.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function orderedDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Ordered | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
        throw new __mf_DeserializeError([
            {
                field: "_root",
                message: `${"Ordered"}.deserializeWithContext: expected an object`
            }
        ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (!("id" in obj)) {
        errors.push({
            field: "id",
            message: "missing required field"
        });
    }
    if (!("in" in obj)) {
        errors.push({
            field: "in",
            message: "missing required field"
        });
    }
    if (!("out" in obj)) {
        errors.push({
            field: "out",
            message: "missing required field"
        });
    }
    if (!("date" in obj)) {
        errors.push({
            field: "date",
            message: "missing required field"
        });
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
        ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
        const __raw_id = obj["id"] as string;
        instance.id = __raw_id;
    }
    {
        const __raw_in = obj["in"] as string | Account;
        instance.in = __raw_in;
    }
    {
        const __raw_out = obj["out"] as string | Order;
        instance.out = __raw_out;
    }
    {
        const __raw_date = obj["date"] as string;
        instance.date = __raw_date;
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    return instance as Ordered;
}
export function orderedValidateField<K extends keyof Ordered>(_field: K, _value: Ordered[K]): Array<{
    field: string;
    message: string;
}> {
    return [];
}
export function orderedValidateFields(_partial: Partial<Ordered>): Array<{
    field: string;
    message: string;
}> {
    return [];
}
export function orderedHasShape(obj: unknown): boolean {
    if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
        return false;
    }
    const o = obj as Record<string, unknown>;
    return '"id" in o && "in" in o && "out" in o && "date" in o';
}
export function orderedIs(obj: unknown): obj is Ordered {
    if (!orderedHasShape(obj)) {
        return false;
    }
    const result = orderedDeserialize(obj);
    return result.success;
}

export type OrderedErrors = {
    _errors: __gf_Option<Array<string>>;
    id: __gf_Option<Array<string>>;
    in: __gf_Option<Array<string>>;
    out: __gf_Option<Array<string>>;
    date: __gf_Option<Array<string>>;
};
export type OrderedTainted = {
    id: __gf_Option<boolean>;
    in: __gf_Option<boolean>;
    out: __gf_Option<boolean>;
    date: __gf_Option<boolean>;
};
export interface OrderedFieldControllers {
    readonly id: FieldController<string>;
    readonly in: FieldController<string | Account>;
    readonly out: FieldController<string | Order>;
    readonly date: FieldController<string>;
}
export interface OrderedGigaform {
    readonly data: Ordered;
    readonly errors: OrderedErrors;
    readonly tainted: OrderedTainted;
    readonly fields: OrderedFieldControllers;
    validate(): Exit<Ordered, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<Ordered>): void;
}
export function orderedCreateForm(overrides?: Partial<Ordered>): OrderedGigaform {
    let data = $state({
        ...orderedDefaultValue(),
        ...overrides
    });
    let errors = $state<OrderedErrors>({
        _errors: optionNone(),
        id: optionNone(),
        in: optionNone(),
        out: optionNone(),
        date: optionNone()
    } as OrderedErrors);
    let tainted = $state<OrderedTainted>({
        id: optionNone(),
        in: optionNone(),
        out: optionNone(),
        date: optionNone()
    } as OrderedTainted);
    const fields = {
        id: {
            path: [
                "id"
            ] as const,
            name: "id",
            constraints: {
                required: true
            },
            get: ()=>data.id,
            set: (value: string)=>{
                data.id = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.id,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.id = value;
            },
            getTainted: ()=>tainted.id,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.id = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = orderedValidateField("id", data.id);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        in: {
            path: [
                "in"
            ] as const,
            name: "in",
            constraints: {
                required: true
            },
            get: ()=>data.in,
            set: (value: string | Account)=>{
                data.in = value;
            },
            transform: (value: string | Account): string | Account =>value,
            getError: ()=>errors.in,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.in = value;
            },
            getTainted: ()=>tainted.in,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.in = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = orderedValidateField("in", data.in);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        out: {
            path: [
                "out"
            ] as const,
            name: "out",
            constraints: {
                required: true
            },
            get: ()=>data.out,
            set: (value: string | Order)=>{
                data.out = value;
            },
            transform: (value: string | Order): string | Order =>value,
            getError: ()=>errors.out,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.out = value;
            },
            getTainted: ()=>tainted.out,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.out = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = orderedValidateField("out", data.out);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        date: {
            path: [
                "date"
            ] as const,
            name: "date",
            constraints: {
                required: true
            },
            get: ()=>data.date,
            set: (value: string)=>{
                data.date = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.date,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.date = value;
            },
            getTainted: ()=>tainted.date,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.date = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = orderedValidateField("date", data.date);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        }
    } as OrderedFieldControllers;
    const __gf_getter_hint = "get data() set data(v) get errors() set errors(v) get tainted() set tainted(v)";
    const __gf_validate_hint = ".map((e: { field: string; message: string }) => e.message)";
    function validate(): Exit<Ordered, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(orderedDeserialize(data));
    }
    function reset(newOverrides?: Partial<Ordered>): void {
        data = {
            ...orderedDefaultValue(),
            ...newOverrides
        };
        errors = {
            _errors: optionNone(),
            id: optionNone(),
            in: optionNone(),
            out: optionNone(),
            date: optionNone()
        };
        tainted = {
            id: optionNone(),
            in: optionNone(),
            out: optionNone(),
            date: optionNone()
        };
    }
    return {
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        fields,
        validate,
        reset
    };
}
export function orderedFromFormData(formData: FormData): Exit<Ordered, Array<{
    field: string;
    message: string;
}>> {
    const obj: Record<string, unknown> = {};
    const __gf_exit_hint = "Exit<Ordered, Array<{ field: string; message: string }>>";
    obj.id = formData.get(`${"id"}`) ?? "";
    obj.in = formData.get(`${"in"}`) ?? "";
    obj.out = formData.get(`${"out"}`) ?? "";
    obj.date = formData.get(`${"date"}`) ?? "";
    return toExit(orderedDeserialize(obj));
}

export const Ordered = {
  defaultValue: orderedDefaultValue,
  serialize: orderedSerialize,
  serializeWithContext: orderedSerializeWithContext,
  deserialize: orderedDeserialize,
  deserializeWithContext: orderedDeserializeWithContext,
  validateFields: orderedValidateFields,
  hasShape: orderedHasShape,
  is: orderedIs,
  createForm: orderedCreateForm,
  fromFormData: orderedFromFormData
} as const;


export interface Email {
    
    canEmail: boolean;
    
    
    emailString: string;
}

export function emailDefaultValue(): Email {
    return {
        canEmail: false,
        emailString: ""
    } as Email;
}

export function emailSerialize(value: Email): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(emailSerializeWithContext(value, ctx));
}
export function emailSerializeWithContext(value: Email, ctx: __mf_SerializeContext): Record<string, unknown> {
    const existingId = ctx.getId(value);
    if (existingId !== undefined) {
        return {
            __ref: existingId
        };
    }
    const __id = ctx.register(value);
    const result: Record<string, unknown> = {
        __type: "Email",
        __id
    };
    result.canEmail = value.canEmail;
    result.emailString = value.emailString;
    return result;
}

export function emailDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: Email } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = emailDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "Email.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function emailDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Email | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
        throw new __mf_DeserializeError([
            {
                field: "_root",
                message: `${"Email"}.deserializeWithContext: expected an object`
            }
        ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (!("canEmail" in obj)) {
        errors.push({
            field: "canEmail",
            message: "missing required field"
        });
    }
    if (!("emailString" in obj)) {
        errors.push({
            field: "emailString",
            message: "missing required field"
        });
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
        ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
        const __raw_canEmail = obj["canEmail"] as boolean;
        instance.canEmail = __raw_canEmail;
    }
    {
        const __raw_emailString = obj["emailString"] as string;
        if (__raw_emailString.trim().length === 0) {
            errors.push({
                field: "emailString",
                message: "Email.emailString must not be empty"
            });
        }
        if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(__raw_emailString)) {
            errors.push({
                field: "emailString",
                message: "Email.emailString must be a valid email"
            });
        }
        instance.emailString = __raw_emailString;
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    return instance as Email;
}
export function emailValidateField<K extends keyof Email>(_field: K, _value: Email[K]): Array<{
    field: string;
    message: string;
}> {
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (_field === "emailString") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "emailString",
                message: "Email.emailString must not be empty"
            });
        }
        if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(__val)) {
            errors.push({
                field: "emailString",
                message: "Email.emailString must be a valid email"
            });
        }
    }
    return errors;
}
export function emailValidateFields(_partial: Partial<Email>): Array<{
    field: string;
    message: string;
}> {
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if ("emailString" in _partial && _partial.emailString !== undefined) {
        const __val = _partial.emailString as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "emailString",
                message: "Email.emailString must not be empty"
            });
        }
        if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(__val)) {
            errors.push({
                field: "emailString",
                message: "Email.emailString must be a valid email"
            });
        }
    }
    return errors;
}
export function emailHasShape(obj: unknown): boolean {
    if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
        return false;
    }
    const o = obj as Record<string, unknown>;
    return '"canEmail" in o && "emailString" in o';
}
export function emailIs(obj: unknown): obj is Email {
    if (!emailHasShape(obj)) {
        return false;
    }
    const result = emailDeserialize(obj);
    return result.success;
}

export type EmailErrors = {
    _errors: __gf_Option<Array<string>>;
    canEmail: __gf_Option<Array<string>>;
    emailString: __gf_Option<Array<string>>;
};
export type EmailTainted = {
    canEmail: __gf_Option<boolean>;
    emailString: __gf_Option<boolean>;
};
export interface EmailFieldControllers {
    readonly canEmail: FieldController<boolean>;
    readonly emailString: FieldController<string>;
}
export interface EmailGigaform {
    readonly data: Email;
    readonly errors: EmailErrors;
    readonly tainted: EmailTainted;
    readonly fields: EmailFieldControllers;
    validate(): Exit<Email, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<Email>): void;
}
export function emailCreateForm(overrides?: Partial<Email>): EmailGigaform {
    let data = $state({
        ...emailDefaultValue(),
        ...overrides
    });
    let errors = $state<EmailErrors>({
        _errors: optionNone(),
        canEmail: optionNone(),
        emailString: optionNone()
    } as EmailErrors);
    let tainted = $state<EmailTainted>({
        canEmail: optionNone(),
        emailString: optionNone()
    } as EmailTainted);
    const fields = {
        canEmail: {
            path: [
                "canEmail"
            ] as const,
            name: "canEmail",
            constraints: {
                required: true
            },
            label: "Can Email",
            get: ()=>data.canEmail,
            set: (value: boolean)=>{
                data.canEmail = value;
            },
            transform: (value: boolean): boolean =>value,
            getError: ()=>errors.canEmail,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.canEmail = value;
            },
            getTainted: ()=>tainted.canEmail,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.canEmail = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = emailValidateField("canEmail", data.canEmail);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        emailString: {
            path: [
                "emailString"
            ] as const,
            name: "emailString",
            constraints: {
                required: true,
                type: "email"
            },
            label: "Email",
            get: ()=>data.emailString,
            set: (value: string)=>{
                data.emailString = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.emailString,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.emailString = value;
            },
            getTainted: ()=>tainted.emailString,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.emailString = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = emailValidateField("emailString", data.emailString);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        }
    } as EmailFieldControllers;
    const __gf_getter_hint = "get data() set data(v) get errors() set errors(v) get tainted() set tainted(v)";
    const __gf_validate_hint = ".map((e: { field: string; message: string }) => e.message)";
    function validate(): Exit<Email, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(emailDeserialize(data));
    }
    function reset(newOverrides?: Partial<Email>): void {
        data = {
            ...emailDefaultValue(),
            ...newOverrides
        };
        errors = {
            _errors: optionNone(),
            canEmail: optionNone(),
            emailString: optionNone()
        };
        tainted = {
            canEmail: optionNone(),
            emailString: optionNone()
        };
    }
    return {
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        fields,
        validate,
        reset
    };
}
export function emailFromFormData(formData: FormData): Exit<Email, Array<{
    field: string;
    message: string;
}>> {
    const obj: Record<string, unknown> = {};
    const __gf_exit_hint = "Exit<Email, Array<{ field: string; message: string }>>";
    {
        const canEmailVal = formData.get(`${"canEmail"}`);
        obj.canEmail = canEmailVal === "true" || canEmailVal === "on" || canEmailVal === "1";
    }
    obj.emailString = formData.get(`${"emailString"}`) ?? "";
    return toExit(emailDeserialize(obj));
}

export const Email = {
  defaultValue: emailDefaultValue,
  serialize: emailSerialize,
  serializeWithContext: emailSerializeWithContext,
  deserialize: emailDeserialize,
  deserializeWithContext: emailDeserializeWithContext,
  validateFields: emailValidateFields,
  hasShape: emailHasShape,
  is: emailIs,
  createForm: emailCreateForm,
  fromFormData: emailFromFormData
} as const;


export interface RecurrenceRule {
    interval: Interval;
    recurrenceBegins: string;
    recurrenceEnds: RecurrenceEnd | null;
    cancelledInstances: Array<string> | null;
    additionalInstances: Array<string> | null;
}

export function recurrenceRuleDefaultValue(): RecurrenceRule {
    return {
        interval: intervalDefaultValue(),
        recurrenceBegins: "",
        recurrenceEnds: null,
        cancelledInstances: null,
        additionalInstances: null
    } as RecurrenceRule;
}

export function recurrenceRuleSerialize(value: RecurrenceRule): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(recurrenceRuleSerializeWithContext(value, ctx));
}
export function recurrenceRuleSerializeWithContext(value: RecurrenceRule, ctx: __mf_SerializeContext): Record<string, unknown> {
    const existingId = ctx.getId(value);
    if (existingId !== undefined) {
        return {
            __ref: existingId
        };
    }
    const __id = ctx.register(value);
    const result: Record<string, unknown> = {
        __type: "RecurrenceRule",
        __id
    };
    result.interval = intervalSerializeWithContext(value.interval, ctx);
    result.recurrenceBegins = value.recurrenceBegins;
    if (value.recurrenceEnds !== null) {
        result.recurrenceEnds = recurrenceEndSerializeWithContext(value.recurrenceEnds, ctx);
    }
    if (value.cancelledInstances !== null) {
        result.cancelledInstances = value.cancelledInstances;
    }
    if (value.additionalInstances !== null) {
        result.additionalInstances = value.additionalInstances;
    }
    return result;
}

export function recurrenceRuleDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: RecurrenceRule } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = recurrenceRuleDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "RecurrenceRule.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function recurrenceRuleDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): RecurrenceRule | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
        throw new __mf_DeserializeError([
            {
                field: "_root",
                message: `${"RecurrenceRule"}.deserializeWithContext: expected an object`
            }
        ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (!("interval" in obj)) {
        errors.push({
            field: "interval",
            message: "missing required field"
        });
    }
    if (!("recurrenceBegins" in obj)) {
        errors.push({
            field: "recurrenceBegins",
            message: "missing required field"
        });
    }
    if (!("recurrenceEnds" in obj)) {
        errors.push({
            field: "recurrenceEnds",
            message: "missing required field"
        });
    }
    if (!("cancelledInstances" in obj)) {
        errors.push({
            field: "cancelledInstances",
            message: "missing required field"
        });
    }
    if (!("additionalInstances" in obj)) {
        errors.push({
            field: "additionalInstances",
            message: "missing required field"
        });
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
        ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
        const __raw_interval = obj["interval"] as Interval;
        {
            const __result = intervalDeserializeWithContext(__raw_interval, ctx);
            ctx.assignOrDefer(instance, "interval", __result);
        }
    }
    {
        const __raw_recurrenceBegins = obj["recurrenceBegins"] as string;
        instance.recurrenceBegins = __raw_recurrenceBegins;
    }
    {
        const __raw_recurrenceEnds = obj["recurrenceEnds"] as RecurrenceEnd | null;
        if (__raw_recurrenceEnds === null) {
            instance.recurrenceEnds = null;
        } else {
            const __result = recurrenceEndDeserializeWithContext(__raw_recurrenceEnds, ctx);
            ctx.assignOrDefer(instance, "recurrenceEnds", __result);
        }
    }
    {
        const __raw_cancelledInstances = obj["cancelledInstances"] as Array<string> | null;
        if (__raw_cancelledInstances === null) {
            instance.cancelledInstances = null;
        } else {
            instance.cancelledInstances = __raw_cancelledInstances;
        }
    }
    {
        const __raw_additionalInstances = obj["additionalInstances"] as Array<string> | null;
        if (__raw_additionalInstances === null) {
            instance.additionalInstances = null;
        } else {
            instance.additionalInstances = __raw_additionalInstances;
        }
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    return instance as RecurrenceRule;
}
export function recurrenceRuleValidateField<K extends keyof RecurrenceRule>(_field: K, _value: RecurrenceRule[K]): Array<{
    field: string;
    message: string;
}> {
    return [];
}
export function recurrenceRuleValidateFields(_partial: Partial<RecurrenceRule>): Array<{
    field: string;
    message: string;
}> {
    return [];
}
export function recurrenceRuleHasShape(obj: unknown): boolean {
    if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
        return false;
    }
    const o = obj as Record<string, unknown>;
    return '"interval" in o && "recurrenceBegins" in o && "recurrenceEnds" in o && "cancelledInstances" in o && "additionalInstances" in o';
}
export function recurrenceRuleIs(obj: unknown): obj is RecurrenceRule {
    if (!recurrenceRuleHasShape(obj)) {
        return false;
    }
    const result = recurrenceRuleDeserialize(obj);
    return result.success;
}

export type RecurrenceRuleErrors = {
    _errors: __gf_Option<Array<string>>;
    interval: __gf_Option<Array<string>>;
    recurrenceBegins: __gf_Option<Array<string>>;
    recurrenceEnds: __gf_Option<Array<string>>;
    cancelledInstances: __gf_Option<Array<string>>;
    additionalInstances: __gf_Option<Array<string>>;
};
export type RecurrenceRuleTainted = {
    interval: __gf_Option<boolean>;
    recurrenceBegins: __gf_Option<boolean>;
    recurrenceEnds: __gf_Option<boolean>;
    cancelledInstances: __gf_Option<boolean>;
    additionalInstances: __gf_Option<boolean>;
};
export interface RecurrenceRuleFieldControllers {
    readonly interval: FieldController<Interval>;
    readonly recurrenceBegins: FieldController<string>;
    readonly recurrenceEnds: FieldController<RecurrenceEnd | null>;
    readonly cancelledInstances: FieldController<Array<string> | null>;
    readonly additionalInstances: FieldController<Array<string> | null>;
}
export interface RecurrenceRuleGigaform {
    readonly data: RecurrenceRule;
    readonly errors: RecurrenceRuleErrors;
    readonly tainted: RecurrenceRuleTainted;
    readonly fields: RecurrenceRuleFieldControllers;
    validate(): Exit<RecurrenceRule, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<RecurrenceRule>): void;
}
export function recurrenceRuleCreateForm(overrides?: Partial<RecurrenceRule>): RecurrenceRuleGigaform {
    let data = $state({
        ...recurrenceRuleDefaultValue(),
        ...overrides
    });
    let errors = $state<RecurrenceRuleErrors>({
        _errors: optionNone(),
        interval: optionNone(),
        recurrenceBegins: optionNone(),
        recurrenceEnds: optionNone(),
        cancelledInstances: optionNone(),
        additionalInstances: optionNone()
    } as RecurrenceRuleErrors);
    let tainted = $state<RecurrenceRuleTainted>({
        interval: optionNone(),
        recurrenceBegins: optionNone(),
        recurrenceEnds: optionNone(),
        cancelledInstances: optionNone(),
        additionalInstances: optionNone()
    } as RecurrenceRuleTainted);
    const fields = {
        interval: {
            path: [
                "interval"
            ] as const,
            name: "interval",
            constraints: {
                required: true
            },
            get: ()=>data.interval,
            set: (value: Interval)=>{
                data.interval = value;
            },
            transform: (value: Interval): Interval =>value,
            getError: ()=>errors.interval,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.interval = value;
            },
            getTainted: ()=>tainted.interval,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.interval = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = recurrenceRuleValidateField("interval", data.interval);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        recurrenceBegins: {
            path: [
                "recurrenceBegins"
            ] as const,
            name: "recurrenceBegins",
            constraints: {
                required: true
            },
            get: ()=>data.recurrenceBegins,
            set: (value: string)=>{
                data.recurrenceBegins = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.recurrenceBegins,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.recurrenceBegins = value;
            },
            getTainted: ()=>tainted.recurrenceBegins,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.recurrenceBegins = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = recurrenceRuleValidateField("recurrenceBegins", data.recurrenceBegins);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        recurrenceEnds: {
            path: [
                "recurrenceEnds"
            ] as const,
            name: "recurrenceEnds",
            constraints: {
                required: true
            },
            get: ()=>data.recurrenceEnds,
            set: (value: RecurrenceEnd | null)=>{
                data.recurrenceEnds = value;
            },
            transform: (value: RecurrenceEnd | null): RecurrenceEnd | null =>value,
            getError: ()=>errors.recurrenceEnds,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.recurrenceEnds = value;
            },
            getTainted: ()=>tainted.recurrenceEnds,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.recurrenceEnds = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = recurrenceRuleValidateField("recurrenceEnds", data.recurrenceEnds);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        cancelledInstances: {
            path: [
                "cancelledInstances"
            ] as const,
            name: "cancelledInstances",
            constraints: {
                required: true
            },
            get: ()=>data.cancelledInstances,
            set: (value: Array<string> | null)=>{
                data.cancelledInstances = value;
            },
            transform: (value: Array<string> | null): Array<string> | null =>value,
            getError: ()=>errors.cancelledInstances,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.cancelledInstances = value;
            },
            getTainted: ()=>tainted.cancelledInstances,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.cancelledInstances = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = recurrenceRuleValidateField("cancelledInstances", data.cancelledInstances);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        additionalInstances: {
            path: [
                "additionalInstances"
            ] as const,
            name: "additionalInstances",
            constraints: {
                required: true
            },
            get: ()=>data.additionalInstances,
            set: (value: Array<string> | null)=>{
                data.additionalInstances = value;
            },
            transform: (value: Array<string> | null): Array<string> | null =>value,
            getError: ()=>errors.additionalInstances,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.additionalInstances = value;
            },
            getTainted: ()=>tainted.additionalInstances,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.additionalInstances = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = recurrenceRuleValidateField("additionalInstances", data.additionalInstances);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        }
    } as RecurrenceRuleFieldControllers;
    const __gf_getter_hint = "get data() set data(v) get errors() set errors(v) get tainted() set tainted(v)";
    const __gf_validate_hint = ".map((e: { field: string; message: string }) => e.message)";
    function validate(): Exit<RecurrenceRule, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(recurrenceRuleDeserialize(data));
    }
    function reset(newOverrides?: Partial<RecurrenceRule>): void {
        data = {
            ...recurrenceRuleDefaultValue(),
            ...newOverrides
        };
        errors = {
            _errors: optionNone(),
            interval: optionNone(),
            recurrenceBegins: optionNone(),
            recurrenceEnds: optionNone(),
            cancelledInstances: optionNone(),
            additionalInstances: optionNone()
        };
        tainted = {
            interval: optionNone(),
            recurrenceBegins: optionNone(),
            recurrenceEnds: optionNone(),
            cancelledInstances: optionNone(),
            additionalInstances: optionNone()
        };
    }
    return {
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        fields,
        validate,
        reset
    };
}
export function recurrenceRuleFromFormData(formData: FormData): Exit<RecurrenceRule, Array<{
    field: string;
    message: string;
}>> {
    const obj: Record<string, unknown> = {};
    const __gf_exit_hint = "Exit<RecurrenceRule, Array<{ field: string; message: string }>>";
    {
        const intervalObj: Record<string, unknown> = {};
        for (const [key, value] of Array.from(formData.entries())){
            if (key.startsWith(`${"interval"}.`)) {
                const fieldName = key.slice(`${"interval"}.`.length);
                const parts = fieldName.split(".");
                let current = intervalObj;
                for(let i = 0; i < parts.length - 1; i++){
                    const part = parts[i]!;
                    if (!(part in current)) {
                        current[part] = {};
                    }
                    current = current[part] as Record<string, unknown>;
                }
                current[parts[parts.length - 1]!] = value;
            }
        }
        obj.interval = intervalObj;
    }
    obj.recurrenceBegins = formData.get(`${"recurrenceBegins"}`) ?? "";
    obj.recurrenceEnds = formData.get(`${"recurrenceEnds"}`) ?? "";
    obj.cancelledInstances = formData.get(`${"cancelledInstances"}`) ?? "";
    obj.additionalInstances = formData.get(`${"additionalInstances"}`) ?? "";
    return toExit(recurrenceRuleDeserialize(obj));
}

export const RecurrenceRule = {
  defaultValue: recurrenceRuleDefaultValue,
  serialize: recurrenceRuleSerialize,
  serializeWithContext: recurrenceRuleSerializeWithContext,
  deserialize: recurrenceRuleDeserialize,
  deserializeWithContext: recurrenceRuleDeserializeWithContext,
  validateFields: recurrenceRuleValidateFields,
  hasShape: recurrenceRuleHasShape,
  is: recurrenceRuleIs,
  createForm: recurrenceRuleCreateForm,
  fromFormData: recurrenceRuleFromFormData
} as const;


export interface LastName {
    
    name: string;
}

export function lastNameDefaultValue(): LastName {
    return {
        name: ""
    } as LastName;
}

export function lastNameSerialize(value: LastName): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(lastNameSerializeWithContext(value, ctx));
}
export function lastNameSerializeWithContext(value: LastName, ctx: __mf_SerializeContext): Record<string, unknown> {
    const existingId = ctx.getId(value);
    if (existingId !== undefined) {
        return {
            __ref: existingId
        };
    }
    const __id = ctx.register(value);
    const result: Record<string, unknown> = {
        __type: "LastName",
        __id
    };
    result.name = value.name;
    return result;
}

export function lastNameDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: LastName } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = lastNameDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "LastName.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function lastNameDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): LastName | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
        throw new __mf_DeserializeError([
            {
                field: "_root",
                message: `${"LastName"}.deserializeWithContext: expected an object`
            }
        ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (!("name" in obj)) {
        errors.push({
            field: "name",
            message: "missing required field"
        });
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
        ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
        const __raw_name = obj["name"] as string;
        if (__raw_name.trim().length === 0) {
            errors.push({
                field: "name",
                message: "LastName.name must not be empty"
            });
        }
        instance.name = __raw_name;
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    return instance as LastName;
}
export function lastNameValidateField<K extends keyof LastName>(_field: K, _value: LastName[K]): Array<{
    field: string;
    message: string;
}> {
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (_field === "name") {
        const __val = _value as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "name",
                message: "LastName.name must not be empty"
            });
        }
    }
    return errors;
}
export function lastNameValidateFields(_partial: Partial<LastName>): Array<{
    field: string;
    message: string;
}> {
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if ("name" in _partial && _partial.name !== undefined) {
        const __val = _partial.name as string;
        if (__val.trim().length === 0) {
            errors.push({
                field: "name",
                message: "LastName.name must not be empty"
            });
        }
    }
    return errors;
}
export function lastNameHasShape(obj: unknown): boolean {
    if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
        return false;
    }
    const o = obj as Record<string, unknown>;
    return '"name" in o';
}
export function lastNameIs(obj: unknown): obj is LastName {
    if (!lastNameHasShape(obj)) {
        return false;
    }
    const result = lastNameDeserialize(obj);
    return result.success;
}

export type LastNameErrors = {
    _errors: __gf_Option<Array<string>>;
    name: __gf_Option<Array<string>>;
};
export type LastNameTainted = {
    name: __gf_Option<boolean>;
};
export interface LastNameFieldControllers {
    readonly name: FieldController<string>;
}
export interface LastNameGigaform {
    readonly data: LastName;
    readonly errors: LastNameErrors;
    readonly tainted: LastNameTainted;
    readonly fields: LastNameFieldControllers;
    validate(): Exit<LastName, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<LastName>): void;
}
export function lastNameCreateForm(overrides?: Partial<LastName>): LastNameGigaform {
    let data = $state({
        ...lastNameDefaultValue(),
        ...overrides
    });
    let errors = $state<LastNameErrors>({
        _errors: optionNone(),
        name: optionNone()
    } as LastNameErrors);
    let tainted = $state<LastNameTainted>({
        name: optionNone()
    } as LastNameTainted);
    const fields = {
        name: {
            path: [
                "name"
            ] as const,
            name: "name",
            constraints: {
                required: true
            },
            get: ()=>data.name,
            set: (value: string)=>{
                data.name = value;
            },
            transform: (value: string): string =>value,
            getError: ()=>errors.name,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.name = value;
            },
            getTainted: ()=>tainted.name,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.name = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = lastNameValidateField("name", data.name);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        }
    } as LastNameFieldControllers;
    const __gf_getter_hint = "get data() set data(v) get errors() set errors(v) get tainted() set tainted(v)";
    const __gf_validate_hint = ".map((e: { field: string; message: string }) => e.message)";
    function validate(): Exit<LastName, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(lastNameDeserialize(data));
    }
    function reset(newOverrides?: Partial<LastName>): void {
        data = {
            ...lastNameDefaultValue(),
            ...newOverrides
        };
        errors = {
            _errors: optionNone(),
            name: optionNone()
        };
        tainted = {
            name: optionNone()
        };
    }
    return {
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        fields,
        validate,
        reset
    };
}
export function lastNameFromFormData(formData: FormData): Exit<LastName, Array<{
    field: string;
    message: string;
}>> {
    const obj: Record<string, unknown> = {};
    const __gf_exit_hint = "Exit<LastName, Array<{ field: string; message: string }>>";
    obj.name = formData.get(`${"name"}`) ?? "";
    return toExit(lastNameDeserialize(obj));
}

export const LastName = {
  defaultValue: lastNameDefaultValue,
  serialize: lastNameSerialize,
  serializeWithContext: lastNameSerializeWithContext,
  deserialize: lastNameDeserialize,
  deserializeWithContext: lastNameDeserializeWithContext,
  validateFields: lastNameValidateFields,
  hasShape: lastNameHasShape,
  is: lastNameIs,
  createForm: lastNameCreateForm,
  fromFormData: lastNameFromFormData
} as const;


export interface Cardinal {
    north: number;
    east: number;
    south: number;
    west: number;
}

export function cardinalDefaultValue(): Cardinal {
    return {
        north: 0,
        east: 0,
        south: 0,
        west: 0
    } as Cardinal;
}

export function cardinalSerialize(value: Cardinal): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(cardinalSerializeWithContext(value, ctx));
}
export function cardinalSerializeWithContext(value: Cardinal, ctx: __mf_SerializeContext): Record<string, unknown> {
    const existingId = ctx.getId(value);
    if (existingId !== undefined) {
        return {
            __ref: existingId
        };
    }
    const __id = ctx.register(value);
    const result: Record<string, unknown> = {
        __type: "Cardinal",
        __id
    };
    result.north = value.north;
    result.east = value.east;
    result.south = value.south;
    result.west = value.west;
    return result;
}

export function cardinalDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: Cardinal } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = cardinalDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "Cardinal.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function cardinalDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Cardinal | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
        throw new __mf_DeserializeError([
            {
                field: "_root",
                message: `${"Cardinal"}.deserializeWithContext: expected an object`
            }
        ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{
        field: string;
        message: string;
    }> = [];
    if (!("north" in obj)) {
        errors.push({
            field: "north",
            message: "missing required field"
        });
    }
    if (!("east" in obj)) {
        errors.push({
            field: "east",
            message: "missing required field"
        });
    }
    if (!("south" in obj)) {
        errors.push({
            field: "south",
            message: "missing required field"
        });
    }
    if (!("west" in obj)) {
        errors.push({
            field: "west",
            message: "missing required field"
        });
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
        ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
        const __raw_north = obj["north"] as number;
        instance.north = __raw_north;
    }
    {
        const __raw_east = obj["east"] as number;
        instance.east = __raw_east;
    }
    {
        const __raw_south = obj["south"] as number;
        instance.south = __raw_south;
    }
    {
        const __raw_west = obj["west"] as number;
        instance.west = __raw_west;
    }
    if (errors.length > 0) {
        throw new __mf_DeserializeError(errors);
    }
    return instance as Cardinal;
}
export function cardinalValidateField<K extends keyof Cardinal>(_field: K, _value: Cardinal[K]): Array<{
    field: string;
    message: string;
}> {
    return [];
}
export function cardinalValidateFields(_partial: Partial<Cardinal>): Array<{
    field: string;
    message: string;
}> {
    return [];
}
export function cardinalHasShape(obj: unknown): boolean {
    if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
        return false;
    }
    const o = obj as Record<string, unknown>;
    return '"north" in o && "east" in o && "south" in o && "west" in o';
}
export function cardinalIs(obj: unknown): obj is Cardinal {
    if (!cardinalHasShape(obj)) {
        return false;
    }
    const result = cardinalDeserialize(obj);
    return result.success;
}

export type CardinalErrors = {
    _errors: __gf_Option<Array<string>>;
    north: __gf_Option<Array<string>>;
    east: __gf_Option<Array<string>>;
    south: __gf_Option<Array<string>>;
    west: __gf_Option<Array<string>>;
};
export type CardinalTainted = {
    north: __gf_Option<boolean>;
    east: __gf_Option<boolean>;
    south: __gf_Option<boolean>;
    west: __gf_Option<boolean>;
};
export interface CardinalFieldControllers {
    readonly north: FieldController<number>;
    readonly east: FieldController<number>;
    readonly south: FieldController<number>;
    readonly west: FieldController<number>;
}
export interface CardinalGigaform {
    readonly data: Cardinal;
    readonly errors: CardinalErrors;
    readonly tainted: CardinalTainted;
    readonly fields: CardinalFieldControllers;
    validate(): Exit<Cardinal, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<Cardinal>): void;
}
export function cardinalCreateForm(overrides?: Partial<Cardinal>): CardinalGigaform {
    let data = $state({
        ...cardinalDefaultValue(),
        ...overrides
    });
    let errors = $state<CardinalErrors>({
        _errors: optionNone(),
        north: optionNone(),
        east: optionNone(),
        south: optionNone(),
        west: optionNone()
    } as CardinalErrors);
    let tainted = $state<CardinalTainted>({
        north: optionNone(),
        east: optionNone(),
        south: optionNone(),
        west: optionNone()
    } as CardinalTainted);
    const fields = {
        north: {
            path: [
                "north"
            ] as const,
            name: "north",
            constraints: {
                required: true
            },
            get: ()=>data.north,
            set: (value: number)=>{
                data.north = value;
            },
            transform: (value: number): number =>value,
            getError: ()=>errors.north,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.north = value;
            },
            getTainted: ()=>tainted.north,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.north = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = cardinalValidateField("north", data.north);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        east: {
            path: [
                "east"
            ] as const,
            name: "east",
            constraints: {
                required: true
            },
            get: ()=>data.east,
            set: (value: number)=>{
                data.east = value;
            },
            transform: (value: number): number =>value,
            getError: ()=>errors.east,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.east = value;
            },
            getTainted: ()=>tainted.east,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.east = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = cardinalValidateField("east", data.east);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        south: {
            path: [
                "south"
            ] as const,
            name: "south",
            constraints: {
                required: true
            },
            get: ()=>data.south,
            set: (value: number)=>{
                data.south = value;
            },
            transform: (value: number): number =>value,
            getError: ()=>errors.south,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.south = value;
            },
            getTainted: ()=>tainted.south,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.south = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = cardinalValidateField("south", data.south);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        },
        west: {
            path: [
                "west"
            ] as const,
            name: "west",
            constraints: {
                required: true
            },
            get: ()=>data.west,
            set: (value: number)=>{
                data.west = value;
            },
            transform: (value: number): number =>value,
            getError: ()=>errors.west,
            setError: (value: __gf_Option<Array<string>>)=>{
                errors.west = value;
            },
            getTainted: ()=>tainted.west,
            setTainted: (value: __gf_Option<boolean>)=>{
                tainted.west = value;
            },
            validate: (): Array<string> =>{
                const fieldErrors = cardinalValidateField("west", data.west);
                return fieldErrors.map((e: {
                    field: string;
                    message: string;
                })=>e.message);
            }
        }
    } as CardinalFieldControllers;
    const __gf_getter_hint = "get data() set data(v) get errors() set errors(v) get tainted() set tainted(v)";
    const __gf_validate_hint = ".map((e: { field: string; message: string }) => e.message)";
    function validate(): Exit<Cardinal, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(cardinalDeserialize(data));
    }
    function reset(newOverrides?: Partial<Cardinal>): void {
        data = {
            ...cardinalDefaultValue(),
            ...newOverrides
        };
        errors = {
            _errors: optionNone(),
            north: optionNone(),
            east: optionNone(),
            south: optionNone(),
            west: optionNone()
        };
        tainted = {
            north: optionNone(),
            east: optionNone(),
            south: optionNone(),
            west: optionNone()
        };
    }
    return {
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        fields,
        validate,
        reset
    };
}
export function cardinalFromFormData(formData: FormData): Exit<Cardinal, Array<{
    field: string;
    message: string;
}>> {
    const obj: Record<string, unknown> = {};
    const __gf_exit_hint = "Exit<Cardinal, Array<{ field: string; message: string }>>";
    {
        const northStr = formData.get(`${"north"}`);
        obj.north = northStr ? parseFloat(northStr as string) : $MfPh5;
        if (obj.north !== undefined && isNaN(obj.north as number)) obj.north = "0";
    }
    {
        const eastStr = formData.get(`${"east"}`);
        obj.east = eastStr ? parseFloat(eastStr as string) : $MfPh5;
        if (obj.east !== undefined && isNaN(obj.east as number)) obj.east = "0";
    }
    {
        const southStr = formData.get(`${"south"}`);
        obj.south = southStr ? parseFloat(southStr as string) : $MfPh5;
        if (obj.south !== undefined && isNaN(obj.south as number)) obj.south = "0";
    }
    {
        const westStr = formData.get(`${"west"}`);
        obj.west = westStr ? parseFloat(westStr as string) : $MfPh5;
        if (obj.west !== undefined && isNaN(obj.west as number)) obj.west = "0";
    }
    return toExit(cardinalDeserialize(obj));
}

export const Cardinal = {
  defaultValue: cardinalDefaultValue,
  serialize: cardinalSerialize,
  serializeWithContext: cardinalSerializeWithContext,
  deserialize: cardinalDeserialize,
  deserializeWithContext: cardinalDeserializeWithContext,
  validateFields: cardinalValidateFields,
  hasShape: cardinalHasShape,
  is: cardinalIs,
  createForm: cardinalCreateForm,
  fromFormData: cardinalFromFormData
} as const;


export type Interval =
    | /** @default */ DailyRecurrenceRule
    | WeeklyRecurrenceRule
    | MonthlyRecurrenceRule
    | YearlyRecurrenceRule;

export function intervalDefaultValue#0#0(): Interval {
    return dailyRecurrenceRuleDefaultValue();
}

export function intervalSerialize(value: Interval): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(intervalSerializeWithContext(value, ctx));
}
export function intervalSerializeWithContext(value: Interval, ctx: __mf_SerializeContext): unknown {
    if (typeof (value as any)?.serializeWithContext === "function") {
        return (value as any).serializeWithContext(ctx);
    }
    return value;
}

export function intervalDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: Interval } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = intervalDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "Interval.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function intervalDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Interval | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref) as Interval | __mf_PendingRef;
    }
    if (typeof value === "object" && value !== null) {
        const __typeName = (value as any).__type;
        if (typeof __typeName === "string") {}
        if (__typeName === "DailyRecurrenceRule") {
            return dailyRecurrenceRuleDeserializeWithContext(value, ctx) as Interval;
        }
        if (__typeName === "WeeklyRecurrenceRule") {
            return weeklyRecurrenceRuleDeserializeWithContext(value, ctx) as Interval;
        }
        if (__typeName === "MonthlyRecurrenceRule") {
            return monthlyRecurrenceRuleDeserializeWithContext(value, ctx) as Interval;
        }
        if (__typeName === "YearlyRecurrenceRule") {
            return yearlyRecurrenceRuleDeserializeWithContext(value, ctx) as Interval;
        }
    }
    throw new __mf_DeserializeError([
        {
            field: "_root",
            message: `${"Interval"}.deserializeWithContext: value does not match any union member`
        }
    ]);
}
export function intervalIs(value: unknown): value is Interval {
    if (typeof value === "object" && value !== null) {
        const __typeName = (value as any).__type;
        if ('__typeName === "DailyRecurrenceRule" || __typeName === "WeeklyRecurrenceRule" || __typeName === "MonthlyRecurrenceRule" || __typeName === "YearlyRecurrenceRule"') return true;
    }
    return false;
}
     }

export type IntervalDailyRecurrenceRuleErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type IntervalWeeklyRecurrenceRuleErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type IntervalMonthlyRecurrenceRuleErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type IntervalYearlyRecurrenceRuleErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type IntervalDailyRecurrenceRuleTainted = {
};
export type IntervalWeeklyRecurrenceRuleTainted = {
};
export type IntervalMonthlyRecurrenceRuleTainted = {
};
export type IntervalYearlyRecurrenceRuleTainted = {
};
export type IntervalErrors = ({
    _type: "DailyRecurrenceRule";
} & IntervalDailyRecurrenceRuleErrors) | ({
    _type: "WeeklyRecurrenceRule";
} & IntervalWeeklyRecurrenceRuleErrors) | ({
    _type: "MonthlyRecurrenceRule";
} & IntervalMonthlyRecurrenceRuleErrors) | ({
    _type: "YearlyRecurrenceRule";
} & IntervalYearlyRecurrenceRuleErrors);
export type IntervalTainted = ({
    _type: "DailyRecurrenceRule";
} & IntervalDailyRecurrenceRuleTainted) | ({
    _type: "WeeklyRecurrenceRule";
} & IntervalWeeklyRecurrenceRuleTainted) | ({
    _type: "MonthlyRecurrenceRule";
} & IntervalMonthlyRecurrenceRuleTainted) | ({
    _type: "YearlyRecurrenceRule";
} & IntervalYearlyRecurrenceRuleTainted);
export interface IntervalDailyRecurrenceRuleFieldControllers {
}
export interface IntervalWeeklyRecurrenceRuleFieldControllers {
}
export interface IntervalMonthlyRecurrenceRuleFieldControllers {
}
export interface IntervalYearlyRecurrenceRuleFieldControllers {
}
export interface IntervalGigaform {
    readonly currentVariant: "DailyRecurrenceRule" | "WeeklyRecurrenceRule" | "MonthlyRecurrenceRule" | "YearlyRecurrenceRule";
    readonly data: Interval;
    readonly errors: IntervalErrors;
    readonly tainted: IntervalTainted;
    readonly variants: IntervalVariantFields;
    switchVariant(variant: "DailyRecurrenceRule" | "WeeklyRecurrenceRule" | "MonthlyRecurrenceRule" | "YearlyRecurrenceRule"): void;
    validate(): Exit<Interval, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<Interval>): void;
}
export interface IntervalVariantFields {
    readonly DailyRecurrenceRule: {
        readonly fields: IntervalDailyRecurrenceRuleFieldControllers;
    };
    readonly WeeklyRecurrenceRule: {
        readonly fields: IntervalWeeklyRecurrenceRuleFieldControllers;
    };
    readonly MonthlyRecurrenceRule: {
        readonly fields: IntervalMonthlyRecurrenceRuleFieldControllers;
    };
    readonly YearlyRecurrenceRule: {
        readonly fields: IntervalYearlyRecurrenceRuleFieldControllers;
    };
}
function intervalGetDefaultForVariant(variant: string): Interval {
    if (variant === "DailyRecurrenceRule") {
        return dailyRecurrenceRuleDefaultValue() as Interval;
    }
    if (variant === "WeeklyRecurrenceRule") {
        return weeklyRecurrenceRuleDefaultValue() as Interval;
    }
    if (variant === "MonthlyRecurrenceRule") {
        return monthlyRecurrenceRuleDefaultValue() as Interval;
    }
    if (variant === "YearlyRecurrenceRule") {
        return yearlyRecurrenceRuleDefaultValue() as Interval;
    }
    return dailyRecurrenceRuleDefaultValue() as Interval;
}
export function intervalCreateForm(initial: Interval): IntervalGigaform {
    const initialVariant: "DailyRecurrenceRule" | "WeeklyRecurrenceRule" | "MonthlyRecurrenceRule" | "YearlyRecurrenceRule" = "DailyRecurrenceRule";
    let currentVariant = $state<$MfPh5>(initialVariant);
    let data = $state<$MfPh6>(initial ?? "intervalGetDefaultForVariant"(initialVariant));
    let errors = $state<$MfPh8>({} as IntervalErrors);
    let tainted = $state<$MfPh10>({} as IntervalTainted);
    const variants = {} as IntervalVariantFields;
    variants[__expr__] = {
        fields: {} as IntervalDailyRecurrenceRuleFieldControllers
    };
    variants[__expr__] = {
        fields: {} as IntervalWeeklyRecurrenceRuleFieldControllers
    };
    variants[__expr__] = {
        fields: {} as IntervalMonthlyRecurrenceRuleFieldControllers
    };
    variants[__expr__] = {
        fields: {} as IntervalYearlyRecurrenceRuleFieldControllers
    };
    function switchVariant(variant: "DailyRecurrenceRule" | "WeeklyRecurrenceRule" | "MonthlyRecurrenceRule" | "YearlyRecurrenceRule"): void {
        currentVariant = variant;
        data = "intervalGetDefaultForVariant"(variant);
        errors = {} as IntervalErrors;
        tainted = {} as IntervalTainted;
    }
    function validate(): Exit<Interval, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(intervalDeserialize(data));
    }
    function reset(overrides: Partial<Interval>): void {
        data = overrides ? overrides as typeof data : intervalGetDefaultForVariant(currentVariant);
        errors = {} as IntervalErrors;
        tainted = {} as IntervalTainted;
    }
    return {
        get currentVariant () {
            return currentVariant;
        },
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        variants,
        switchVariant,
        validate,
        reset
    };
}
export function intervalFromFormData(formData: FormData): Exit<Interval, Array<{
    field: string;
    message: string;
}>> {
    const discriminant = formData.get(`${"_type"}`) as "DailyRecurrenceRule" | "WeeklyRecurrenceRule" | "MonthlyRecurrenceRule" | "YearlyRecurrenceRule" | null;
    if (!discriminant) {
        return toExit({
            success: false,
            errors: [
                {
                    field: `${"_type"}`,
                    message: "Missing discriminant field"
                }
            ]
        });
    }
    const obj: Record<string, unknown> = {};
    obj._type = discriminant;
    return toExit(intervalDeserialize(obj));
}

export const Interval = {
  serialize: intervalSerialize,
  serializeWithContext: intervalSerializeWithContext,
  deserialize: intervalDeserialize,
  deserializeWithContext: intervalDeserializeWithContext,
  is: intervalIs,
  createForm: intervalCreateForm,
  fromFormData: intervalFromFormData
} as const;


export type Page =
    | /** @default */ 'SalesHomeDashboard'
    | 'SalesHomeProducts'
    | 'SalesHomeServices'
    | 'SalesHomePackages'
    | 'SalesHomeTaxRates'
    | 'SalesLeadsOverview'
    | 'SalesLeadsActivities'
    | 'SalesLeadsCampaigns'
    | 'SalesLeadsDripCampaigns'
    | 'SalesLeadsOpportunities'
    | 'SalesLeadsPromotions'
    | 'SalesAccountsOverview'
    | 'SalesAccountsActivities'
    | 'SalesAccountsBilling'
    | 'SalesAccountsContracts'
    | 'SalesOrdersOverview'
    | 'SalesOrdersActivities'
    | 'SalesOrdersPayments'
    | 'SalesOrdersCommissions'
    | 'SalesSchedulingSchedule'
    | 'SalesSchedulingAppointments'
    | 'SalesSchedulingRecurring'
    | 'SalesSchedulingRoutes'
    | 'SalesSchedulingReminders'
    | 'UserHome';

export function pageDefaultValue#0#0(): Page {
    return 'SalesHomeDashboard';
}

export function pageSerialize(value: Page): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(pageSerializeWithContext(value, ctx));
}
export function pageSerializeWithContext(value: Page, ctx: __mf_SerializeContext): unknown {
    if (typeof (value as any)?.serializeWithContext === "function") {
        return (value as any).serializeWithContext(ctx);
    }
    return value;
}

export function pageDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: Page } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = pageDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "Page.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function pageDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Page | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref) as Page | __mf_PendingRef;
    }
    const allowedValues = [
        "'SalesHomeDashboard', 'SalesHomeProducts', 'SalesHomeServices', 'SalesHomePackages', 'SalesHomeTaxRates', 'SalesLeadsOverview', 'SalesLeadsActivities', 'SalesLeadsCampaigns', 'SalesLeadsDripCampaigns', 'SalesLeadsOpportunities', 'SalesLeadsPromotions', 'SalesAccountsOverview', 'SalesAccountsActivities', 'SalesAccountsBilling', 'SalesAccountsContracts', 'SalesOrdersOverview', 'SalesOrdersActivities', 'SalesOrdersPayments', 'SalesOrdersCommissions', 'SalesSchedulingSchedule', 'SalesSchedulingAppointments', 'SalesSchedulingRecurring', 'SalesSchedulingRoutes', 'SalesSchedulingReminders', 'UserHome'"
    ] as const;
    if (!allowedValues.includes(value)) {
        throw new __mf_DeserializeError([
            {
                field: "_root",
                message: `Invalid value for ${"Page"}: expected one of ` + allowedValues.map((v)=>JSON.stringify(v)).join(", ") + ", got " + JSON.stringify(value)
            }
        ]);
    }
    return value as Page;
}
export function pageIs(value: unknown): value is Page {
    const allowedValues = [
        "'SalesHomeDashboard', 'SalesHomeProducts', 'SalesHomeServices', 'SalesHomePackages', 'SalesHomeTaxRates', 'SalesLeadsOverview', 'SalesLeadsActivities', 'SalesLeadsCampaigns', 'SalesLeadsDripCampaigns', 'SalesLeadsOpportunities', 'SalesLeadsPromotions', 'SalesAccountsOverview', 'SalesAccountsActivities', 'SalesAccountsBilling', 'SalesAccountsContracts', 'SalesOrdersOverview', 'SalesOrdersActivities', 'SalesOrdersPayments', 'SalesOrdersCommissions', 'SalesSchedulingSchedule', 'SalesSchedulingAppointments', 'SalesSchedulingRecurring', 'SalesSchedulingRoutes', 'SalesSchedulingReminders', 'UserHome'"
    ] as const;
    return allowedValues.includes(value as any);
}

export type PageSalesHomeDashboardErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type PageSalesHomeProductsErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type PageSalesHomeServicesErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type PageSalesHomePackagesErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type PageSalesHomeTaxRatesErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type PageSalesLeadsOverviewErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type PageSalesLeadsActivitiesErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type PageSalesLeadsCampaignsErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type PageSalesLeadsDripCampaignsErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type PageSalesLeadsOpportunitiesErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type PageSalesLeadsPromotionsErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type PageSalesAccountsOverviewErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type PageSalesAccountsActivitiesErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type PageSalesAccountsBillingErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type PageSalesAccountsContractsErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type PageSalesOrdersOverviewErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type PageSalesOrdersActivitiesErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type PageSalesOrdersPaymentsErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type PageSalesOrdersCommissionsErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type PageSalesSchedulingScheduleErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type PageSalesSchedulingAppointmentsErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type PageSalesSchedulingRecurringErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type PageSalesSchedulingRoutesErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type PageSalesSchedulingRemindersErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type PageUserHomeErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type PageSalesHomeDashboardTainted = {
};
export type PageSalesHomeProductsTainted = {
};
export type PageSalesHomeServicesTainted = {
};
export type PageSalesHomePackagesTainted = {
};
export type PageSalesHomeTaxRatesTainted = {
};
export type PageSalesLeadsOverviewTainted = {
};
export type PageSalesLeadsActivitiesTainted = {
};
export type PageSalesLeadsCampaignsTainted = {
};
export type PageSalesLeadsDripCampaignsTainted = {
};
export type PageSalesLeadsOpportunitiesTainted = {
};
export type PageSalesLeadsPromotionsTainted = {
};
export type PageSalesAccountsOverviewTainted = {
};
export type PageSalesAccountsActivitiesTainted = {
};
export type PageSalesAccountsBillingTainted = {
};
export type PageSalesAccountsContractsTainted = {
};
export type PageSalesOrdersOverviewTainted = {
};
export type PageSalesOrdersActivitiesTainted = {
};
export type PageSalesOrdersPaymentsTainted = {
};
export type PageSalesOrdersCommissionsTainted = {
};
export type PageSalesSchedulingScheduleTainted = {
};
export type PageSalesSchedulingAppointmentsTainted = {
};
export type PageSalesSchedulingRecurringTainted = {
};
export type PageSalesSchedulingRoutesTainted = {
};
export type PageSalesSchedulingRemindersTainted = {
};
export type PageUserHomeTainted = {
};
export type PageErrors = ({
    _value: "SalesHomeDashboard";
} & PageSalesHomeDashboardErrors) | ({
    _value: "SalesHomeProducts";
} & PageSalesHomeProductsErrors) | ({
    _value: "SalesHomeServices";
} & PageSalesHomeServicesErrors) | ({
    _value: "SalesHomePackages";
} & PageSalesHomePackagesErrors) | ({
    _value: "SalesHomeTaxRates";
} & PageSalesHomeTaxRatesErrors) | ({
    _value: "SalesLeadsOverview";
} & PageSalesLeadsOverviewErrors) | ({
    _value: "SalesLeadsActivities";
} & PageSalesLeadsActivitiesErrors) | ({
    _value: "SalesLeadsCampaigns";
} & PageSalesLeadsCampaignsErrors) | ({
    _value: "SalesLeadsDripCampaigns";
} & PageSalesLeadsDripCampaignsErrors) | ({
    _value: "SalesLeadsOpportunities";
} & PageSalesLeadsOpportunitiesErrors) | ({
    _value: "SalesLeadsPromotions";
} & PageSalesLeadsPromotionsErrors) | ({
    _value: "SalesAccountsOverview";
} & PageSalesAccountsOverviewErrors) | ({
    _value: "SalesAccountsActivities";
} & PageSalesAccountsActivitiesErrors) | ({
    _value: "SalesAccountsBilling";
} & PageSalesAccountsBillingErrors) | ({
    _value: "SalesAccountsContracts";
} & PageSalesAccountsContractsErrors) | ({
    _value: "SalesOrdersOverview";
} & PageSalesOrdersOverviewErrors) | ({
    _value: "SalesOrdersActivities";
} & PageSalesOrdersActivitiesErrors) | ({
    _value: "SalesOrdersPayments";
} & PageSalesOrdersPaymentsErrors) | ({
    _value: "SalesOrdersCommissions";
} & PageSalesOrdersCommissionsErrors) | ({
    _value: "SalesSchedulingSchedule";
} & PageSalesSchedulingScheduleErrors) | ({
    _value: "SalesSchedulingAppointments";
} & PageSalesSchedulingAppointmentsErrors) | ({
    _value: "SalesSchedulingRecurring";
} & PageSalesSchedulingRecurringErrors) | ({
    _value: "SalesSchedulingRoutes";
} & PageSalesSchedulingRoutesErrors) | ({
    _value: "SalesSchedulingReminders";
} & PageSalesSchedulingRemindersErrors) | ({
    _value: "UserHome";
} & PageUserHomeErrors);
export type PageTainted = ({
    _value: "SalesHomeDashboard";
} & PageSalesHomeDashboardTainted) | ({
    _value: "SalesHomeProducts";
} & PageSalesHomeProductsTainted) | ({
    _value: "SalesHomeServices";
} & PageSalesHomeServicesTainted) | ({
    _value: "SalesHomePackages";
} & PageSalesHomePackagesTainted) | ({
    _value: "SalesHomeTaxRates";
} & PageSalesHomeTaxRatesTainted) | ({
    _value: "SalesLeadsOverview";
} & PageSalesLeadsOverviewTainted) | ({
    _value: "SalesLeadsActivities";
} & PageSalesLeadsActivitiesTainted) | ({
    _value: "SalesLeadsCampaigns";
} & PageSalesLeadsCampaignsTainted) | ({
    _value: "SalesLeadsDripCampaigns";
} & PageSalesLeadsDripCampaignsTainted) | ({
    _value: "SalesLeadsOpportunities";
} & PageSalesLeadsOpportunitiesTainted) | ({
    _value: "SalesLeadsPromotions";
} & PageSalesLeadsPromotionsTainted) | ({
    _value: "SalesAccountsOverview";
} & PageSalesAccountsOverviewTainted) | ({
    _value: "SalesAccountsActivities";
} & PageSalesAccountsActivitiesTainted) | ({
    _value: "SalesAccountsBilling";
} & PageSalesAccountsBillingTainted) | ({
    _value: "SalesAccountsContracts";
} & PageSalesAccountsContractsTainted) | ({
    _value: "SalesOrdersOverview";
} & PageSalesOrdersOverviewTainted) | ({
    _value: "SalesOrdersActivities";
} & PageSalesOrdersActivitiesTainted) | ({
    _value: "SalesOrdersPayments";
} & PageSalesOrdersPaymentsTainted) | ({
    _value: "SalesOrdersCommissions";
} & PageSalesOrdersCommissionsTainted) | ({
    _value: "SalesSchedulingSchedule";
} & PageSalesSchedulingScheduleTainted) | ({
    _value: "SalesSchedulingAppointments";
} & PageSalesSchedulingAppointmentsTainted) | ({
    _value: "SalesSchedulingRecurring";
} & PageSalesSchedulingRecurringTainted) | ({
    _value: "SalesSchedulingRoutes";
} & PageSalesSchedulingRoutesTainted) | ({
    _value: "SalesSchedulingReminders";
} & PageSalesSchedulingRemindersTainted) | ({
    _value: "UserHome";
} & PageUserHomeTainted);
export interface PageSalesHomeDashboardFieldControllers {
}
export interface PageSalesHomeProductsFieldControllers {
}
export interface PageSalesHomeServicesFieldControllers {
}
export interface PageSalesHomePackagesFieldControllers {
}
export interface PageSalesHomeTaxRatesFieldControllers {
}
export interface PageSalesLeadsOverviewFieldControllers {
}
export interface PageSalesLeadsActivitiesFieldControllers {
}
export interface PageSalesLeadsCampaignsFieldControllers {
}
export interface PageSalesLeadsDripCampaignsFieldControllers {
}
export interface PageSalesLeadsOpportunitiesFieldControllers {
}
export interface PageSalesLeadsPromotionsFieldControllers {
}
export interface PageSalesAccountsOverviewFieldControllers {
}
export interface PageSalesAccountsActivitiesFieldControllers {
}
export interface PageSalesAccountsBillingFieldControllers {
}
export interface PageSalesAccountsContractsFieldControllers {
}
export interface PageSalesOrdersOverviewFieldControllers {
}
export interface PageSalesOrdersActivitiesFieldControllers {
}
export interface PageSalesOrdersPaymentsFieldControllers {
}
export interface PageSalesOrdersCommissionsFieldControllers {
}
export interface PageSalesSchedulingScheduleFieldControllers {
}
export interface PageSalesSchedulingAppointmentsFieldControllers {
}
export interface PageSalesSchedulingRecurringFieldControllers {
}
export interface PageSalesSchedulingRoutesFieldControllers {
}
export interface PageSalesSchedulingRemindersFieldControllers {
}
export interface PageUserHomeFieldControllers {
}
export interface PageGigaform {
    readonly currentVariant: "SalesHomeDashboard" | "SalesHomeProducts" | "SalesHomeServices" | "SalesHomePackages" | "SalesHomeTaxRates" | "SalesLeadsOverview" | "SalesLeadsActivities" | "SalesLeadsCampaigns" | "SalesLeadsDripCampaigns" | "SalesLeadsOpportunities" | "SalesLeadsPromotions" | "SalesAccountsOverview" | "SalesAccountsActivities" | "SalesAccountsBilling" | "SalesAccountsContracts" | "SalesOrdersOverview" | "SalesOrdersActivities" | "SalesOrdersPayments" | "SalesOrdersCommissions" | "SalesSchedulingSchedule" | "SalesSchedulingAppointments" | "SalesSchedulingRecurring" | "SalesSchedulingRoutes" | "SalesSchedulingReminders" | "UserHome";
    readonly data: Page;
    readonly errors: PageErrors;
    readonly tainted: PageTainted;
    readonly variants: PageVariantFields;
    switchVariant(variant: "SalesHomeDashboard" | "SalesHomeProducts" | "SalesHomeServices" | "SalesHomePackages" | "SalesHomeTaxRates" | "SalesLeadsOverview" | "SalesLeadsActivities" | "SalesLeadsCampaigns" | "SalesLeadsDripCampaigns" | "SalesLeadsOpportunities" | "SalesLeadsPromotions" | "SalesAccountsOverview" | "SalesAccountsActivities" | "SalesAccountsBilling" | "SalesAccountsContracts" | "SalesOrdersOverview" | "SalesOrdersActivities" | "SalesOrdersPayments" | "SalesOrdersCommissions" | "SalesSchedulingSchedule" | "SalesSchedulingAppointments" | "SalesSchedulingRecurring" | "SalesSchedulingRoutes" | "SalesSchedulingReminders" | "UserHome"): void;
    validate(): Exit<Page, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<Page>): void;
}
export interface PageVariantFields {
    readonly SalesHomeDashboard: {
        readonly fields: PageSalesHomeDashboardFieldControllers;
    };
    readonly SalesHomeProducts: {
        readonly fields: PageSalesHomeProductsFieldControllers;
    };
    readonly SalesHomeServices: {
        readonly fields: PageSalesHomeServicesFieldControllers;
    };
    readonly SalesHomePackages: {
        readonly fields: PageSalesHomePackagesFieldControllers;
    };
    readonly SalesHomeTaxRates: {
        readonly fields: PageSalesHomeTaxRatesFieldControllers;
    };
    readonly SalesLeadsOverview: {
        readonly fields: PageSalesLeadsOverviewFieldControllers;
    };
    readonly SalesLeadsActivities: {
        readonly fields: PageSalesLeadsActivitiesFieldControllers;
    };
    readonly SalesLeadsCampaigns: {
        readonly fields: PageSalesLeadsCampaignsFieldControllers;
    };
    readonly SalesLeadsDripCampaigns: {
        readonly fields: PageSalesLeadsDripCampaignsFieldControllers;
    };
    readonly SalesLeadsOpportunities: {
        readonly fields: PageSalesLeadsOpportunitiesFieldControllers;
    };
    readonly SalesLeadsPromotions: {
        readonly fields: PageSalesLeadsPromotionsFieldControllers;
    };
    readonly SalesAccountsOverview: {
        readonly fields: PageSalesAccountsOverviewFieldControllers;
    };
    readonly SalesAccountsActivities: {
        readonly fields: PageSalesAccountsActivitiesFieldControllers;
    };
    readonly SalesAccountsBilling: {
        readonly fields: PageSalesAccountsBillingFieldControllers;
    };
    readonly SalesAccountsContracts: {
        readonly fields: PageSalesAccountsContractsFieldControllers;
    };
    readonly SalesOrdersOverview: {
        readonly fields: PageSalesOrdersOverviewFieldControllers;
    };
    readonly SalesOrdersActivities: {
        readonly fields: PageSalesOrdersActivitiesFieldControllers;
    };
    readonly SalesOrdersPayments: {
        readonly fields: PageSalesOrdersPaymentsFieldControllers;
    };
    readonly SalesOrdersCommissions: {
        readonly fields: PageSalesOrdersCommissionsFieldControllers;
    };
    readonly SalesSchedulingSchedule: {
        readonly fields: PageSalesSchedulingScheduleFieldControllers;
    };
    readonly SalesSchedulingAppointments: {
        readonly fields: PageSalesSchedulingAppointmentsFieldControllers;
    };
    readonly SalesSchedulingRecurring: {
        readonly fields: PageSalesSchedulingRecurringFieldControllers;
    };
    readonly SalesSchedulingRoutes: {
        readonly fields: PageSalesSchedulingRoutesFieldControllers;
    };
    readonly SalesSchedulingReminders: {
        readonly fields: PageSalesSchedulingRemindersFieldControllers;
    };
    readonly UserHome: {
        readonly fields: PageUserHomeFieldControllers;
    };
}
function pageGetDefaultForVariant(variant: string): Page {
    if (variant === "SalesHomeDashboard") {
        return "SalesHomeDashboard" as Page;
    }
    if (variant === "SalesHomeProducts") {
        return "SalesHomeProducts" as Page;
    }
    if (variant === "SalesHomeServices") {
        return "SalesHomeServices" as Page;
    }
    if (variant === "SalesHomePackages") {
        return "SalesHomePackages" as Page;
    }
    if (variant === "SalesHomeTaxRates") {
        return "SalesHomeTaxRates" as Page;
    }
    if (variant === "SalesLeadsOverview") {
        return "SalesLeadsOverview" as Page;
    }
    if (variant === "SalesLeadsActivities") {
        return "SalesLeadsActivities" as Page;
    }
    if (variant === "SalesLeadsCampaigns") {
        return "SalesLeadsCampaigns" as Page;
    }
    if (variant === "SalesLeadsDripCampaigns") {
        return "SalesLeadsDripCampaigns" as Page;
    }
    if (variant === "SalesLeadsOpportunities") {
        return "SalesLeadsOpportunities" as Page;
    }
    if (variant === "SalesLeadsPromotions") {
        return "SalesLeadsPromotions" as Page;
    }
    if (variant === "SalesAccountsOverview") {
        return "SalesAccountsOverview" as Page;
    }
    if (variant === "SalesAccountsActivities") {
        return "SalesAccountsActivities" as Page;
    }
    if (variant === "SalesAccountsBilling") {
        return "SalesAccountsBilling" as Page;
    }
    if (variant === "SalesAccountsContracts") {
        return "SalesAccountsContracts" as Page;
    }
    if (variant === "SalesOrdersOverview") {
        return "SalesOrdersOverview" as Page;
    }
    if (variant === "SalesOrdersActivities") {
        return "SalesOrdersActivities" as Page;
    }
    if (variant === "SalesOrdersPayments") {
        return "SalesOrdersPayments" as Page;
    }
    if (variant === "SalesOrdersCommissions") {
        return "SalesOrdersCommissions" as Page;
    }
    if (variant === "SalesSchedulingSchedule") {
        return "SalesSchedulingSchedule" as Page;
    }
    if (variant === "SalesSchedulingAppointments") {
        return "SalesSchedulingAppointments" as Page;
    }
    if (variant === "SalesSchedulingRecurring") {
        return "SalesSchedulingRecurring" as Page;
    }
    if (variant === "SalesSchedulingRoutes") {
        return "SalesSchedulingRoutes" as Page;
    }
    if (variant === "SalesSchedulingReminders") {
        return "SalesSchedulingReminders" as Page;
    }
    if (variant === "UserHome") {
        return "UserHome" as Page;
    }
    return "SalesHomeDashboard" as Page;
}
export function pageCreateForm(initial: Page): PageGigaform {
    const initialVariant: "SalesHomeDashboard" | "SalesHomeProducts" | "SalesHomeServices" | "SalesHomePackages" | "SalesHomeTaxRates" | "SalesLeadsOverview" | "SalesLeadsActivities" | "SalesLeadsCampaigns" | "SalesLeadsDripCampaigns" | "SalesLeadsOpportunities" | "SalesLeadsPromotions" | "SalesAccountsOverview" | "SalesAccountsActivities" | "SalesAccountsBilling" | "SalesAccountsContracts" | "SalesOrdersOverview" | "SalesOrdersActivities" | "SalesOrdersPayments" | "SalesOrdersCommissions" | "SalesSchedulingSchedule" | "SalesSchedulingAppointments" | "SalesSchedulingRecurring" | "SalesSchedulingRoutes" | "SalesSchedulingReminders" | "UserHome" = (initial as "SalesHomeDashboard" | "SalesHomeProducts" | "SalesHomeServices" | "SalesHomePackages" | "SalesHomeTaxRates" | "SalesLeadsOverview" | "SalesLeadsActivities" | "SalesLeadsCampaigns" | "SalesLeadsDripCampaigns" | "SalesLeadsOpportunities" | "SalesLeadsPromotions" | "SalesAccountsOverview" | "SalesAccountsActivities" | "SalesAccountsBilling" | "SalesAccountsContracts" | "SalesOrdersOverview" | "SalesOrdersActivities" | "SalesOrdersPayments" | "SalesOrdersCommissions" | "SalesSchedulingSchedule" | "SalesSchedulingAppointments" | "SalesSchedulingRecurring" | "SalesSchedulingRoutes" | "SalesSchedulingReminders" | "UserHome") ?? "SalesHomeDashboard";
    let currentVariant = $state<$MfPh5>(initialVariant);
    let data = $state<$MfPh6>(initial ?? "pageGetDefaultForVariant"(initialVariant));
    let errors = $state<$MfPh8>({} as PageErrors);
    let tainted = $state<$MfPh10>({} as PageTainted);
    const variants = {} as PageVariantFields;
    variants[__expr__] = {
        fields: {} as PageSalesHomeDashboardFieldControllers
    };
    variants[__expr__] = {
        fields: {} as PageSalesHomeProductsFieldControllers
    };
    variants[__expr__] = {
        fields: {} as PageSalesHomeServicesFieldControllers
    };
    variants[__expr__] = {
        fields: {} as PageSalesHomePackagesFieldControllers
    };
    variants[__expr__] = {
        fields: {} as PageSalesHomeTaxRatesFieldControllers
    };
    variants[__expr__] = {
        fields: {} as PageSalesLeadsOverviewFieldControllers
    };
    variants[__expr__] = {
        fields: {} as PageSalesLeadsActivitiesFieldControllers
    };
    variants[__expr__] = {
        fields: {} as PageSalesLeadsCampaignsFieldControllers
    };
    variants[__expr__] = {
        fields: {} as PageSalesLeadsDripCampaignsFieldControllers
    };
    variants[__expr__] = {
        fields: {} as PageSalesLeadsOpportunitiesFieldControllers
    };
    variants[__expr__] = {
        fields: {} as PageSalesLeadsPromotionsFieldControllers
    };
    variants[__expr__] = {
        fields: {} as PageSalesAccountsOverviewFieldControllers
    };
    variants[__expr__] = {
        fields: {} as PageSalesAccountsActivitiesFieldControllers
    };
    variants[__expr__] = {
        fields: {} as PageSalesAccountsBillingFieldControllers
    };
    variants[__expr__] = {
        fields: {} as PageSalesAccountsContractsFieldControllers
    };
    variants[__expr__] = {
        fields: {} as PageSalesOrdersOverviewFieldControllers
    };
    variants[__expr__] = {
        fields: {} as PageSalesOrdersActivitiesFieldControllers
    };
    variants[__expr__] = {
        fields: {} as PageSalesOrdersPaymentsFieldControllers
    };
    variants[__expr__] = {
        fields: {} as PageSalesOrdersCommissionsFieldControllers
    };
    variants[__expr__] = {
        fields: {} as PageSalesSchedulingScheduleFieldControllers
    };
    variants[__expr__] = {
        fields: {} as PageSalesSchedulingAppointmentsFieldControllers
    };
    variants[__expr__] = {
        fields: {} as PageSalesSchedulingRecurringFieldControllers
    };
    variants[__expr__] = {
        fields: {} as PageSalesSchedulingRoutesFieldControllers
    };
    variants[__expr__] = {
        fields: {} as PageSalesSchedulingRemindersFieldControllers
    };
    variants[__expr__] = {
        fields: {} as PageUserHomeFieldControllers
    };
    function switchVariant(variant: "SalesHomeDashboard" | "SalesHomeProducts" | "SalesHomeServices" | "SalesHomePackages" | "SalesHomeTaxRates" | "SalesLeadsOverview" | "SalesLeadsActivities" | "SalesLeadsCampaigns" | "SalesLeadsDripCampaigns" | "SalesLeadsOpportunities" | "SalesLeadsPromotions" | "SalesAccountsOverview" | "SalesAccountsActivities" | "SalesAccountsBilling" | "SalesAccountsContracts" | "SalesOrdersOverview" | "SalesOrdersActivities" | "SalesOrdersPayments" | "SalesOrdersCommissions" | "SalesSchedulingSchedule" | "SalesSchedulingAppointments" | "SalesSchedulingRecurring" | "SalesSchedulingRoutes" | "SalesSchedulingReminders" | "UserHome"): void {
        currentVariant = variant;
        data = "pageGetDefaultForVariant"(variant);
        errors = {} as PageErrors;
        tainted = {} as PageTainted;
    }
    function validate(): Exit<Page, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(pageDeserialize(data));
    }
    function reset(overrides: Partial<Page>): void {
        data = overrides ? overrides as typeof data : pageGetDefaultForVariant(currentVariant);
        errors = {} as PageErrors;
        tainted = {} as PageTainted;
    }
    return {
        get currentVariant () {
            return currentVariant;
        },
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        variants,
        switchVariant,
        validate,
        reset
    };
}
export function pageFromFormData(formData: FormData): Exit<Page, Array<{
    field: string;
    message: string;
}>> {
    const discriminant = formData.get(`${"_value"}`) as "SalesHomeDashboard" | "SalesHomeProducts" | "SalesHomeServices" | "SalesHomePackages" | "SalesHomeTaxRates" | "SalesLeadsOverview" | "SalesLeadsActivities" | "SalesLeadsCampaigns" | "SalesLeadsDripCampaigns" | "SalesLeadsOpportunities" | "SalesLeadsPromotions" | "SalesAccountsOverview" | "SalesAccountsActivities" | "SalesAccountsBilling" | "SalesAccountsContracts" | "SalesOrdersOverview" | "SalesOrdersActivities" | "SalesOrdersPayments" | "SalesOrdersCommissions" | "SalesSchedulingSchedule" | "SalesSchedulingAppointments" | "SalesSchedulingRecurring" | "SalesSchedulingRoutes" | "SalesSchedulingReminders" | "UserHome" | null;
    if (!discriminant) {
        return toExit({
            success: false,
            errors: [
                {
                    field: `${"_value"}`,
                    message: "Missing discriminant field"
                }
            ]
        });
    }
    const obj: Record<string, unknown> = {};
    obj._value = discriminant;
    return toExit(pageDeserialize(obj));
}

export const Page = {
  serialize: pageSerialize,
  serializeWithContext: pageSerializeWithContext,
  deserialize: pageDeserialize,
  deserializeWithContext: pageDeserializeWithContext,
  is: pageIs,
  createForm: pageCreateForm,
  fromFormData: pageFromFormData
} as const;


export type UserRole =
    | /** @default */ 'Administrator'
    | 'SalesRepresentative'
    | 'Technician'
    | 'HumanResources'
    | 'InformationTechnology';

export function userRoleDefaultValue#0#0(): UserRole {
    return 'Administrator';
}

export function userRoleSerialize(value: UserRole): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(userRoleSerializeWithContext(value, ctx));
}
export function userRoleSerializeWithContext(value: UserRole, ctx: __mf_SerializeContext): unknown {
    if (typeof (value as any)?.serializeWithContext === "function") {
        return (value as any).serializeWithContext(ctx);
    }
    return value;
}

export function userRoleDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: UserRole } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = userRoleDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "UserRole.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function userRoleDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): UserRole | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref) as UserRole | __mf_PendingRef;
    }
    const allowedValues = [
        "'Administrator', 'SalesRepresentative', 'Technician', 'HumanResources', 'InformationTechnology'"
    ] as const;
    if (!allowedValues.includes(value)) {
        throw new __mf_DeserializeError([
            {
                field: "_root",
                message: `Invalid value for ${"UserRole"}: expected one of ` + allowedValues.map((v)=>JSON.stringify(v)).join(", ") + ", got " + JSON.stringify(value)
            }
        ]);
    }
    return value as UserRole;
}
export function userRoleIs(value: unknown): value is UserRole {
    const allowedValues = [
        "'Administrator', 'SalesRepresentative', 'Technician', 'HumanResources', 'InformationTechnology'"
    ] as const;
    return allowedValues.includes(value as any);
}

export type UserRoleAdministratorErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type UserRoleSalesRepresentativeErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type UserRoleTechnicianErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type UserRoleHumanResourcesErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type UserRoleInformationTechnologyErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type UserRoleAdministratorTainted = {
};
export type UserRoleSalesRepresentativeTainted = {
};
export type UserRoleTechnicianTainted = {
};
export type UserRoleHumanResourcesTainted = {
};
export type UserRoleInformationTechnologyTainted = {
};
export type UserRoleErrors = ({
    _value: "Administrator";
} & UserRoleAdministratorErrors) | ({
    _value: "SalesRepresentative";
} & UserRoleSalesRepresentativeErrors) | ({
    _value: "Technician";
} & UserRoleTechnicianErrors) | ({
    _value: "HumanResources";
} & UserRoleHumanResourcesErrors) | ({
    _value: "InformationTechnology";
} & UserRoleInformationTechnologyErrors);
export type UserRoleTainted = ({
    _value: "Administrator";
} & UserRoleAdministratorTainted) | ({
    _value: "SalesRepresentative";
} & UserRoleSalesRepresentativeTainted) | ({
    _value: "Technician";
} & UserRoleTechnicianTainted) | ({
    _value: "HumanResources";
} & UserRoleHumanResourcesTainted) | ({
    _value: "InformationTechnology";
} & UserRoleInformationTechnologyTainted);
export interface UserRoleAdministratorFieldControllers {
}
export interface UserRoleSalesRepresentativeFieldControllers {
}
export interface UserRoleTechnicianFieldControllers {
}
export interface UserRoleHumanResourcesFieldControllers {
}
export interface UserRoleInformationTechnologyFieldControllers {
}
export interface UserRoleGigaform {
    readonly currentVariant: "Administrator" | "SalesRepresentative" | "Technician" | "HumanResources" | "InformationTechnology";
    readonly data: UserRole;
    readonly errors: UserRoleErrors;
    readonly tainted: UserRoleTainted;
    readonly variants: UserRoleVariantFields;
    switchVariant(variant: "Administrator" | "SalesRepresentative" | "Technician" | "HumanResources" | "InformationTechnology"): void;
    validate(): Exit<UserRole, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<UserRole>): void;
}
export interface UserRoleVariantFields {
    readonly Administrator: {
        readonly fields: UserRoleAdministratorFieldControllers;
    };
    readonly SalesRepresentative: {
        readonly fields: UserRoleSalesRepresentativeFieldControllers;
    };
    readonly Technician: {
        readonly fields: UserRoleTechnicianFieldControllers;
    };
    readonly HumanResources: {
        readonly fields: UserRoleHumanResourcesFieldControllers;
    };
    readonly InformationTechnology: {
        readonly fields: UserRoleInformationTechnologyFieldControllers;
    };
}
function userRoleGetDefaultForVariant(variant: string): UserRole {
    if (variant === "Administrator") {
        return "Administrator" as UserRole;
    }
    if (variant === "SalesRepresentative") {
        return "SalesRepresentative" as UserRole;
    }
    if (variant === "Technician") {
        return "Technician" as UserRole;
    }
    if (variant === "HumanResources") {
        return "HumanResources" as UserRole;
    }
    if (variant === "InformationTechnology") {
        return "InformationTechnology" as UserRole;
    }
    return "Administrator" as UserRole;
}
export function userRoleCreateForm(initial: UserRole): UserRoleGigaform {
    const initialVariant: "Administrator" | "SalesRepresentative" | "Technician" | "HumanResources" | "InformationTechnology" = (initial as "Administrator" | "SalesRepresentative" | "Technician" | "HumanResources" | "InformationTechnology") ?? "Administrator";
    let currentVariant = $state<$MfPh5>(initialVariant);
    let data = $state<$MfPh6>(initial ?? "userRoleGetDefaultForVariant"(initialVariant));
    let errors = $state<$MfPh8>({} as UserRoleErrors);
    let tainted = $state<$MfPh10>({} as UserRoleTainted);
    const variants = {} as UserRoleVariantFields;
    variants[__expr__] = {
        fields: {} as UserRoleAdministratorFieldControllers
    };
    variants[__expr__] = {
        fields: {} as UserRoleSalesRepresentativeFieldControllers
    };
    variants[__expr__] = {
        fields: {} as UserRoleTechnicianFieldControllers
    };
    variants[__expr__] = {
        fields: {} as UserRoleHumanResourcesFieldControllers
    };
    variants[__expr__] = {
        fields: {} as UserRoleInformationTechnologyFieldControllers
    };
    function switchVariant(variant: "Administrator" | "SalesRepresentative" | "Technician" | "HumanResources" | "InformationTechnology"): void {
        currentVariant = variant;
        data = "userRoleGetDefaultForVariant"(variant);
        errors = {} as UserRoleErrors;
        tainted = {} as UserRoleTainted;
    }
    function validate(): Exit<UserRole, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(userRoleDeserialize(data));
    }
    function reset(overrides: Partial<UserRole>): void {
        data = overrides ? overrides as typeof data : userRoleGetDefaultForVariant(currentVariant);
        errors = {} as UserRoleErrors;
        tainted = {} as UserRoleTainted;
    }
    return {
        get currentVariant () {
            return currentVariant;
        },
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        variants,
        switchVariant,
        validate,
        reset
    };
}
export function userRoleFromFormData(formData: FormData): Exit<UserRole, Array<{
    field: string;
    message: string;
}>> {
    const discriminant = formData.get(`${"_value"}`) as "Administrator" | "SalesRepresentative" | "Technician" | "HumanResources" | "InformationTechnology" | null;
    if (!discriminant) {
        return toExit({
            success: false,
            errors: [
                {
                    field: `${"_value"}`,
                    message: "Missing discriminant field"
                }
            ]
        });
    }
    const obj: Record<string, unknown> = {};
    obj._value = discriminant;
    return toExit(userRoleDeserialize(obj));
}

export const UserRole = {
  serialize: userRoleSerialize,
  serializeWithContext: userRoleSerializeWithContext,
  deserialize: userRoleDeserialize,
  deserializeWithContext: userRoleDeserializeWithContext,
  is: userRoleIs,
  createForm: userRoleCreateForm,
  fromFormData: userRoleFromFormData
} as const;


export type Target =
    | /** @default */ Account
    | User
    | Employee
    | Appointment
    | Lead
    | TaxRate
    | Site
    | Route
    | Company
    | Product
    | Service
    | Order
    | Payment
    | Package
    | Promotion
    | Represents
    | Ordered;

export function targetDefaultValue#0#0(): Target {
    return accountDefaultValue();
}

export function targetSerialize(value: Target): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(targetSerializeWithContext(value, ctx));
}
export function targetSerializeWithContext(value: Target, ctx: __mf_SerializeContext): unknown {
    if (typeof (value as any)?.serializeWithContext === "function") {
        return (value as any).serializeWithContext(ctx);
    }
    return value;
}

export function targetDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: Target } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = targetDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "Target.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function targetDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Target | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref) as Target | __mf_PendingRef;
    }
    if (typeof value === "object" && value !== null) {
        const __typeName = (value as any).__type;
        if (typeof __typeName === "string") {}
        if (__typeName === "Account") {
            return accountDeserializeWithContext(value, ctx) as Target;
        }
        if (__typeName === "User") {
            return userDeserializeWithContext(value, ctx) as Target;
        }
        if (__typeName === "Employee") {
            return employeeDeserializeWithContext(value, ctx) as Target;
        }
        if (__typeName === "Appointment") {
            return appointmentDeserializeWithContext(value, ctx) as Target;
        }
        if (__typeName === "Lead") {
            return leadDeserializeWithContext(value, ctx) as Target;
        }
        if (__typeName === "TaxRate") {
            return taxRateDeserializeWithContext(value, ctx) as Target;
        }
        if (__typeName === "Site") {
            return siteDeserializeWithContext(value, ctx) as Target;
        }
        if (__typeName === "Route") {
            return routeDeserializeWithContext(value, ctx) as Target;
        }
        if (__typeName === "Company") {
            return companyDeserializeWithContext(value, ctx) as Target;
        }
        if (__typeName === "Product") {
            return productDeserializeWithContext(value, ctx) as Target;
        }
        if (__typeName === "Service") {
            return serviceDeserializeWithContext(value, ctx) as Target;
        }
        if (__typeName === "Order") {
            return orderDeserializeWithContext(value, ctx) as Target;
        }
        if (__typeName === "Payment") {
            return paymentDeserializeWithContext(value, ctx) as Target;
        }
        if (__typeName === "Package") {
            return packageDeserializeWithContext(value, ctx) as Target;
        }
        if (__typeName === "Promotion") {
            return promotionDeserializeWithContext(value, ctx) as Target;
        }
        if (__typeName === "Represents") {
            return representsDeserializeWithContext(value, ctx) as Target;
        }
        if (__typeName === "Ordered") {
            return orderedDeserializeWithContext(value, ctx) as Target;
        }
    }
    throw new __mf_DeserializeError([
        {
            field: "_root",
            message: `${"Target"}.deserializeWithContext: value does not match any union member`
        }
    ]);
}
export function targetIs(value: unknown): value is Target {
    if (typeof value === "object" && value !== null) {
        const __typeName = (value as any).__type;
        if ('__typeName === "Account" || __typeName === "User" || __typeName === "Employee" || __typeName === "Appointment" || __typeName === "Lead" || __typeName === "TaxRate" || __typeName === "Site" || __typeName === "Route" || __typeName === "Company" || __typeName === "Product" || __typeName === "Service" || __typeName === "Order" || __typeName === "Payment" || __typeName === "Package" || __typeName === "Promotion" || __typeName === "Represents" || __typeName === "Ordered"') return true;
    }
    return false;
}
     }

export type TargetAccountErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type TargetUserErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type TargetEmployeeErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type TargetAppointmentErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type TargetLeadErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type TargetTaxRateErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type TargetSiteErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type TargetRouteErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type TargetCompanyErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type TargetProductErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type TargetServiceErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type TargetOrderErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type TargetPaymentErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type TargetPackageErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type TargetPromotionErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type TargetRepresentsErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type TargetOrderedErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type TargetAccountTainted = {
};
export type TargetUserTainted = {
};
export type TargetEmployeeTainted = {
};
export type TargetAppointmentTainted = {
};
export type TargetLeadTainted = {
};
export type TargetTaxRateTainted = {
};
export type TargetSiteTainted = {
};
export type TargetRouteTainted = {
};
export type TargetCompanyTainted = {
};
export type TargetProductTainted = {
};
export type TargetServiceTainted = {
};
export type TargetOrderTainted = {
};
export type TargetPaymentTainted = {
};
export type TargetPackageTainted = {
};
export type TargetPromotionTainted = {
};
export type TargetRepresentsTainted = {
};
export type TargetOrderedTainted = {
};
export type TargetErrors = ({
    _type: "Account";
} & TargetAccountErrors) | ({
    _type: "User";
} & TargetUserErrors) | ({
    _type: "Employee";
} & TargetEmployeeErrors) | ({
    _type: "Appointment";
} & TargetAppointmentErrors) | ({
    _type: "Lead";
} & TargetLeadErrors) | ({
    _type: "TaxRate";
} & TargetTaxRateErrors) | ({
    _type: "Site";
} & TargetSiteErrors) | ({
    _type: "Route";
} & TargetRouteErrors) | ({
    _type: "Company";
} & TargetCompanyErrors) | ({
    _type: "Product";
} & TargetProductErrors) | ({
    _type: "Service";
} & TargetServiceErrors) | ({
    _type: "Order";
} & TargetOrderErrors) | ({
    _type: "Payment";
} & TargetPaymentErrors) | ({
    _type: "Package";
} & TargetPackageErrors) | ({
    _type: "Promotion";
} & TargetPromotionErrors) | ({
    _type: "Represents";
} & TargetRepresentsErrors) | ({
    _type: "Ordered";
} & TargetOrderedErrors);
export type TargetTainted = ({
    _type: "Account";
} & TargetAccountTainted) | ({
    _type: "User";
} & TargetUserTainted) | ({
    _type: "Employee";
} & TargetEmployeeTainted) | ({
    _type: "Appointment";
} & TargetAppointmentTainted) | ({
    _type: "Lead";
} & TargetLeadTainted) | ({
    _type: "TaxRate";
} & TargetTaxRateTainted) | ({
    _type: "Site";
} & TargetSiteTainted) | ({
    _type: "Route";
} & TargetRouteTainted) | ({
    _type: "Company";
} & TargetCompanyTainted) | ({
    _type: "Product";
} & TargetProductTainted) | ({
    _type: "Service";
} & TargetServiceTainted) | ({
    _type: "Order";
} & TargetOrderTainted) | ({
    _type: "Payment";
} & TargetPaymentTainted) | ({
    _type: "Package";
} & TargetPackageTainted) | ({
    _type: "Promotion";
} & TargetPromotionTainted) | ({
    _type: "Represents";
} & TargetRepresentsTainted) | ({
    _type: "Ordered";
} & TargetOrderedTainted);
export interface TargetAccountFieldControllers {
}
export interface TargetUserFieldControllers {
}
export interface TargetEmployeeFieldControllers {
}
export interface TargetAppointmentFieldControllers {
}
export interface TargetLeadFieldControllers {
}
export interface TargetTaxRateFieldControllers {
}
export interface TargetSiteFieldControllers {
}
export interface TargetRouteFieldControllers {
}
export interface TargetCompanyFieldControllers {
}
export interface TargetProductFieldControllers {
}
export interface TargetServiceFieldControllers {
}
export interface TargetOrderFieldControllers {
}
export interface TargetPaymentFieldControllers {
}
export interface TargetPackageFieldControllers {
}
export interface TargetPromotionFieldControllers {
}
export interface TargetRepresentsFieldControllers {
}
export interface TargetOrderedFieldControllers {
}
export interface TargetGigaform {
    readonly currentVariant: "Account" | "User" | "Employee" | "Appointment" | "Lead" | "TaxRate" | "Site" | "Route" | "Company" | "Product" | "Service" | "Order" | "Payment" | "Package" | "Promotion" | "Represents" | "Ordered";
    readonly data: Target;
    readonly errors: TargetErrors;
    readonly tainted: TargetTainted;
    readonly variants: TargetVariantFields;
    switchVariant(variant: "Account" | "User" | "Employee" | "Appointment" | "Lead" | "TaxRate" | "Site" | "Route" | "Company" | "Product" | "Service" | "Order" | "Payment" | "Package" | "Promotion" | "Represents" | "Ordered"): void;
    validate(): Exit<Target, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<Target>): void;
}
export interface TargetVariantFields {
    readonly Account: {
        readonly fields: TargetAccountFieldControllers;
    };
    readonly User: {
        readonly fields: TargetUserFieldControllers;
    };
    readonly Employee: {
        readonly fields: TargetEmployeeFieldControllers;
    };
    readonly Appointment: {
        readonly fields: TargetAppointmentFieldControllers;
    };
    readonly Lead: {
        readonly fields: TargetLeadFieldControllers;
    };
    readonly TaxRate: {
        readonly fields: TargetTaxRateFieldControllers;
    };
    readonly Site: {
        readonly fields: TargetSiteFieldControllers;
    };
    readonly Route: {
        readonly fields: TargetRouteFieldControllers;
    };
    readonly Company: {
        readonly fields: TargetCompanyFieldControllers;
    };
    readonly Product: {
        readonly fields: TargetProductFieldControllers;
    };
    readonly Service: {
        readonly fields: TargetServiceFieldControllers;
    };
    readonly Order: {
        readonly fields: TargetOrderFieldControllers;
    };
    readonly Payment: {
        readonly fields: TargetPaymentFieldControllers;
    };
    readonly Package: {
        readonly fields: TargetPackageFieldControllers;
    };
    readonly Promotion: {
        readonly fields: TargetPromotionFieldControllers;
    };
    readonly Represents: {
        readonly fields: TargetRepresentsFieldControllers;
    };
    readonly Ordered: {
        readonly fields: TargetOrderedFieldControllers;
    };
}
function targetGetDefaultForVariant(variant: string): Target {
    if (variant === "Account") {
        return accountDefaultValue() as Target;
    }
    if (variant === "User") {
        return userDefaultValue() as Target;
    }
    if (variant === "Employee") {
        return employeeDefaultValue() as Target;
    }
    if (variant === "Appointment") {
        return appointmentDefaultValue() as Target;
    }
    if (variant === "Lead") {
        return leadDefaultValue() as Target;
    }
    if (variant === "TaxRate") {
        return taxRateDefaultValue() as Target;
    }
    if (variant === "Site") {
        return siteDefaultValue() as Target;
    }
    if (variant === "Route") {
        return routeDefaultValue() as Target;
    }
    if (variant === "Company") {
        return companyDefaultValue() as Target;
    }
    if (variant === "Product") {
        return productDefaultValue() as Target;
    }
    if (variant === "Service") {
        return serviceDefaultValue() as Target;
    }
    if (variant === "Order") {
        return orderDefaultValue() as Target;
    }
    if (variant === "Payment") {
        return paymentDefaultValue() as Target;
    }
    if (variant === "Package") {
        return packageDefaultValue() as Target;
    }
    if (variant === "Promotion") {
        return promotionDefaultValue() as Target;
    }
    if (variant === "Represents") {
        return representsDefaultValue() as Target;
    }
    if (variant === "Ordered") {
        return orderedDefaultValue() as Target;
    }
    return accountDefaultValue() as Target;
}
export function targetCreateForm(initial: Target): TargetGigaform {
    const initialVariant: "Account" | "User" | "Employee" | "Appointment" | "Lead" | "TaxRate" | "Site" | "Route" | "Company" | "Product" | "Service" | "Order" | "Payment" | "Package" | "Promotion" | "Represents" | "Ordered" = "Account";
    let currentVariant = $state<$MfPh5>(initialVariant);
    let data = $state<$MfPh6>(initial ?? "targetGetDefaultForVariant"(initialVariant));
    let errors = $state<$MfPh8>({} as TargetErrors);
    let tainted = $state<$MfPh10>({} as TargetTainted);
    const variants = {} as TargetVariantFields;
    variants[__expr__] = {
        fields: {} as TargetAccountFieldControllers
    };
    variants[__expr__] = {
        fields: {} as TargetUserFieldControllers
    };
    variants[__expr__] = {
        fields: {} as TargetEmployeeFieldControllers
    };
    variants[__expr__] = {
        fields: {} as TargetAppointmentFieldControllers
    };
    variants[__expr__] = {
        fields: {} as TargetLeadFieldControllers
    };
    variants[__expr__] = {
        fields: {} as TargetTaxRateFieldControllers
    };
    variants[__expr__] = {
        fields: {} as TargetSiteFieldControllers
    };
    variants[__expr__] = {
        fields: {} as TargetRouteFieldControllers
    };
    variants[__expr__] = {
        fields: {} as TargetCompanyFieldControllers
    };
    variants[__expr__] = {
        fields: {} as TargetProductFieldControllers
    };
    variants[__expr__] = {
        fields: {} as TargetServiceFieldControllers
    };
    variants[__expr__] = {
        fields: {} as TargetOrderFieldControllers
    };
    variants[__expr__] = {
        fields: {} as TargetPaymentFieldControllers
    };
    variants[__expr__] = {
        fields: {} as TargetPackageFieldControllers
    };
    variants[__expr__] = {
        fields: {} as TargetPromotionFieldControllers
    };
    variants[__expr__] = {
        fields: {} as TargetRepresentsFieldControllers
    };
    variants[__expr__] = {
        fields: {} as TargetOrderedFieldControllers
    };
    function switchVariant(variant: "Account" | "User" | "Employee" | "Appointment" | "Lead" | "TaxRate" | "Site" | "Route" | "Company" | "Product" | "Service" | "Order" | "Payment" | "Package" | "Promotion" | "Represents" | "Ordered"): void {
        currentVariant = variant;
        data = "targetGetDefaultForVariant"(variant);
        errors = {} as TargetErrors;
        tainted = {} as TargetTainted;
    }
    function validate(): Exit<Target, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(targetDeserialize(data));
    }
    function reset(overrides: Partial<Target>): void {
        data = overrides ? overrides as typeof data : targetGetDefaultForVariant(currentVariant);
        errors = {} as TargetErrors;
        tainted = {} as TargetTainted;
    }
    return {
        get currentVariant () {
            return currentVariant;
        },
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        variants,
        switchVariant,
        validate,
        reset
    };
}
export function targetFromFormData(formData: FormData): Exit<Target, Array<{
    field: string;
    message: string;
}>> {
    const discriminant = formData.get(`${"_type"}`) as "Account" | "User" | "Employee" | "Appointment" | "Lead" | "TaxRate" | "Site" | "Route" | "Company" | "Product" | "Service" | "Order" | "Payment" | "Package" | "Promotion" | "Represents" | "Ordered" | null;
    if (!discriminant) {
        return toExit({
            success: false,
            errors: [
                {
                    field: `${"_type"}`,
                    message: "Missing discriminant field"
                }
            ]
        });
    }
    const obj: Record<string, unknown> = {};
    obj._type = discriminant;
    return toExit(targetDeserialize(obj));
}

export const Target = {
  serialize: targetSerialize,
  serializeWithContext: targetSerializeWithContext,
  deserialize: targetDeserialize,
  deserializeWithContext: targetDeserializeWithContext,
  is: targetIs,
  createForm: targetCreateForm,
  fromFormData: targetFromFormData
} as const;


export type RecurrenceEnd = /** @default(0) */ number | string;

export function recurrenceEndDefaultValue#0#0(): RecurrenceEnd {
    return 0;
}

export function recurrenceEndSerialize(value: RecurrenceEnd): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(recurrenceEndSerializeWithContext(value, ctx));
}
export function recurrenceEndSerializeWithContext(value: RecurrenceEnd, ctx: __mf_SerializeContext): unknown {
    if (typeof (value as any)?.serializeWithContext === "function") {
        return (value as any).serializeWithContext(ctx);
    }
    return value;
}

export function recurrenceEndDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: RecurrenceEnd } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = recurrenceEndDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "RecurrenceEnd.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function recurrenceEndDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): RecurrenceEnd | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref) as RecurrenceEnd | __mf_PendingRef;
    }
    if (typeof value === "number") {
        return value as RecurrenceEnd;
    }
    if (typeof value === "string") {
        return value as RecurrenceEnd;
    }
    throw new __mf_DeserializeError([
        {
            field: "_root",
            message: `${"RecurrenceEnd"}.deserializeWithContext: value does not match any union member`
        }
    ]);
}
export function recurrenceEndIs(value: unknown): value is RecurrenceEnd {
    if (typeof value === "number") return true;
    if (typeof value === "string") return true;
    return false;
}

export type RecurrenceEndNumberErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type RecurrenceEndStringErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type RecurrenceEndNumberTainted = {
};
export type RecurrenceEndStringTainted = {
};
export type RecurrenceEndErrors = ({
    _type: "number";
} & RecurrenceEndNumberErrors) | ({
    _type: "string";
} & RecurrenceEndStringErrors);
export type RecurrenceEndTainted = ({
    _type: "number";
} & RecurrenceEndNumberTainted) | ({
    _type: "string";
} & RecurrenceEndStringTainted);
export interface RecurrenceEndNumberFieldControllers {
}
export interface RecurrenceEndStringFieldControllers {
}
export interface RecurrenceEndGigaform {
    readonly currentVariant: "number" | "string";
    readonly data: RecurrenceEnd;
    readonly errors: RecurrenceEndErrors;
    readonly tainted: RecurrenceEndTainted;
    readonly variants: RecurrenceEndVariantFields;
    switchVariant(variant: "number" | "string"): void;
    validate(): Exit<RecurrenceEnd, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<RecurrenceEnd>): void;
}
export interface RecurrenceEndVariantFields {
    readonly number: {
        readonly fields: RecurrenceEndNumberFieldControllers;
    };
    readonly string: {
        readonly fields: RecurrenceEndStringFieldControllers;
    };
}
function recurrenceEndGetDefaultForVariant(variant: string): RecurrenceEnd {
    if (variant === "number") {
        return 0 as RecurrenceEnd;
    }
    if (variant === "string") {
        return "" as RecurrenceEnd;
    }
    return 0 as RecurrenceEnd;
}
export function recurrenceEndCreateForm(initial: RecurrenceEnd): RecurrenceEndGigaform {
    const initialVariant: "number" | "string" = "number";
    let currentVariant = $state<$MfPh5>(initialVariant);
    let data = $state<$MfPh6>(initial ?? "recurrenceEndGetDefaultForVariant"(initialVariant));
    let errors = $state<$MfPh8>({} as RecurrenceEndErrors);
    let tainted = $state<$MfPh10>({} as RecurrenceEndTainted);
    const variants = {} as RecurrenceEndVariantFields;
    variants[__expr__] = {
        fields: {} as RecurrenceEndNumberFieldControllers
    };
    variants[__expr__] = {
        fields: {} as RecurrenceEndStringFieldControllers
    };
    function switchVariant(variant: "number" | "string"): void {
        currentVariant = variant;
        data = "recurrenceEndGetDefaultForVariant"(variant);
        errors = {} as RecurrenceEndErrors;
        tainted = {} as RecurrenceEndTainted;
    }
    function validate(): Exit<RecurrenceEnd, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(recurrenceEndDeserialize(data));
    }
    function reset(overrides: Partial<RecurrenceEnd>): void {
        data = overrides ? overrides as typeof data : recurrenceEndGetDefaultForVariant(currentVariant);
        errors = {} as RecurrenceEndErrors;
        tainted = {} as RecurrenceEndTainted;
    }
    return {
        get currentVariant () {
            return currentVariant;
        },
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        variants,
        switchVariant,
        validate,
        reset
    };
}
export function recurrenceEndFromFormData(formData: FormData): Exit<RecurrenceEnd, Array<{
    field: string;
    message: string;
}>> {
    const discriminant = formData.get(`${"_type"}`) as "number" | "string" | null;
    if (!discriminant) {
        return toExit({
            success: false,
            errors: [
                {
                    field: `${"_type"}`,
                    message: "Missing discriminant field"
                }
            ]
        });
    }
    const obj: Record<string, unknown> = {};
    obj._type = discriminant;
    return toExit(recurrenceEndDeserialize(obj));
}

export const RecurrenceEnd = {
  serialize: recurrenceEndSerialize,
  serializeWithContext: recurrenceEndSerializeWithContext,
  deserialize: recurrenceEndDeserialize,
  deserializeWithContext: recurrenceEndDeserializeWithContext,
  is: recurrenceEndIs,
  createForm: recurrenceEndCreateForm,
  fromFormData: recurrenceEndFromFormData
} as const;


export type OverviewDisplay = /** @default */ 'Card' | 'Table';

export function overviewDisplayDefaultValue#0#0(): OverviewDisplay {
    return 'Card';
}

export function overviewDisplaySerialize(value: OverviewDisplay): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(overviewDisplaySerializeWithContext(value, ctx));
}
export function overviewDisplaySerializeWithContext(value: OverviewDisplay, ctx: __mf_SerializeContext): unknown {
    if (typeof (value as any)?.serializeWithContext === "function") {
        return (value as any).serializeWithContext(ctx);
    }
    return value;
}

export function overviewDisplayDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: OverviewDisplay } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = overviewDisplayDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "OverviewDisplay.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function overviewDisplayDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): OverviewDisplay | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref) as OverviewDisplay | __mf_PendingRef;
    }
    const allowedValues = [
        "'Card', 'Table'"
    ] as const;
    if (!allowedValues.includes(value)) {
        throw new __mf_DeserializeError([
            {
                field: "_root",
                message: `Invalid value for ${"OverviewDisplay"}: expected one of ` + allowedValues.map((v)=>JSON.stringify(v)).join(", ") + ", got " + JSON.stringify(value)
            }
        ]);
    }
    return value as OverviewDisplay;
}
export function overviewDisplayIs(value: unknown): value is OverviewDisplay {
    const allowedValues = [
        "'Card', 'Table'"
    ] as const;
    return allowedValues.includes(value as any);
}

export type OverviewDisplayCardErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type OverviewDisplayTableErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type OverviewDisplayCardTainted = {
};
export type OverviewDisplayTableTainted = {
};
export type OverviewDisplayErrors = ({
    _value: "Card";
} & OverviewDisplayCardErrors) | ({
    _value: "Table";
} & OverviewDisplayTableErrors);
export type OverviewDisplayTainted = ({
    _value: "Card";
} & OverviewDisplayCardTainted) | ({
    _value: "Table";
} & OverviewDisplayTableTainted);
export interface OverviewDisplayCardFieldControllers {
}
export interface OverviewDisplayTableFieldControllers {
}
export interface OverviewDisplayGigaform {
    readonly currentVariant: "Card" | "Table";
    readonly data: OverviewDisplay;
    readonly errors: OverviewDisplayErrors;
    readonly tainted: OverviewDisplayTainted;
    readonly variants: OverviewDisplayVariantFields;
    switchVariant(variant: "Card" | "Table"): void;
    validate(): Exit<OverviewDisplay, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<OverviewDisplay>): void;
}
export interface OverviewDisplayVariantFields {
    readonly Card: {
        readonly fields: OverviewDisplayCardFieldControllers;
    };
    readonly Table: {
        readonly fields: OverviewDisplayTableFieldControllers;
    };
}
function overviewDisplayGetDefaultForVariant(variant: string): OverviewDisplay {
    if (variant === "Card") {
        return "Card" as OverviewDisplay;
    }
    if (variant === "Table") {
        return "Table" as OverviewDisplay;
    }
    return "Card" as OverviewDisplay;
}
export function overviewDisplayCreateForm(initial: OverviewDisplay): OverviewDisplayGigaform {
    const initialVariant: "Card" | "Table" = (initial as "Card" | "Table") ?? "Card";
    let currentVariant = $state<$MfPh5>(initialVariant);
    let data = $state<$MfPh6>(initial ?? "overviewDisplayGetDefaultForVariant"(initialVariant));
    let errors = $state<$MfPh8>({} as OverviewDisplayErrors);
    let tainted = $state<$MfPh10>({} as OverviewDisplayTainted);
    const variants = {} as OverviewDisplayVariantFields;
    variants[__expr__] = {
        fields: {} as OverviewDisplayCardFieldControllers
    };
    variants[__expr__] = {
        fields: {} as OverviewDisplayTableFieldControllers
    };
    function switchVariant(variant: "Card" | "Table"): void {
        currentVariant = variant;
        data = "overviewDisplayGetDefaultForVariant"(variant);
        errors = {} as OverviewDisplayErrors;
        tainted = {} as OverviewDisplayTainted;
    }
    function validate(): Exit<OverviewDisplay, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(overviewDisplayDeserialize(data));
    }
    function reset(overrides: Partial<OverviewDisplay>): void {
        data = overrides ? overrides as typeof data : overviewDisplayGetDefaultForVariant(currentVariant);
        errors = {} as OverviewDisplayErrors;
        tainted = {} as OverviewDisplayTainted;
    }
    return {
        get currentVariant () {
            return currentVariant;
        },
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        variants,
        switchVariant,
        validate,
        reset
    };
}
export function overviewDisplayFromFormData(formData: FormData): Exit<OverviewDisplay, Array<{
    field: string;
    message: string;
}>> {
    const discriminant = formData.get(`${"_value"}`) as "Card" | "Table" | null;
    if (!discriminant) {
        return toExit({
            success: false,
            errors: [
                {
                    field: `${"_value"}`,
                    message: "Missing discriminant field"
                }
            ]
        });
    }
    const obj: Record<string, unknown> = {};
    obj._value = discriminant;
    return toExit(overviewDisplayDeserialize(obj));
}

export const OverviewDisplay = {
  serialize: overviewDisplaySerialize,
  serializeWithContext: overviewDisplaySerializeWithContext,
  deserialize: overviewDisplayDeserialize,
  deserializeWithContext: overviewDisplayDeserializeWithContext,
  is: overviewDisplayIs,
  createForm: overviewDisplayCreateForm,
  fromFormData: overviewDisplayFromFormData
} as const;


export type IntervalUnit = /** @default */ 'Day' | 'Week' | 'Month' | 'Year';

export function intervalUnitDefaultValue#0#0(): IntervalUnit {
    return 'Day';
}

export function intervalUnitSerialize(value: IntervalUnit): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(intervalUnitSerializeWithContext(value, ctx));
}
export function intervalUnitSerializeWithContext(value: IntervalUnit, ctx: __mf_SerializeContext): unknown {
    if (typeof (value as any)?.serializeWithContext === "function") {
        return (value as any).serializeWithContext(ctx);
    }
    return value;
}

export function intervalUnitDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: IntervalUnit } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = intervalUnitDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "IntervalUnit.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function intervalUnitDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): IntervalUnit | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref) as IntervalUnit | __mf_PendingRef;
    }
    const allowedValues = [
        "'Day', 'Week', 'Month', 'Year'"
    ] as const;
    if (!allowedValues.includes(value)) {
        throw new __mf_DeserializeError([
            {
                field: "_root",
                message: `Invalid value for ${"IntervalUnit"}: expected one of ` + allowedValues.map((v)=>JSON.stringify(v)).join(", ") + ", got " + JSON.stringify(value)
            }
        ]);
    }
    return value as IntervalUnit;
}
export function intervalUnitIs(value: unknown): value is IntervalUnit {
    const allowedValues = [
        "'Day', 'Week', 'Month', 'Year'"
    ] as const;
    return allowedValues.includes(value as any);
}

export type IntervalUnitDayErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type IntervalUnitWeekErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type IntervalUnitMonthErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type IntervalUnitYearErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type IntervalUnitDayTainted = {
};
export type IntervalUnitWeekTainted = {
};
export type IntervalUnitMonthTainted = {
};
export type IntervalUnitYearTainted = {
};
export type IntervalUnitErrors = ({
    _value: "Day";
} & IntervalUnitDayErrors) | ({
    _value: "Week";
} & IntervalUnitWeekErrors) | ({
    _value: "Month";
} & IntervalUnitMonthErrors) | ({
    _value: "Year";
} & IntervalUnitYearErrors);
export type IntervalUnitTainted = ({
    _value: "Day";
} & IntervalUnitDayTainted) | ({
    _value: "Week";
} & IntervalUnitWeekTainted) | ({
    _value: "Month";
} & IntervalUnitMonthTainted) | ({
    _value: "Year";
} & IntervalUnitYearTainted);
export interface IntervalUnitDayFieldControllers {
}
export interface IntervalUnitWeekFieldControllers {
}
export interface IntervalUnitMonthFieldControllers {
}
export interface IntervalUnitYearFieldControllers {
}
export interface IntervalUnitGigaform {
    readonly currentVariant: "Day" | "Week" | "Month" | "Year";
    readonly data: IntervalUnit;
    readonly errors: IntervalUnitErrors;
    readonly tainted: IntervalUnitTainted;
    readonly variants: IntervalUnitVariantFields;
    switchVariant(variant: "Day" | "Week" | "Month" | "Year"): void;
    validate(): Exit<IntervalUnit, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<IntervalUnit>): void;
}
export interface IntervalUnitVariantFields {
    readonly Day: {
        readonly fields: IntervalUnitDayFieldControllers;
    };
    readonly Week: {
        readonly fields: IntervalUnitWeekFieldControllers;
    };
    readonly Month: {
        readonly fields: IntervalUnitMonthFieldControllers;
    };
    readonly Year: {
        readonly fields: IntervalUnitYearFieldControllers;
    };
}
function intervalUnitGetDefaultForVariant(variant: string): IntervalUnit {
    if (variant === "Day") {
        return "Day" as IntervalUnit;
    }
    if (variant === "Week") {
        return "Week" as IntervalUnit;
    }
    if (variant === "Month") {
        return "Month" as IntervalUnit;
    }
    if (variant === "Year") {
        return "Year" as IntervalUnit;
    }
    return "Day" as IntervalUnit;
}
export function intervalUnitCreateForm(initial: IntervalUnit): IntervalUnitGigaform {
    const initialVariant: "Day" | "Week" | "Month" | "Year" = (initial as "Day" | "Week" | "Month" | "Year") ?? "Day";
    let currentVariant = $state<$MfPh5>(initialVariant);
    let data = $state<$MfPh6>(initial ?? "intervalUnitGetDefaultForVariant"(initialVariant));
    let errors = $state<$MfPh8>({} as IntervalUnitErrors);
    let tainted = $state<$MfPh10>({} as IntervalUnitTainted);
    const variants = {} as IntervalUnitVariantFields;
    variants[__expr__] = {
        fields: {} as IntervalUnitDayFieldControllers
    };
    variants[__expr__] = {
        fields: {} as IntervalUnitWeekFieldControllers
    };
    variants[__expr__] = {
        fields: {} as IntervalUnitMonthFieldControllers
    };
    variants[__expr__] = {
        fields: {} as IntervalUnitYearFieldControllers
    };
    function switchVariant(variant: "Day" | "Week" | "Month" | "Year"): void {
        currentVariant = variant;
        data = "intervalUnitGetDefaultForVariant"(variant);
        errors = {} as IntervalUnitErrors;
        tainted = {} as IntervalUnitTainted;
    }
    function validate(): Exit<IntervalUnit, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(intervalUnitDeserialize(data));
    }
    function reset(overrides: Partial<IntervalUnit>): void {
        data = overrides ? overrides as typeof data : intervalUnitGetDefaultForVariant(currentVariant);
        errors = {} as IntervalUnitErrors;
        tainted = {} as IntervalUnitTainted;
    }
    return {
        get currentVariant () {
            return currentVariant;
        },
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        variants,
        switchVariant,
        validate,
        reset
    };
}
export function intervalUnitFromFormData(formData: FormData): Exit<IntervalUnit, Array<{
    field: string;
    message: string;
}>> {
    const discriminant = formData.get(`${"_value"}`) as "Day" | "Week" | "Month" | "Year" | null;
    if (!discriminant) {
        return toExit({
            success: false,
            errors: [
                {
                    field: `${"_value"}`,
                    message: "Missing discriminant field"
                }
            ]
        });
    }
    const obj: Record<string, unknown> = {};
    obj._value = discriminant;
    return toExit(intervalUnitDeserialize(obj));
}

export const IntervalUnit = {
  serialize: intervalUnitSerialize,
  serializeWithContext: intervalUnitSerializeWithContext,
  deserialize: intervalUnitDeserialize,
  deserializeWithContext: intervalUnitDeserializeWithContext,
  is: intervalUnitIs,
  createForm: intervalUnitCreateForm,
  fromFormData: intervalUnitFromFormData
} as const;


export type Sector = /** @default */ 'Residential' | 'Commercial';

export function sectorDefaultValue#0#0(): Sector {
    return 'Residential';
}

export function sectorSerialize(value: Sector): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(sectorSerializeWithContext(value, ctx));
}
export function sectorSerializeWithContext(value: Sector, ctx: __mf_SerializeContext): unknown {
    if (typeof (value as any)?.serializeWithContext === "function") {
        return (value as any).serializeWithContext(ctx);
    }
    return value;
}

export function sectorDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: Sector } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = sectorDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "Sector.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function sectorDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Sector | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref) as Sector | __mf_PendingRef;
    }
    const allowedValues = [
        "'Residential', 'Commercial'"
    ] as const;
    if (!allowedValues.includes(value)) {
        throw new __mf_DeserializeError([
            {
                field: "_root",
                message: `Invalid value for ${"Sector"}: expected one of ` + allowedValues.map((v)=>JSON.stringify(v)).join(", ") + ", got " + JSON.stringify(value)
            }
        ]);
    }
    return value as Sector;
}
export function sectorIs(value: unknown): value is Sector {
    const allowedValues = [
        "'Residential', 'Commercial'"
    ] as const;
    return allowedValues.includes(value as any);
}

export type SectorResidentialErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type SectorCommercialErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type SectorResidentialTainted = {
};
export type SectorCommercialTainted = {
};
export type SectorErrors = ({
    _value: "Residential";
} & SectorResidentialErrors) | ({
    _value: "Commercial";
} & SectorCommercialErrors);
export type SectorTainted = ({
    _value: "Residential";
} & SectorResidentialTainted) | ({
    _value: "Commercial";
} & SectorCommercialTainted);
export interface SectorResidentialFieldControllers {
}
export interface SectorCommercialFieldControllers {
}
export interface SectorGigaform {
    readonly currentVariant: "Residential" | "Commercial";
    readonly data: Sector;
    readonly errors: SectorErrors;
    readonly tainted: SectorTainted;
    readonly variants: SectorVariantFields;
    switchVariant(variant: "Residential" | "Commercial"): void;
    validate(): Exit<Sector, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<Sector>): void;
}
export interface SectorVariantFields {
    readonly Residential: {
        readonly fields: SectorResidentialFieldControllers;
    };
    readonly Commercial: {
        readonly fields: SectorCommercialFieldControllers;
    };
}
function sectorGetDefaultForVariant(variant: string): Sector {
    if (variant === "Residential") {
        return "Residential" as Sector;
    }
    if (variant === "Commercial") {
        return "Commercial" as Sector;
    }
    return "Residential" as Sector;
}
export function sectorCreateForm(initial: Sector): SectorGigaform {
    const initialVariant: "Residential" | "Commercial" = (initial as "Residential" | "Commercial") ?? "Residential";
    let currentVariant = $state<$MfPh5>(initialVariant);
    let data = $state<$MfPh6>(initial ?? "sectorGetDefaultForVariant"(initialVariant));
    let errors = $state<$MfPh8>({} as SectorErrors);
    let tainted = $state<$MfPh10>({} as SectorTainted);
    const variants = {} as SectorVariantFields;
    variants[__expr__] = {
        fields: {} as SectorResidentialFieldControllers
    };
    variants[__expr__] = {
        fields: {} as SectorCommercialFieldControllers
    };
    function switchVariant(variant: "Residential" | "Commercial"): void {
        currentVariant = variant;
        data = "sectorGetDefaultForVariant"(variant);
        errors = {} as SectorErrors;
        tainted = {} as SectorTainted;
    }
    function validate(): Exit<Sector, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(sectorDeserialize(data));
    }
    function reset(overrides: Partial<Sector>): void {
        data = overrides ? overrides as typeof data : sectorGetDefaultForVariant(currentVariant);
        errors = {} as SectorErrors;
        tainted = {} as SectorTainted;
    }
    return {
        get currentVariant () {
            return currentVariant;
        },
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        variants,
        switchVariant,
        validate,
        reset
    };
}
export function sectorFromFormData(formData: FormData): Exit<Sector, Array<{
    field: string;
    message: string;
}>> {
    const discriminant = formData.get(`${"_value"}`) as "Residential" | "Commercial" | null;
    if (!discriminant) {
        return toExit({
            success: false,
            errors: [
                {
                    field: `${"_value"}`,
                    message: "Missing discriminant field"
                }
            ]
        });
    }
    const obj: Record<string, unknown> = {};
    obj._value = discriminant;
    return toExit(sectorDeserialize(obj));
}

export const Sector = {
  serialize: sectorSerialize,
  serializeWithContext: sectorSerializeWithContext,
  deserialize: sectorDeserialize,
  deserializeWithContext: sectorDeserializeWithContext,
  is: sectorIs,
  createForm: sectorCreateForm,
  fromFormData: sectorFromFormData
} as const;


export type Weekday =
    | /** @default */ 'Monday'
    | 'Tuesday'
    | 'Wednesday'
    | 'Thursday'
    | 'Friday'
    | 'Saturday'
    | 'Sunday';

export function weekdayDefaultValue#0#0(): Weekday {
    return 'Monday';
}

export function weekdaySerialize(value: Weekday): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(weekdaySerializeWithContext(value, ctx));
}
export function weekdaySerializeWithContext(value: Weekday, ctx: __mf_SerializeContext): unknown {
    if (typeof (value as any)?.serializeWithContext === "function") {
        return (value as any).serializeWithContext(ctx);
    }
    return value;
}

export function weekdayDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: Weekday } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = weekdayDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "Weekday.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function weekdayDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Weekday | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref) as Weekday | __mf_PendingRef;
    }
    const allowedValues = [
        "'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'"
    ] as const;
    if (!allowedValues.includes(value)) {
        throw new __mf_DeserializeError([
            {
                field: "_root",
                message: `Invalid value for ${"Weekday"}: expected one of ` + allowedValues.map((v)=>JSON.stringify(v)).join(", ") + ", got " + JSON.stringify(value)
            }
        ]);
    }
    return value as Weekday;
}
export function weekdayIs(value: unknown): value is Weekday {
    const allowedValues = [
        "'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'"
    ] as const;
    return allowedValues.includes(value as any);
}

export type WeekdayMondayErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type WeekdayTuesdayErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type WeekdayWednesdayErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type WeekdayThursdayErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type WeekdayFridayErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type WeekdaySaturdayErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type WeekdaySundayErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type WeekdayMondayTainted = {
};
export type WeekdayTuesdayTainted = {
};
export type WeekdayWednesdayTainted = {
};
export type WeekdayThursdayTainted = {
};
export type WeekdayFridayTainted = {
};
export type WeekdaySaturdayTainted = {
};
export type WeekdaySundayTainted = {
};
export type WeekdayErrors = ({
    _value: "Monday";
} & WeekdayMondayErrors) | ({
    _value: "Tuesday";
} & WeekdayTuesdayErrors) | ({
    _value: "Wednesday";
} & WeekdayWednesdayErrors) | ({
    _value: "Thursday";
} & WeekdayThursdayErrors) | ({
    _value: "Friday";
} & WeekdayFridayErrors) | ({
    _value: "Saturday";
} & WeekdaySaturdayErrors) | ({
    _value: "Sunday";
} & WeekdaySundayErrors);
export type WeekdayTainted = ({
    _value: "Monday";
} & WeekdayMondayTainted) | ({
    _value: "Tuesday";
} & WeekdayTuesdayTainted) | ({
    _value: "Wednesday";
} & WeekdayWednesdayTainted) | ({
    _value: "Thursday";
} & WeekdayThursdayTainted) | ({
    _value: "Friday";
} & WeekdayFridayTainted) | ({
    _value: "Saturday";
} & WeekdaySaturdayTainted) | ({
    _value: "Sunday";
} & WeekdaySundayTainted);
export interface WeekdayMondayFieldControllers {
}
export interface WeekdayTuesdayFieldControllers {
}
export interface WeekdayWednesdayFieldControllers {
}
export interface WeekdayThursdayFieldControllers {
}
export interface WeekdayFridayFieldControllers {
}
export interface WeekdaySaturdayFieldControllers {
}
export interface WeekdaySundayFieldControllers {
}
export interface WeekdayGigaform {
    readonly currentVariant: "Monday" | "Tuesday" | "Wednesday" | "Thursday" | "Friday" | "Saturday" | "Sunday";
    readonly data: Weekday;
    readonly errors: WeekdayErrors;
    readonly tainted: WeekdayTainted;
    readonly variants: WeekdayVariantFields;
    switchVariant(variant: "Monday" | "Tuesday" | "Wednesday" | "Thursday" | "Friday" | "Saturday" | "Sunday"): void;
    validate(): Exit<Weekday, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<Weekday>): void;
}
export interface WeekdayVariantFields {
    readonly Monday: {
        readonly fields: WeekdayMondayFieldControllers;
    };
    readonly Tuesday: {
        readonly fields: WeekdayTuesdayFieldControllers;
    };
    readonly Wednesday: {
        readonly fields: WeekdayWednesdayFieldControllers;
    };
    readonly Thursday: {
        readonly fields: WeekdayThursdayFieldControllers;
    };
    readonly Friday: {
        readonly fields: WeekdayFridayFieldControllers;
    };
    readonly Saturday: {
        readonly fields: WeekdaySaturdayFieldControllers;
    };
    readonly Sunday: {
        readonly fields: WeekdaySundayFieldControllers;
    };
}
function weekdayGetDefaultForVariant(variant: string): Weekday {
    if (variant === "Monday") {
        return "Monday" as Weekday;
    }
    if (variant === "Tuesday") {
        return "Tuesday" as Weekday;
    }
    if (variant === "Wednesday") {
        return "Wednesday" as Weekday;
    }
    if (variant === "Thursday") {
        return "Thursday" as Weekday;
    }
    if (variant === "Friday") {
        return "Friday" as Weekday;
    }
    if (variant === "Saturday") {
        return "Saturday" as Weekday;
    }
    if (variant === "Sunday") {
        return "Sunday" as Weekday;
    }
    return "Monday" as Weekday;
}
export function weekdayCreateForm(initial: Weekday): WeekdayGigaform {
    const initialVariant: "Monday" | "Tuesday" | "Wednesday" | "Thursday" | "Friday" | "Saturday" | "Sunday" = (initial as "Monday" | "Tuesday" | "Wednesday" | "Thursday" | "Friday" | "Saturday" | "Sunday") ?? "Monday";
    let currentVariant = $state<$MfPh5>(initialVariant);
    let data = $state<$MfPh6>(initial ?? "weekdayGetDefaultForVariant"(initialVariant));
    let errors = $state<$MfPh8>({} as WeekdayErrors);
    let tainted = $state<$MfPh10>({} as WeekdayTainted);
    const variants = {} as WeekdayVariantFields;
    variants[__expr__] = {
        fields: {} as WeekdayMondayFieldControllers
    };
    variants[__expr__] = {
        fields: {} as WeekdayTuesdayFieldControllers
    };
    variants[__expr__] = {
        fields: {} as WeekdayWednesdayFieldControllers
    };
    variants[__expr__] = {
        fields: {} as WeekdayThursdayFieldControllers
    };
    variants[__expr__] = {
        fields: {} as WeekdayFridayFieldControllers
    };
    variants[__expr__] = {
        fields: {} as WeekdaySaturdayFieldControllers
    };
    variants[__expr__] = {
        fields: {} as WeekdaySundayFieldControllers
    };
    function switchVariant(variant: "Monday" | "Tuesday" | "Wednesday" | "Thursday" | "Friday" | "Saturday" | "Sunday"): void {
        currentVariant = variant;
        data = "weekdayGetDefaultForVariant"(variant);
        errors = {} as WeekdayErrors;
        tainted = {} as WeekdayTainted;
    }
    function validate(): Exit<Weekday, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(weekdayDeserialize(data));
    }
    function reset(overrides: Partial<Weekday>): void {
        data = overrides ? overrides as typeof data : weekdayGetDefaultForVariant(currentVariant);
        errors = {} as WeekdayErrors;
        tainted = {} as WeekdayTainted;
    }
    return {
        get currentVariant () {
            return currentVariant;
        },
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        variants,
        switchVariant,
        validate,
        reset
    };
}
export function weekdayFromFormData(formData: FormData): Exit<Weekday, Array<{
    field: string;
    message: string;
}>> {
    const discriminant = formData.get(`${"_value"}`) as "Monday" | "Tuesday" | "Wednesday" | "Thursday" | "Friday" | "Saturday" | "Sunday" | null;
    if (!discriminant) {
        return toExit({
            success: false,
            errors: [
                {
                    field: `${"_value"}`,
                    message: "Missing discriminant field"
                }
            ]
        });
    }
    const obj: Record<string, unknown> = {};
    obj._value = discriminant;
    return toExit(weekdayDeserialize(obj));
}

export const Weekday = {
  serialize: weekdaySerialize,
  serializeWithContext: weekdaySerializeWithContext,
  deserialize: weekdayDeserialize,
  deserializeWithContext: weekdayDeserializeWithContext,
  is: weekdayIs,
  createForm: weekdayCreateForm,
  fromFormData: weekdayFromFormData
} as const;


export type Status = /** @default */ 'Scheduled' | 'OnDeck' | 'Waiting';

export function statusDefaultValue#0#0(): Status {
    return 'Scheduled';
}

export function statusSerialize(value: Status): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(statusSerializeWithContext(value, ctx));
}
export function statusSerializeWithContext(value: Status, ctx: __mf_SerializeContext): unknown {
    if (typeof (value as any)?.serializeWithContext === "function") {
        return (value as any).serializeWithContext(ctx);
    }
    return value;
}

export function statusDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: Status } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = statusDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "Status.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function statusDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Status | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref) as Status | __mf_PendingRef;
    }
    const allowedValues = [
        "'Scheduled', 'OnDeck', 'Waiting'"
    ] as const;
    if (!allowedValues.includes(value)) {
        throw new __mf_DeserializeError([
            {
                field: "_root",
                message: `Invalid value for ${"Status"}: expected one of ` + allowedValues.map((v)=>JSON.stringify(v)).join(", ") + ", got " + JSON.stringify(value)
            }
        ]);
    }
    return value as Status;
}
export function statusIs(value: unknown): value is Status {
    const allowedValues = [
        "'Scheduled', 'OnDeck', 'Waiting'"
    ] as const;
    return allowedValues.includes(value as any);
}

export type StatusScheduledErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type StatusOnDeckErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type StatusWaitingErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type StatusScheduledTainted = {
};
export type StatusOnDeckTainted = {
};
export type StatusWaitingTainted = {
};
export type StatusErrors = ({
    _value: "Scheduled";
} & StatusScheduledErrors) | ({
    _value: "OnDeck";
} & StatusOnDeckErrors) | ({
    _value: "Waiting";
} & StatusWaitingErrors);
export type StatusTainted = ({
    _value: "Scheduled";
} & StatusScheduledTainted) | ({
    _value: "OnDeck";
} & StatusOnDeckTainted) | ({
    _value: "Waiting";
} & StatusWaitingTainted);
export interface StatusScheduledFieldControllers {
}
export interface StatusOnDeckFieldControllers {
}
export interface StatusWaitingFieldControllers {
}
export interface StatusGigaform {
    readonly currentVariant: "Scheduled" | "OnDeck" | "Waiting";
    readonly data: Status;
    readonly errors: StatusErrors;
    readonly tainted: StatusTainted;
    readonly variants: StatusVariantFields;
    switchVariant(variant: "Scheduled" | "OnDeck" | "Waiting"): void;
    validate(): Exit<Status, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<Status>): void;
}
export interface StatusVariantFields {
    readonly Scheduled: {
        readonly fields: StatusScheduledFieldControllers;
    };
    readonly OnDeck: {
        readonly fields: StatusOnDeckFieldControllers;
    };
    readonly Waiting: {
        readonly fields: StatusWaitingFieldControllers;
    };
}
function statusGetDefaultForVariant(variant: string): Status {
    if (variant === "Scheduled") {
        return "Scheduled" as Status;
    }
    if (variant === "OnDeck") {
        return "OnDeck" as Status;
    }
    if (variant === "Waiting") {
        return "Waiting" as Status;
    }
    return "Scheduled" as Status;
}
export function statusCreateForm(initial: Status): StatusGigaform {
    const initialVariant: "Scheduled" | "OnDeck" | "Waiting" = (initial as "Scheduled" | "OnDeck" | "Waiting") ?? "Scheduled";
    let currentVariant = $state<$MfPh5>(initialVariant);
    let data = $state<$MfPh6>(initial ?? "statusGetDefaultForVariant"(initialVariant));
    let errors = $state<$MfPh8>({} as StatusErrors);
    let tainted = $state<$MfPh10>({} as StatusTainted);
    const variants = {} as StatusVariantFields;
    variants[__expr__] = {
        fields: {} as StatusScheduledFieldControllers
    };
    variants[__expr__] = {
        fields: {} as StatusOnDeckFieldControllers
    };
    variants[__expr__] = {
        fields: {} as StatusWaitingFieldControllers
    };
    function switchVariant(variant: "Scheduled" | "OnDeck" | "Waiting"): void {
        currentVariant = variant;
        data = "statusGetDefaultForVariant"(variant);
        errors = {} as StatusErrors;
        tainted = {} as StatusTainted;
    }
    function validate(): Exit<Status, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(statusDeserialize(data));
    }
    function reset(overrides: Partial<Status>): void {
        data = overrides ? overrides as typeof data : statusGetDefaultForVariant(currentVariant);
        errors = {} as StatusErrors;
        tainted = {} as StatusTainted;
    }
    return {
        get currentVariant () {
            return currentVariant;
        },
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        variants,
        switchVariant,
        validate,
        reset
    };
}
export function statusFromFormData(formData: FormData): Exit<Status, Array<{
    field: string;
    message: string;
}>> {
    const discriminant = formData.get(`${"_value"}`) as "Scheduled" | "OnDeck" | "Waiting" | null;
    if (!discriminant) {
        return toExit({
            success: false,
            errors: [
                {
                    field: `${"_value"}`,
                    message: "Missing discriminant field"
                }
            ]
        });
    }
    const obj: Record<string, unknown> = {};
    obj._value = discriminant;
    return toExit(statusDeserialize(obj));
}

export const Status = {
  serialize: statusSerialize,
  serializeWithContext: statusSerializeWithContext,
  deserialize: statusDeserialize,
  deserializeWithContext: statusDeserializeWithContext,
  is: statusIs,
  createForm: statusCreateForm,
  fromFormData: statusFromFormData
} as const;


export type NextStep = /** @default */ 'InitialContact' | 'Qualified' | 'Estimate' | 'Negotiation';

export function nextStepDefaultValue#0#0(): NextStep {
    return 'InitialContact';
}

export function nextStepSerialize(value: NextStep): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(nextStepSerializeWithContext(value, ctx));
}
export function nextStepSerializeWithContext(value: NextStep, ctx: __mf_SerializeContext): unknown {
    if (typeof (value as any)?.serializeWithContext === "function") {
        return (value as any).serializeWithContext(ctx);
    }
    return value;
}

export function nextStepDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: NextStep } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = nextStepDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "NextStep.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function nextStepDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): NextStep | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref) as NextStep | __mf_PendingRef;
    }
    const allowedValues = [
        "'InitialContact', 'Qualified', 'Estimate', 'Negotiation'"
    ] as const;
    if (!allowedValues.includes(value)) {
        throw new __mf_DeserializeError([
            {
                field: "_root",
                message: `Invalid value for ${"NextStep"}: expected one of ` + allowedValues.map((v)=>JSON.stringify(v)).join(", ") + ", got " + JSON.stringify(value)
            }
        ]);
    }
    return value as NextStep;
}
export function nextStepIs(value: unknown): value is NextStep {
    const allowedValues = [
        "'InitialContact', 'Qualified', 'Estimate', 'Negotiation'"
    ] as const;
    return allowedValues.includes(value as any);
}

export type NextStepInitialContactErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type NextStepQualifiedErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type NextStepEstimateErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type NextStepNegotiationErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type NextStepInitialContactTainted = {
};
export type NextStepQualifiedTainted = {
};
export type NextStepEstimateTainted = {
};
export type NextStepNegotiationTainted = {
};
export type NextStepErrors = ({
    _value: "InitialContact";
} & NextStepInitialContactErrors) | ({
    _value: "Qualified";
} & NextStepQualifiedErrors) | ({
    _value: "Estimate";
} & NextStepEstimateErrors) | ({
    _value: "Negotiation";
} & NextStepNegotiationErrors);
export type NextStepTainted = ({
    _value: "InitialContact";
} & NextStepInitialContactTainted) | ({
    _value: "Qualified";
} & NextStepQualifiedTainted) | ({
    _value: "Estimate";
} & NextStepEstimateTainted) | ({
    _value: "Negotiation";
} & NextStepNegotiationTainted);
export interface NextStepInitialContactFieldControllers {
}
export interface NextStepQualifiedFieldControllers {
}
export interface NextStepEstimateFieldControllers {
}
export interface NextStepNegotiationFieldControllers {
}
export interface NextStepGigaform {
    readonly currentVariant: "InitialContact" | "Qualified" | "Estimate" | "Negotiation";
    readonly data: NextStep;
    readonly errors: NextStepErrors;
    readonly tainted: NextStepTainted;
    readonly variants: NextStepVariantFields;
    switchVariant(variant: "InitialContact" | "Qualified" | "Estimate" | "Negotiation"): void;
    validate(): Exit<NextStep, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<NextStep>): void;
}
export interface NextStepVariantFields {
    readonly InitialContact: {
        readonly fields: NextStepInitialContactFieldControllers;
    };
    readonly Qualified: {
        readonly fields: NextStepQualifiedFieldControllers;
    };
    readonly Estimate: {
        readonly fields: NextStepEstimateFieldControllers;
    };
    readonly Negotiation: {
        readonly fields: NextStepNegotiationFieldControllers;
    };
}
function nextStepGetDefaultForVariant(variant: string): NextStep {
    if (variant === "InitialContact") {
        return "InitialContact" as NextStep;
    }
    if (variant === "Qualified") {
        return "Qualified" as NextStep;
    }
    if (variant === "Estimate") {
        return "Estimate" as NextStep;
    }
    if (variant === "Negotiation") {
        return "Negotiation" as NextStep;
    }
    return "InitialContact" as NextStep;
}
export function nextStepCreateForm(initial: NextStep): NextStepGigaform {
    const initialVariant: "InitialContact" | "Qualified" | "Estimate" | "Negotiation" = (initial as "InitialContact" | "Qualified" | "Estimate" | "Negotiation") ?? "InitialContact";
    let currentVariant = $state<$MfPh5>(initialVariant);
    let data = $state<$MfPh6>(initial ?? "nextStepGetDefaultForVariant"(initialVariant));
    let errors = $state<$MfPh8>({} as NextStepErrors);
    let tainted = $state<$MfPh10>({} as NextStepTainted);
    const variants = {} as NextStepVariantFields;
    variants[__expr__] = {
        fields: {} as NextStepInitialContactFieldControllers
    };
    variants[__expr__] = {
        fields: {} as NextStepQualifiedFieldControllers
    };
    variants[__expr__] = {
        fields: {} as NextStepEstimateFieldControllers
    };
    variants[__expr__] = {
        fields: {} as NextStepNegotiationFieldControllers
    };
    function switchVariant(variant: "InitialContact" | "Qualified" | "Estimate" | "Negotiation"): void {
        currentVariant = variant;
        data = "nextStepGetDefaultForVariant"(variant);
        errors = {} as NextStepErrors;
        tainted = {} as NextStepTainted;
    }
    function validate(): Exit<NextStep, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(nextStepDeserialize(data));
    }
    function reset(overrides: Partial<NextStep>): void {
        data = overrides ? overrides as typeof data : nextStepGetDefaultForVariant(currentVariant);
        errors = {} as NextStepErrors;
        tainted = {} as NextStepTainted;
    }
    return {
        get currentVariant () {
            return currentVariant;
        },
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        variants,
        switchVariant,
        validate,
        reset
    };
}
export function nextStepFromFormData(formData: FormData): Exit<NextStep, Array<{
    field: string;
    message: string;
}>> {
    const discriminant = formData.get(`${"_value"}`) as "InitialContact" | "Qualified" | "Estimate" | "Negotiation" | null;
    if (!discriminant) {
        return toExit({
            success: false,
            errors: [
                {
                    field: `${"_value"}`,
                    message: "Missing discriminant field"
                }
            ]
        });
    }
    const obj: Record<string, unknown> = {};
    obj._value = discriminant;
    return toExit(nextStepDeserialize(obj));
}

export const NextStep = {
  serialize: nextStepSerialize,
  serializeWithContext: nextStepSerializeWithContext,
  deserialize: nextStepDeserialize,
  deserializeWithContext: nextStepDeserializeWithContext,
  is: nextStepIs,
  createForm: nextStepCreateForm,
  fromFormData: nextStepFromFormData
} as const;


export type LeadStage =
    | /** @default */ 'Open'
    | 'InitialContact'
    | 'Qualified'
    | 'Estimate'
    | 'Negotiation';

export function leadStageDefaultValue#0#0(): LeadStage {
    return 'Open';
}

export function leadStageSerialize(value: LeadStage): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(leadStageSerializeWithContext(value, ctx));
}
export function leadStageSerializeWithContext(value: LeadStage, ctx: __mf_SerializeContext): unknown {
    if (typeof (value as any)?.serializeWithContext === "function") {
        return (value as any).serializeWithContext(ctx);
    }
    return value;
}

export function leadStageDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: LeadStage } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = leadStageDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "LeadStage.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function leadStageDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): LeadStage | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref) as LeadStage | __mf_PendingRef;
    }
    const allowedValues = [
        "'Open', 'InitialContact', 'Qualified', 'Estimate', 'Negotiation'"
    ] as const;
    if (!allowedValues.includes(value)) {
        throw new __mf_DeserializeError([
            {
                field: "_root",
                message: `Invalid value for ${"LeadStage"}: expected one of ` + allowedValues.map((v)=>JSON.stringify(v)).join(", ") + ", got " + JSON.stringify(value)
            }
        ]);
    }
    return value as LeadStage;
}
export function leadStageIs(value: unknown): value is LeadStage {
    const allowedValues = [
        "'Open', 'InitialContact', 'Qualified', 'Estimate', 'Negotiation'"
    ] as const;
    return allowedValues.includes(value as any);
}

export type LeadStageOpenErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type LeadStageInitialContactErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type LeadStageQualifiedErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type LeadStageEstimateErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type LeadStageNegotiationErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type LeadStageOpenTainted = {
};
export type LeadStageInitialContactTainted = {
};
export type LeadStageQualifiedTainted = {
};
export type LeadStageEstimateTainted = {
};
export type LeadStageNegotiationTainted = {
};
export type LeadStageErrors = ({
    _value: "Open";
} & LeadStageOpenErrors) | ({
    _value: "InitialContact";
} & LeadStageInitialContactErrors) | ({
    _value: "Qualified";
} & LeadStageQualifiedErrors) | ({
    _value: "Estimate";
} & LeadStageEstimateErrors) | ({
    _value: "Negotiation";
} & LeadStageNegotiationErrors);
export type LeadStageTainted = ({
    _value: "Open";
} & LeadStageOpenTainted) | ({
    _value: "InitialContact";
} & LeadStageInitialContactTainted) | ({
    _value: "Qualified";
} & LeadStageQualifiedTainted) | ({
    _value: "Estimate";
} & LeadStageEstimateTainted) | ({
    _value: "Negotiation";
} & LeadStageNegotiationTainted);
export interface LeadStageOpenFieldControllers {
}
export interface LeadStageInitialContactFieldControllers {
}
export interface LeadStageQualifiedFieldControllers {
}
export interface LeadStageEstimateFieldControllers {
}
export interface LeadStageNegotiationFieldControllers {
}
export interface LeadStageGigaform {
    readonly currentVariant: "Open" | "InitialContact" | "Qualified" | "Estimate" | "Negotiation";
    readonly data: LeadStage;
    readonly errors: LeadStageErrors;
    readonly tainted: LeadStageTainted;
    readonly variants: LeadStageVariantFields;
    switchVariant(variant: "Open" | "InitialContact" | "Qualified" | "Estimate" | "Negotiation"): void;
    validate(): Exit<LeadStage, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<LeadStage>): void;
}
export interface LeadStageVariantFields {
    readonly Open: {
        readonly fields: LeadStageOpenFieldControllers;
    };
    readonly InitialContact: {
        readonly fields: LeadStageInitialContactFieldControllers;
    };
    readonly Qualified: {
        readonly fields: LeadStageQualifiedFieldControllers;
    };
    readonly Estimate: {
        readonly fields: LeadStageEstimateFieldControllers;
    };
    readonly Negotiation: {
        readonly fields: LeadStageNegotiationFieldControllers;
    };
}
function leadStageGetDefaultForVariant(variant: string): LeadStage {
    if (variant === "Open") {
        return "Open" as LeadStage;
    }
    if (variant === "InitialContact") {
        return "InitialContact" as LeadStage;
    }
    if (variant === "Qualified") {
        return "Qualified" as LeadStage;
    }
    if (variant === "Estimate") {
        return "Estimate" as LeadStage;
    }
    if (variant === "Negotiation") {
        return "Negotiation" as LeadStage;
    }
    return "Open" as LeadStage;
}
export function leadStageCreateForm(initial: LeadStage): LeadStageGigaform {
    const initialVariant: "Open" | "InitialContact" | "Qualified" | "Estimate" | "Negotiation" = (initial as "Open" | "InitialContact" | "Qualified" | "Estimate" | "Negotiation") ?? "Open";
    let currentVariant = $state<$MfPh5>(initialVariant);
    let data = $state<$MfPh6>(initial ?? "leadStageGetDefaultForVariant"(initialVariant));
    let errors = $state<$MfPh8>({} as LeadStageErrors);
    let tainted = $state<$MfPh10>({} as LeadStageTainted);
    const variants = {} as LeadStageVariantFields;
    variants[__expr__] = {
        fields: {} as LeadStageOpenFieldControllers
    };
    variants[__expr__] = {
        fields: {} as LeadStageInitialContactFieldControllers
    };
    variants[__expr__] = {
        fields: {} as LeadStageQualifiedFieldControllers
    };
    variants[__expr__] = {
        fields: {} as LeadStageEstimateFieldControllers
    };
    variants[__expr__] = {
        fields: {} as LeadStageNegotiationFieldControllers
    };
    function switchVariant(variant: "Open" | "InitialContact" | "Qualified" | "Estimate" | "Negotiation"): void {
        currentVariant = variant;
        data = "leadStageGetDefaultForVariant"(variant);
        errors = {} as LeadStageErrors;
        tainted = {} as LeadStageTainted;
    }
    function validate(): Exit<LeadStage, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(leadStageDeserialize(data));
    }
    function reset(overrides: Partial<LeadStage>): void {
        data = overrides ? overrides as typeof data : leadStageGetDefaultForVariant(currentVariant);
        errors = {} as LeadStageErrors;
        tainted = {} as LeadStageTainted;
    }
    return {
        get currentVariant () {
            return currentVariant;
        },
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        variants,
        switchVariant,
        validate,
        reset
    };
}
export function leadStageFromFormData(formData: FormData): Exit<LeadStage, Array<{
    field: string;
    message: string;
}>> {
    const discriminant = formData.get(`${"_value"}`) as "Open" | "InitialContact" | "Qualified" | "Estimate" | "Negotiation" | null;
    if (!discriminant) {
        return toExit({
            success: false,
            errors: [
                {
                    field: `${"_value"}`,
                    message: "Missing discriminant field"
                }
            ]
        });
    }
    const obj: Record<string, unknown> = {};
    obj._value = discriminant;
    return toExit(leadStageDeserialize(obj));
}

export const LeadStage = {
  serialize: leadStageSerialize,
  serializeWithContext: leadStageSerializeWithContext,
  deserialize: leadStageDeserialize,
  deserializeWithContext: leadStageDeserializeWithContext,
  is: leadStageIs,
  createForm: leadStageCreateForm,
  fromFormData: leadStageFromFormData
} as const;


export type AccountName = /** @default */ CompanyName | PersonName;

export function accountNameDefaultValue#0#0(): AccountName {
    return companyNameDefaultValue();
}

export function accountNameSerialize(value: AccountName): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(accountNameSerializeWithContext(value, ctx));
}
export function accountNameSerializeWithContext(value: AccountName, ctx: __mf_SerializeContext): unknown {
    if (typeof (value as any)?.serializeWithContext === "function") {
        return (value as any).serializeWithContext(ctx);
    }
    return value;
}

export function accountNameDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: AccountName } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = accountNameDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "AccountName.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function accountNameDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): AccountName | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref) as AccountName | __mf_PendingRef;
    }
    if (typeof value === "object" && value !== null) {
        const __typeName = (value as any).__type;
        if (typeof __typeName === "string") {}
        if (__typeName === "CompanyName") {
            return companyNameDeserializeWithContext(value, ctx) as AccountName;
        }
        if (__typeName === "PersonName") {
            return personNameDeserializeWithContext(value, ctx) as AccountName;
        }
    }
    throw new __mf_DeserializeError([
        {
            field: "_root",
            message: `${"AccountName"}.deserializeWithContext: value does not match any union member`
        }
    ]);
}
export function accountNameIs(value: unknown): value is AccountName {
    if (typeof value === "object" && value !== null) {
        const __typeName = (value as any).__type;
        if ('__typeName === "CompanyName" || __typeName === "PersonName"') return true;
    }
    return false;
}
     }

export type AccountNameCompanyNameErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type AccountNamePersonNameErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type AccountNameCompanyNameTainted = {
};
export type AccountNamePersonNameTainted = {
};
export type AccountNameErrors = ({
    _type: "CompanyName";
} & AccountNameCompanyNameErrors) | ({
    _type: "PersonName";
} & AccountNamePersonNameErrors);
export type AccountNameTainted = ({
    _type: "CompanyName";
} & AccountNameCompanyNameTainted) | ({
    _type: "PersonName";
} & AccountNamePersonNameTainted);
export interface AccountNameCompanyNameFieldControllers {
}
export interface AccountNamePersonNameFieldControllers {
}
export interface AccountNameGigaform {
    readonly currentVariant: "CompanyName" | "PersonName";
    readonly data: AccountName;
    readonly errors: AccountNameErrors;
    readonly tainted: AccountNameTainted;
    readonly variants: AccountNameVariantFields;
    switchVariant(variant: "CompanyName" | "PersonName"): void;
    validate(): Exit<AccountName, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<AccountName>): void;
}
export interface AccountNameVariantFields {
    readonly CompanyName: {
        readonly fields: AccountNameCompanyNameFieldControllers;
    };
    readonly PersonName: {
        readonly fields: AccountNamePersonNameFieldControllers;
    };
}
function accountNameGetDefaultForVariant(variant: string): AccountName {
    if (variant === "CompanyName") {
        return companyNameDefaultValue() as AccountName;
    }
    if (variant === "PersonName") {
        return personNameDefaultValue() as AccountName;
    }
    return companyNameDefaultValue() as AccountName;
}
export function accountNameCreateForm(initial: AccountName): AccountNameGigaform {
    const initialVariant: "CompanyName" | "PersonName" = "CompanyName";
    let currentVariant = $state<$MfPh5>(initialVariant);
    let data = $state<$MfPh6>(initial ?? "accountNameGetDefaultForVariant"(initialVariant));
    let errors = $state<$MfPh8>({} as AccountNameErrors);
    let tainted = $state<$MfPh10>({} as AccountNameTainted);
    const variants = {} as AccountNameVariantFields;
    variants[__expr__] = {
        fields: {} as AccountNameCompanyNameFieldControllers
    };
    variants[__expr__] = {
        fields: {} as AccountNamePersonNameFieldControllers
    };
    function switchVariant(variant: "CompanyName" | "PersonName"): void {
        currentVariant = variant;
        data = "accountNameGetDefaultForVariant"(variant);
        errors = {} as AccountNameErrors;
        tainted = {} as AccountNameTainted;
    }
    function validate(): Exit<AccountName, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(accountNameDeserialize(data));
    }
    function reset(overrides: Partial<AccountName>): void {
        data = overrides ? overrides as typeof data : accountNameGetDefaultForVariant(currentVariant);
        errors = {} as AccountNameErrors;
        tainted = {} as AccountNameTainted;
    }
    return {
        get currentVariant () {
            return currentVariant;
        },
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        variants,
        switchVariant,
        validate,
        reset
    };
}
export function accountNameFromFormData(formData: FormData): Exit<AccountName, Array<{
    field: string;
    message: string;
}>> {
    const discriminant = formData.get(`${"_type"}`) as "CompanyName" | "PersonName" | null;
    if (!discriminant) {
        return toExit({
            success: false,
            errors: [
                {
                    field: `${"_type"}`,
                    message: "Missing discriminant field"
                }
            ]
        });
    }
    const obj: Record<string, unknown> = {};
    obj._type = discriminant;
    return toExit(accountNameDeserialize(obj));
}

export const AccountName = {
  serialize: accountNameSerialize,
  serializeWithContext: accountNameSerializeWithContext,
  deserialize: accountNameDeserialize,
  deserializeWithContext: accountNameDeserializeWithContext,
  is: accountNameIs,
  createForm: accountNameCreateForm,
  fromFormData: accountNameFromFormData
} as const;


export type Priority = /** @default */ 'Medium' | 'High' | 'Low';

export function priorityDefaultValue#0#0(): Priority {
    return 'Medium';
}

export function prioritySerialize(value: Priority): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(prioritySerializeWithContext(value, ctx));
}
export function prioritySerializeWithContext(value: Priority, ctx: __mf_SerializeContext): unknown {
    if (typeof (value as any)?.serializeWithContext === "function") {
        return (value as any).serializeWithContext(ctx);
    }
    return value;
}

export function priorityDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: Priority } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = priorityDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "Priority.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function priorityDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Priority | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref) as Priority | __mf_PendingRef;
    }
    const allowedValues = [
        "'Medium', 'High', 'Low'"
    ] as const;
    if (!allowedValues.includes(value)) {
        throw new __mf_DeserializeError([
            {
                field: "_root",
                message: `Invalid value for ${"Priority"}: expected one of ` + allowedValues.map((v)=>JSON.stringify(v)).join(", ") + ", got " + JSON.stringify(value)
            }
        ]);
    }
    return value as Priority;
}
export function priorityIs(value: unknown): value is Priority {
    const allowedValues = [
        "'Medium', 'High', 'Low'"
    ] as const;
    return allowedValues.includes(value as any);
}

export type PriorityMediumErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type PriorityHighErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type PriorityLowErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type PriorityMediumTainted = {
};
export type PriorityHighTainted = {
};
export type PriorityLowTainted = {
};
export type PriorityErrors = ({
    _value: "Medium";
} & PriorityMediumErrors) | ({
    _value: "High";
} & PriorityHighErrors) | ({
    _value: "Low";
} & PriorityLowErrors);
export type PriorityTainted = ({
    _value: "Medium";
} & PriorityMediumTainted) | ({
    _value: "High";
} & PriorityHighTainted) | ({
    _value: "Low";
} & PriorityLowTainted);
export interface PriorityMediumFieldControllers {
}
export interface PriorityHighFieldControllers {
}
export interface PriorityLowFieldControllers {
}
export interface PriorityGigaform {
    readonly currentVariant: "Medium" | "High" | "Low";
    readonly data: Priority;
    readonly errors: PriorityErrors;
    readonly tainted: PriorityTainted;
    readonly variants: PriorityVariantFields;
    switchVariant(variant: "Medium" | "High" | "Low"): void;
    validate(): Exit<Priority, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<Priority>): void;
}
export interface PriorityVariantFields {
    readonly Medium: {
        readonly fields: PriorityMediumFieldControllers;
    };
    readonly High: {
        readonly fields: PriorityHighFieldControllers;
    };
    readonly Low: {
        readonly fields: PriorityLowFieldControllers;
    };
}
function priorityGetDefaultForVariant(variant: string): Priority {
    if (variant === "Medium") {
        return "Medium" as Priority;
    }
    if (variant === "High") {
        return "High" as Priority;
    }
    if (variant === "Low") {
        return "Low" as Priority;
    }
    return "Medium" as Priority;
}
export function priorityCreateForm(initial: Priority): PriorityGigaform {
    const initialVariant: "Medium" | "High" | "Low" = (initial as "Medium" | "High" | "Low") ?? "Medium";
    let currentVariant = $state<$MfPh5>(initialVariant);
    let data = $state<$MfPh6>(initial ?? "priorityGetDefaultForVariant"(initialVariant));
    let errors = $state<$MfPh8>({} as PriorityErrors);
    let tainted = $state<$MfPh10>({} as PriorityTainted);
    const variants = {} as PriorityVariantFields;
    variants[__expr__] = {
        fields: {} as PriorityMediumFieldControllers
    };
    variants[__expr__] = {
        fields: {} as PriorityHighFieldControllers
    };
    variants[__expr__] = {
        fields: {} as PriorityLowFieldControllers
    };
    function switchVariant(variant: "Medium" | "High" | "Low"): void {
        currentVariant = variant;
        data = "priorityGetDefaultForVariant"(variant);
        errors = {} as PriorityErrors;
        tainted = {} as PriorityTainted;
    }
    function validate(): Exit<Priority, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(priorityDeserialize(data));
    }
    function reset(overrides: Partial<Priority>): void {
        data = overrides ? overrides as typeof data : priorityGetDefaultForVariant(currentVariant);
        errors = {} as PriorityErrors;
        tainted = {} as PriorityTainted;
    }
    return {
        get currentVariant () {
            return currentVariant;
        },
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        variants,
        switchVariant,
        validate,
        reset
    };
}
export function priorityFromFormData(formData: FormData): Exit<Priority, Array<{
    field: string;
    message: string;
}>> {
    const discriminant = formData.get(`${"_value"}`) as "Medium" | "High" | "Low" | null;
    if (!discriminant) {
        return toExit({
            success: false,
            errors: [
                {
                    field: `${"_value"}`,
                    message: "Missing discriminant field"
                }
            ]
        });
    }
    const obj: Record<string, unknown> = {};
    obj._value = discriminant;
    return toExit(priorityDeserialize(obj));
}

export const Priority = {
  serialize: prioritySerialize,
  serializeWithContext: prioritySerializeWithContext,
  deserialize: priorityDeserialize,
  deserializeWithContext: priorityDeserializeWithContext,
  is: priorityIs,
  createForm: priorityCreateForm,
  fromFormData: priorityFromFormData
} as const;


export type Applications =
    | /** @default */ 'Sales'
    | 'Accounting'
    | 'Errand'
    | 'HumanResources'
    | 'Logistics'
    | 'Marketing'
    | 'Website';

export function applicationsDefaultValue#0#0(): Applications {
    return 'Sales';
}

export function applicationsSerialize(value: Applications): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(applicationsSerializeWithContext(value, ctx));
}
export function applicationsSerializeWithContext(value: Applications, ctx: __mf_SerializeContext): unknown {
    if (typeof (value as any)?.serializeWithContext === "function") {
        return (value as any).serializeWithContext(ctx);
    }
    return value;
}

export function applicationsDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: Applications } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = applicationsDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "Applications.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function applicationsDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Applications | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref) as Applications | __mf_PendingRef;
    }
    const allowedValues = [
        "'Sales', 'Accounting', 'Errand', 'HumanResources', 'Logistics', 'Marketing', 'Website'"
    ] as const;
    if (!allowedValues.includes(value)) {
        throw new __mf_DeserializeError([
            {
                field: "_root",
                message: `Invalid value for ${"Applications"}: expected one of ` + allowedValues.map((v)=>JSON.stringify(v)).join(", ") + ", got " + JSON.stringify(value)
            }
        ]);
    }
    return value as Applications;
}
export function applicationsIs(value: unknown): value is Applications {
    const allowedValues = [
        "'Sales', 'Accounting', 'Errand', 'HumanResources', 'Logistics', 'Marketing', 'Website'"
    ] as const;
    return allowedValues.includes(value as any);
}

export type ApplicationsSalesErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type ApplicationsAccountingErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type ApplicationsErrandErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type ApplicationsHumanResourcesErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type ApplicationsLogisticsErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type ApplicationsMarketingErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type ApplicationsWebsiteErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type ApplicationsSalesTainted = {
};
export type ApplicationsAccountingTainted = {
};
export type ApplicationsErrandTainted = {
};
export type ApplicationsHumanResourcesTainted = {
};
export type ApplicationsLogisticsTainted = {
};
export type ApplicationsMarketingTainted = {
};
export type ApplicationsWebsiteTainted = {
};
export type ApplicationsErrors = ({
    _value: "Sales";
} & ApplicationsSalesErrors) | ({
    _value: "Accounting";
} & ApplicationsAccountingErrors) | ({
    _value: "Errand";
} & ApplicationsErrandErrors) | ({
    _value: "HumanResources";
} & ApplicationsHumanResourcesErrors) | ({
    _value: "Logistics";
} & ApplicationsLogisticsErrors) | ({
    _value: "Marketing";
} & ApplicationsMarketingErrors) | ({
    _value: "Website";
} & ApplicationsWebsiteErrors);
export type ApplicationsTainted = ({
    _value: "Sales";
} & ApplicationsSalesTainted) | ({
    _value: "Accounting";
} & ApplicationsAccountingTainted) | ({
    _value: "Errand";
} & ApplicationsErrandTainted) | ({
    _value: "HumanResources";
} & ApplicationsHumanResourcesTainted) | ({
    _value: "Logistics";
} & ApplicationsLogisticsTainted) | ({
    _value: "Marketing";
} & ApplicationsMarketingTainted) | ({
    _value: "Website";
} & ApplicationsWebsiteTainted);
export interface ApplicationsSalesFieldControllers {
}
export interface ApplicationsAccountingFieldControllers {
}
export interface ApplicationsErrandFieldControllers {
}
export interface ApplicationsHumanResourcesFieldControllers {
}
export interface ApplicationsLogisticsFieldControllers {
}
export interface ApplicationsMarketingFieldControllers {
}
export interface ApplicationsWebsiteFieldControllers {
}
export interface ApplicationsGigaform {
    readonly currentVariant: "Sales" | "Accounting" | "Errand" | "HumanResources" | "Logistics" | "Marketing" | "Website";
    readonly data: Applications;
    readonly errors: ApplicationsErrors;
    readonly tainted: ApplicationsTainted;
    readonly variants: ApplicationsVariantFields;
    switchVariant(variant: "Sales" | "Accounting" | "Errand" | "HumanResources" | "Logistics" | "Marketing" | "Website"): void;
    validate(): Exit<Applications, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<Applications>): void;
}
export interface ApplicationsVariantFields {
    readonly Sales: {
        readonly fields: ApplicationsSalesFieldControllers;
    };
    readonly Accounting: {
        readonly fields: ApplicationsAccountingFieldControllers;
    };
    readonly Errand: {
        readonly fields: ApplicationsErrandFieldControllers;
    };
    readonly HumanResources: {
        readonly fields: ApplicationsHumanResourcesFieldControllers;
    };
    readonly Logistics: {
        readonly fields: ApplicationsLogisticsFieldControllers;
    };
    readonly Marketing: {
        readonly fields: ApplicationsMarketingFieldControllers;
    };
    readonly Website: {
        readonly fields: ApplicationsWebsiteFieldControllers;
    };
}
function applicationsGetDefaultForVariant(variant: string): Applications {
    if (variant === "Sales") {
        return "Sales" as Applications;
    }
    if (variant === "Accounting") {
        return "Accounting" as Applications;
    }
    if (variant === "Errand") {
        return "Errand" as Applications;
    }
    if (variant === "HumanResources") {
        return "HumanResources" as Applications;
    }
    if (variant === "Logistics") {
        return "Logistics" as Applications;
    }
    if (variant === "Marketing") {
        return "Marketing" as Applications;
    }
    if (variant === "Website") {
        return "Website" as Applications;
    }
    return "Sales" as Applications;
}
export function applicationsCreateForm(initial: Applications): ApplicationsGigaform {
    const initialVariant: "Sales" | "Accounting" | "Errand" | "HumanResources" | "Logistics" | "Marketing" | "Website" = (initial as "Sales" | "Accounting" | "Errand" | "HumanResources" | "Logistics" | "Marketing" | "Website") ?? "Sales";
    let currentVariant = $state<$MfPh5>(initialVariant);
    let data = $state<$MfPh6>(initial ?? "applicationsGetDefaultForVariant"(initialVariant));
    let errors = $state<$MfPh8>({} as ApplicationsErrors);
    let tainted = $state<$MfPh10>({} as ApplicationsTainted);
    const variants = {} as ApplicationsVariantFields;
    variants[__expr__] = {
        fields: {} as ApplicationsSalesFieldControllers
    };
    variants[__expr__] = {
        fields: {} as ApplicationsAccountingFieldControllers
    };
    variants[__expr__] = {
        fields: {} as ApplicationsErrandFieldControllers
    };
    variants[__expr__] = {
        fields: {} as ApplicationsHumanResourcesFieldControllers
    };
    variants[__expr__] = {
        fields: {} as ApplicationsLogisticsFieldControllers
    };
    variants[__expr__] = {
        fields: {} as ApplicationsMarketingFieldControllers
    };
    variants[__expr__] = {
        fields: {} as ApplicationsWebsiteFieldControllers
    };
    function switchVariant(variant: "Sales" | "Accounting" | "Errand" | "HumanResources" | "Logistics" | "Marketing" | "Website"): void {
        currentVariant = variant;
        data = "applicationsGetDefaultForVariant"(variant);
        errors = {} as ApplicationsErrors;
        tainted = {} as ApplicationsTainted;
    }
    function validate(): Exit<Applications, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(applicationsDeserialize(data));
    }
    function reset(overrides: Partial<Applications>): void {
        data = overrides ? overrides as typeof data : applicationsGetDefaultForVariant(currentVariant);
        errors = {} as ApplicationsErrors;
        tainted = {} as ApplicationsTainted;
    }
    return {
        get currentVariant () {
            return currentVariant;
        },
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        variants,
        switchVariant,
        validate,
        reset
    };
}
export function applicationsFromFormData(formData: FormData): Exit<Applications, Array<{
    field: string;
    message: string;
}>> {
    const discriminant = formData.get(`${"_value"}`) as "Sales" | "Accounting" | "Errand" | "HumanResources" | "Logistics" | "Marketing" | "Website" | null;
    if (!discriminant) {
        return toExit({
            success: false,
            errors: [
                {
                    field: `${"_value"}`,
                    message: "Missing discriminant field"
                }
            ]
        });
    }
    const obj: Record<string, unknown> = {};
    obj._value = discriminant;
    return toExit(applicationsDeserialize(obj));
}

export const Applications = {
  serialize: applicationsSerialize,
  serializeWithContext: applicationsSerializeWithContext,
  deserialize: applicationsDeserialize,
  deserializeWithContext: applicationsDeserializeWithContext,
  is: applicationsIs,
  createForm: applicationsCreateForm,
  fromFormData: applicationsFromFormData
} as const;


export type JobTitle =
    | /** @default */ 'Technician'
    | 'SalesRepresentative'
    | 'HumanResources'
    | 'InformationTechnology';

export function jobTitleDefaultValue#0#0(): JobTitle {
    return 'Technician';
}

export function jobTitleSerialize(value: JobTitle): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(jobTitleSerializeWithContext(value, ctx));
}
export function jobTitleSerializeWithContext(value: JobTitle, ctx: __mf_SerializeContext): unknown {
    if (typeof (value as any)?.serializeWithContext === "function") {
        return (value as any).serializeWithContext(ctx);
    }
    return value;
}

export function jobTitleDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: JobTitle } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = jobTitleDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "JobTitle.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function jobTitleDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): JobTitle | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref) as JobTitle | __mf_PendingRef;
    }
    const allowedValues = [
        "'Technician', 'SalesRepresentative', 'HumanResources', 'InformationTechnology'"
    ] as const;
    if (!allowedValues.includes(value)) {
        throw new __mf_DeserializeError([
            {
                field: "_root",
                message: `Invalid value for ${"JobTitle"}: expected one of ` + allowedValues.map((v)=>JSON.stringify(v)).join(", ") + ", got " + JSON.stringify(value)
            }
        ]);
    }
    return value as JobTitle;
}
export function jobTitleIs(value: unknown): value is JobTitle {
    const allowedValues = [
        "'Technician', 'SalesRepresentative', 'HumanResources', 'InformationTechnology'"
    ] as const;
    return allowedValues.includes(value as any);
}

export type JobTitleTechnicianErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type JobTitleSalesRepresentativeErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type JobTitleHumanResourcesErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type JobTitleInformationTechnologyErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type JobTitleTechnicianTainted = {
};
export type JobTitleSalesRepresentativeTainted = {
};
export type JobTitleHumanResourcesTainted = {
};
export type JobTitleInformationTechnologyTainted = {
};
export type JobTitleErrors = ({
    _value: "Technician";
} & JobTitleTechnicianErrors) | ({
    _value: "SalesRepresentative";
} & JobTitleSalesRepresentativeErrors) | ({
    _value: "HumanResources";
} & JobTitleHumanResourcesErrors) | ({
    _value: "InformationTechnology";
} & JobTitleInformationTechnologyErrors);
export type JobTitleTainted = ({
    _value: "Technician";
} & JobTitleTechnicianTainted) | ({
    _value: "SalesRepresentative";
} & JobTitleSalesRepresentativeTainted) | ({
    _value: "HumanResources";
} & JobTitleHumanResourcesTainted) | ({
    _value: "InformationTechnology";
} & JobTitleInformationTechnologyTainted);
export interface JobTitleTechnicianFieldControllers {
}
export interface JobTitleSalesRepresentativeFieldControllers {
}
export interface JobTitleHumanResourcesFieldControllers {
}
export interface JobTitleInformationTechnologyFieldControllers {
}
export interface JobTitleGigaform {
    readonly currentVariant: "Technician" | "SalesRepresentative" | "HumanResources" | "InformationTechnology";
    readonly data: JobTitle;
    readonly errors: JobTitleErrors;
    readonly tainted: JobTitleTainted;
    readonly variants: JobTitleVariantFields;
    switchVariant(variant: "Technician" | "SalesRepresentative" | "HumanResources" | "InformationTechnology"): void;
    validate(): Exit<JobTitle, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<JobTitle>): void;
}
export interface JobTitleVariantFields {
    readonly Technician: {
        readonly fields: JobTitleTechnicianFieldControllers;
    };
    readonly SalesRepresentative: {
        readonly fields: JobTitleSalesRepresentativeFieldControllers;
    };
    readonly HumanResources: {
        readonly fields: JobTitleHumanResourcesFieldControllers;
    };
    readonly InformationTechnology: {
        readonly fields: JobTitleInformationTechnologyFieldControllers;
    };
}
function jobTitleGetDefaultForVariant(variant: string): JobTitle {
    if (variant === "Technician") {
        return "Technician" as JobTitle;
    }
    if (variant === "SalesRepresentative") {
        return "SalesRepresentative" as JobTitle;
    }
    if (variant === "HumanResources") {
        return "HumanResources" as JobTitle;
    }
    if (variant === "InformationTechnology") {
        return "InformationTechnology" as JobTitle;
    }
    return "Technician" as JobTitle;
}
export function jobTitleCreateForm(initial: JobTitle): JobTitleGigaform {
    const initialVariant: "Technician" | "SalesRepresentative" | "HumanResources" | "InformationTechnology" = (initial as "Technician" | "SalesRepresentative" | "HumanResources" | "InformationTechnology") ?? "Technician";
    let currentVariant = $state<$MfPh5>(initialVariant);
    let data = $state<$MfPh6>(initial ?? "jobTitleGetDefaultForVariant"(initialVariant));
    let errors = $state<$MfPh8>({} as JobTitleErrors);
    let tainted = $state<$MfPh10>({} as JobTitleTainted);
    const variants = {} as JobTitleVariantFields;
    variants[__expr__] = {
        fields: {} as JobTitleTechnicianFieldControllers
    };
    variants[__expr__] = {
        fields: {} as JobTitleSalesRepresentativeFieldControllers
    };
    variants[__expr__] = {
        fields: {} as JobTitleHumanResourcesFieldControllers
    };
    variants[__expr__] = {
        fields: {} as JobTitleInformationTechnologyFieldControllers
    };
    function switchVariant(variant: "Technician" | "SalesRepresentative" | "HumanResources" | "InformationTechnology"): void {
        currentVariant = variant;
        data = "jobTitleGetDefaultForVariant"(variant);
        errors = {} as JobTitleErrors;
        tainted = {} as JobTitleTainted;
    }
    function validate(): Exit<JobTitle, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(jobTitleDeserialize(data));
    }
    function reset(overrides: Partial<JobTitle>): void {
        data = overrides ? overrides as typeof data : jobTitleGetDefaultForVariant(currentVariant);
        errors = {} as JobTitleErrors;
        tainted = {} as JobTitleTainted;
    }
    return {
        get currentVariant () {
            return currentVariant;
        },
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        variants,
        switchVariant,
        validate,
        reset
    };
}
export function jobTitleFromFormData(formData: FormData): Exit<JobTitle, Array<{
    field: string;
    message: string;
}>> {
    const discriminant = formData.get(`${"_value"}`) as "Technician" | "SalesRepresentative" | "HumanResources" | "InformationTechnology" | null;
    if (!discriminant) {
        return toExit({
            success: false,
            errors: [
                {
                    field: `${"_value"}`,
                    message: "Missing discriminant field"
                }
            ]
        });
    }
    const obj: Record<string, unknown> = {};
    obj._value = discriminant;
    return toExit(jobTitleDeserialize(obj));
}

export const JobTitle = {
  serialize: jobTitleSerialize,
  serializeWithContext: jobTitleSerializeWithContext,
  deserialize: jobTitleDeserialize,
  deserializeWithContext: jobTitleDeserializeWithContext,
  is: jobTitleIs,
  createForm: jobTitleCreateForm,
  fromFormData: jobTitleFromFormData
} as const;


export type ColorsConfig = Cardinal | Ordinal | Custom | /** @default */ Gradient;

export function colorsConfigDefaultValue#0#0(): ColorsConfig {
    return gradientDefaultValue();
}

export function colorsConfigSerialize(value: ColorsConfig): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(colorsConfigSerializeWithContext(value, ctx));
}
export function colorsConfigSerializeWithContext(value: ColorsConfig, ctx: __mf_SerializeContext): unknown {
    if (typeof (value as any)?.serializeWithContext === "function") {
        return (value as any).serializeWithContext(ctx);
    }
    return value;
}

export function colorsConfigDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: ColorsConfig } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = colorsConfigDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "ColorsConfig.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function colorsConfigDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): ColorsConfig | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref) as ColorsConfig | __mf_PendingRef;
    }
    if (typeof value === "object" && value !== null) {
        const __typeName = (value as any).__type;
        if (typeof __typeName === "string") {}
        if (__typeName === "Cardinal") {
            return cardinalDeserializeWithContext(value, ctx) as ColorsConfig;
        }
        if (__typeName === "Ordinal") {
            return ordinalDeserializeWithContext(value, ctx) as ColorsConfig;
        }
        if (__typeName === "Custom") {
            return customDeserializeWithContext(value, ctx) as ColorsConfig;
        }
        if (__typeName === "Gradient") {
            return gradientDeserializeWithContext(value, ctx) as ColorsConfig;
        }
    }
    throw new __mf_DeserializeError([
        {
            field: "_root",
            message: `${"ColorsConfig"}.deserializeWithContext: value does not match any union member`
        }
    ]);
}
export function colorsConfigIs(value: unknown): value is ColorsConfig {
    if (typeof value === "object" && value !== null) {
        const __typeName = (value as any).__type;
        if ('__typeName === "Cardinal" || __typeName === "Ordinal" || __typeName === "Custom" || __typeName === "Gradient"') return true;
    }
    return false;
}
     }

export type ColorsConfigCardinalErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type ColorsConfigOrdinalErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type ColorsConfigCustomErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type ColorsConfigGradientErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type ColorsConfigCardinalTainted = {
};
export type ColorsConfigOrdinalTainted = {
};
export type ColorsConfigCustomTainted = {
};
export type ColorsConfigGradientTainted = {
};
export type ColorsConfigErrors = ({
    _type: "Cardinal";
} & ColorsConfigCardinalErrors) | ({
    _type: "Ordinal";
} & ColorsConfigOrdinalErrors) | ({
    _type: "Custom";
} & ColorsConfigCustomErrors) | ({
    _type: "Gradient";
} & ColorsConfigGradientErrors);
export type ColorsConfigTainted = ({
    _type: "Cardinal";
} & ColorsConfigCardinalTainted) | ({
    _type: "Ordinal";
} & ColorsConfigOrdinalTainted) | ({
    _type: "Custom";
} & ColorsConfigCustomTainted) | ({
    _type: "Gradient";
} & ColorsConfigGradientTainted);
export interface ColorsConfigCardinalFieldControllers {
}
export interface ColorsConfigOrdinalFieldControllers {
}
export interface ColorsConfigCustomFieldControllers {
}
export interface ColorsConfigGradientFieldControllers {
}
export interface ColorsConfigGigaform {
    readonly currentVariant: "Cardinal" | "Ordinal" | "Custom" | "Gradient";
    readonly data: ColorsConfig;
    readonly errors: ColorsConfigErrors;
    readonly tainted: ColorsConfigTainted;
    readonly variants: ColorsConfigVariantFields;
    switchVariant(variant: "Cardinal" | "Ordinal" | "Custom" | "Gradient"): void;
    validate(): Exit<ColorsConfig, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<ColorsConfig>): void;
}
export interface ColorsConfigVariantFields {
    readonly Cardinal: {
        readonly fields: ColorsConfigCardinalFieldControllers;
    };
    readonly Ordinal: {
        readonly fields: ColorsConfigOrdinalFieldControllers;
    };
    readonly Custom: {
        readonly fields: ColorsConfigCustomFieldControllers;
    };
    readonly Gradient: {
        readonly fields: ColorsConfigGradientFieldControllers;
    };
}
function colorsConfigGetDefaultForVariant(variant: string): ColorsConfig {
    if (variant === "Cardinal") {
        return cardinalDefaultValue() as ColorsConfig;
    }
    if (variant === "Ordinal") {
        return ordinalDefaultValue() as ColorsConfig;
    }
    if (variant === "Custom") {
        return customDefaultValue() as ColorsConfig;
    }
    if (variant === "Gradient") {
        return gradientDefaultValue() as ColorsConfig;
    }
    return cardinalDefaultValue() as ColorsConfig;
}
export function colorsConfigCreateForm(initial: ColorsConfig): ColorsConfigGigaform {
    const initialVariant: "Cardinal" | "Ordinal" | "Custom" | "Gradient" = "Cardinal";
    let currentVariant = $state<$MfPh5>(initialVariant);
    let data = $state<$MfPh6>(initial ?? "colorsConfigGetDefaultForVariant"(initialVariant));
    let errors = $state<$MfPh8>({} as ColorsConfigErrors);
    let tainted = $state<$MfPh10>({} as ColorsConfigTainted);
    const variants = {} as ColorsConfigVariantFields;
    variants[__expr__] = {
        fields: {} as ColorsConfigCardinalFieldControllers
    };
    variants[__expr__] = {
        fields: {} as ColorsConfigOrdinalFieldControllers
    };
    variants[__expr__] = {
        fields: {} as ColorsConfigCustomFieldControllers
    };
    variants[__expr__] = {
        fields: {} as ColorsConfigGradientFieldControllers
    };
    function switchVariant(variant: "Cardinal" | "Ordinal" | "Custom" | "Gradient"): void {
        currentVariant = variant;
        data = "colorsConfigGetDefaultForVariant"(variant);
        errors = {} as ColorsConfigErrors;
        tainted = {} as ColorsConfigTainted;
    }
    function validate(): Exit<ColorsConfig, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(colorsConfigDeserialize(data));
    }
    function reset(overrides: Partial<ColorsConfig>): void {
        data = overrides ? overrides as typeof data : colorsConfigGetDefaultForVariant(currentVariant);
        errors = {} as ColorsConfigErrors;
        tainted = {} as ColorsConfigTainted;
    }
    return {
        get currentVariant () {
            return currentVariant;
        },
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        variants,
        switchVariant,
        validate,
        reset
    };
}
export function colorsConfigFromFormData(formData: FormData): Exit<ColorsConfig, Array<{
    field: string;
    message: string;
}>> {
    const discriminant = formData.get(`${"_type"}`) as "Cardinal" | "Ordinal" | "Custom" | "Gradient" | null;
    if (!discriminant) {
        return toExit({
            success: false,
            errors: [
                {
                    field: `${"_type"}`,
                    message: "Missing discriminant field"
                }
            ]
        });
    }
    const obj: Record<string, unknown> = {};
    obj._type = discriminant;
    return toExit(colorsConfigDeserialize(obj));
}

export const ColorsConfig = {
  serialize: colorsConfigSerialize,
  serializeWithContext: colorsConfigSerializeWithContext,
  deserialize: colorsConfigDeserialize,
  deserializeWithContext: colorsConfigDeserializeWithContext,
  is: colorsConfigIs,
  createForm: colorsConfigCreateForm,
  fromFormData: colorsConfigFromFormData
} as const;


export type WeekOfMonth = /** @default */ 'First' | 'Second' | 'Third' | 'Fourth' | 'Last';

export function weekOfMonthDefaultValue#0#0(): WeekOfMonth {
    return 'First';
}

export function weekOfMonthSerialize(value: WeekOfMonth): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(weekOfMonthSerializeWithContext(value, ctx));
}
export function weekOfMonthSerializeWithContext(value: WeekOfMonth, ctx: __mf_SerializeContext): unknown {
    if (typeof (value as any)?.serializeWithContext === "function") {
        return (value as any).serializeWithContext(ctx);
    }
    return value;
}

export function weekOfMonthDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: WeekOfMonth } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = weekOfMonthDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "WeekOfMonth.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function weekOfMonthDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): WeekOfMonth | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref) as WeekOfMonth | __mf_PendingRef;
    }
    const allowedValues = [
        "'First', 'Second', 'Third', 'Fourth', 'Last'"
    ] as const;
    if (!allowedValues.includes(value)) {
        throw new __mf_DeserializeError([
            {
                field: "_root",
                message: `Invalid value for ${"WeekOfMonth"}: expected one of ` + allowedValues.map((v)=>JSON.stringify(v)).join(", ") + ", got " + JSON.stringify(value)
            }
        ]);
    }
    return value as WeekOfMonth;
}
export function weekOfMonthIs(value: unknown): value is WeekOfMonth {
    const allowedValues = [
        "'First', 'Second', 'Third', 'Fourth', 'Last'"
    ] as const;
    return allowedValues.includes(value as any);
}

export type WeekOfMonthFirstErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type WeekOfMonthSecondErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type WeekOfMonthThirdErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type WeekOfMonthFourthErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type WeekOfMonthLastErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type WeekOfMonthFirstTainted = {
};
export type WeekOfMonthSecondTainted = {
};
export type WeekOfMonthThirdTainted = {
};
export type WeekOfMonthFourthTainted = {
};
export type WeekOfMonthLastTainted = {
};
export type WeekOfMonthErrors = ({
    _value: "First";
} & WeekOfMonthFirstErrors) | ({
    _value: "Second";
} & WeekOfMonthSecondErrors) | ({
    _value: "Third";
} & WeekOfMonthThirdErrors) | ({
    _value: "Fourth";
} & WeekOfMonthFourthErrors) | ({
    _value: "Last";
} & WeekOfMonthLastErrors);
export type WeekOfMonthTainted = ({
    _value: "First";
} & WeekOfMonthFirstTainted) | ({
    _value: "Second";
} & WeekOfMonthSecondTainted) | ({
    _value: "Third";
} & WeekOfMonthThirdTainted) | ({
    _value: "Fourth";
} & WeekOfMonthFourthTainted) | ({
    _value: "Last";
} & WeekOfMonthLastTainted);
export interface WeekOfMonthFirstFieldControllers {
}
export interface WeekOfMonthSecondFieldControllers {
}
export interface WeekOfMonthThirdFieldControllers {
}
export interface WeekOfMonthFourthFieldControllers {
}
export interface WeekOfMonthLastFieldControllers {
}
export interface WeekOfMonthGigaform {
    readonly currentVariant: "First" | "Second" | "Third" | "Fourth" | "Last";
    readonly data: WeekOfMonth;
    readonly errors: WeekOfMonthErrors;
    readonly tainted: WeekOfMonthTainted;
    readonly variants: WeekOfMonthVariantFields;
    switchVariant(variant: "First" | "Second" | "Third" | "Fourth" | "Last"): void;
    validate(): Exit<WeekOfMonth, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<WeekOfMonth>): void;
}
export interface WeekOfMonthVariantFields {
    readonly First: {
        readonly fields: WeekOfMonthFirstFieldControllers;
    };
    readonly Second: {
        readonly fields: WeekOfMonthSecondFieldControllers;
    };
    readonly Third: {
        readonly fields: WeekOfMonthThirdFieldControllers;
    };
    readonly Fourth: {
        readonly fields: WeekOfMonthFourthFieldControllers;
    };
    readonly Last: {
        readonly fields: WeekOfMonthLastFieldControllers;
    };
}
function weekOfMonthGetDefaultForVariant(variant: string): WeekOfMonth {
    if (variant === "First") {
        return "First" as WeekOfMonth;
    }
    if (variant === "Second") {
        return "Second" as WeekOfMonth;
    }
    if (variant === "Third") {
        return "Third" as WeekOfMonth;
    }
    if (variant === "Fourth") {
        return "Fourth" as WeekOfMonth;
    }
    if (variant === "Last") {
        return "Last" as WeekOfMonth;
    }
    return "First" as WeekOfMonth;
}
export function weekOfMonthCreateForm(initial: WeekOfMonth): WeekOfMonthGigaform {
    const initialVariant: "First" | "Second" | "Third" | "Fourth" | "Last" = (initial as "First" | "Second" | "Third" | "Fourth" | "Last") ?? "First";
    let currentVariant = $state<$MfPh5>(initialVariant);
    let data = $state<$MfPh6>(initial ?? "weekOfMonthGetDefaultForVariant"(initialVariant));
    let errors = $state<$MfPh8>({} as WeekOfMonthErrors);
    let tainted = $state<$MfPh10>({} as WeekOfMonthTainted);
    const variants = {} as WeekOfMonthVariantFields;
    variants[__expr__] = {
        fields: {} as WeekOfMonthFirstFieldControllers
    };
    variants[__expr__] = {
        fields: {} as WeekOfMonthSecondFieldControllers
    };
    variants[__expr__] = {
        fields: {} as WeekOfMonthThirdFieldControllers
    };
    variants[__expr__] = {
        fields: {} as WeekOfMonthFourthFieldControllers
    };
    variants[__expr__] = {
        fields: {} as WeekOfMonthLastFieldControllers
    };
    function switchVariant(variant: "First" | "Second" | "Third" | "Fourth" | "Last"): void {
        currentVariant = variant;
        data = "weekOfMonthGetDefaultForVariant"(variant);
        errors = {} as WeekOfMonthErrors;
        tainted = {} as WeekOfMonthTainted;
    }
    function validate(): Exit<WeekOfMonth, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(weekOfMonthDeserialize(data));
    }
    function reset(overrides: Partial<WeekOfMonth>): void {
        data = overrides ? overrides as typeof data : weekOfMonthGetDefaultForVariant(currentVariant);
        errors = {} as WeekOfMonthErrors;
        tainted = {} as WeekOfMonthTainted;
    }
    return {
        get currentVariant () {
            return currentVariant;
        },
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        variants,
        switchVariant,
        validate,
        reset
    };
}
export function weekOfMonthFromFormData(formData: FormData): Exit<WeekOfMonth, Array<{
    field: string;
    message: string;
}>> {
    const discriminant = formData.get(`${"_value"}`) as "First" | "Second" | "Third" | "Fourth" | "Last" | null;
    if (!discriminant) {
        return toExit({
            success: false,
            errors: [
                {
                    field: `${"_value"}`,
                    message: "Missing discriminant field"
                }
            ]
        });
    }
    const obj: Record<string, unknown> = {};
    obj._value = discriminant;
    return toExit(weekOfMonthDeserialize(obj));
}

export const WeekOfMonth = {
  serialize: weekOfMonthSerialize,
  serializeWithContext: weekOfMonthSerializeWithContext,
  deserialize: weekOfMonthDeserialize,
  deserializeWithContext: weekOfMonthDeserializeWithContext,
  is: weekOfMonthIs,
  createForm: weekOfMonthCreateForm,
  fromFormData: weekOfMonthFromFormData
} as const;


export type ActivityType = /** @default */ Created | Edited | Sent | Viewed | Commented | Paid;

export function activityTypeDefaultValue#0#0(): ActivityType {
    return createdDefaultValue();
}

export function activityTypeSerialize(value: ActivityType): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(activityTypeSerializeWithContext(value, ctx));
}
export function activityTypeSerializeWithContext(value: ActivityType, ctx: __mf_SerializeContext): unknown {
    if (typeof (value as any)?.serializeWithContext === "function") {
        return (value as any).serializeWithContext(ctx);
    }
    return value;
}

export function activityTypeDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: ActivityType } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = activityTypeDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "ActivityType.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function activityTypeDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): ActivityType | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref) as ActivityType | __mf_PendingRef;
    }
    if (typeof value === "object" && value !== null) {
        const __typeName = (value as any).__type;
        if (typeof __typeName === "string") {}
        if (__typeName === "Created") {
            return createdDeserializeWithContext(value, ctx) as ActivityType;
        }
        if (__typeName === "Edited") {
            return editedDeserializeWithContext(value, ctx) as ActivityType;
        }
        if (__typeName === "Sent") {
            return sentDeserializeWithContext(value, ctx) as ActivityType;
        }
        if (__typeName === "Viewed") {
            return viewedDeserializeWithContext(value, ctx) as ActivityType;
        }
        if (__typeName === "Commented") {
            return commentedDeserializeWithContext(value, ctx) as ActivityType;
        }
        if (__typeName === "Paid") {
            return paidDeserializeWithContext(value, ctx) as ActivityType;
        }
    }
    throw new __mf_DeserializeError([
        {
            field: "_root",
            message: `${"ActivityType"}.deserializeWithContext: value does not match any union member`
        }
    ]);
}
export function activityTypeIs(value: unknown): value is ActivityType {
    if (typeof value === "object" && value !== null) {
        const __typeName = (value as any).__type;
        if ('__typeName === "Created" || __typeName === "Edited" || __typeName === "Sent" || __typeName === "Viewed" || __typeName === "Commented" || __typeName === "Paid"') return true;
    }
    return false;
}
     }

export type ActivityTypeCreatedErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type ActivityTypeEditedErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type ActivityTypeSentErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type ActivityTypeViewedErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type ActivityTypeCommentedErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type ActivityTypePaidErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type ActivityTypeCreatedTainted = {
};
export type ActivityTypeEditedTainted = {
};
export type ActivityTypeSentTainted = {
};
export type ActivityTypeViewedTainted = {
};
export type ActivityTypeCommentedTainted = {
};
export type ActivityTypePaidTainted = {
};
export type ActivityTypeErrors = ({
    _type: "Created";
} & ActivityTypeCreatedErrors) | ({
    _type: "Edited";
} & ActivityTypeEditedErrors) | ({
    _type: "Sent";
} & ActivityTypeSentErrors) | ({
    _type: "Viewed";
} & ActivityTypeViewedErrors) | ({
    _type: "Commented";
} & ActivityTypeCommentedErrors) | ({
    _type: "Paid";
} & ActivityTypePaidErrors);
export type ActivityTypeTainted = ({
    _type: "Created";
} & ActivityTypeCreatedTainted) | ({
    _type: "Edited";
} & ActivityTypeEditedTainted) | ({
    _type: "Sent";
} & ActivityTypeSentTainted) | ({
    _type: "Viewed";
} & ActivityTypeViewedTainted) | ({
    _type: "Commented";
} & ActivityTypeCommentedTainted) | ({
    _type: "Paid";
} & ActivityTypePaidTainted);
export interface ActivityTypeCreatedFieldControllers {
}
export interface ActivityTypeEditedFieldControllers {
}
export interface ActivityTypeSentFieldControllers {
}
export interface ActivityTypeViewedFieldControllers {
}
export interface ActivityTypeCommentedFieldControllers {
}
export interface ActivityTypePaidFieldControllers {
}
export interface ActivityTypeGigaform {
    readonly currentVariant: "Created" | "Edited" | "Sent" | "Viewed" | "Commented" | "Paid";
    readonly data: ActivityType;
    readonly errors: ActivityTypeErrors;
    readonly tainted: ActivityTypeTainted;
    readonly variants: ActivityTypeVariantFields;
    switchVariant(variant: "Created" | "Edited" | "Sent" | "Viewed" | "Commented" | "Paid"): void;
    validate(): Exit<ActivityType, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<ActivityType>): void;
}
export interface ActivityTypeVariantFields {
    readonly Created: {
        readonly fields: ActivityTypeCreatedFieldControllers;
    };
    readonly Edited: {
        readonly fields: ActivityTypeEditedFieldControllers;
    };
    readonly Sent: {
        readonly fields: ActivityTypeSentFieldControllers;
    };
    readonly Viewed: {
        readonly fields: ActivityTypeViewedFieldControllers;
    };
    readonly Commented: {
        readonly fields: ActivityTypeCommentedFieldControllers;
    };
    readonly Paid: {
        readonly fields: ActivityTypePaidFieldControllers;
    };
}
function activityTypeGetDefaultForVariant(variant: string): ActivityType {
    if (variant === "Created") {
        return createdDefaultValue() as ActivityType;
    }
    if (variant === "Edited") {
        return editedDefaultValue() as ActivityType;
    }
    if (variant === "Sent") {
        return sentDefaultValue() as ActivityType;
    }
    if (variant === "Viewed") {
        return viewedDefaultValue() as ActivityType;
    }
    if (variant === "Commented") {
        return commentedDefaultValue() as ActivityType;
    }
    if (variant === "Paid") {
        return paidDefaultValue() as ActivityType;
    }
    return createdDefaultValue() as ActivityType;
}
export function activityTypeCreateForm(initial: ActivityType): ActivityTypeGigaform {
    const initialVariant: "Created" | "Edited" | "Sent" | "Viewed" | "Commented" | "Paid" = "Created";
    let currentVariant = $state<$MfPh5>(initialVariant);
    let data = $state<$MfPh6>(initial ?? "activityTypeGetDefaultForVariant"(initialVariant));
    let errors = $state<$MfPh8>({} as ActivityTypeErrors);
    let tainted = $state<$MfPh10>({} as ActivityTypeTainted);
    const variants = {} as ActivityTypeVariantFields;
    variants[__expr__] = {
        fields: {} as ActivityTypeCreatedFieldControllers
    };
    variants[__expr__] = {
        fields: {} as ActivityTypeEditedFieldControllers
    };
    variants[__expr__] = {
        fields: {} as ActivityTypeSentFieldControllers
    };
    variants[__expr__] = {
        fields: {} as ActivityTypeViewedFieldControllers
    };
    variants[__expr__] = {
        fields: {} as ActivityTypeCommentedFieldControllers
    };
    variants[__expr__] = {
        fields: {} as ActivityTypePaidFieldControllers
    };
    function switchVariant(variant: "Created" | "Edited" | "Sent" | "Viewed" | "Commented" | "Paid"): void {
        currentVariant = variant;
        data = "activityTypeGetDefaultForVariant"(variant);
        errors = {} as ActivityTypeErrors;
        tainted = {} as ActivityTypeTainted;
    }
    function validate(): Exit<ActivityType, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(activityTypeDeserialize(data));
    }
    function reset(overrides: Partial<ActivityType>): void {
        data = overrides ? overrides as typeof data : activityTypeGetDefaultForVariant(currentVariant);
        errors = {} as ActivityTypeErrors;
        tainted = {} as ActivityTypeTainted;
    }
    return {
        get currentVariant () {
            return currentVariant;
        },
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        variants,
        switchVariant,
        validate,
        reset
    };
}
export function activityTypeFromFormData(formData: FormData): Exit<ActivityType, Array<{
    field: string;
    message: string;
}>> {
    const discriminant = formData.get(`${"_type"}`) as "Created" | "Edited" | "Sent" | "Viewed" | "Commented" | "Paid" | null;
    if (!discriminant) {
        return toExit({
            success: false,
            errors: [
                {
                    field: `${"_type"}`,
                    message: "Missing discriminant field"
                }
            ]
        });
    }
    const obj: Record<string, unknown> = {};
    obj._type = discriminant;
    return toExit(activityTypeDeserialize(obj));
}

export const ActivityType = {
  serialize: activityTypeSerialize,
  serializeWithContext: activityTypeSerializeWithContext,
  deserialize: activityTypeDeserialize,
  deserializeWithContext: activityTypeDeserializeWithContext,
  is: activityTypeIs,
  createForm: activityTypeCreateForm,
  fromFormData: activityTypeFromFormData
} as const;


export type RowHeight = 'ExtraSmall' | 'Small' | /** @default */ 'Medium' | 'Large';

export function rowHeightDefaultValue#0#0(): RowHeight {
    return 'Medium';
}

export function rowHeightSerialize(value: RowHeight): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(rowHeightSerializeWithContext(value, ctx));
}
export function rowHeightSerializeWithContext(value: RowHeight, ctx: __mf_SerializeContext): unknown {
    if (typeof (value as any)?.serializeWithContext === "function") {
        return (value as any).serializeWithContext(ctx);
    }
    return value;
}

export function rowHeightDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: RowHeight } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = rowHeightDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "RowHeight.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function rowHeightDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): RowHeight | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref) as RowHeight | __mf_PendingRef;
    }
    const allowedValues = [
        "'ExtraSmall', 'Small', 'Medium', 'Large'"
    ] as const;
    if (!allowedValues.includes(value)) {
        throw new __mf_DeserializeError([
            {
                field: "_root",
                message: `Invalid value for ${"RowHeight"}: expected one of ` + allowedValues.map((v)=>JSON.stringify(v)).join(", ") + ", got " + JSON.stringify(value)
            }
        ]);
    }
    return value as RowHeight;
}
export function rowHeightIs(value: unknown): value is RowHeight {
    const allowedValues = [
        "'ExtraSmall', 'Small', 'Medium', 'Large'"
    ] as const;
    return allowedValues.includes(value as any);
}

export type RowHeightExtraSmallErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type RowHeightSmallErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type RowHeightMediumErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type RowHeightLargeErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type RowHeightExtraSmallTainted = {
};
export type RowHeightSmallTainted = {
};
export type RowHeightMediumTainted = {
};
export type RowHeightLargeTainted = {
};
export type RowHeightErrors = ({
    _value: "ExtraSmall";
} & RowHeightExtraSmallErrors) | ({
    _value: "Small";
} & RowHeightSmallErrors) | ({
    _value: "Medium";
} & RowHeightMediumErrors) | ({
    _value: "Large";
} & RowHeightLargeErrors);
export type RowHeightTainted = ({
    _value: "ExtraSmall";
} & RowHeightExtraSmallTainted) | ({
    _value: "Small";
} & RowHeightSmallTainted) | ({
    _value: "Medium";
} & RowHeightMediumTainted) | ({
    _value: "Large";
} & RowHeightLargeTainted);
export interface RowHeightExtraSmallFieldControllers {
}
export interface RowHeightSmallFieldControllers {
}
export interface RowHeightMediumFieldControllers {
}
export interface RowHeightLargeFieldControllers {
}
export interface RowHeightGigaform {
    readonly currentVariant: "ExtraSmall" | "Small" | "Medium" | "Large";
    readonly data: RowHeight;
    readonly errors: RowHeightErrors;
    readonly tainted: RowHeightTainted;
    readonly variants: RowHeightVariantFields;
    switchVariant(variant: "ExtraSmall" | "Small" | "Medium" | "Large"): void;
    validate(): Exit<RowHeight, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<RowHeight>): void;
}
export interface RowHeightVariantFields {
    readonly ExtraSmall: {
        readonly fields: RowHeightExtraSmallFieldControllers;
    };
    readonly Small: {
        readonly fields: RowHeightSmallFieldControllers;
    };
    readonly Medium: {
        readonly fields: RowHeightMediumFieldControllers;
    };
    readonly Large: {
        readonly fields: RowHeightLargeFieldControllers;
    };
}
function rowHeightGetDefaultForVariant(variant: string): RowHeight {
    if (variant === "ExtraSmall") {
        return "ExtraSmall" as RowHeight;
    }
    if (variant === "Small") {
        return "Small" as RowHeight;
    }
    if (variant === "Medium") {
        return "Medium" as RowHeight;
    }
    if (variant === "Large") {
        return "Large" as RowHeight;
    }
    return "ExtraSmall" as RowHeight;
}
export function rowHeightCreateForm(initial: RowHeight): RowHeightGigaform {
    const initialVariant: "ExtraSmall" | "Small" | "Medium" | "Large" = (initial as "ExtraSmall" | "Small" | "Medium" | "Large") ?? "ExtraSmall";
    let currentVariant = $state<$MfPh5>(initialVariant);
    let data = $state<$MfPh6>(initial ?? "rowHeightGetDefaultForVariant"(initialVariant));
    let errors = $state<$MfPh8>({} as RowHeightErrors);
    let tainted = $state<$MfPh10>({} as RowHeightTainted);
    const variants = {} as RowHeightVariantFields;
    variants[__expr__] = {
        fields: {} as RowHeightExtraSmallFieldControllers
    };
    variants[__expr__] = {
        fields: {} as RowHeightSmallFieldControllers
    };
    variants[__expr__] = {
        fields: {} as RowHeightMediumFieldControllers
    };
    variants[__expr__] = {
        fields: {} as RowHeightLargeFieldControllers
    };
    function switchVariant(variant: "ExtraSmall" | "Small" | "Medium" | "Large"): void {
        currentVariant = variant;
        data = "rowHeightGetDefaultForVariant"(variant);
        errors = {} as RowHeightErrors;
        tainted = {} as RowHeightTainted;
    }
    function validate(): Exit<RowHeight, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(rowHeightDeserialize(data));
    }
    function reset(overrides: Partial<RowHeight>): void {
        data = overrides ? overrides as typeof data : rowHeightGetDefaultForVariant(currentVariant);
        errors = {} as RowHeightErrors;
        tainted = {} as RowHeightTainted;
    }
    return {
        get currentVariant () {
            return currentVariant;
        },
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        variants,
        switchVariant,
        validate,
        reset
    };
}
export function rowHeightFromFormData(formData: FormData): Exit<RowHeight, Array<{
    field: string;
    message: string;
}>> {
    const discriminant = formData.get(`${"_value"}`) as "ExtraSmall" | "Small" | "Medium" | "Large" | null;
    if (!discriminant) {
        return toExit({
            success: false,
            errors: [
                {
                    field: `${"_value"}`,
                    message: "Missing discriminant field"
                }
            ]
        });
    }
    const obj: Record<string, unknown> = {};
    obj._value = discriminant;
    return toExit(rowHeightDeserialize(obj));
}

export const RowHeight = {
  serialize: rowHeightSerialize,
  serializeWithContext: rowHeightSerializeWithContext,
  deserialize: rowHeightDeserialize,
  deserializeWithContext: rowHeightDeserializeWithContext,
  is: rowHeightIs,
  createForm: rowHeightCreateForm,
  fromFormData: rowHeightFromFormData
} as const;


export type OrderStage = /** @default */ 'Estimate' | 'Active' | 'Invoice';

export function orderStageDefaultValue#0#0(): OrderStage {
    return 'Estimate';
}

export function orderStageSerialize(value: OrderStage): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(orderStageSerializeWithContext(value, ctx));
}
export function orderStageSerializeWithContext(value: OrderStage, ctx: __mf_SerializeContext): unknown {
    if (typeof (value as any)?.serializeWithContext === "function") {
        return (value as any).serializeWithContext(ctx);
    }
    return value;
}

export function orderStageDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: OrderStage } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = orderStageDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "OrderStage.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function orderStageDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): OrderStage | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref) as OrderStage | __mf_PendingRef;
    }
    const allowedValues = [
        "'Estimate', 'Active', 'Invoice'"
    ] as const;
    if (!allowedValues.includes(value)) {
        throw new __mf_DeserializeError([
            {
                field: "_root",
                message: `Invalid value for ${"OrderStage"}: expected one of ` + allowedValues.map((v)=>JSON.stringify(v)).join(", ") + ", got " + JSON.stringify(value)
            }
        ]);
    }
    return value as OrderStage;
}
export function orderStageIs(value: unknown): value is OrderStage {
    const allowedValues = [
        "'Estimate', 'Active', 'Invoice'"
    ] as const;
    return allowedValues.includes(value as any);
}

export type OrderStageEstimateErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type OrderStageActiveErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type OrderStageInvoiceErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type OrderStageEstimateTainted = {
};
export type OrderStageActiveTainted = {
};
export type OrderStageInvoiceTainted = {
};
export type OrderStageErrors = ({
    _value: "Estimate";
} & OrderStageEstimateErrors) | ({
    _value: "Active";
} & OrderStageActiveErrors) | ({
    _value: "Invoice";
} & OrderStageInvoiceErrors);
export type OrderStageTainted = ({
    _value: "Estimate";
} & OrderStageEstimateTainted) | ({
    _value: "Active";
} & OrderStageActiveTainted) | ({
    _value: "Invoice";
} & OrderStageInvoiceTainted);
export interface OrderStageEstimateFieldControllers {
}
export interface OrderStageActiveFieldControllers {
}
export interface OrderStageInvoiceFieldControllers {
}
export interface OrderStageGigaform {
    readonly currentVariant: "Estimate" | "Active" | "Invoice";
    readonly data: OrderStage;
    readonly errors: OrderStageErrors;
    readonly tainted: OrderStageTainted;
    readonly variants: OrderStageVariantFields;
    switchVariant(variant: "Estimate" | "Active" | "Invoice"): void;
    validate(): Exit<OrderStage, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<OrderStage>): void;
}
export interface OrderStageVariantFields {
    readonly Estimate: {
        readonly fields: OrderStageEstimateFieldControllers;
    };
    readonly Active: {
        readonly fields: OrderStageActiveFieldControllers;
    };
    readonly Invoice: {
        readonly fields: OrderStageInvoiceFieldControllers;
    };
}
function orderStageGetDefaultForVariant(variant: string): OrderStage {
    if (variant === "Estimate") {
        return "Estimate" as OrderStage;
    }
    if (variant === "Active") {
        return "Active" as OrderStage;
    }
    if (variant === "Invoice") {
        return "Invoice" as OrderStage;
    }
    return "Estimate" as OrderStage;
}
export function orderStageCreateForm(initial: OrderStage): OrderStageGigaform {
    const initialVariant: "Estimate" | "Active" | "Invoice" = (initial as "Estimate" | "Active" | "Invoice") ?? "Estimate";
    let currentVariant = $state<$MfPh5>(initialVariant);
    let data = $state<$MfPh6>(initial ?? "orderStageGetDefaultForVariant"(initialVariant));
    let errors = $state<$MfPh8>({} as OrderStageErrors);
    let tainted = $state<$MfPh10>({} as OrderStageTainted);
    const variants = {} as OrderStageVariantFields;
    variants[__expr__] = {
        fields: {} as OrderStageEstimateFieldControllers
    };
    variants[__expr__] = {
        fields: {} as OrderStageActiveFieldControllers
    };
    variants[__expr__] = {
        fields: {} as OrderStageInvoiceFieldControllers
    };
    function switchVariant(variant: "Estimate" | "Active" | "Invoice"): void {
        currentVariant = variant;
        data = "orderStageGetDefaultForVariant"(variant);
        errors = {} as OrderStageErrors;
        tainted = {} as OrderStageTainted;
    }
    function validate(): Exit<OrderStage, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(orderStageDeserialize(data));
    }
    function reset(overrides: Partial<OrderStage>): void {
        data = overrides ? overrides as typeof data : orderStageGetDefaultForVariant(currentVariant);
        errors = {} as OrderStageErrors;
        tainted = {} as OrderStageTainted;
    }
    return {
        get currentVariant () {
            return currentVariant;
        },
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        variants,
        switchVariant,
        validate,
        reset
    };
}
export function orderStageFromFormData(formData: FormData): Exit<OrderStage, Array<{
    field: string;
    message: string;
}>> {
    const discriminant = formData.get(`${"_value"}`) as "Estimate" | "Active" | "Invoice" | null;
    if (!discriminant) {
        return toExit({
            success: false,
            errors: [
                {
                    field: `${"_value"}`,
                    message: "Missing discriminant field"
                }
            ]
        });
    }
    const obj: Record<string, unknown> = {};
    obj._value = discriminant;
    return toExit(orderStageDeserialize(obj));
}

export const OrderStage = {
  serialize: orderStageSerialize,
  serializeWithContext: orderStageSerializeWithContext,
  deserialize: orderStageDeserialize,
  deserializeWithContext: orderStageDeserializeWithContext,
  is: orderStageIs,
  createForm: orderStageCreateForm,
  fromFormData: orderStageFromFormData
} as const;


export type Table =
    | /** @default */ 'Account'
    | 'Did'
    | 'Appointment'
    | 'Lead'
    | 'TaxRate'
    | 'Site'
    | 'Employee'
    | 'Route'
    | 'Company'
    | 'Product'
    | 'Service'
    | 'User'
    | 'Order'
    | 'Payment'
    | 'Package'
    | 'Promotion'
    | 'Represents'
    | 'Ordered';

export function tableDefaultValue#0#0(): Table {
    return 'Account';
}

export function tableSerialize(value: Table): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(tableSerializeWithContext(value, ctx));
}
export function tableSerializeWithContext(value: Table, ctx: __mf_SerializeContext): unknown {
    if (typeof (value as any)?.serializeWithContext === "function") {
        return (value as any).serializeWithContext(ctx);
    }
    return value;
}

export function tableDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: Table } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = tableDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "Table.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function tableDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Table | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref) as Table | __mf_PendingRef;
    }
    const allowedValues = [
        "'Account', 'Did', 'Appointment', 'Lead', 'TaxRate', 'Site', 'Employee', 'Route', 'Company', 'Product', 'Service', 'User', 'Order', 'Payment', 'Package', 'Promotion', 'Represents', 'Ordered'"
    ] as const;
    if (!allowedValues.includes(value)) {
        throw new __mf_DeserializeError([
            {
                field: "_root",
                message: `Invalid value for ${"Table"}: expected one of ` + allowedValues.map((v)=>JSON.stringify(v)).join(", ") + ", got " + JSON.stringify(value)
            }
        ]);
    }
    return value as Table;
}
export function tableIs(value: unknown): value is Table {
    const allowedValues = [
        "'Account', 'Did', 'Appointment', 'Lead', 'TaxRate', 'Site', 'Employee', 'Route', 'Company', 'Product', 'Service', 'User', 'Order', 'Payment', 'Package', 'Promotion', 'Represents', 'Ordered'"
    ] as const;
    return allowedValues.includes(value as any);
}

export type TableAccountErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type TableDidErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type TableAppointmentErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type TableLeadErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type TableTaxRateErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type TableSiteErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type TableEmployeeErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type TableRouteErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type TableCompanyErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type TableProductErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type TableServiceErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type TableUserErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type TableOrderErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type TablePaymentErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type TablePackageErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type TablePromotionErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type TableRepresentsErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type TableOrderedErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type TableAccountTainted = {
};
export type TableDidTainted = {
};
export type TableAppointmentTainted = {
};
export type TableLeadTainted = {
};
export type TableTaxRateTainted = {
};
export type TableSiteTainted = {
};
export type TableEmployeeTainted = {
};
export type TableRouteTainted = {
};
export type TableCompanyTainted = {
};
export type TableProductTainted = {
};
export type TableServiceTainted = {
};
export type TableUserTainted = {
};
export type TableOrderTainted = {
};
export type TablePaymentTainted = {
};
export type TablePackageTainted = {
};
export type TablePromotionTainted = {
};
export type TableRepresentsTainted = {
};
export type TableOrderedTainted = {
};
export type TableErrors = ({
    _value: "Account";
} & TableAccountErrors) | ({
    _value: "Did";
} & TableDidErrors) | ({
    _value: "Appointment";
} & TableAppointmentErrors) | ({
    _value: "Lead";
} & TableLeadErrors) | ({
    _value: "TaxRate";
} & TableTaxRateErrors) | ({
    _value: "Site";
} & TableSiteErrors) | ({
    _value: "Employee";
} & TableEmployeeErrors) | ({
    _value: "Route";
} & TableRouteErrors) | ({
    _value: "Company";
} & TableCompanyErrors) | ({
    _value: "Product";
} & TableProductErrors) | ({
    _value: "Service";
} & TableServiceErrors) | ({
    _value: "User";
} & TableUserErrors) | ({
    _value: "Order";
} & TableOrderErrors) | ({
    _value: "Payment";
} & TablePaymentErrors) | ({
    _value: "Package";
} & TablePackageErrors) | ({
    _value: "Promotion";
} & TablePromotionErrors) | ({
    _value: "Represents";
} & TableRepresentsErrors) | ({
    _value: "Ordered";
} & TableOrderedErrors);
export type TableTainted = ({
    _value: "Account";
} & TableAccountTainted) | ({
    _value: "Did";
} & TableDidTainted) | ({
    _value: "Appointment";
} & TableAppointmentTainted) | ({
    _value: "Lead";
} & TableLeadTainted) | ({
    _value: "TaxRate";
} & TableTaxRateTainted) | ({
    _value: "Site";
} & TableSiteTainted) | ({
    _value: "Employee";
} & TableEmployeeTainted) | ({
    _value: "Route";
} & TableRouteTainted) | ({
    _value: "Company";
} & TableCompanyTainted) | ({
    _value: "Product";
} & TableProductTainted) | ({
    _value: "Service";
} & TableServiceTainted) | ({
    _value: "User";
} & TableUserTainted) | ({
    _value: "Order";
} & TableOrderTainted) | ({
    _value: "Payment";
} & TablePaymentTainted) | ({
    _value: "Package";
} & TablePackageTainted) | ({
    _value: "Promotion";
} & TablePromotionTainted) | ({
    _value: "Represents";
} & TableRepresentsTainted) | ({
    _value: "Ordered";
} & TableOrderedTainted);
export interface TableAccountFieldControllers {
}
export interface TableDidFieldControllers {
}
export interface TableAppointmentFieldControllers {
}
export interface TableLeadFieldControllers {
}
export interface TableTaxRateFieldControllers {
}
export interface TableSiteFieldControllers {
}
export interface TableEmployeeFieldControllers {
}
export interface TableRouteFieldControllers {
}
export interface TableCompanyFieldControllers {
}
export interface TableProductFieldControllers {
}
export interface TableServiceFieldControllers {
}
export interface TableUserFieldControllers {
}
export interface TableOrderFieldControllers {
}
export interface TablePaymentFieldControllers {
}
export interface TablePackageFieldControllers {
}
export interface TablePromotionFieldControllers {
}
export interface TableRepresentsFieldControllers {
}
export interface TableOrderedFieldControllers {
}
export interface TableGigaform {
    readonly currentVariant: "Account" | "Did" | "Appointment" | "Lead" | "TaxRate" | "Site" | "Employee" | "Route" | "Company" | "Product" | "Service" | "User" | "Order" | "Payment" | "Package" | "Promotion" | "Represents" | "Ordered";
    readonly data: Table;
    readonly errors: TableErrors;
    readonly tainted: TableTainted;
    readonly variants: TableVariantFields;
    switchVariant(variant: "Account" | "Did" | "Appointment" | "Lead" | "TaxRate" | "Site" | "Employee" | "Route" | "Company" | "Product" | "Service" | "User" | "Order" | "Payment" | "Package" | "Promotion" | "Represents" | "Ordered"): void;
    validate(): Exit<Table, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<Table>): void;
}
export interface TableVariantFields {
    readonly Account: {
        readonly fields: TableAccountFieldControllers;
    };
    readonly Did: {
        readonly fields: TableDidFieldControllers;
    };
    readonly Appointment: {
        readonly fields: TableAppointmentFieldControllers;
    };
    readonly Lead: {
        readonly fields: TableLeadFieldControllers;
    };
    readonly TaxRate: {
        readonly fields: TableTaxRateFieldControllers;
    };
    readonly Site: {
        readonly fields: TableSiteFieldControllers;
    };
    readonly Employee: {
        readonly fields: TableEmployeeFieldControllers;
    };
    readonly Route: {
        readonly fields: TableRouteFieldControllers;
    };
    readonly Company: {
        readonly fields: TableCompanyFieldControllers;
    };
    readonly Product: {
        readonly fields: TableProductFieldControllers;
    };
    readonly Service: {
        readonly fields: TableServiceFieldControllers;
    };
    readonly User: {
        readonly fields: TableUserFieldControllers;
    };
    readonly Order: {
        readonly fields: TableOrderFieldControllers;
    };
    readonly Payment: {
        readonly fields: TablePaymentFieldControllers;
    };
    readonly Package: {
        readonly fields: TablePackageFieldControllers;
    };
    readonly Promotion: {
        readonly fields: TablePromotionFieldControllers;
    };
    readonly Represents: {
        readonly fields: TableRepresentsFieldControllers;
    };
    readonly Ordered: {
        readonly fields: TableOrderedFieldControllers;
    };
}
function tableGetDefaultForVariant(variant: string): Table {
    if (variant === "Account") {
        return "Account" as Table;
    }
    if (variant === "Did") {
        return "Did" as Table;
    }
    if (variant === "Appointment") {
        return "Appointment" as Table;
    }
    if (variant === "Lead") {
        return "Lead" as Table;
    }
    if (variant === "TaxRate") {
        return "TaxRate" as Table;
    }
    if (variant === "Site") {
        return "Site" as Table;
    }
    if (variant === "Employee") {
        return "Employee" as Table;
    }
    if (variant === "Route") {
        return "Route" as Table;
    }
    if (variant === "Company") {
        return "Company" as Table;
    }
    if (variant === "Product") {
        return "Product" as Table;
    }
    if (variant === "Service") {
        return "Service" as Table;
    }
    if (variant === "User") {
        return "User" as Table;
    }
    if (variant === "Order") {
        return "Order" as Table;
    }
    if (variant === "Payment") {
        return "Payment" as Table;
    }
    if (variant === "Package") {
        return "Package" as Table;
    }
    if (variant === "Promotion") {
        return "Promotion" as Table;
    }
    if (variant === "Represents") {
        return "Represents" as Table;
    }
    if (variant === "Ordered") {
        return "Ordered" as Table;
    }
    return "Account" as Table;
}
export function tableCreateForm(initial: Table): TableGigaform {
    const initialVariant: "Account" | "Did" | "Appointment" | "Lead" | "TaxRate" | "Site" | "Employee" | "Route" | "Company" | "Product" | "Service" | "User" | "Order" | "Payment" | "Package" | "Promotion" | "Represents" | "Ordered" = (initial as "Account" | "Did" | "Appointment" | "Lead" | "TaxRate" | "Site" | "Employee" | "Route" | "Company" | "Product" | "Service" | "User" | "Order" | "Payment" | "Package" | "Promotion" | "Represents" | "Ordered") ?? "Account";
    let currentVariant = $state<$MfPh5>(initialVariant);
    let data = $state<$MfPh6>(initial ?? "tableGetDefaultForVariant"(initialVariant));
    let errors = $state<$MfPh8>({} as TableErrors);
    let tainted = $state<$MfPh10>({} as TableTainted);
    const variants = {} as TableVariantFields;
    variants[__expr__] = {
        fields: {} as TableAccountFieldControllers
    };
    variants[__expr__] = {
        fields: {} as TableDidFieldControllers
    };
    variants[__expr__] = {
        fields: {} as TableAppointmentFieldControllers
    };
    variants[__expr__] = {
        fields: {} as TableLeadFieldControllers
    };
    variants[__expr__] = {
        fields: {} as TableTaxRateFieldControllers
    };
    variants[__expr__] = {
        fields: {} as TableSiteFieldControllers
    };
    variants[__expr__] = {
        fields: {} as TableEmployeeFieldControllers
    };
    variants[__expr__] = {
        fields: {} as TableRouteFieldControllers
    };
    variants[__expr__] = {
        fields: {} as TableCompanyFieldControllers
    };
    variants[__expr__] = {
        fields: {} as TableProductFieldControllers
    };
    variants[__expr__] = {
        fields: {} as TableServiceFieldControllers
    };
    variants[__expr__] = {
        fields: {} as TableUserFieldControllers
    };
    variants[__expr__] = {
        fields: {} as TableOrderFieldControllers
    };
    variants[__expr__] = {
        fields: {} as TablePaymentFieldControllers
    };
    variants[__expr__] = {
        fields: {} as TablePackageFieldControllers
    };
    variants[__expr__] = {
        fields: {} as TablePromotionFieldControllers
    };
    variants[__expr__] = {
        fields: {} as TableRepresentsFieldControllers
    };
    variants[__expr__] = {
        fields: {} as TableOrderedFieldControllers
    };
    function switchVariant(variant: "Account" | "Did" | "Appointment" | "Lead" | "TaxRate" | "Site" | "Employee" | "Route" | "Company" | "Product" | "Service" | "User" | "Order" | "Payment" | "Package" | "Promotion" | "Represents" | "Ordered"): void {
        currentVariant = variant;
        data = "tableGetDefaultForVariant"(variant);
        errors = {} as TableErrors;
        tainted = {} as TableTainted;
    }
    function validate(): Exit<Table, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(tableDeserialize(data));
    }
    function reset(overrides: Partial<Table>): void {
        data = overrides ? overrides as typeof data : tableGetDefaultForVariant(currentVariant);
        errors = {} as TableErrors;
        tainted = {} as TableTainted;
    }
    return {
        get currentVariant () {
            return currentVariant;
        },
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        variants,
        switchVariant,
        validate,
        reset
    };
}
export function tableFromFormData(formData: FormData): Exit<Table, Array<{
    field: string;
    message: string;
}>> {
    const discriminant = formData.get(`${"_value"}`) as "Account" | "Did" | "Appointment" | "Lead" | "TaxRate" | "Site" | "Employee" | "Route" | "Company" | "Product" | "Service" | "User" | "Order" | "Payment" | "Package" | "Promotion" | "Represents" | "Ordered" | null;
    if (!discriminant) {
        return toExit({
            success: false,
            errors: [
                {
                    field: `${"_value"}`,
                    message: "Missing discriminant field"
                }
            ]
        });
    }
    const obj: Record<string, unknown> = {};
    obj._value = discriminant;
    return toExit(tableDeserialize(obj));
}

export const Table = {
  serialize: tableSerialize,
  serializeWithContext: tableSerializeWithContext,
  deserialize: tableDeserialize,
  deserializeWithContext: tableDeserializeWithContext,
  is: tableIs,
  createForm: tableCreateForm,
  fromFormData: tableFromFormData
} as const;


export type Item = RecordLink<Product> | /** @default */ RecordLink<Service>;

export function itemDefaultValue#0#0(): Item {
    return recordLinkDefaultValue<Service>();
}

export function itemSerialize(value: Item): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(itemSerializeWithContext(value, ctx));
}
export function itemSerializeWithContext(value: Item, ctx: __mf_SerializeContext): unknown {
    if (typeof (value as any)?.serializeWithContext === "function") {
        return (value as any).serializeWithContext(ctx);
    }
    return value;
}

export function itemDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: Item } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = itemDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "Item.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function itemDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Item | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref) as Item | __mf_PendingRef;
    }
    if (typeof value === "object" && value !== null) {
        const __typeName = (value as any).__type;
        if (typeof __typeName === "string") {}
        if (__typeName === "RecordLink<Product>") {
            return recordLinkDeserializeWithContext(value, ctx) as Item;
        }
        if (__typeName === "RecordLink<Service>") {
            return recordLinkDeserializeWithContext(value, ctx) as Item;
        }
    }
    throw new __mf_DeserializeError([
        {
            field: "_root",
            message: `${"Item"}.deserializeWithContext: value does not match any union member`
        }
    ]);
}
export function itemIs(value: unknown): value is Item {
    if (typeof value === "object" && value !== null) {
        const __typeName = (value as any).__type;
        if ('__typeName === "RecordLink<Product>" || __typeName === "RecordLink<Service>"') return true;
    }
    return false;
}
     }

export type ItemRecordLinkProductErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type ItemRecordLinkServiceErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type ItemRecordLinkProductTainted = {
};
export type ItemRecordLinkServiceTainted = {
};
export type ItemErrors = ({
    _type: "RecordLink<Product>";
} & ItemRecordLinkProductErrors) | ({
    _type: "RecordLink<Service>";
} & ItemRecordLinkServiceErrors);
export type ItemTainted = ({
    _type: "RecordLink<Product>";
} & ItemRecordLinkProductTainted) | ({
    _type: "RecordLink<Service>";
} & ItemRecordLinkServiceTainted);
export interface ItemRecordLinkProductFieldControllers {
}
export interface ItemRecordLinkServiceFieldControllers {
}
export interface ItemGigaform {
    readonly currentVariant: "RecordLink<Product>" | "RecordLink<Service>";
    readonly data: Item;
    readonly errors: ItemErrors;
    readonly tainted: ItemTainted;
    readonly variants: ItemVariantFields;
    switchVariant(variant: "RecordLink<Product>" | "RecordLink<Service>"): void;
    validate(): Exit<Item, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<Item>): void;
}
export interface ItemVariantFields {
    readonly "RecordLink<Product>": {
        readonly fields: ItemRecordLinkProductFieldControllers;
    };
    readonly "RecordLink<Service>": {
        readonly fields: ItemRecordLinkServiceFieldControllers;
    };
}
function itemGetDefaultForVariant(variant: string): Item {
    if (variant === "RecordLink<Product>") {
        return recordLinkDefaultValue<Product>() as Item;
    }
    if (variant === "RecordLink<Service>") {
        return recordLinkDefaultValue<Service>() as Item;
    }
    return recordLinkDefaultValue<Product>() as Item;
}
export function itemCreateForm(initial: Item): ItemGigaform {
    const initialVariant: "RecordLink<Product>" | "RecordLink<Service>" = "RecordLink<Product>";
    let currentVariant = $state<$MfPh5>(initialVariant);
    let data = $state<$MfPh6>(initial ?? "itemGetDefaultForVariant"(initialVariant));
    let errors = $state<$MfPh8>({} as ItemErrors);
    let tainted = $state<$MfPh10>({} as ItemTainted);
    const variants = {} as ItemVariantFields;
    variants[__expr__] = {
        fields: {} as ItemRecordLinkProductFieldControllers
    };
    variants[__expr__] = {
        fields: {} as ItemRecordLinkServiceFieldControllers
    };
    function switchVariant(variant: "RecordLink<Product>" | "RecordLink<Service>"): void {
        currentVariant = variant;
        data = "itemGetDefaultForVariant"(variant);
        errors = {} as ItemErrors;
        tainted = {} as ItemTainted;
    }
    function validate(): Exit<Item, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(itemDeserialize(data));
    }
    function reset(overrides: Partial<Item>): void {
        data = overrides ? overrides as typeof data : itemGetDefaultForVariant(currentVariant);
        errors = {} as ItemErrors;
        tainted = {} as ItemTainted;
    }
    return {
        get currentVariant () {
            return currentVariant;
        },
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        variants,
        switchVariant,
        validate,
        reset
    };
}
export function itemFromFormData(formData: FormData): Exit<Item, Array<{
    field: string;
    message: string;
}>> {
    const discriminant = formData.get(`${"_type"}`) as "RecordLink<Product>" | "RecordLink<Service>" | null;
    if (!discriminant) {
        return toExit({
            success: false,
            errors: [
                {
                    field: `${"_type"}`,
                    message: "Missing discriminant field"
                }
            ]
        });
    }
    const obj: Record<string, unknown> = {};
    obj._type = discriminant;
    return toExit(itemDeserialize(obj));
}

export const Item = {
  serialize: itemSerialize,
  serializeWithContext: itemSerializeWithContext,
  deserialize: itemDeserialize,
  deserializeWithContext: itemDeserializeWithContext,
  is: itemIs,
  createForm: itemCreateForm,
  fromFormData: itemFromFormData
} as const;


export type RecordLink<T> = /** @default */ string | T;

export function recordLinkDefaultValue#0<T>#0(): RecordLink<T> {
    return "";
}

export function recordLinkSerialize<$MfPh1>(value: RecordLink<T>): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(recordLinkSerializeWithContext(value, ctx));
}
export function recordLinkSerializeWithContext<$MfPh6>(value: RecordLink<T>, ctx: __mf_SerializeContext): unknown {
    if (typeof (value as any)?.serializeWithContext === "function") {
        return (value as any).serializeWithContext(ctx);
    }
    return value;
}

export function recordLinkDeserialize<T>(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: RecordLink<T> } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = recordLinkDeserializeWithContext<T>(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "RecordLink.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function recordLinkDeserializeWithContext<T>(value: any, ctx: __mf_DeserializeContext): RecordLink<T> | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref) as RecordLink<T> | __mf_PendingRef;
    }
    if (typeof value === "string") {
        return value as RecordLink<T>;
    }
    return value as RecordLink<T>;
    throw new __mf_DeserializeError([
        {
            field: "_root",
            message: `${"RecordLink"}.deserializeWithContext: value does not match any union member`
        }
    ]);
}
export function recordLinkIs<T>(value: unknown): value is RecordLink<T> {
    if (typeof value === "string") return true;
    return true;
}


export type Actor = /** @default */ User | Employee | Account;

export function actorDefaultValue#0#0(): Actor {
    return userDefaultValue();
}

export function actorSerialize(value: Actor): string {
    const ctx = __mf_SerializeContext.create();
    return JSON.stringify(actorSerializeWithContext(value, ctx));
}
export function actorSerializeWithContext(value: Actor, ctx: __mf_SerializeContext): unknown {
    if (typeof (value as any)?.serializeWithContext === "function") {
        return (value as any).serializeWithContext(ctx);
    }
    return value;
}

export function actorDeserialize(input: unknown, opts: __mf_DeserializeOptions): { success: true; value: Actor } | { success: false; errors: Array<{ field: string; message: string }> } {
    try {
        const data = typeof input === "string" ? JSON.parse(input) : input;
        const ctx = __mf_DeserializeContext.create();
        const resultOrRef = actorDeserializeWithContext(data, ctx);
        if (__mf_PendingRef.is(resultOrRef)) {
            return {
                success: false,
                errors: [
                    {
                        field: "_root",
                        message: "Actor.deserialize: root cannot be a forward reference"
                    }
                ]
            };
        }
        ctx.applyPatches();
        if (opts?.freeze) {
            ctx.freezeAll();
        }
        return {
            success: true,
            value: resultOrRef
        };
    } catch (e) {
        if (e instanceof __mf_DeserializeError) {
            return {
                success: false,
                errors: e.errors
            };
        }
        const message = e instanceof Error ? e.message : String(e);
        return {
            success: false,
            errors: [
                {
                    field: "_root",
                    message
                }
            ]
        };
    }
}
export function actorDeserializeWithContext(value: any, ctx: __mf_DeserializeContext): Actor | __mf_PendingRef {
    if (value?.__ref !== undefined) {
        return ctx.getOrDefer(value.__ref) as Actor | __mf_PendingRef;
    }
    if (typeof value === "object" && value !== null) {
        const __typeName = (value as any).__type;
        if (typeof __typeName === "string") {}
        if (__typeName === "User") {
            return userDeserializeWithContext(value, ctx) as Actor;
        }
        if (__typeName === "Employee") {
            return employeeDeserializeWithContext(value, ctx) as Actor;
        }
        if (__typeName === "Account") {
            return accountDeserializeWithContext(value, ctx) as Actor;
        }
    }
    throw new __mf_DeserializeError([
        {
            field: "_root",
            message: `${"Actor"}.deserializeWithContext: value does not match any union member`
        }
    ]);
}
export function actorIs(value: unknown): value is Actor {
    if (typeof value === "object" && value !== null) {
        const __typeName = (value as any).__type;
        if ('__typeName === "User" || __typeName === "Employee" || __typeName === "Account"') return true;
    }
    return false;
}
     }

export type ActorUserErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type ActorEmployeeErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type ActorAccountErrors = {
    _errors: __gf_Option<Array<string>>;
};
export type ActorUserTainted = {
};
export type ActorEmployeeTainted = {
};
export type ActorAccountTainted = {
};
export type ActorErrors = ({
    _type: "User";
} & ActorUserErrors) | ({
    _type: "Employee";
} & ActorEmployeeErrors) | ({
    _type: "Account";
} & ActorAccountErrors);
export type ActorTainted = ({
    _type: "User";
} & ActorUserTainted) | ({
    _type: "Employee";
} & ActorEmployeeTainted) | ({
    _type: "Account";
} & ActorAccountTainted);
export interface ActorUserFieldControllers {
}
export interface ActorEmployeeFieldControllers {
}
export interface ActorAccountFieldControllers {
}
export interface ActorGigaform {
    readonly currentVariant: "User" | "Employee" | "Account";
    readonly data: Actor;
    readonly errors: ActorErrors;
    readonly tainted: ActorTainted;
    readonly variants: ActorVariantFields;
    switchVariant(variant: "User" | "Employee" | "Account"): void;
    validate(): Exit<Actor, Array<{
        field: string;
        message: string;
    }>>;
    reset(overrides?: Partial<Actor>): void;
}
export interface ActorVariantFields {
    readonly User: {
        readonly fields: ActorUserFieldControllers;
    };
    readonly Employee: {
        readonly fields: ActorEmployeeFieldControllers;
    };
    readonly Account: {
        readonly fields: ActorAccountFieldControllers;
    };
}
function actorGetDefaultForVariant(variant: string): Actor {
    if (variant === "User") {
        return userDefaultValue() as Actor;
    }
    if (variant === "Employee") {
        return employeeDefaultValue() as Actor;
    }
    if (variant === "Account") {
        return accountDefaultValue() as Actor;
    }
    return userDefaultValue() as Actor;
}
export function actorCreateForm(initial: Actor): ActorGigaform {
    const initialVariant: "User" | "Employee" | "Account" = "User";
    let currentVariant = $state<$MfPh5>(initialVariant);
    let data = $state<$MfPh6>(initial ?? "actorGetDefaultForVariant"(initialVariant));
    let errors = $state<$MfPh8>({} as ActorErrors);
    let tainted = $state<$MfPh10>({} as ActorTainted);
    const variants = {} as ActorVariantFields;
    variants[__expr__] = {
        fields: {} as ActorUserFieldControllers
    };
    variants[__expr__] = {
        fields: {} as ActorEmployeeFieldControllers
    };
    variants[__expr__] = {
        fields: {} as ActorAccountFieldControllers
    };
    function switchVariant(variant: "User" | "Employee" | "Account"): void {
        currentVariant = variant;
        data = "actorGetDefaultForVariant"(variant);
        errors = {} as ActorErrors;
        tainted = {} as ActorTainted;
    }
    function validate(): Exit<Actor, Array<{
        field: string;
        message: string;
    }>> {
        return toExit(actorDeserialize(data));
    }
    function reset(overrides: Partial<Actor>): void {
        data = overrides ? overrides as typeof data : actorGetDefaultForVariant(currentVariant);
        errors = {} as ActorErrors;
        tainted = {} as ActorTainted;
    }
    return {
        get currentVariant () {
            return currentVariant;
        },
        get data () {
            return data;
        },
        set data (v){
            data = v;
        },
        get errors () {
            return errors;
        },
        set errors (v){
            errors = v;
        },
        get tainted () {
            return tainted;
        },
        set tainted (v){
            tainted = v;
        },
        variants,
        switchVariant,
        validate,
        reset
    };
}
export function actorFromFormData(formData: FormData): Exit<Actor, Array<{
    field: string;
    message: string;
}>> {
    const discriminant = formData.get(`${"_type"}`) as "User" | "Employee" | "Account" | null;
    if (!discriminant) {
        return toExit({
            success: false,
            errors: [
                {
                    field: `${"_type"}`,
                    message: "Missing discriminant field"
                }
            ]
        });
    }
    const obj: Record<string, unknown> = {};
    obj._type = discriminant;
    return toExit(actorDeserialize(obj));
}

export const Actor = {
  serialize: actorSerialize,
  serializeWithContext: actorSerializeWithContext,
  deserialize: actorDeserialize,
  deserializeWithContext: actorDeserializeWithContext,
  is: actorIs,
  createForm: actorCreateForm,
  fromFormData: actorFromFormData
} as const;